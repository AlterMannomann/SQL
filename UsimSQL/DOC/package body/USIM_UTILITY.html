<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<script src="USIM_UTILITY/report.js" type="text/javascript"></script>
<link href="USIM_UTILITY/report.css" type="text/css" rel="stylesheet">
</head>
<body>
<div class="banner">
<table width="98%"><tr>
<td><h2 class="banner">USIM_UTILITY</h2></td>
</tr></table></div>
<div id="maintabs">
<div class="currentmaintab" onclick="onSelectMainTab(this, 0)">
<div>
<p>Doc</p>
</div>
</div>
<div class="maintab" onclick="onSelectMainTab(this, 1)">
<div>
<p>Details</p>
</div>
</div>
<div class="maintab" onclick="onSelectMainTab(this, 2)">
<div>
<p>Grants</p>
</div>
</div>
<div class="maintab" onclick="onSelectMainTab(this, 3)">
<div>
<p>References</p>
</div>
</div>
<div class="maintab" onclick="onSelectMainTab(this, 4)">
<div>
<p>Dependencies</p>
</div>
</div>
<div class="maintab" onclick="onSelectMainTab(this, 5)">
<div>
<p>Code</p>
</div>
</div>
</div>
<br/>
<div id="masterreports">
<div id="Master.0">
<div class="currentmasterreport">
<TABLE CELLSPACING="0" CELLPADDING="1" WIDTH="100%" BORDER="0">
<TR><TD CLASS="NavBarRow3" VALIGN="top"><FONT SIZE="-2">      SUMMARY:  <A HREF="#field_summary">FIELD</A> | <A HREF="#type_summary">TYPE</A> | <A HREF="#method_summary">METHOD</A></FONT></TD><TD CLASS="NavBarRow3" VALIGN="top"><FONT SIZE="-2"></TR></TABLE><HR><P> documentation see header</P><HR><TABLE CELLSPACING="0" CELLPADDING="1" WIDTH="100%" BORDER="0">
<TR><TD CLASS="NavBarRow3" VALIGN="top"><FONT SIZE="-2">      SUMMARY:  <A HREF="#field_summary">FIELD</A> | <A HREF="#type_summary">TYPE</A> | <A HREF="#method_summary">METHOD</A></FONT></TD><TD CLASS="NavBarRow3" VALIGN="top"><FONT SIZE="-2"></TR></TABLE></div>
</div>
<div id="Master.1">
<div class="masterreport">
<table id="Table.0" cellpadding="0" cellspacing="0" summary="">
<th>NAME</th>
<th>VALUE</th>
</tr>
<tr>
<td>OWNER</td>
<td>USIM</td>
</tr>
<tr>
<td>OBJECT_NAME</td>
<td>USIM_UTILITY</td>
</tr>
<tr>
<td>SUBOBJECT_NAME</td>
<td>null</td>
</tr>
<tr>
<td>OBJECT_ID</td>
<td>80516</td>
</tr>
<tr>
<td>DATA_OBJECT_ID</td>
<td>null</td>
</tr>
<tr>
<td>OBJECT_TYPE</td>
<td>PACKAGE&nbsp;BODY</td>
</tr>
<tr>
<td>CREATED</td>
<td>26.05.2023&nbsp;22:56:14</td>
</tr>
<tr>
<td>LAST_DDL_TIME</td>
<td>30.05.2023&nbsp;00:48:13</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>2023-05-30:00:48:13</td>
</tr>
<tr>
<td>STATUS</td>
<td>VALID</td>
</tr>
<tr>
<td>TEMPORARY</td>
<td>N</td>
</tr>
<tr>
<td>GENERATED</td>
<td>N</td>
</tr>
<tr>
<td>SECONDARY</td>
<td>N</td>
</tr>
<tr>
<td>NAMESPACE</td>
<td>2</td>
</tr>
<tr>
<td>EDITION_NAME</td>
<td>null</td>
</tr>
<tr>
<td>SHARING</td>
<td>NONE</td>
</tr>
<tr>
<td>EDITIONABLE</td>
<td>Y</td>
</tr>
<tr>
<td>ORACLE_MAINTAINED</td>
<td>N</td>
</tr>
<tr>
<td>APPLICATION</td>
<td>N</td>
</tr>
<tr>
<td>DEFAULT_COLLATION</td>
<td>null</td>
</tr>
<tr>
<td>DUPLICATED</td>
<td>N</td>
</tr>
<tr>
<td>SHARDED</td>
<td>N</td>
</tr>
<tr>
<td>IMPORTED_OBJECT</td>
<td>N</td>
</tr>
<tr>
<td>CREATED_APPID</td>
<td>null</td>
</tr>
<tr>
<td>CREATED_VSNID</td>
<td>null</td>
</tr>
<tr>
<td>MODIFIED_APPID</td>
<td>null</td>
</tr>
<tr>
<td>MODIFIED_VSNID</td>
<td>null</td>
</tr>
</table>
</div>
</div>
<div id="Master.2">
<div class="masterreport">
<table id="Table.1" cellpadding="0" cellspacing="0" summary="">
<tr>
<th>PRIVILEGE</th>
<th>GRANTEE</th>
<th>GRANTABLE</th>
<th>GRANTOR</th>
<th>OBJECT_NAME</th>
</tr>
</table>
</div>
</div>
<div id="Master.3">
<div class="masterreport">
<table id="Table.2" cellpadding="0" cellspacing="0" summary="">
<tr>
<th>NAME</th>
<th>OWNER</th>
<th>TYPE</th>
<th>OBJECT_ID</th>
<th>STATUS</th>
<th>TYPE_LINK</th>
</tr>
</table>
</div>
</div>
<div id="Master.4">
<div class="masterreport">
<table id="Table.3" cellpadding="0" cellspacing="0" summary="">
<tr>
<th>NAME</th>
<th>OWNER</th>
<th>TYPE</th>
<th>OBJECT_ID</th>
<th>STATUS</th>
<th>TYPE_LINK</th>
</tr>
</table>
</div>
</div>
<div id="Master.5">
<div class="masterreport">
<pre>
PACKAGE BODY usim_utility IS
  -- documentation see header
  FUNCTION extract_coordinate( p_string         IN usim_poi_dim_position.usim_coords%TYPE
                             , p_position       IN NUMBER
                             , p_delimiter      IN VARCHAR2 DEFAULT ','
                             , p_ignore_start   IN VARCHAR2 DEFAULT '('
                             , p_ignore_end     IN VARCHAR2 DEFAULT ')'
                             )
    RETURN VARCHAR2
  IS
    l_result            usim_poi_dim_position.usim_coords%TYPE;
    l_pos_string        usim_poi_dim_position.usim_coords%TYPE;
    l_start             INTEGER;
    l_end               INTEGER;
    l_position          INTEGER;
    l_has_delimiter     BOOLEAN;
    l_req_delimiter     BOOLEAN;
    l_debug_id          usim_debug_log.usim_id_dlg%TYPE;
    l_debug_object      usim_debug_log.usim_log_object%TYPE := 'USIM_UTILITY.EXTRACT_COORDINATE';
    l_debug_content     usim_debug_log.usim_log_content%TYPE;
  BEGIN
    l_debug_id      := usim_debug.start_debug;
    l_debug_content := 'PARAMETER: p_string[' || p_string || '] p_position[' || p_position || '] p_delimiter[' || p_delimiter || '] p_ignore_start[' || p_ignore_start || '] p_ignore_end[' || p_ignore_end || ']';
    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
    l_result        := NULL;
    l_position      := CASE WHEN p_position &lt; 0 THEN 0 ELSE p_position END;
    l_has_delimiter := INSTR(p_string, p_delimiter, 1) > 0;
    -- do we have required delimiters for desired position
    IF p_position > 0
    THEN
      l_req_delimiter := INSTR(p_string, p_delimiter, 1, p_position) > 0;
    ELSE
      l_req_delimiter := TRUE;
    END IF;
    -- get the position substr, consider that delimiter could be missing
    IF l_req_delimiter
    THEN
      IF l_has_delimiter
      THEN
        IF l_position = 0
        THEN
          l_end         := INSTR(p_string, p_delimiter, 1) - 1;
          l_pos_string  := SUBSTR(p_string, 1, l_end);
        ELSE
          l_start       := INSTR(p_string, p_delimiter, 1, p_position) + 1;
          l_end         := INSTR(p_string, p_delimiter, 1, p_position + 1);
          IF l_end > l_start
          THEN
            l_pos_string  := SUBSTR(p_string, l_start, l_end - l_start);
          ELSE
            -- no final delimiter
            l_pos_string  := SUBSTR(p_string, l_start);
          END IF;
        END IF;
      ELSE
        l_pos_string  := p_string;
      END IF;
    ELSE
      -- we have no fitting position
      l_pos_string := '';
    END IF;
    l_debug_content := 'STATE: l_pos_string[' || l_pos_string || '] l_position[' || l_position || '] l_has_delimiter[' || usim_static.get_bool_str(l_has_delimiter) || '] l_rec_delimiter[' || usim_static.get_bool_str(l_req_delimiter) || '] l_start[' || l_start || '] l_end[' || l_end || ']';
    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
    -- discard the level, if present
    IF INSTR(l_pos_string, p_ignore_start, 1) > 0
    THEN
      l_end     := INSTR(l_pos_string, p_ignore_start, 1) - 1;
      -- remove any non number char
      l_result  := TRIM(REGEXP_REPLACE(SUBSTR(l_pos_string, 1, l_end), '[^0-9]', ''));
    ELSE
      -- remove any non number char
      l_result  := TRIM(REGEXP_REPLACE(l_pos_string, '[^0-9]', ''));
    END IF;
    l_debug_content := 'RESULT: l_result[' || l_result || '] l_end[' || l_end || ']';
    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
    RETURN l_result;
  END extract_coordinate
  ;

  FUNCTION extract_number_level( p_string         IN usim_poi_dim_position.usim_coords%TYPE
                               , p_position       IN NUMBER
                               , p_delimiter      IN VARCHAR2 DEFAULT ','
                               , p_level_start    IN VARCHAR2 DEFAULT '('
                               , p_level_end      IN VARCHAR2 DEFAULT ')'
                               )
    RETURN VARCHAR2
  IS
    l_result            usim_poi_dim_position.usim_coords%TYPE;
    l_pos_string        usim_poi_dim_position.usim_coords%TYPE;
    l_level_string      usim_poi_dim_position.usim_coords%TYPE;
    l_start             INTEGER;
    l_end               INTEGER;
    l_position          INTEGER;
    l_has_delimiter     BOOLEAN;
    l_req_delimiter     BOOLEAN;
    l_debug_id          usim_debug_log.usim_id_dlg%TYPE;
    l_debug_object      usim_debug_log.usim_log_object%TYPE := 'USIM_UTILITY.EXTRACT_NUMBER_LEVEL';
    l_debug_content     usim_debug_log.usim_log_content%TYPE;
  BEGIN
    l_debug_id      := usim_debug.start_debug;
    l_debug_content := 'PARAMETER: p_string[' || p_string || '] p_position[' || p_position || '] p_delimiter[' || p_delimiter || '] p_level_start[' || p_level_start || '] p_level_end[' || p_level_end || ']';
    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
    l_result        := NULL;
    l_position      := CASE WHEN p_position &lt; 0 THEN 0 ELSE p_position END;
    l_has_delimiter := INSTR(p_string, p_delimiter, 1) > 0;
    -- do we have required delimiters for desired position
    IF p_position > 0
    THEN
      l_req_delimiter := INSTR(p_string, p_delimiter, 1, p_position) > 0;
    ELSE
      l_req_delimiter := TRUE;
    END IF;
    -- get the position substr, consider that delimiter could be missing
    IF l_req_delimiter
    THEN
      IF l_has_delimiter
      THEN
        IF l_position = 0
        THEN
          l_end         := INSTR(p_string, p_delimiter, 1) - 1;
          l_pos_string  := SUBSTR(p_string, 1, l_end);
        ELSE
          l_start       := INSTR(p_string, p_delimiter, 1, p_position) + 1;
          l_end         := INSTR(p_string, p_delimiter, 1, p_position + 1);
          IF l_end > l_start
          THEN
            l_pos_string  := SUBSTR(p_string, l_start, l_end - l_start);
          ELSE
            -- no final delimiter
            l_pos_string  := SUBSTR(p_string, l_start);
          END IF;
        END IF;
      ELSE
        l_pos_string  := p_string;
      END IF;
    ELSE
      -- we have no fitting position
      l_pos_string := '';
    END IF;
    l_debug_content := 'STATE: l_pos_string[' || l_pos_string || '] l_position[' || l_position || '] l_has_delimiter[' || usim_static.get_bool_str(l_has_delimiter) || '] l_rec_delimiter[' || usim_static.get_bool_str(l_req_delimiter) || '] l_start[' || l_start || '] l_end[' || l_end || ']';
    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
    -- extract the level
    l_start := INSTR(l_pos_string, p_level_start, 1);
    l_end   := INSTR(l_pos_string, p_level_end, 1);
    IF l_start > 0 AND l_end > 0
    THEN
      l_level_string := SUBSTR(l_pos_string, l_start + 1);
      -- remove any non number char
      l_result := TRIM(REGEXP_REPLACE(l_level_string, '[^0-9]', ''));
    END IF;
    l_debug_content := 'RESULT: l_result[' || l_result || '] l_start[' || l_start || '] l_end[' || l_end || '] l_level_string[' || l_level_string || ']';
    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
    RETURN l_result;
  END extract_number_level
  ;

  FUNCTION get_coordinate( p_string         IN usim_poi_dim_position.usim_coords%TYPE
                         , p_position       IN NUMBER
                         )
    RETURN NUMBER
  IS
  BEGIN
    RETURN NVL(TO_NUMBER(extract_coordinate(p_string, p_position)), 0);
  END get_coordinate
  ;

  FUNCTION get_number_level( p_string         IN usim_poi_dim_position.usim_coords%TYPE
                           , p_position       IN NUMBER
                           )
    RETURN NUMBER
  IS
  BEGIN
    RETURN NVL(TO_NUMBER(extract_number_level(p_string, p_position)), 0);
  END get_number_level
  ;


  FUNCTION get_x(p_usim_coords IN usim_poi_dim_position.usim_coords%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  IS
  BEGIN
    RETURN get_coordinate(p_usim_coords, 1);
  END get_x
  ;

  FUNCTION get_x_level(p_usim_coords IN usim_poi_dim_position.usim_coords%TYPE)
    RETURN usim_position.usim_coord_level%TYPE
  IS
  BEGIN
    RETURN get_number_level(p_usim_coords, 1);
  END get_x_level
  ;

  FUNCTION get_y(p_usim_coords IN usim_poi_dim_position.usim_coords%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  IS
  BEGIN
    RETURN get_coordinate(p_usim_coords, 2);
  END get_y
  ;

  FUNCTION get_y_level(p_usim_coords IN usim_poi_dim_position.usim_coords%TYPE)
    RETURN usim_position.usim_coord_level%TYPE
  IS
  BEGIN
    RETURN get_number_level(p_usim_coords, 2);
  END get_y_level
  ;

  FUNCTION get_z(p_usim_coords IN usim_poi_dim_position.usim_coords%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  IS
  BEGIN
    RETURN get_coordinate(p_usim_coords, 3);
  END get_z
  ;

  FUNCTION get_z_level(p_usim_coords IN usim_poi_dim_position.usim_coords%TYPE)
    RETURN usim_position.usim_coord_level%TYPE
  IS
  BEGIN
    RETURN get_number_level(p_usim_coords, 3);
  END get_z_level
  ;

  FUNCTION next_planck_time
    RETURN VARCHAR2
  IS
  BEGIN
    -- update table to cause next value
    UPDATE usim_planck_time
       SET usim_last_planck_time = 'NEW'
     WHERE usim_id_plt = usim_static.usim_planck_timer
    ;
    COMMIT;
    RETURN current_planck_time;
  END next_planck_time
  ;

  FUNCTION current_planck_time
    RETURN VARCHAR2
  IS
    l_result  usim_planck_time.usim_current_planck_time%TYPE;
  BEGIN
    SELECT usim_current_planck_time INTO l_result FROM usim_planck_time WHERE usim_id_plt = usim_static.usim_planck_timer;
    RETURN l_result;
  END current_planck_time
  ;

  FUNCTION last_planck_time
    RETURN VARCHAR2
  IS
    l_result  usim_planck_time.usim_last_planck_time%TYPE;
  BEGIN
    SELECT usim_last_planck_time INTO l_result FROM usim_planck_time WHERE usim_id_plt = usim_static.usim_planck_timer;
    RETURN l_result;
  END last_planck_time
  ;

  FUNCTION get_seq_currval(p_sequence_name IN VARCHAR2)
    RETURN NUMBER
  IS
    l_last_number       INTEGER;
    l_exists            INTEGER;
    l_curr_val          INTEGER;
    l_statement         VARCHAR2(4000);
    l_debug_id          usim_debug_log.usim_id_dlg%TYPE;
    l_debug_object      usim_debug_log.usim_log_object%TYPE := 'USIM_UTILITY.GET_SEQ_CURRVAL';
    l_debug_content     usim_debug_log.usim_log_content%TYPE;
  BEGIN
    l_debug_id      := usim_debug.start_debug;
    l_debug_content := 'PARAMETER: p_sequence_name[' || p_sequence_name || ']';
    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
    SELECT COUNT(*) INTO l_exists FROM user_sequences WHERE sequence_name = UPPER(p_sequence_name);
    l_debug_content := 'CHECK SEQUENCE NAME: l_exists[' || l_exists || ']';
    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
    IF l_exists = 0
    THEN
      l_debug_content := 'RETURN: NULL';
      usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
      RETURN NULL;
    END IF;
    SELECT last_number INTO l_last_number FROM user_sequences WHERE sequence_name = UPPER(p_sequence_name);
    l_debug_content := 'GET LAST SEQUENCE NUMBER: l_last_number[' || l_last_number || ']';
    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
    IF l_last_number = 1
    THEN
      l_statement := 'SELECT ' || p_sequence_name || '.NEXTVAL FROM dual';
    ELSE
      l_statement := 'SELECT ' || p_sequence_name || '.CURRVAL FROM dual';
    END IF;
    l_debug_content := 'SEQUENCE STATEMENT: l_statement[' || l_statement || ']';
    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
    EXECUTE IMMEDIATE l_statement INTO l_curr_val;
    l_debug_content := 'RESULT: l_curr_val[' || l_curr_val || ']';
    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
    RETURN l_curr_val;
  END get_seq_currval
  ;

  FUNCTION coords_diff( p_usim_coords1  IN usim_poi_dim_position.usim_coords%TYPE
                      , p_usim_coords2  IN usim_poi_dim_position.usim_coords%TYPE
                      )
    RETURN NUMBER
  IS
  BEGIN
    RETURN NULL;
  END
  ;

  FUNCTION vector_distance( p_usim_coords1  IN usim_poi_dim_position.usim_coords%TYPE
                          , p_usim_coords2  IN usim_poi_dim_position.usim_coords%TYPE
                          )
    RETURN NUMBER
  IS
    l_min_vector        usim_poi_dim_position.usim_coords%TYPE;
    l_max_vector        usim_poi_dim_position.usim_coords%TYPE;
    l_sum_vector1       NUMBER;
    l_sum_vector2       NUMBER;
    l_distance          NUMBER;
    l_debug_id          usim_debug_log.usim_id_dlg%TYPE;
    l_debug_object      usim_debug_log.usim_log_object%TYPE := 'USIM_UTILITY.VECTOR_DISTANCE';
    l_debug_content     usim_debug_log.usim_log_content%TYPE;

    -- get the vector with more entries
    CURSOR cur_max_vector( cp_coords1 IN VARCHAR2
                         , cp_coords2 IN VARCHAR2
                         )
    IS
        WITH coord1 AS
             (SELECT TRIM(REGEXP_SUBSTR(str, '[^,]+', 1, LEVEL)) AS coord
                   , LEVEL AS lvl
                FROM (SELECT cp_coords1 AS str
                        FROM dual
                     )
             CONNECT BY LEVEL &lt;= LENGTH(str) - LENGTH(REPLACE(str, ',')) + 1
             )
           , coord2 AS
             (SELECT TRIM(REGEXP_SUBSTR(str, '[^,]+', 1, LEVEL)) AS coord
                   , LEVEL AS lvl
                FROM (SELECT cp_coords2 AS str
                        FROM dual
                     )
             CONNECT BY LEVEL &lt;= LENGTH(str) - LENGTH(REPLACE(str, ',')) + 1
             )
      SELECT (SELECT NVL(SUM(lvl), 0) FROM coord1) AS sum_coord1
           , (SELECT NVL(SUM(lvl), 0) FROM coord2) AS sum_coord2
        FROM dual
    ;
    CURSOR cur_distance( cp_coords_max IN VARCHAR2
                       , cp_coords_min IN VARCHAR2
                       )
    IS
      SELECT SQRT(SUM(diff_vec_sq)) AS distance
        FROM (  WITH cmax AS
                     (SELECT TRIM(REGEXP_SUBSTR(str, '[^,]+', 1, LEVEL)) AS coord
                           , LEVEL AS lvl
                        FROM (SELECT cp_coords_max AS str
                                FROM dual
                             )
                     CONNECT BY LEVEL &lt;= LENGTH(str) - LENGTH(REPLACE(str, ',')) + 1
                     )
                   , cmin AS
                     (SELECT TRIM(REGEXP_SUBSTR(str, '[^,]+', 1, LEVEL)) AS coord
                           , LEVEL AS lvl
                        FROM (SELECT cp_coords_min AS str
                                FROM dual
                             )
                     CONNECT BY LEVEL &lt;= LENGTH(str) - LENGTH(REPLACE(str, ',')) + 1
                     )
                     -- square of difference between vec1 - vec2
              SELECT POWER(NVL(TO_NUMBER(cmax.coord), 0) - NVL(TO_NUMBER(cmin.coord), 0), 2) AS diff_vec_sq
                FROM cmax
                LEFT OUTER JOIN cmin
                  ON cmax.lvl = cmax.lvl
             )
    ;
  BEGIN
    l_debug_id      := usim_debug.start_debug;
    l_debug_content := 'PARAMETER: p_usim_coords1[' || p_usim_coords1 || '] p_usim_coords2[' || p_usim_coords2 || ']';
    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
    -- if no values in both coords return 0
    IF     (p_usim_coords1 IS NULL OR LENGTH(p_usim_coords1) = 0)
       AND (p_usim_coords2 IS NULL OR LENGTH(p_usim_coords2) = 0)
    THEN
      l_debug_content := 'RETURN: 0';
      usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
      RETURN 0;
    END IF;
    -- find the bigger one (the one with more elements)
    OPEN cur_max_vector(p_usim_coords1, p_usim_coords2);
    FETCH cur_max_vector INTO l_sum_vector1, l_sum_vector2;
    CLOSE cur_max_vector;
    IF l_sum_vector1 > l_sum_vector2
    THEN
      l_max_vector := p_usim_coords1;
      l_min_vector := p_usim_coords2;
    ELSE
      l_max_vector := p_usim_coords2;
      l_min_vector := p_usim_coords1;
    END IF;
    OPEN cur_distance(l_max_vector, l_min_vector);
    FETCH cur_distance INTO l_distance;
    CLOSE cur_distance;
    RETURN l_distance;
  END vector_distance
  ;
  -- see header for documentation
  FUNCTION energy_force( p_usim_energy_source         IN usim_point.usim_energy%TYPE
                       , p_usim_energy_target         IN usim_point.usim_energy%TYPE
                       , p_usim_distance              IN NUMBER
                       , p_usim_target_sign           IN NUMBER
                       , p_usim_gravitation_constant  IN NUMBER
                       )
    RETURN NUMBER
  IS
    l_usim_energy_force   NUMBER;
  BEGIN
    -- first special case distance = 0
    IF p_usim_distance = 0
    THEN
      -- setting values, no calculation
      RETURN NVL(p_usim_energy_source, 0);
    ELSE
      l_usim_energy_force := ABS(NVL(p_usim_gravitation_constant, 1)) * ((ABS(NVL(p_usim_energy_source, 1)) * ABS(NVL(p_usim_energy_target, 1))) / POWER(p_usim_distance, 2));
      -- handle sign
      l_usim_energy_force := l_usim_energy_force * CASE WHEN p_usim_target_sign = 0 THEN 1 ELSE p_usim_target_sign END;
      RETURN l_usim_energy_force;
    END IF;
  END energy_force
  ;

  FUNCTION insert_position(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN VARCHAR2
  IS
    l_current_level   INTEGER;
    l_new_sequence    INTEGER;
    l_check_exists    INTEGER;
    l_return          usim_position.usim_id_pos%TYPE;
  BEGIN
    -- get correct sequence
    IF SIGN(p_usim_coordinate) >= 0
    THEN
      l_current_level := get_seq_currval('USIM_POS_LVLP_SEQ');
    ELSE
      l_current_level := get_seq_currval('USIM_POS_LVLN_SEQ');
    END IF;
    -- check if position exist
    SELECT COUNT(*) INTO l_check_exists FROM usim_position WHERE usim_coordinate = p_usim_coordinate AND usim_coord_level = l_current_level;
    IF l_check_exists > 0
    THEN
      -- exists, return id
      SELECT usim_id_pos INTO l_return FROM usim_position WHERE usim_coordinate = p_usim_coordinate AND usim_coord_level = l_current_level;
    ELSE
      -- create a new entry
      INSERT INTO usim_position (usim_coordinate, usim_coord_level) VALUES (p_usim_coordinate, l_current_level);
      -- if max reached, update sequence
      IF usim_static.is_overflow_reached(p_usim_coordinate)
      THEN
        IF SIGN(p_usim_coordinate) >= 0
        THEN
          SELECT usim_pos_lvlp_seq.NEXTVAL INTO l_new_sequence FROM dual;
        ELSE
          SELECT usim_pos_lvln_seq.NEXTVAL INTO l_new_sequence FROM dual;
        END IF;
      END IF;
    END IF;
    RETURN l_return;
  END insert_position
  ;

  FUNCTION get_max_position(p_sign IN NUMBER DEFAULT 1)
    RETURN NUMBER
  IS
    l_result      NUMBER;
    l_curr_val    INTEGER;
    l_has_values  INTEGER;
  BEGIN
    IF p_sign >= 0
    THEN
      l_curr_val := get_seq_currval('USIM_POS_LVLP_SEQ');
      -- check if we have values for current level
      SELECT COUNT(*) INTO l_has_values FROM usim_position WHERE usim_coord_level = l_curr_val;
      IF l_has_values > 0
      THEN
        SELECT MAX(usim_coordinate) INTO l_result FROM usim_position WHERE usim_coord_level = l_curr_val;
      ELSE
        IF l_curr_val > 1
        THEN
          SELECT MAX(usim_coordinate) INTO l_result FROM usim_position WHERE usim_coord_level = (l_curr_val - 1);
        ELSE
          l_result := NULL;
        END IF;
      END IF;
    ELSE
      l_curr_val := get_seq_currval('USIM_POS_LVLN_SEQ');
      -- check if we have values for current level
      SELECT COUNT(*) INTO l_has_values FROM usim_position WHERE usim_coord_level = l_curr_val;
      IF l_has_values > 0
      THEN
        SELECT MIN(usim_coordinate) INTO l_result FROM usim_position WHERE usim_coord_level = l_curr_val;
      ELSE
        IF l_curr_val > 1
        THEN
          SELECT MIN(usim_coordinate) INTO l_result FROM usim_position WHERE usim_coord_level = (l_curr_val - 1);
        ELSE
          l_result := NULL;
        END IF;
      END IF;
    END IF;
    RETURN l_result;
  END get_max_position
  ;

  FUNCTION get_max_position_1st(p_sign IN NUMBER DEFAULT 1)
    RETURN NUMBER
  IS
    l_return  NUMBER;
  BEGIN
    IF p_sign >= 0
    THEN
      IF usim_static.is_overflow_reached(get_max_position)
      THEN
        l_return := 1;
      ELSE
        l_return := get_max_position + 1;
      END IF;
    ELSE
      IF usim_static.is_overflow_reached(get_max_position(-1))
      THEN
        l_return := -1;
      ELSE
        l_return := get_max_position(-1) - 1;
      END IF;
    END IF;
    RETURN l_return;
  END get_max_position_1st
  ;

  FUNCTION get_max_position_2nd(p_sign IN NUMBER DEFAULT 1)
    RETURN NUMBER
  IS
    l_return  NUMBER;
  BEGIN
    IF p_sign >= 0
    THEN
      IF usim_static.is_overflow_reached(get_max_position_1st)
      THEN
        l_return := 1;
      ELSE
        l_return := get_max_position_1st + 1;
      END IF;
    ELSE
      IF usim_static.is_overflow_reached(get_max_position_1st(-1))
      THEN
        l_return := -1;
      ELSE
        l_return := get_max_position_1st(-1) - 1;
      END IF;
    END IF;
    RETURN l_return;
  END get_max_position_2nd
  ;

  FUNCTION amplitude( p_usim_energy_source      IN usim_point.usim_energy%TYPE
                    , p_usim_angular_frequency  IN NUMBER
                    )
    RETURN NUMBER
  IS
  BEGIN
    RETURN NULL;
  END amplitude
  ;

  FUNCTION wavelength( p_usim_angular_frequency   IN NUMBER
                     , p_usim_velocity            IN NUMBER DEFAULT 1
                     )
    RETURN NUMBER
  IS
  BEGIN
    RETURN p_usim_velocity / p_usim_angular_frequency;
  END wavelength
  ;
END usim_utility;
</pre>
</div>
</div>
</div>
</body>
</html>
