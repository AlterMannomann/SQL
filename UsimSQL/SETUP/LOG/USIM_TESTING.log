SQL> -- get system information roughly formatted
SQL> @@../UTIL/SYSTEM_INFO.sql
SQL> SELECT SYSDATE AS exec_date
  2       , SUBSTR(SYS_CONTEXT('USERENV', 'DB_NAME'), 1, 30) AS db_name
  3       , SUBSTR(SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'), 1, 30) AS db_schema
  4       , SUBSTR(SYS_CONTEXT('USERENV', 'OS_USER'), 1, 60) AS os_user
  5    FROM dual
  6  ;

EXEC_DATE           DB_NAME                        DB_SCHEMA                      OS_USER
------------------- ------------------------------ ------------------------------ ------------------------------------------------------------
20.05.2024 04:19:39 FREEPDB1                       USIM_TEST                      Adi

1 Zeile ausgewählt.

SQL>
SQL> -- Check user
SQL> SELECT 'Check USIM user/schema' AS info FROM dual;

INFO
----------------------
Check USIM user/schema

1 Zeile ausgewählt.

SQL> -- USIM_LIVE
SQL> SELECT CASE
  2           WHEN USER = 'USIM_TEST'
  3             OR SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') = 'USIM_TEST'
  4           THEN '../UTIL/CHECK_SUCCESSFUL.sql "Acting on schema USIM_TEST."'
  5           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Wrong user or schema, USIM_TEST required."'
  6         END AS SCRIPTFILE
  7    FROM dual
  8  ;

SCRIPTFILE
------------------------------------------------------------------------------
../UTIL/CHECK_SUCCESSFUL.sql "Acting on schema USIM_TEST."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Check successful. ' || NVL('&1', 'No further information available.') AS info FROM dual;
alt:SELECT 'Check successful. ' || NVL('&1', 'No further information available.') AS info FROM dual
neu:SELECT 'Check successful. ' || NVL('Acting on schema USIM_TEST.', 'No further information available.') AS info FROM dual

INFO
---------------------------------------------
Check successful. Acting on schema USIM_TEST.

1 Zeile ausgewählt.

SQL>
SQL> -- delete model
SQL> @@USIM_DROP.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> SELECT 'Remove all USIM objects if needed.' AS info FROM dual;

INFO
----------------------------------
Remove all USIM objects if needed.

1 Zeile ausgewählt.

SQL> --== basic packages start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_STATIC_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_STATIC does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_STATIC'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_STATIC_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_STATIC does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_STATIC'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_STATIC_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_STATIC does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_STATIC'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_STATIC does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_STATIC does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Package body USIM_STATIC does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_STATIC_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_STATIC does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_STATIC'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_STATIC_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_STATIC does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_STATIC'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_STATIC_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_STATIC does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_STATIC'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_STATIC does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_STATIC does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------------
Nothing to do. Package header USIM_STATIC does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_MATHS_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_MATHS does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MATHS'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_MATHS_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_MATHS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MATHS'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_MATHS_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_MATHS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MATHS'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_MATHS does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_MATHS does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package body USIM_MATHS does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_MATHS_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_MATHS does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MATHS'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_MATHS_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_MATHS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MATHS'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_MATHS_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_MATHS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MATHS'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_MATHS does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_MATHS does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------------
Nothing to do. Package header USIM_MATHS does not exist.

1 Zeile ausgewählt.

SQL> --== basic packages end ==--
SQL>
SQL> --== sequences start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../SEQUENCES/DROP/DROP_USIM_DLG_ID_SEQ.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_DLG_ID_SEQ does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DLG_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_DLG_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_DLG_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DLG_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_DLG_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_DLG_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DLG_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_DLG_ID_SEQ does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Sequence USIM_DLG_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_DLG_ID_SEQ does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../SEQUENCES/DROP/DROP_USIM_ERL_TICK_SEQ.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_ERL_TICK_SEQ does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_ERL_TICK_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_ERL_TICK_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_ERL_TICK_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_ERL_TICK_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_ERL_TICK_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_ERL_TICK_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_ERL_TICK_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_ERL_TICK_SEQ does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Sequence USIM_ERL_TICK_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------------
Nothing to do. Sequence USIM_ERL_TICK_SEQ does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../SEQUENCES/DROP/DROP_USIM_MLV_ID_SEQ.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_MLV_ID_SEQ does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MLV_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_MLV_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_MLV_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MLV_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_MLV_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_MLV_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MLV_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_MLV_ID_SEQ does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Sequence USIM_MLV_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_MLV_ID_SEQ does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../SEQUENCES/DROP/DROP_USIM_PLANCK_TIME_SEQ.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_PLANCK_TIME_SEQ does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_PLANCK_TIME_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_PLANCK_TIME_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_PLANCK_TIME_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_PLANCK_TIME_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_PLANCK_TIME_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_PLANCK_TIME_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_PLANCK_TIME_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_PLANCK_TIME_SEQ does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Sequence USIM_PLANCK_TIME_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------------
Nothing to do. Sequence USIM_PLANCK_TIME_SEQ does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../SEQUENCES/DROP/DROP_USIM_PLANCK_AEON_SEQ.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_PLANCK_AEON_SEQ does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_PLANCK_AEON_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_PLANCK_AEON_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_PLANCK_AEON_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_PLANCK_AEON_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_PLANCK_AEON_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_PLANCK_AEON_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_PLANCK_AEON_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_PLANCK_AEON_SEQ does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Sequence USIM_PLANCK_AEON_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------------
Nothing to do. Sequence USIM_PLANCK_AEON_SEQ does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../SEQUENCES/DROP/DROP_USIM_DIM_ID_SEQ.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_DIM_ID_SEQ does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DIM_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_DIM_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_DIM_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DIM_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_DIM_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_DIM_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DIM_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_DIM_ID_SEQ does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Sequence USIM_DIM_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_DIM_ID_SEQ does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../SEQUENCES/DROP/DROP_USIM_TSU_ID_SEQ.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_TSU_ID_SEQ does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TSU_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_TSU_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_TSU_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TSU_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_TSU_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_TSU_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TSU_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_TSU_ID_SEQ does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Sequence USIM_TSU_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_TSU_ID_SEQ does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../SEQUENCES/DROP/DROP_USIM_POS_ID_SEQ.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_POS_ID_SEQ does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_POS_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_POS_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_POS_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_POS_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_POS_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_POS_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_POS_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_POS_ID_SEQ does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Sequence USIM_POS_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_POS_ID_SEQ does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../SEQUENCES/DROP/DROP_USIM_NOD_ID_SEQ.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_NOD_ID_SEQ does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_NOD_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_NOD_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_NOD_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_NOD_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_NOD_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_NOD_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_NOD_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_NOD_ID_SEQ does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Sequence USIM_NOD_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_NOD_ID_SEQ does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../SEQUENCES/DROP/DROP_USIM_RMD_ID_SEQ.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_RMD_ID_SEQ does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_RMD_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_RMD_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_RMD_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_RMD_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_RMD_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_RMD_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_RMD_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_RMD_ID_SEQ does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Sequence USIM_RMD_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_RMD_ID_SEQ does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../SEQUENCES/DROP/DROP_USIM_SPC_ID_SEQ.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_SPC_ID_SEQ does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_SPC_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_SPC_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_SPC_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_SPC_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_SPC_ID_SEQ does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Sequence USIM_SPC_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_SPC_ID_SEQ does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../SEQUENCES/DROP/DROP_USIM_SPR_ID_SEQ.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_SPR_ID_SEQ does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPR_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_SPR_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_SPR_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPR_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../SEQUENCES/DROP/DROP_USIM_SPR_ID_SEQ.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_SPR_ID_SEQ does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPR_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_SPR_ID_SEQ does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Sequence USIM_SPR_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_SPR_ID_SEQ does not exist.

1 Zeile ausgewählt.

SQL> --== sequences end ==--
SQL>
SQL> --== foreign keys drop for easy delete start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_RMD_MLV_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RMD_MLV_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_REL_MLV_DIM'
  9     AND constraint_name  = 'USIM_RMD_MLV_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_RMD_MLV_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RMD_MLV_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_REL_MLV_DIM'
   AND constraint_name  = 'USIM_RMD_MLV_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_RMD_MLV_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RMD_MLV_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_REL_MLV_DIM'
   AND constraint_name  = 'USIM_RMD_MLV_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RMD_MLV_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_RMD_MLV_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_RMD_MLV_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_RMD_DIM_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RMD_DIM_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_REL_MLV_DIM'
  9     AND constraint_name  = 'USIM_RMD_DIM_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_RMD_DIM_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RMD_DIM_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_REL_MLV_DIM'
   AND constraint_name  = 'USIM_RMD_DIM_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_RMD_DIM_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RMD_DIM_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_REL_MLV_DIM'
   AND constraint_name  = 'USIM_RMD_DIM_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RMD_DIM_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_RMD_DIM_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_RMD_DIM_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_RCHI_PARENT_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RCHI_PARENT_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_RMD_CHILD'
  9     AND constraint_name  = 'USIM_RCHI_PARENT_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_RCHI_PARENT_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RCHI_PARENT_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_RMD_CHILD'
   AND constraint_name  = 'USIM_RCHI_PARENT_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_RCHI_PARENT_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RCHI_PARENT_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_RMD_CHILD'
   AND constraint_name  = 'USIM_RCHI_PARENT_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RCHI_PARENT_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_RCHI_PARENT_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------------------
Nothing to do. Foreign key USIM_RCHI_PARENT_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_RCHI_CHILD_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RCHI_CHILD_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_RMD_CHILD'
  9     AND constraint_name  = 'USIM_RCHI_CHILD_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_RCHI_CHILD_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RCHI_CHILD_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_RMD_CHILD'
   AND constraint_name  = 'USIM_RCHI_CHILD_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_RCHI_CHILD_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RCHI_CHILD_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_RMD_CHILD'
   AND constraint_name  = 'USIM_RCHI_CHILD_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RCHI_CHILD_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_RCHI_CHILD_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------------
Nothing to do. Foreign key USIM_RCHI_CHILD_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_SPC_POS_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_POS_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_SPACE'
  9     AND constraint_name  = 'USIM_SPC_POS_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPC_POS_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_POS_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPACE'
   AND constraint_name  = 'USIM_SPC_POS_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPC_POS_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_POS_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPACE'
   AND constraint_name  = 'USIM_SPC_POS_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_POS_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPC_POS_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPC_POS_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_SPC_NOD_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_NOD_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_SPACE'
  9     AND constraint_name  = 'USIM_SPC_NOD_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPC_NOD_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_NOD_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPACE'
   AND constraint_name  = 'USIM_SPC_NOD_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPC_NOD_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_NOD_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPACE'
   AND constraint_name  = 'USIM_SPC_NOD_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_NOD_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPC_NOD_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPC_NOD_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_SPC_RMD_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_RMD_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_SPACE'
  9     AND constraint_name  = 'USIM_SPC_RMD_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPC_RMD_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_RMD_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPACE'
   AND constraint_name  = 'USIM_SPC_RMD_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPC_RMD_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_RMD_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPACE'
   AND constraint_name  = 'USIM_SPC_RMD_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_RMD_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPC_RMD_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPC_RMD_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_CHI_PARENT_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_CHI_PARENT_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_SPC_CHILD'
  9     AND constraint_name  = 'USIM_CHI_PARENT_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_CHI_PARENT_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_CHI_PARENT_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_CHILD'
   AND constraint_name  = 'USIM_CHI_PARENT_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_CHI_PARENT_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_CHI_PARENT_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_CHILD'
   AND constraint_name  = 'USIM_CHI_PARENT_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_CHI_PARENT_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_CHI_PARENT_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------------
Nothing to do. Foreign key USIM_CHI_PARENT_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_CHI_CHILD_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_CHI_CHILD_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_SPC_CHILD'
  9     AND constraint_name  = 'USIM_CHI_CHILD_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_CHI_CHILD_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_CHI_CHILD_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_CHILD'
   AND constraint_name  = 'USIM_CHI_CHILD_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_CHI_CHILD_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_CHI_CHILD_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_CHILD'
   AND constraint_name  = 'USIM_CHI_CHILD_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_CHI_CHILD_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_CHI_CHILD_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------------
Nothing to do. Foreign key USIM_CHI_CHILD_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_SPO_SPC_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_SPC_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_SPC_POS'
  9     AND constraint_name  = 'USIM_SPO_SPC_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPO_SPC_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_SPC_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_POS'
   AND constraint_name  = 'USIM_SPO_SPC_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPO_SPC_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_SPC_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_POS'
   AND constraint_name  = 'USIM_SPO_SPC_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_SPC_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPO_SPC_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPO_SPC_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_SPO_RMD_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_RMD_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_SPC_POS'
  9     AND constraint_name  = 'USIM_SPO_RMD_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPO_RMD_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_RMD_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_POS'
   AND constraint_name  = 'USIM_SPO_RMD_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPO_RMD_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_RMD_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_POS'
   AND constraint_name  = 'USIM_SPO_RMD_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_RMD_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPO_RMD_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPO_RMD_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_SPO_POS_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_POS_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_SPC_POS'
  9     AND constraint_name  = 'USIM_SPO_POS_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPO_POS_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_POS_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_POS'
   AND constraint_name  = 'USIM_SPO_POS_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPO_POS_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_POS_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_POS'
   AND constraint_name  = 'USIM_SPO_POS_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_POS_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPO_POS_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPO_POS_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_SPR_SRC_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPR_SRC_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_SPC_PROCESS'
  9     AND constraint_name  = 'USIM_SPR_SRC_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPR_SRC_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPR_SRC_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_PROCESS'
   AND constraint_name  = 'USIM_SPR_SRC_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPR_SRC_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPR_SRC_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_PROCESS'
   AND constraint_name  = 'USIM_SPR_SRC_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPR_SRC_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPR_SRC_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPR_SRC_FK does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../FK/DROP/DROP_USIM_SPR_TGT_FK.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPR_TGT_FK does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8     AND table_name       = 'USIM_SPC_PROCESS'
  9     AND constraint_name  = 'USIM_SPR_TGT_FK'
 10     AND owner            = '&USIM_SCHEMA'
 11  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPR_TGT_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPR_TGT_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_PROCESS'
   AND constraint_name  = 'USIM_SPR_TGT_FK'
   AND owner            = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../FK/DROP/DROP_USIM_SPR_TGT_FK.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPR_TGT_FK does not exist."'
       END AS SCRIPTFILE
  FROM all_constraints
 WHERE constraint_type  = 'R'
   AND table_name       = 'USIM_SPC_PROCESS'
   AND constraint_name  = 'USIM_SPR_TGT_FK'
   AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPR_TGT_FK does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPR_TGT_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPR_TGT_FK does not exist.

1 Zeile ausgewählt.

SQL> --== foreign keys drop for easy delete end ==--
SQL>
SQL> --== drop views start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../VIEW/DROP/DROP_USIM_RMD_V.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_RMD_V does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8     AND object_name = 'USIM_RMD_V'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_RMD_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_RMD_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_RMD_V'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_RMD_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_RMD_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_RMD_V'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_RMD_V does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('View USIM_RMD_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------
Nothing to do. View USIM_RMD_V does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../VIEW/DROP/DROP_USIM_SPC_CHI_V.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPC_CHI_V does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8     AND object_name = 'USIM_SPC_CHI_V'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPC_CHI_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPC_CHI_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPC_CHI_V'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPC_CHI_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPC_CHI_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPC_CHI_V'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPC_CHI_V does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('View USIM_SPC_CHI_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------
Nothing to do. View USIM_SPC_CHI_V does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../VIEW/DROP/DROP_USIM_SPC_V.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPC_V does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8     AND object_name = 'USIM_SPC_V'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPC_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPC_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPC_V'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPC_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPC_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPC_V'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPC_V does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('View USIM_SPC_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------
Nothing to do. View USIM_SPC_V does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../VIEW/DROP/DROP_USIM_CHI_V.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_CHI_V does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8     AND object_name = 'USIM_CHI_V'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_CHI_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_CHI_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_CHI_V'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_CHI_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_CHI_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_CHI_V'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_CHI_V does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('View USIM_CHI_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------
Nothing to do. View USIM_CHI_V does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../VIEW/DROP/DROP_USIM_SPO_V.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_V does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8     AND object_name = 'USIM_SPO_V'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPO_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPO_V'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPO_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPO_V'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_V does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('View USIM_SPO_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------
Nothing to do. View USIM_SPO_V does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../VIEW/DROP/DROP_USIM_SPO_XYZ_V.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_XYZ_V does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8     AND object_name = 'USIM_SPO_XYZ_V'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPO_XYZ_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_XYZ_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPO_XYZ_V'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPO_XYZ_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_XYZ_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPO_XYZ_V'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_XYZ_V does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('View USIM_SPO_XYZ_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------
Nothing to do. View USIM_SPO_XYZ_V does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../VIEW/DROP/DROP_USIM_SPO_BASE3D_V.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_BASE3D_V does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8     AND object_name = 'USIM_SPO_BASE3D_V'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPO_BASE3D_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_BASE3D_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPO_BASE3D_V'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPO_BASE3D_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_BASE3D_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPO_BASE3D_V'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_BASE3D_V does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('View USIM_SPO_BASE3D_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. View USIM_SPO_BASE3D_V does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../VIEW/DROP/DROP_USIM_SPO_ZERO3D_V.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_ZERO3D_V does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8     AND object_name = 'USIM_SPO_ZERO3D_V'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPO_ZERO3D_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_ZERO3D_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPO_ZERO3D_V'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPO_ZERO3D_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_ZERO3D_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPO_ZERO3D_V'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_ZERO3D_V does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('View USIM_SPO_ZERO3D_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. View USIM_SPO_ZERO3D_V does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../VIEW/DROP/DROP_USIM_SPR_V.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPR_V does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8     AND object_name = 'USIM_SPR_V'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPR_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPR_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPR_V'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_SPR_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPR_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_SPR_V'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPR_V does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('View USIM_SPR_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------
Nothing to do. View USIM_SPR_V does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../VIEW/DROP/DROP_USIM_MLV_STATE_V.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_MLV_STATE_V does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8     AND object_name = 'USIM_MLV_STATE_V'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_MLV_STATE_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_MLV_STATE_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_MLV_STATE_V'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../VIEW/DROP/DROP_USIM_MLV_STATE_V.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_MLV_STATE_V does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_type = 'VIEW'
   AND object_name = 'USIM_MLV_STATE_V'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_MLV_STATE_V does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('View USIM_MLV_STATE_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. View USIM_MLV_STATE_V does not exist.

1 Zeile ausgewählt.

SQL> --== drop views end ==--
SQL>
SQL> --== debug tables start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_DEBUG_LOG_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_DEBUG_LOG does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DEBUG_LOG'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_DEBUG_LOG_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_DEBUG_LOG does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DEBUG_LOG'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_DEBUG_LOG_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_DEBUG_LOG does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DEBUG_LOG'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_DEBUG_LOG does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_DEBUG_LOG does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------
Nothing to do. Table USIM_DEBUG_LOG does not exist.

1 Zeile ausgewählt.

SQL> --== debug tables end ==--
SQL>
SQL> --== debug package start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_DEBUG_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_DEBUG does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DEBUG'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_DEBUG_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_DEBUG does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DEBUG'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_DEBUG_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_DEBUG does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DEBUG'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_DEBUG does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_DEBUG does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package body USIM_DEBUG does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_DEBUG_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_DEBUG does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DEBUG'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_DEBUG_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_DEBUG does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DEBUG'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_DEBUG_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_DEBUG does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DEBUG'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_DEBUG does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_DEBUG does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------------
Nothing to do. Package header USIM_DEBUG does not exist.

1 Zeile ausgewählt.

SQL> --== debug package end ==--
SQL>
SQL> --== test tables start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_TEST_SUMMARY_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_TEST_SUMMARY does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TEST_SUMMARY'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_TEST_SUMMARY_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_TEST_SUMMARY does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TEST_SUMMARY'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_TEST_SUMMARY_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_TEST_SUMMARY does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TEST_SUMMARY'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_TEST_SUMMARY does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_TEST_SUMMARY does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Table USIM_TEST_SUMMARY does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_TEST_ERRORS_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_TEST_ERRORS does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TEST_ERRORS'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_TEST_ERRORS_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_TEST_ERRORS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TEST_ERRORS'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_TEST_ERRORS_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_TEST_ERRORS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TEST_ERRORS'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_TEST_ERRORS does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_TEST_ERRORS does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Table USIM_TEST_ERRORS does not exist.

1 Zeile ausgewählt.

SQL> --== test tables end ==--
SQL>
SQL> --== test package start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_TEST_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_TEST does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TEST'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_TEST_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_TEST does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TEST'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_TEST_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_TEST does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TEST'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_TEST does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_TEST does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Package body USIM_TEST does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_TEST_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_TEST does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TEST'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_TEST_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_TEST does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TEST'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_TEST_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_TEST does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TEST'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_TEST does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_TEST does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Package header USIM_TEST does not exist.

1 Zeile ausgewählt.

SQL> --== test package end ==--
SQL>
SQL> --== packages depending on tables start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_ERL_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_ERL does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_ERL'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_ERL_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_ERL does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_ERL'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_ERL_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_ERL does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_ERL'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_ERL does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_ERL does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_ERL does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_ERL_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_ERL does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_ERL'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_ERL_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_ERL does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_ERL'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_ERL_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_ERL does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_ERL'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_ERL does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_ERL does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_ERL does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_BASE_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_BASE does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_BASE'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_BASE_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_BASE does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_BASE'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_BASE_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_BASE does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_BASE'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_BASE does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_BASE does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Package body USIM_BASE does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_BASE_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_BASE does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_BASE'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_BASE_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_BASE does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_BASE'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_BASE_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_BASE does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_BASE'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_BASE does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_BASE does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Package header USIM_BASE does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_MLV_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_MLV does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MLV'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_MLV_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_MLV does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MLV'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_MLV_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_MLV does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MLV'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_MLV does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_MLV does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_MLV does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_MLV_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_MLV does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MLV'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_MLV_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_MLV does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MLV'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_MLV_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_MLV does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MLV'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_MLV does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_MLV does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_MLV does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_DIM_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_DIM does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DIM'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_DIM_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_DIM does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DIM'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_DIM_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_DIM does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DIM'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_DIM does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_DIM does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_DIM does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_DIM_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_DIM does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DIM'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_DIM_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_DIM does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DIM'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_DIM_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_DIM does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DIM'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_DIM does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_DIM does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_DIM does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_POS_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_POS does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_POS'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_POS_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_POS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_POS'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_POS_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_POS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_POS'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_POS does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_POS does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_POS does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_POS_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_POS does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_POS'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_POS_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_POS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_POS'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_POS_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_POS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_POS'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_POS does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_POS does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_POS does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_NOD_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_NOD does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_NOD'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_NOD_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_NOD does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_NOD'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_NOD_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_NOD does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_NOD'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_NOD does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_NOD does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_NOD does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_NOD_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_NOD does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_NOD'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_NOD_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_NOD does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_NOD'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_NOD_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_NOD does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_NOD'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_NOD does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_NOD does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_NOD does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_RMD_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_RMD does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_RMD'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_RMD_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_RMD does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_RMD'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_RMD_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_RMD does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_RMD'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_RMD does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_RMD does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_RMD does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_RMD_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_RMD does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_RMD'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_RMD_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_RMD does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_RMD'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_RMD_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_RMD does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_RMD'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_RMD does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_RMD does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_RMD does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_SPC_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPC does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_SPC_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPC does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_SPC_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPC does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPC does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_SPC does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_SPC does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_SPC_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPC does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_SPC_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPC does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_SPC_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPC does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPC does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_SPC does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_SPC does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_CHI_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_CHI does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_CHI'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_CHI_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_CHI does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_CHI'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_CHI_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_CHI does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_CHI'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_CHI does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_CHI does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_CHI does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_CHI_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_CHI does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_CHI'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_CHI_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_CHI does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_CHI'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_CHI_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_CHI does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_CHI'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_CHI does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_CHI does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_CHI does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_SPO_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPO does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPO'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_SPO_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPO does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPO'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_SPO_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPO does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPO'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPO does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_SPO does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_SPO does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_SPO_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPO does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPO'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_SPO_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPO does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPO'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_SPO_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPO does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPO'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPO does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_SPO does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_SPO does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_SPR_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPR does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPR'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_SPR_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPR does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPR'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_SPR_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPR does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPR'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPR does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_SPR does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_SPR does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_SPR_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPR does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPR'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_SPR_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPR does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPR'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_SPR_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPR does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPR'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPR does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_SPR does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_SPR does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_CREATOR_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_CREATOR does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_CREATOR'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_CREATOR_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_CREATOR does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_CREATOR'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_CREATOR_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_CREATOR does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_CREATOR'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_CREATOR does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_CREATOR does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------------
Nothing to do. Package body USIM_CREATOR does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_CREATOR_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_CREATOR does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_CREATOR'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_CREATOR_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_CREATOR does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_CREATOR'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_CREATOR_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_CREATOR does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_CREATOR'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_CREATOR does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_CREATOR does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Package header USIM_CREATOR does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_PROCESS_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_PROCESS does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_PROCESS'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_PROCESS_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_PROCESS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_PROCESS'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_PROCESS_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_PROCESS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_PROCESS'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_PROCESS does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_PROCESS does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------------
Nothing to do. Package body USIM_PROCESS does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_PROCESS_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_PROCESS does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_PROCESS'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_PROCESS_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_PROCESS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_PROCESS'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_PROCESS_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_PROCESS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_PROCESS'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_PROCESS does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_PROCESS does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Package header USIM_PROCESS does not exist.

1 Zeile ausgewählt.

SQL>
SQL>
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_DBIF_PKB.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_DBIF does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DBIF'
  8     AND object_type = 'PACKAGE BODY'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_DBIF_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_DBIF does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DBIF'
   AND object_type = 'PACKAGE BODY'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_DBIF_PKB.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_DBIF does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DBIF'
   AND object_type = 'PACKAGE BODY'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_DBIF does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package body USIM_DBIF does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Package body USIM_DBIF does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../PACKAGES/DROP/DROP_USIM_DBIF_PKS.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_DBIF does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DBIF'
  8     AND object_type = 'PACKAGE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_DBIF_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_DBIF does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DBIF'
   AND object_type = 'PACKAGE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../PACKAGES/DROP/DROP_USIM_DBIF_PKS.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_DBIF does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DBIF'
   AND object_type = 'PACKAGE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_DBIF does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Package header USIM_DBIF does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Package header USIM_DBIF does not exist.

1 Zeile ausgewählt.

SQL> --== packages depending on tables end ==--
SQL>
SQL> --== base data start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_BASEDATA_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_BASEDATA does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_BASEDATA'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_BASEDATA_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_BASEDATA does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_BASEDATA'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_BASEDATA_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_BASEDATA does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_BASEDATA'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_BASEDATA does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_BASEDATA does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------
Nothing to do. Table USIM_BASEDATA does not exist.

1 Zeile ausgewählt.

SQL> --== base data end ==--
SQL>
SQL> --== base tables start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_ERROR_LOG_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_ERROR_LOG does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_ERROR_LOG'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_ERROR_LOG_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_ERROR_LOG does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_ERROR_LOG'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_ERROR_LOG_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_ERROR_LOG does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_ERROR_LOG'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_ERROR_LOG does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_ERROR_LOG does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------
Nothing to do. Table USIM_ERROR_LOG does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_MULTIVERSE_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_MULTIVERSE does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MULTIVERSE'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_MULTIVERSE_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_MULTIVERSE does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MULTIVERSE'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_MULTIVERSE_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_MULTIVERSE does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MULTIVERSE'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_MULTIVERSE does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_MULTIVERSE does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Table USIM_MULTIVERSE does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_DIMENSION_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_DIMENSION does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DIMENSION'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_DIMENSION_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_DIMENSION does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DIMENSION'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_DIMENSION_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_DIMENSION does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DIMENSION'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_DIMENSION does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_DIMENSION does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------
Nothing to do. Table USIM_DIMENSION does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_POSITION_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_POSITION does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_POSITION'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_POSITION_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_POSITION does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_POSITION'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_POSITION_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_POSITION does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_POSITION'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_POSITION does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_POSITION does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------
Nothing to do. Table USIM_POSITION does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_NODE_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_NODE does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_NODE'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_NODE_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_NODE does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_NODE'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_NODE_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_NODE does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_NODE'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_NODE does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_NODE does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------
Nothing to do. Table USIM_NODE does not exist.

1 Zeile ausgewählt.

SQL> --== base tables end ==--
SQL>
SQL> --== relation tables start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_REL_MLV_DIM_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_REL_MLV_DIM does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_REL_MLV_DIM'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_REL_MLV_DIM_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_REL_MLV_DIM does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_REL_MLV_DIM'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_REL_MLV_DIM_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_REL_MLV_DIM does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_REL_MLV_DIM'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_REL_MLV_DIM does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_REL_MLV_DIM does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Table USIM_REL_MLV_DIM does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_RMD_CHILD_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_RMD_CHILD does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_RMD_CHILD'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_RMD_CHILD_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_RMD_CHILD does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_RMD_CHILD'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_RMD_CHILD_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_RMD_CHILD does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_RMD_CHILD'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_RMD_CHILD does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_RMD_CHILD does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------
Nothing to do. Table USIM_RMD_CHILD does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_SPACE_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPACE does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPACE'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_SPACE_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPACE does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPACE'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_SPACE_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPACE does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPACE'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_SPACE does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_SPACE does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------
Nothing to do. Table USIM_SPACE does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_SPC_CHILD_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_CHILD does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_CHILD'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_SPC_CHILD_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_CHILD does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_CHILD'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_SPC_CHILD_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_CHILD does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_CHILD'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_CHILD does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_SPC_CHILD does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------
Nothing to do. Table USIM_SPC_CHILD does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_SPC_POS_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_POS does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_POS'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_SPC_POS_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_POS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_POS'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_SPC_POS_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_POS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_POS'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_POS does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_SPC_POS does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------
Nothing to do. Table USIM_SPC_POS does not exist.

1 Zeile ausgewählt.

SQL> SELECT CASE
  2           WHEN COUNT(*) > 0
  3           THEN '../TABLES/DROP/DROP_USIM_SPC_PROCESS_TBL.sql'
  4           ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_PROCESS does not exist."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_PROCESS'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_SPC_PROCESS_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_PROCESS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_PROCESS'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) > 0
         THEN '../TABLES/DROP/DROP_USIM_SPC_PROCESS_TBL.sql'
         ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_PROCESS does not exist."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_PROCESS'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_PROCESS does not exist."

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
alt:SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
neu:SELECT 'Nothing to do. ' || NVL('Table USIM_SPC_PROCESS does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Table USIM_SPC_PROCESS does not exist.

1 Zeile ausgewählt.

SQL> --== relation tables end ==--
SQL>
SQL> --== log tables start ==--
SQL> --== log tables end ==--
SQL>
SQL>
SQL> -- empty recycle bin
SQL> PURGE recyclebin;

Recyclebin gelöscht.

SQL> @@../UTIL/VERIFY_DROP.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> SELECT COUNT(*) AS objects_after_cleanup
  2    FROM all_objects
  3   WHERE owner = '&USIM_SCHEMA'
  4  ;
alt:SELECT COUNT(*) AS objects_after_cleanup
  FROM all_objects
 WHERE owner = '&USIM_SCHEMA'

neu:SELECT COUNT(*) AS objects_after_cleanup
  FROM all_objects
 WHERE owner = 'USIM_TEST'

OBJECTS_AFTER_CLEANUP
---------------------
                    0

1 Zeile ausgewählt.

SQL> -- overview remaining objects after cleanup
SQL> SELECT object_type
  2       , COUNT(*) AS object_cnt
  3    FROM all_objects
  4   WHERE owner = '&USIM_SCHEMA'
  5   GROUP BY object_type
  6  ;
alt:SELECT object_type
     , COUNT(*) AS object_cnt
  FROM all_objects
 WHERE owner = '&USIM_SCHEMA'
 GROUP BY object_type

neu:SELECT object_type
     , COUNT(*) AS object_cnt
  FROM all_objects
 WHERE owner = 'USIM_TEST'
 GROUP BY object_type

0 Zeilen ausgewählt.

SQL>
SQL> -- build model
SQL> @@USIM_MODEL.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> SELECT 'Create or recreate USIM objects.' AS info FROM dual;

INFO
--------------------------------
Create or recreate USIM objects.

1 Zeile ausgewählt.

SQL> --== error logging start ==--
SQL> -- USIM_ERL_TICK_SEQ
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../SEQUENCES/USIM_ERL_TICK_SEQ.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_ERL_TICK_SEQ still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_ERL_TICK_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_ERL_TICK_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_ERL_TICK_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_ERL_TICK_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_ERL_TICK_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_ERL_TICK_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_ERL_TICK_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------------
../SEQUENCES/USIM_ERL_TICK_SEQ.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_ERROR_LOG (erl) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_erl_tick_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
alt:CREATE SEQUENCE &USIM_SCHEMA..usim_erl_tick_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

neu:CREATE SEQUENCE USIM_TEST.usim_erl_tick_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

Sequence USIM_TEST.USIM_ERL_TICK_SEQ erstellt.

SQL> -- USIM_ERROR_LOG (erl)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_ERROR_LOG_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_ERROR_LOG still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_ERROR_LOG'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_ERROR_LOG_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_ERROR_LOG still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_ERROR_LOG'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_ERROR_LOG_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_ERROR_LOG still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_ERROR_LOG'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../TABLES/USIM_ERROR_LOG_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_ERROR_LOG (erl)
SQL> CREATE TABLE &USIM_SCHEMA..usim_error_log
  2    ( usim_timestamp    TIMESTAMP       DEFAULT SYSTIMESTAMP  NOT NULL ENABLE
  3    , usim_tick         NUMBER                                NOT NULL ENABLE
  4    , usim_err_object   VARCHAR2(200)                         NOT NULL ENABLE
  5    , usim_err_info     VARCHAR2(4000)                        NOT NULL ENABLE
  6    )
  7  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_error_log
  ( usim_timestamp    TIMESTAMP       DEFAULT SYSTIMESTAMP  NOT NULL ENABLE
  , usim_tick         NUMBER                                NOT NULL ENABLE
  , usim_err_object   VARCHAR2(200)                         NOT NULL ENABLE
  , usim_err_info     VARCHAR2(4000)                        NOT NULL ENABLE
  )

neu:CREATE TABLE USIM_TEST.usim_error_log
  ( usim_timestamp    TIMESTAMP       DEFAULT SYSTIMESTAMP  NOT NULL ENABLE
  , usim_tick         NUMBER                                NOT NULL ENABLE
  , usim_err_object   VARCHAR2(200)                         NOT NULL ENABLE
  , usim_err_info     VARCHAR2(4000)                        NOT NULL ENABLE
  )

Table USIM_TEST.USIM_ERROR_LOG erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_error_log IS 'Used by package functions returning NULL to report the error condition. Will use the alias erl.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_error_log IS 'Used by package functions returning NULL to report the error condition. Will use the alias erl.'
neu:COMMENT ON TABLE USIM_TEST.usim_error_log IS 'Used by package functions returning NULL to report the error condition. Will use the alias erl.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_error_log.usim_timestamp IS 'The timestamp of the error logging action.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_error_log.usim_timestamp IS 'The timestamp of the error logging action.'
neu:COMMENT ON COLUMN USIM_TEST.usim_error_log.usim_timestamp IS 'The timestamp of the error logging action.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_error_log.usim_err_object IS 'The object description in form of package.function.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_error_log.usim_err_object IS 'The object description in form of package.function.'
neu:COMMENT ON COLUMN USIM_TEST.usim_error_log.usim_err_object IS 'The object description in form of package.function.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_error_log.usim_err_info IS 'The short details on the error, e.g. used parameters.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_error_log.usim_err_info IS 'The short details on the error, e.g. used parameters.'
neu:COMMENT ON COLUMN USIM_TEST.usim_error_log.usim_err_info IS 'The short details on the error, e.g. used parameters.'

Comment erstellt.

SQL>
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_erl_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_error_log
  3      FOR EACH ROW
  4      BEGIN
  5        :NEW.usim_tick := usim_erl_tick_seq.NEXTVAL;
  6      END;
  7  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_erl_ins_trg
  BEFORE INSERT ON &USIM_SCHEMA..usim_error_log
    FOR EACH ROW
    BEGIN
      :NEW.usim_tick := usim_erl_tick_seq.NEXTVAL;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_erl_ins_trg
  BEFORE INSERT ON USIM_TEST.usim_error_log
    FOR EACH ROW
    BEGIN
      :NEW.usim_tick := usim_erl_tick_seq.NEXTVAL;
    END;

Trigger USIM_ERL_INS_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_erl_ins_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_erl_ins_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_erl_ins_trg ENABLE

Trigger USIM_TEST.USIM_ERL_INS_TRG geändert.

SQL> -- USIM_DLG_ID_SEQ
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../SEQUENCES/USIM_DLG_ID_SEQ.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_DLG_ID_SEQ still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DLG_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_DLG_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_DLG_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DLG_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_DLG_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_DLG_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DLG_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_DLG_ID_SEQ.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_DEBUG_LOG (dlg) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_dlg_id_seq
  2    MINVALUE 1
  3    INCREMENT BY 1
  4    START WITH 1
  5    CACHE 20
  6    NOORDER
  7    NOCYCLE
  8    NOKEEP
  9    NOSCALE
 10    GLOBAL
 11  ;
alt:CREATE SEQUENCE &USIM_SCHEMA..usim_dlg_id_seq
  MINVALUE 1
  INCREMENT BY 1
  START WITH 1
  CACHE 20
  NOORDER
  NOCYCLE
  NOKEEP
  NOSCALE
  GLOBAL

neu:CREATE SEQUENCE USIM_TEST.usim_dlg_id_seq
  MINVALUE 1
  INCREMENT BY 1
  START WITH 1
  CACHE 20
  NOORDER
  NOCYCLE
  NOKEEP
  NOSCALE
  GLOBAL

Sequence USIM_TEST.USIM_DLG_ID_SEQ erstellt.

SQL> -- USIM_DEBUG_LOG (dlg)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_DEBUG_LOG_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_DEBUG_LOG still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DEBUG_LOG'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_DEBUG_LOG_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_DEBUG_LOG still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DEBUG_LOG'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_DEBUG_LOG_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_DEBUG_LOG still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DEBUG_LOG'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../TABLES/USIM_DEBUG_LOG_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_DEBUG_LOG (dlg)
SQL> CREATE TABLE &USIM_SCHEMA..usim_debug_log
  2    ( usim_id_dlg         NUMBER(38, 0)
  3    , usim_timestamp      TIMESTAMP
  4    , usim_status         NUMBER(1, 0)
  5    , usim_log_object     VARCHAR2(1000)
  6    , usim_log_content    CLOB
  7    )
  8  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_debug_log
  ( usim_id_dlg         NUMBER(38, 0)
  , usim_timestamp      TIMESTAMP
  , usim_status         NUMBER(1, 0)
  , usim_log_object     VARCHAR2(1000)
  , usim_log_content    CLOB
  )

neu:CREATE TABLE USIM_TEST.usim_debug_log
  ( usim_id_dlg         NUMBER(38, 0)
  , usim_timestamp      TIMESTAMP
  , usim_status         NUMBER(1, 0)
  , usim_log_object     VARCHAR2(1000)
  , usim_log_content    CLOB
  )

Table USIM_TEST.USIM_DEBUG_LOG erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_debug_log IS 'A table for logging temporary debug results. Will use the alias dlg.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_debug_log IS 'A table for logging temporary debug results. Will use the alias dlg.'
neu:COMMENT ON TABLE USIM_TEST.usim_debug_log IS 'A table for logging temporary debug results. Will use the alias dlg.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_id_dlg IS 'The id for debug log action.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_id_dlg IS 'The id for debug log action.'
neu:COMMENT ON COLUMN USIM_TEST.usim_debug_log.usim_id_dlg IS 'The id for debug log action.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_timestamp IS 'The timestamp for a debug log action.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_timestamp IS 'The timestamp for a debug log action.'
neu:COMMENT ON COLUMN USIM_TEST.usim_debug_log.usim_timestamp IS 'The timestamp for a debug log action.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_status IS 'Status of debug action -1 = ERROR, 0 = WARNING, 1 = SUCCESS, 2 = INFO.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_status IS 'Status of debug action -1 = ERROR, 0 = WARNING, 1 = SUCCESS, 2 = INFO.'
neu:COMMENT ON COLUMN USIM_TEST.usim_debug_log.usim_status IS 'Status of debug action -1 = ERROR, 0 = WARNING, 1 = SUCCESS, 2 = INFO.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_log_object IS 'The object of a debug log action.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_log_object IS 'The object of a debug log action.'
neu:COMMENT ON COLUMN USIM_TEST.usim_debug_log.usim_log_object IS 'The object of a debug log action.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_log_content IS 'The debug information content of a debug log action.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_log_content IS 'The debug information content of a debug log action.'
neu:COMMENT ON COLUMN USIM_TEST.usim_debug_log.usim_log_content IS 'The debug information content of a debug log action.'

Comment erstellt.

SQL>
SQL> -- idx
SQL> CREATE INDEX &USIM_SCHEMA..usim_dlg_idx
  2      ON &USIM_SCHEMA..usim_debug_log
  3         (usim_id_dlg)
  4  ;
alt:CREATE INDEX &USIM_SCHEMA..usim_dlg_idx
    ON &USIM_SCHEMA..usim_debug_log
       (usim_id_dlg)

neu:CREATE INDEX USIM_TEST.usim_dlg_idx
    ON USIM_TEST.usim_debug_log
       (usim_id_dlg)

Index USIM_TEST.USIM_DLG_IDX erstellt.

SQL> -- error logging package
SQL> @@../PACKAGES/USIM_ERL.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_erl
  2  IS
  3    /**A package for actions on table usim_error_log.*/
  4
  5    /**
  6    * Writes given possible error informations to usim_error_log as an autonomous transaction.
  7    * Package functions returning NULL state in most cases an inproper use of functions, if not
  8    * handled in the calling code explicitly, except for testing. Purge log after testing.
  9    * Will cut strings to meet the size of the table columns.
 10    */
 11    PROCEDURE log_error( p_usim_err_object  IN VARCHAR2
 12                       , p_usim_err_info    IN VARCHAR2
 13                       )
 14    ;
 15
 16    /**
 17    * Purges all current saved informations from the usim_error_log table.
 18    */
 19    PROCEDURE purge_log;
 20
 21  END usim_erl;
 22  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_erl
IS
  /**A package for actions on table usim_error_log.*/

  /**
  * Writes given possible error informations to usim_error_log as an autonomous transaction.
  * Package functions returning NULL state in most cases an inproper use of functions, if not
  * handled in the calling code explicitly, except for testing. Purge log after testing.
  * Will cut strings to meet the size of the table columns.
  */
  PROCEDURE log_error( p_usim_err_object  IN VARCHAR2
                     , p_usim_err_info    IN VARCHAR2
                     )
  ;

  /**
  * Purges all current saved informations from the usim_error_log table.
  */
  PROCEDURE purge_log;

END usim_erl;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_erl
IS
  /**A package for actions on table usim_error_log.*/

  /**
  * Writes given possible error informations to usim_error_log as an autonomous transaction.
  * Package functions returning NULL state in most cases an inproper use of functions, if not
  * handled in the calling code explicitly, except for testing. Purge log after testing.
  * Will cut strings to meet the size of the table columns.
  */
  PROCEDURE log_error( p_usim_err_object  IN VARCHAR2
                     , p_usim_err_info    IN VARCHAR2
                     )
  ;

  /**
  * Purges all current saved informations from the usim_error_log table.
  */
  PROCEDURE purge_log;

END usim_erl;

Package USIM_ERL kompiliert

SQL> @@../PACKAGES/USIM_ERL.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_erl
  2  IS
  3    -- see header for documentation
  4    PROCEDURE log_error( p_usim_err_object  IN VARCHAR2
  5                       , p_usim_err_info    IN VARCHAR2
  6                       )
  7    IS
  8      PRAGMA AUTONOMOUS_TRANSACTION;
  9    BEGIN
 10      INSERT INTO usim_error_log
 11        ( usim_timestamp
 12        , usim_err_object
 13        , usim_err_info
 14        )
 15        VALUES
 16        ( SYSTIMESTAMP
 17        , NVL(SUBSTR(p_usim_err_object, 1, 200), 'ERROR MISSING object definition')
 18        , NVL(SUBSTR(p_usim_err_info, 1, 4000), 'ERROR MISSING error description')
 19        )
 20      ;
 21      COMMIT;
 22    END log_error
 23    ;
 24
 25    PROCEDURE purge_log
 26    IS
 27      PRAGMA AUTONOMOUS_TRANSACTION;
 28    BEGIN
 29      DELETE usim_error_log;
 30      COMMIT;
 31    END purge_log
 32    ;
 33
 34  END usim_erl;
 35  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_erl
IS
  -- see header for documentation
  PROCEDURE log_error( p_usim_err_object  IN VARCHAR2
                     , p_usim_err_info    IN VARCHAR2
                     )
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO usim_error_log
      ( usim_timestamp
      , usim_err_object
      , usim_err_info
      )
      VALUES
      ( SYSTIMESTAMP
      , NVL(SUBSTR(p_usim_err_object, 1, 200), 'ERROR MISSING object definition')
      , NVL(SUBSTR(p_usim_err_info, 1, 4000), 'ERROR MISSING error description')
      )
    ;
    COMMIT;
  END log_error
  ;

  PROCEDURE purge_log
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    DELETE usim_error_log;
    COMMIT;
  END purge_log
  ;

END usim_erl;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_erl
IS
  -- see header for documentation
  PROCEDURE log_error( p_usim_err_object  IN VARCHAR2
                     , p_usim_err_info    IN VARCHAR2
                     )
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO usim_error_log
      ( usim_timestamp
      , usim_err_object
      , usim_err_info
      )
      VALUES
      ( SYSTIMESTAMP
      , NVL(SUBSTR(p_usim_err_object, 1, 200), 'ERROR MISSING object definition')
      , NVL(SUBSTR(p_usim_err_info, 1, 4000), 'ERROR MISSING error description')
      )
    ;
    COMMIT;
  END log_error
  ;

  PROCEDURE purge_log
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    DELETE usim_error_log;
    COMMIT;
  END purge_log
  ;

END usim_erl;

Package Body USIM_ERL kompiliert

SQL> @@../PACKAGES/USIM_DEBUG.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_debug
  2  IS
  3    /** A package for debugging purposes.
  4    *
  5    * Package is session dependend. Debug mode is
  6    * disabled by default and if set only valid in the
  7    * the current session.
  8    */
  9
 10    /**
 11    * Check debug state in PL/SQL Code.
 12    * @return TRUE if debug is enabled for this session, otherwise FALSE.
 13    */
 14    FUNCTION is_debug_on
 15      RETURN BOOLEAN
 16    ;
 17
 18    /**
 19    * Check debug state in SQL.
 20    * @return "TRUE" if debug is enabled for this session, otherwise "FALSE".
 21    */
 22    FUNCTION is_debug
 23      RETURN VARCHAR2
 24    ;
 25
 26    /**
 27    * Activate debug state and intialize an internal debug id which can be used
 28    * for the whole session.
 29    */
 30    PROCEDURE set_debug_on;
 31
 32    /**
 33    * Deactivate debug state.
 34    */
 35    PROCEDURE set_debug_off;
 36
 37    /**
 38    * Starts a debug session, if debug state is on for this session and user wants to control
 39    * the debug ids.
 40    * @return A new debug id or NULL if debug state is not set.
 41    */
 42    FUNCTION start_debug
 43      RETURN usim_debug_log.usim_id_dlg%TYPE
 44    ;
 45
 46    /**
 47    * Returns a text representation of supported status values.
 48    * @param p_usim_status The status value to get the text representation for.
 49    * @return The text for the given status value or UNKNOWN.
 50    */
 51    FUNCTION debug_status_txt(p_usim_status IN usim_debug_log.usim_status%TYPE)
 52      RETURN VARCHAR2
 53      DETERMINISTIC
 54      PARALLEL_ENABLE
 55    ;
 56
 57    /**
 58    * Delete all entries of the current debug log.
 59    */
 60    PROCEDURE purge_log;
 61
 62    /**
 63    * Creates a debug log entry in USIM_DEBUG_LOG if debug state
 64    * is set. Requires a valid id from START_DEBUG.
 65    * @param p_usim_id_dlg The debug ID to use.
 66    * @param p_usim_status The debug status for this debug entry.
 67    * @param p_usim_log_object The function or procedure name, e.g. USIM_DEBUG.DEBUG_LOG.
 68    * @param p_usim_log_content The debug message to use limited to VARCHAR2 size.
 69    */
 70    PROCEDURE debug_log( p_usim_id_dlg        IN usim_debug_log.usim_id_dlg%TYPE
 71                       , p_usim_status        IN usim_debug_log.usim_status%TYPE
 72                       , p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
 73                       , p_usim_log_content   IN VARCHAR2
 74                       )
 75    ;
 76
 77    /**
 78    * Creates a debug log entry in USIM_DEBUG_LOG if debug state
 79    * is set. Requires a valid id from START_DEBUG.
 80    * @param p_usim_id_dlg The debug ID to use.
 81    * @param p_usim_status The debug status for this debug entry.
 82    * @param p_usim_log_object The function or procedure name, e.g. USIM_DEBUG.DEBUG_LOG.
 83    * @param p_usim_log_content The debug message to use limited to CLOB size.
 84    */
 85    PROCEDURE debug_log( p_usim_id_dlg        IN usim_debug_log.usim_id_dlg%TYPE
 86                       , p_usim_status        IN usim_debug_log.usim_status%TYPE
 87                       , p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
 88                       , p_usim_log_content   IN usim_debug_log.usim_log_content%TYPE
 89                       )
 90    ;
 91
 92    /**
 93    * Creates a debug log entry in USIM_DEBUG_LOG if debug state
 94    * is set. Uses internal session debug id.
 95    * @param p_usim_log_object The function or procedure name, e.g. USIM_DEBUG.DEBUG_LOG.
 96    * @param p_usim_log_content The debug message to use limited to CLOB size.
 97    * @param p_usim_status The debug status for this debug entry. Default 2 INFO.
 98    */
 99    PROCEDURE debug_log( p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
100                       , p_usim_log_content   IN usim_debug_log.usim_log_content%TYPE
101                       , p_usim_status        IN usim_debug_log.usim_status%TYPE      DEFAULT 2
102                       )
103    ;
104
105  END usim_debug;
106  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_debug
IS
  /** A package for debugging purposes.
  *
  * Package is session dependend. Debug mode is
  * disabled by default and if set only valid in the
  * the current session.
  */

  /**
  * Check debug state in PL/SQL Code.
  * @return TRUE if debug is enabled for this session, otherwise FALSE.
  */
  FUNCTION is_debug_on
    RETURN BOOLEAN
  ;

  /**
  * Check debug state in SQL.
  * @return "TRUE" if debug is enabled for this session, otherwise "FALSE".
  */
  FUNCTION is_debug
    RETURN VARCHAR2
  ;

  /**
  * Activate debug state and intialize an internal debug id which can be used
  * for the whole session.
  */
  PROCEDURE set_debug_on;

  /**
  * Deactivate debug state.
  */
  PROCEDURE set_debug_off;

  /**
  * Starts a debug session, if debug state is on for this session and user wants to control
  * the debug ids.
  * @return A new debug id or NULL if debug state is not set.
  */
  FUNCTION start_debug
    RETURN usim_debug_log.usim_id_dlg%TYPE
  ;

  /**
  * Returns a text representation of supported status values.
  * @param p_usim_status The status value to get the text representation for.
  * @return The text for the given status value or UNKNOWN.
  */
  FUNCTION debug_status_txt(p_usim_status IN usim_debug_log.usim_status%TYPE)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Delete all entries of the current debug log.
  */
  PROCEDURE purge_log;

  /**
  * Creates a debug log entry in USIM_DEBUG_LOG if debug state
  * is set. Requires a valid id from START_DEBUG.
  * @param p_usim_id_dlg The debug ID to use.
  * @param p_usim_status The debug status for this debug entry.
  * @param p_usim_log_object The function or procedure name, e.g. USIM_DEBUG.DEBUG_LOG.
  * @param p_usim_log_content The debug message to use limited to VARCHAR2 size.
  */
  PROCEDURE debug_log( p_usim_id_dlg        IN usim_debug_log.usim_id_dlg%TYPE
                     , p_usim_status        IN usim_debug_log.usim_status%TYPE
                     , p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
                     , p_usim_log_content   IN VARCHAR2
                     )
  ;

  /**
  * Creates a debug log entry in USIM_DEBUG_LOG if debug state
  * is set. Requires a valid id from START_DEBUG.
  * @param p_usim_id_dlg The debug ID to use.
  * @param p_usim_status The debug status for this debug entry.
  * @param p_usim_log_object The function or procedure name, e.g. USIM_DEBUG.DEBUG_LOG.
  * @param p_usim_log_content The debug message to use limited to CLOB size.
  */
  PROCEDURE debug_log( p_usim_id_dlg        IN usim_debug_log.usim_id_dlg%TYPE
                     , p_usim_status        IN usim_debug_log.usim_status%TYPE
                     , p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
                     , p_usim_log_content   IN usim_debug_log.usim_log_content%TYPE
                     )
  ;

  /**
  * Creates a debug log entry in USIM_DEBUG_LOG if debug state
  * is set. Uses internal session debug id.
  * @param p_usim_log_object The function or procedure name, e.g. USIM_DEBUG.DEBUG_LOG.
  * @param p_usim_log_content The debug message to use limited to CLOB size.
  * @param p_usim_status The debug status for this debug entry. Default 2 INFO.
  */
  PROCEDURE debug_log( p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
                     , p_usim_log_content   IN usim_debug_log.usim_log_content%TYPE
                     , p_usim_status        IN usim_debug_log.usim_status%TYPE      DEFAULT 2
                     )
  ;

END usim_debug;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_debug
IS
  /** A package for debugging purposes.
  *
  * Package is session dependend. Debug mode is
  * disabled by default and if set only valid in the
  * the current session.
  */

  /**
  * Check debug state in PL/SQL Code.
  * @return TRUE if debug is enabled for this session, otherwise FALSE.
  */
  FUNCTION is_debug_on
    RETURN BOOLEAN
  ;

  /**
  * Check debug state in SQL.
  * @return "TRUE" if debug is enabled for this session, otherwise "FALSE".
  */
  FUNCTION is_debug
    RETURN VARCHAR2
  ;

  /**
  * Activate debug state and intialize an internal debug id which can be used
  * for the whole session.
  */
  PROCEDURE set_debug_on;

  /**
  * Deactivate debug state.
  */
  PROCEDURE set_debug_off;

  /**
  * Starts a debug session, if debug state is on for this session and user wants to control
  * the debug ids.
  * @return A new debug id or NULL if debug state is not set.
  */
  FUNCTION start_debug
    RETURN usim_debug_log.usim_id_dlg%TYPE
  ;

  /**
  * Returns a text representation of supported status values.
  * @param p_usim_status The status value to get the text representation for.
  * @return The text for the given status value or UNKNOWN.
  */
  FUNCTION debug_status_txt(p_usim_status IN usim_debug_log.usim_status%TYPE)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Delete all entries of the current debug log.
  */
  PROCEDURE purge_log;

  /**
  * Creates a debug log entry in USIM_DEBUG_LOG if debug state
  * is set. Requires a valid id from START_DEBUG.
  * @param p_usim_id_dlg The debug ID to use.
  * @param p_usim_status The debug status for this debug entry.
  * @param p_usim_log_object The function or procedure name, e.g. USIM_DEBUG.DEBUG_LOG.
  * @param p_usim_log_content The debug message to use limited to VARCHAR2 size.
  */
  PROCEDURE debug_log( p_usim_id_dlg        IN usim_debug_log.usim_id_dlg%TYPE
                     , p_usim_status        IN usim_debug_log.usim_status%TYPE
                     , p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
                     , p_usim_log_content   IN VARCHAR2
                     )
  ;

  /**
  * Creates a debug log entry in USIM_DEBUG_LOG if debug state
  * is set. Requires a valid id from START_DEBUG.
  * @param p_usim_id_dlg The debug ID to use.
  * @param p_usim_status The debug status for this debug entry.
  * @param p_usim_log_object The function or procedure name, e.g. USIM_DEBUG.DEBUG_LOG.
  * @param p_usim_log_content The debug message to use limited to CLOB size.
  */
  PROCEDURE debug_log( p_usim_id_dlg        IN usim_debug_log.usim_id_dlg%TYPE
                     , p_usim_status        IN usim_debug_log.usim_status%TYPE
                     , p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
                     , p_usim_log_content   IN usim_debug_log.usim_log_content%TYPE
                     )
  ;

  /**
  * Creates a debug log entry in USIM_DEBUG_LOG if debug state
  * is set. Uses internal session debug id.
  * @param p_usim_log_object The function or procedure name, e.g. USIM_DEBUG.DEBUG_LOG.
  * @param p_usim_log_content The debug message to use limited to CLOB size.
  * @param p_usim_status The debug status for this debug entry. Default 2 INFO.
  */
  PROCEDURE debug_log( p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
                     , p_usim_log_content   IN usim_debug_log.usim_log_content%TYPE
                     , p_usim_status        IN usim_debug_log.usim_status%TYPE      DEFAULT 2
                     )
  ;

END usim_debug;

Package USIM_DEBUG kompiliert

SQL> @@../PACKAGES/USIM_DEBUG.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_debug
  2  IS
  3    -- package variables
  4    debug_status  BOOLEAN;
  5    debug_id      usim_debug_log.usim_id_dlg%TYPE;
  6
  7    -- functions and procedures
  8    FUNCTION is_debug_on
  9      RETURN BOOLEAN
 10    IS
 11    BEGIN
 12      RETURN debug_status;
 13    END is_debug_on
 14    ;
 15
 16    FUNCTION is_debug
 17      RETURN VARCHAR2
 18    IS
 19    BEGIN
 20      RETURN CASE WHEN debug_status THEN 'TRUE' ELSE 'FALSE' END;
 21    END is_debug
 22    ;
 23
 24    PROCEDURE set_debug_on
 25    IS
 26    BEGIN
 27      debug_status := TRUE;
 28      debug_id     := usim_dlg_id_seq.NEXTVAL;
 29    END set_debug_on
 30    ;
 31
 32    PROCEDURE set_debug_off
 33    IS
 34    BEGIN
 35      debug_status := FALSE;
 36    END set_debug_off
 37    ;
 38
 39    FUNCTION start_debug
 40      RETURN usim_debug_log.usim_id_dlg%TYPE
 41    IS
 42    BEGIN
 43      IF debug_status
 44      THEN
 45        RETURN usim_dlg_id_seq.NEXTVAL;
 46      ELSE
 47        RETURN NULL;
 48      END IF;
 49    END start_debug
 50    ;
 51
 52    FUNCTION debug_status_txt(p_usim_status IN usim_debug_log.usim_status%TYPE)
 53      RETURN VARCHAR2
 54      DETERMINISTIC
 55      PARALLEL_ENABLE
 56    IS
 57    BEGIN
 58      IF p_usim_status = -1
 59      THEN
 60        RETURN 'ERROR';
 61      ELSIF p_usim_status = 0
 62      THEN
 63        RETURN 'WARNING';
 64      ELSIF p_usim_status = 1
 65      THEN
 66        RETURN 'SUCCESS';
 67      ELSIF p_usim_status = 2
 68      THEN
 69        RETURN 'INFO';
 70      ELSE
 71        RETURN 'UNKNOWN';
 72      END IF;
 73    END debug_status_txt
 74    ;
 75
 76    PROCEDURE purge_log
 77    IS
 78      PRAGMA AUTONOMOUS_TRANSACTION;
 79    BEGIN
 80      DELETE usim_debug_log;
 81      COMMIT;
 82    END purge_log
 83    ;
 84
 85    PROCEDURE debug_log( p_usim_id_dlg        IN usim_debug_log.usim_id_dlg%TYPE
 86                       , p_usim_status        IN usim_debug_log.usim_status%TYPE
 87                       , p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
 88                       , p_usim_log_content   IN VARCHAR2
 89                       )
 90    IS
 91      l_usim_log_content  CLOB;
 92    BEGIN
 93      IF debug_status AND p_usim_id_dlg IS NOT NULL
 94      THEN
 95        l_usim_log_content := p_usim_log_content;
 96        debug_log(p_usim_id_dlg, p_usim_status, p_usim_log_object, l_usim_log_content);
 97      END IF;
 98    END debug_log
 99    ;
100
101    PROCEDURE debug_log( p_usim_id_dlg        IN usim_debug_log.usim_id_dlg%TYPE
102                       , p_usim_status        IN usim_debug_log.usim_status%TYPE
103                       , p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
104                       , p_usim_log_content   IN usim_debug_log.usim_log_content%TYPE
105                       )
106    IS
107      PRAGMA AUTONOMOUS_TRANSACTION;
108    BEGIN
109      IF debug_status AND p_usim_id_dlg IS NOT NULL
110      THEN
111        INSERT INTO usim_debug_log
112          ( usim_id_dlg
113          , usim_timestamp
114          , usim_status
115          , usim_log_object
116          , usim_log_content
117          )
118          VALUES
119          ( p_usim_id_dlg
120          , SYSTIMESTAMP
121          , p_usim_status
122          , p_usim_log_object
123          , p_usim_log_content
124          )
125        ;
126        COMMIT;
127      END IF;
128    END debug_log
129    ;
130
131    PROCEDURE debug_log( p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
132                       , p_usim_log_content   IN usim_debug_log.usim_log_content%TYPE
133                       , p_usim_status        IN usim_debug_log.usim_status%TYPE      DEFAULT 2
134                       )
135    IS
136      PRAGMA AUTONOMOUS_TRANSACTION;
137    BEGIN
138      IF debug_status
139      THEN
140        INSERT INTO usim_debug_log
141          ( usim_id_dlg
142          , usim_timestamp
143          , usim_status
144          , usim_log_object
145          , usim_log_content
146          )
147          VALUES
148          ( debug_id
149          , SYSTIMESTAMP
150          , p_usim_status
151          , p_usim_log_object
152          , p_usim_log_content
153          )
154        ;
155        COMMIT;
156      END IF;
157    END debug_log
158    ;
159
160  BEGIN
161    -- init debug state for the current session
162    debug_status := FALSE;
163    debug_id     := NULL;
164  END usim_debug;
165  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_debug
IS
  -- package variables
  debug_status  BOOLEAN;
  debug_id      usim_debug_log.usim_id_dlg%TYPE;

  -- functions and procedures
  FUNCTION is_debug_on
    RETURN BOOLEAN
  IS
  BEGIN
    RETURN debug_status;
  END is_debug_on
  ;

  FUNCTION is_debug
    RETURN VARCHAR2
  IS
  BEGIN
    RETURN CASE WHEN debug_status THEN 'TRUE' ELSE 'FALSE' END;
  END is_debug
  ;

  PROCEDURE set_debug_on
  IS
  BEGIN
    debug_status := TRUE;
    debug_id     := usim_dlg_id_seq.NEXTVAL;
  END set_debug_on
  ;

  PROCEDURE set_debug_off
  IS
  BEGIN
    debug_status := FALSE;
  END set_debug_off
  ;

  FUNCTION start_debug
    RETURN usim_debug_log.usim_id_dlg%TYPE
  IS
  BEGIN
    IF debug_status
    THEN
      RETURN usim_dlg_id_seq.NEXTVAL;
    ELSE
      RETURN NULL;
    END IF;
  END start_debug
  ;

  FUNCTION debug_status_txt(p_usim_status IN usim_debug_log.usim_status%TYPE)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    IF p_usim_status = -1
    THEN
      RETURN 'ERROR';
    ELSIF p_usim_status = 0
    THEN
      RETURN 'WARNING';
    ELSIF p_usim_status = 1
    THEN
      RETURN 'SUCCESS';
    ELSIF p_usim_status = 2
    THEN
      RETURN 'INFO';
    ELSE
      RETURN 'UNKNOWN';
    END IF;
  END debug_status_txt
  ;

  PROCEDURE purge_log
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    DELETE usim_debug_log;
    COMMIT;
  END purge_log
  ;

  PROCEDURE debug_log( p_usim_id_dlg        IN usim_debug_log.usim_id_dlg%TYPE
                     , p_usim_status        IN usim_debug_log.usim_status%TYPE
                     , p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
                     , p_usim_log_content   IN VARCHAR2
                     )
  IS
    l_usim_log_content  CLOB;
  BEGIN
    IF debug_status AND p_usim_id_dlg IS NOT NULL
    THEN
      l_usim_log_content := p_usim_log_content;
      debug_log(p_usim_id_dlg, p_usim_status, p_usim_log_object, l_usim_log_content);
    END IF;
  END debug_log
  ;

  PROCEDURE debug_log( p_usim_id_dlg        IN usim_debug_log.usim_id_dlg%TYPE
                     , p_usim_status        IN usim_debug_log.usim_status%TYPE
                     , p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
                     , p_usim_log_content   IN usim_debug_log.usim_log_content%TYPE
                     )
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    IF debug_status AND p_usim_id_dlg IS NOT NULL
    THEN
      INSERT INTO usim_debug_log
        ( usim_id_dlg
        , usim_timestamp
        , usim_status
        , usim_log_object
        , usim_log_content
        )
        VALUES
        ( p_usim_id_dlg
        , SYSTIMESTAMP
        , p_usim_status
        , p_usim_log_object
        , p_usim_log_content
        )
      ;
      COMMIT;
    END IF;
  END debug_log
  ;

  PROCEDURE debug_log( p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
                     , p_usim_log_content   IN usim_debug_log.usim_log_content%TYPE
                     , p_usim_status        IN usim_debug_log.usim_status%TYPE      DEFAULT 2
                     )
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    IF debug_status
    THEN
      INSERT INTO usim_debug_log
        ( usim_id_dlg
        , usim_timestamp
        , usim_status
        , usim_log_object
        , usim_log_content
        )
        VALUES
        ( debug_id
        , SYSTIMESTAMP
        , p_usim_status
        , p_usim_log_object
        , p_usim_log_content
        )
      ;
      COMMIT;
    END IF;
  END debug_log
  ;

BEGIN
  -- init debug state for the current session
  debug_status := FALSE;
  debug_id     := NULL;
END usim_debug;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_debug
IS
  -- package variables
  debug_status  BOOLEAN;
  debug_id      usim_debug_log.usim_id_dlg%TYPE;

  -- functions and procedures
  FUNCTION is_debug_on
    RETURN BOOLEAN
  IS
  BEGIN
    RETURN debug_status;
  END is_debug_on
  ;

  FUNCTION is_debug
    RETURN VARCHAR2
  IS
  BEGIN
    RETURN CASE WHEN debug_status THEN 'TRUE' ELSE 'FALSE' END;
  END is_debug
  ;

  PROCEDURE set_debug_on
  IS
  BEGIN
    debug_status := TRUE;
    debug_id     := usim_dlg_id_seq.NEXTVAL;
  END set_debug_on
  ;

  PROCEDURE set_debug_off
  IS
  BEGIN
    debug_status := FALSE;
  END set_debug_off
  ;

  FUNCTION start_debug
    RETURN usim_debug_log.usim_id_dlg%TYPE
  IS
  BEGIN
    IF debug_status
    THEN
      RETURN usim_dlg_id_seq.NEXTVAL;
    ELSE
      RETURN NULL;
    END IF;
  END start_debug
  ;

  FUNCTION debug_status_txt(p_usim_status IN usim_debug_log.usim_status%TYPE)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    IF p_usim_status = -1
    THEN
      RETURN 'ERROR';
    ELSIF p_usim_status = 0
    THEN
      RETURN 'WARNING';
    ELSIF p_usim_status = 1
    THEN
      RETURN 'SUCCESS';
    ELSIF p_usim_status = 2
    THEN
      RETURN 'INFO';
    ELSE
      RETURN 'UNKNOWN';
    END IF;
  END debug_status_txt
  ;

  PROCEDURE purge_log
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    DELETE usim_debug_log;
    COMMIT;
  END purge_log
  ;

  PROCEDURE debug_log( p_usim_id_dlg        IN usim_debug_log.usim_id_dlg%TYPE
                     , p_usim_status        IN usim_debug_log.usim_status%TYPE
                     , p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
                     , p_usim_log_content   IN VARCHAR2
                     )
  IS
    l_usim_log_content  CLOB;
  BEGIN
    IF debug_status AND p_usim_id_dlg IS NOT NULL
    THEN
      l_usim_log_content := p_usim_log_content;
      debug_log(p_usim_id_dlg, p_usim_status, p_usim_log_object, l_usim_log_content);
    END IF;
  END debug_log
  ;

  PROCEDURE debug_log( p_usim_id_dlg        IN usim_debug_log.usim_id_dlg%TYPE
                     , p_usim_status        IN usim_debug_log.usim_status%TYPE
                     , p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
                     , p_usim_log_content   IN usim_debug_log.usim_log_content%TYPE
                     )
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    IF debug_status AND p_usim_id_dlg IS NOT NULL
    THEN
      INSERT INTO usim_debug_log
        ( usim_id_dlg
        , usim_timestamp
        , usim_status
        , usim_log_object
        , usim_log_content
        )
        VALUES
        ( p_usim_id_dlg
        , SYSTIMESTAMP
        , p_usim_status
        , p_usim_log_object
        , p_usim_log_content
        )
      ;
      COMMIT;
    END IF;
  END debug_log
  ;

  PROCEDURE debug_log( p_usim_log_object    IN usim_debug_log.usim_log_object%TYPE
                     , p_usim_log_content   IN usim_debug_log.usim_log_content%TYPE
                     , p_usim_status        IN usim_debug_log.usim_status%TYPE      DEFAULT 2
                     )
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    IF debug_status
    THEN
      INSERT INTO usim_debug_log
        ( usim_id_dlg
        , usim_timestamp
        , usim_status
        , usim_log_object
        , usim_log_content
        )
        VALUES
        ( debug_id
        , SYSTIMESTAMP
        , p_usim_status
        , p_usim_log_object
        , p_usim_log_content
        )
      ;
      COMMIT;
    END IF;
  END debug_log
  ;

BEGIN
  -- init debug state for the current session
  debug_status := FALSE;
  debug_id     := NULL;
END usim_debug;

Package Body USIM_DEBUG kompiliert

SQL> --== error logging end ==--
SQL>
SQL> --== basic packages start ==--
SQL> @@../PACKAGES/USIM_STATIC.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_static
  2  IS
  3    /** A Package containing static values and SQL functions for retrieving this values to be used with the application. Changing values
  4    * in this package may break the application.
  5    *
  6    * Package constants:
  7    * <b>usim_max_childs_per_dimension</b> - a constant value for the allowed amount of child nodes within a given dimension. Application relies on this value.
  8    * <b>usim_max_seeds</b> - a constant value for the maximum seeds a universe can have, means the maximum of points with dimension and position without a parent. Application relies on this value.
  9    * <b>usim_planck_time_seq_name</b> - a constant for the sequence name responsible for planck time ticks.
 10    * <b>usim_planck_aeon_seq_name</b> - a constant for the sequence name responsible for planck aeons.
 11    * <b>usim_not_available</b> - a constant name for filled char fields which are not Null, but have no usable content.
 12    * <b>usim_side_from</b> - a constant name for the from side of a volume in space.
 13    * <b>usim_side_to</b> - a constant name for the to side of a volume in space.
 14    * <b>usim_side_both</b> - a constant name for basic space universe nodes in dimension 0, position 0 and sign 0 which are parents to base and mirror at the same time.
 15    * <b>usim_status_success</b> - a constant for debug success.
 16    * <b>usim_status_error</b> - a constant for debug error.
 17    * <b>usim_status_warning</b> - a constant for debug warning.
 18    * <b>usim_multiverse_status_active</b> - a constant for the active status of a multiverse.
 19    * <b>usim_multiverse_status_inactive</b> - a constant for the inactive status of a multiverse (all energy equals NULL).
 20    * <b>usim_multiverse_status_dead</b> - a constant for the dead status of a multiverse (all energy equals 0).
 21    * <b>usim_multiverse_status_crashed</b> - a constant for the crashed status of a multiverse (energy not equilibrated between universe and mirror).
 22    * <b>PI</b> - a constant for PI definition with Oracle precision.
 23    * <b>PI_DOUBLE</b> - a constant for 2 * PI definition with Oracle precision.
 24    * <b>PI_QUARTER</b> - a constant for PI / 4 definition with Oracle precision.
 25    */
 26    usim_max_childs_per_dimension   CONSTANT INTEGER      := 1;
 27    usim_max_seeds                  CONSTANT INTEGER      := 1;
 28    usim_planck_time_seq_name       CONSTANT CHAR(20)     := 'USIM_PLANCK_TIME_SEQ';
 29    usim_planck_aeon_seq_name       CONSTANT CHAR(20)     := 'USIM_PLANCK_AEON_SEQ';
 30    usim_not_available              CONSTANT CHAR(3)      := 'N/A';
 31    usim_side_from                  CONSTANT CHAR(1)      := 'F';
 32    usim_side_to                    CONSTANT CHAR(1)      := 'T';
 33    usim_side_both                  CONSTANT CHAR(1)      := 'B';
 34    usim_status_success             CONSTANT NUMBER       := 1;
 35    usim_status_error               CONSTANT NUMBER       := -1;
 36    usim_status_warning             CONSTANT NUMBER       := 0;
 37    usim_multiverse_status_active   CONSTANT NUMBER       := 1;
 38    usim_multiverse_status_inactive CONSTANT NUMBER       := 0;
 39    usim_multiverse_status_dead     CONSTANT NUMBER       := -1;
 40    usim_multiverse_status_crashed  CONSTANT NUMBER       := -2;
 41    PI                              CONSTANT NUMBER       := ACOS(-1);
 42    PI_DOUBLE                       CONSTANT NUMBER       := ACOS(-1) * 2;
 43    PI_QUARTER                      CONSTANT NUMBER       := ACOS(-1) / 4;
 44
 45    /**
 46    * Types
 47    */
 48    SUBTYPE usim_id IS CHAR(55);
 49    TYPE usim_ids_type IS TABLE OF usim_id INDEX BY PLS_INTEGER;
 50
 51    /**
 52    * Get the maximum of childs a node within a dimension can have.
 53    * @return USIM_STATIC.USIM_MAX_CHILDS_PER_DIMENSION
 54    */
 55    FUNCTION get_max_childs_per_dimension
 56      RETURN NUMBER
 57      DETERMINISTIC
 58      PARALLEL_ENABLE
 59    ;
 60
 61    /**
 62    * Get the maximum of seeds a universe can have.
 63    * @return USIM_STATIC.USIM_MAX_SEEDS
 64    */
 65    FUNCTION get_max_seeds
 66      RETURN NUMBER
 67      DETERMINISTIC
 68      PARALLEL_ENABLE
 69    ;
 70
 71    /**
 72    * Get the static PI value.
 73    * @return USIM_STATIC.PI
 74    */
 75    FUNCTION get_pi
 76      RETURN NUMBER
 77      DETERMINISTIC
 78      PARALLEL_ENABLE
 79    ;
 80
 81    /**
 82    * Get the static PI_DOUBLE (2 * PI) value.
 83    * @return USIM_STATIC.PI_DOUBLE
 84    */
 85    FUNCTION get_pi_double
 86      RETURN NUMBER
 87      DETERMINISTIC
 88      PARALLEL_ENABLE
 89    ;
 90
 91    /**
 92    * Get the static PI_QUARTER (PI / 4) value.
 93    * @return USIM_STATIC.PI_QUARTER
 94    */
 95    FUNCTION get_pi_quarter
 96      RETURN NUMBER
 97      DETERMINISTIC
 98      PARALLEL_ENABLE
 99    ;
100
101    /**
102    * Get the static name of the planck time sequence.
103    * @return USIM_STATIC.USIM_PLANCK_TIME_SEQ_NAME
104    */
105    FUNCTION get_planck_time_seq_name
106      RETURN VARCHAR2
107      DETERMINISTIC
108      PARALLEL_ENABLE
109    ;
110
111    /**
112    * Get the static name of the planck time sequence.
113    * @return USIM_STATIC.USIM_PLANCK_AEON_SEQ_NAME
114    */
115    FUNCTION get_planck_aeon_seq_name
116      RETURN VARCHAR2
117      DETERMINISTIC
118      PARALLEL_ENABLE
119    ;
120
121    /**
122    * Get the static name for not available.
123    * @return USIM_STATIC.USIM_NOT_AVAILABLE
124    */
125    FUNCTION get_not_available
126      RETURN VARCHAR2
127      DETERMINISTIC
128      PARALLEL_ENABLE
129    ;
130
131    /**
132    * Get the static name for volume side from.
133    * @return USIM_STATIC.USIM_SIDE_FROM
134    */
135    FUNCTION get_side_from
136      RETURN VARCHAR2
137      DETERMINISTIC
138      PARALLEL_ENABLE
139    ;
140
141    /**
142    * Get the static name for volume side to.
143    * @return USIM_STATIC.USIM_SIDE_TO
144    */
145    FUNCTION get_side_to
146      RETURN VARCHAR2
147      DETERMINISTIC
148      PARALLEL_ENABLE
149    ;
150
151    /**
152    * Get the static name for volume side both.
153    * @return USIM_STATIC.USIM_SIDE_BOTH
154    */
155    FUNCTION get_side_both
156      RETURN VARCHAR2
157      DETERMINISTIC
158      PARALLEL_ENABLE
159    ;
160
161    /**
162    * Get the identifier number for success of debug operations.
163    * @return USIM_STATIC.USIM_STATUS_SUCCESS
164    */
165    FUNCTION get_debug_success
166      RETURN NUMBER
167      DETERMINISTIC
168      PARALLEL_ENABLE
169    ;
170
171    /**
172    * Get the identifier number for error of debug operations.
173    * @return USIM_STATIC.USIM_STATUS_ERROR
174    */
175    FUNCTION get_debug_error
176      RETURN NUMBER
177      DETERMINISTIC
178      PARALLEL_ENABLE
179    ;
180
181    /**
182    * Get the identifier number for warning of debug operations.
183    * @return USIM_STATIC.USIM_STATUS_WARNING
184    */
185    FUNCTION get_debug_warning
186      RETURN NUMBER
187      DETERMINISTIC
188      PARALLEL_ENABLE
189    ;
190
191    /**
192    * Get the active status of a multiverse.
193    * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_ACTIVE
194    */
195    FUNCTION get_multiverse_active
196      RETURN NUMBER
197      DETERMINISTIC
198      PARALLEL_ENABLE
199    ;
200
201    /**
202    * Get the inactive status of a multiverse.
203    * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_INACTIVE
204    */
205    FUNCTION get_multiverse_inactive
206      RETURN NUMBER
207      DETERMINISTIC
208      PARALLEL_ENABLE
209    ;
210
211    /**
212    * Get the dead status of a multiverse.
213    * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_DEAD
214    */
215    FUNCTION get_multiverse_dead
216      RETURN NUMBER
217      DETERMINISTIC
218      PARALLEL_ENABLE
219    ;
220
221    /**
222    * Get the crashed status of a multiverse.
223    * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_CRASHED
224    */
225    FUNCTION get_multiverse_crashed
226      RETURN NUMBER
227      DETERMINISTIC
228      PARALLEL_ENABLE
229    ;
230
231    /**
232    * Get a text representation of the status of a multiverse.
233    * @return ACTIVE, INACTIVE, DEAD, CRASHED or UNKOWN status of universe by number identifier.
234    */
235    FUNCTION get_multiverse_status(p_status IN NUMBER)
236      RETURN VARCHAR2
237      DETERMINISTIC
238      PARALLEL_ENABLE
239    ;
240
241    /**
242    * Get the identifier text for status of debug operations.
243    * @param p_status - the debug status to get the text for.
244    * @return SUCCESS, WARNING or ERROR
245    */
246    FUNCTION get_debug_status(p_status IN NUMBER)
247      RETURN VARCHAR2
248      DETERMINISTIC
249      PARALLEL_ENABLE
250    ;
251
252    /**
253    * Get a text representation of a boolean value. Only for use in PL/SQL. Won't work with SQL statements.
254    * @param p_boolean - the boolean expression or variable.
255    * @return "TRUE" or "FALSE"
256    */
257    FUNCTION get_bool_str(p_boolean IN BOOLEAN)
258      RETURN VARCHAR2
259      DETERMINISTIC
260      PARALLEL_ENABLE
261    ;
262
263    /**
264    * Returns a VARCHAR2 of length 55 using current timestamp
265    * and the number from a cycling sequence to build a generic
266    * primary key which does not cause number overflows or end of
267    * available sequence numbers.
268    * @param p_sequence_number - the cycling sequence number to add to the key.
269    * @return New primary key in format TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISSFF3') || LPAD([sequence], 38, '0').
270    */
271    FUNCTION get_big_pk(p_sequence_number IN NUMBER)
272      RETURN VARCHAR2
273    ;
274
275    /**
276    * Returns the date value of a big primary key.
277    * @param p_primary_key - the primary key to get the date from.
278    * @return Normal DATE including seconds of the given primary key.
279    */
280    FUNCTION get_big_pk_date(p_primary_key IN VARCHAR2)
281      RETURN DATE
282    ;
283
284    /**
285    * Returns the number value of a big primary key.
286    * @param p_primary_key - the primary key to get the number value from.
287    * @return Number value of the given primary key.
288    */
289    FUNCTION get_big_pk_number(p_primary_key IN VARCHAR2)
290      RETURN NUMBER
291    ;
292
293    /**
294    * Returns the next number based on given number and sign.
295    * Adds 1 for sign +1 and subtract 1 for sign -1.
296    * @param p_number The number to get the next number for.
297    * @param p_sign The sign for the number to use. Only used if number is 0, otherwise sign is retrieved from given number. Sign 0 is interpreted positive.
298    * @return The next number based on (given) sign of the number.
299    */
300    FUNCTION get_next_number( p_number IN NUMBER
301                            , p_sign   IN NUMBER DEFAULT 1
302                            )
303      RETURN NUMBER
304    ;
305
306    /**
307    * Calculates the nodes defining a volume by dimension.
308    * Uses 2<sup>dimension</sup>.
309    * @param p_dimension The dimension to calculate the amount of nodes. Must be >= 0, values < 0 are interpreted as 0.
310    * @return The amount of nodes that define a volume for a given dimension.
311    */
312    FUNCTION nodes_per_dimension(p_dimension IN NUMBER)
313      RETURN NUMBER
314      DETERMINISTIC
315      PARALLEL_ENABLE
316    ;
317
318    /**
319    * Calculates the nodes missing for a given dimension, supposing that former dimensions and nodes already exist.
320    * Uses nodes_per_dimension(dimension) - nodes_per_dimension(dimension - 1) with special case dimension 0 and 1.
321    * @param p_dimension The dimension to calculate the amount of missing nodes. Must be >= 0, values < 0 are interpreted as 0.
322    * @return The amount of missing nodes for a volume and a given dimension.
323    */
324    FUNCTION missing_nodes_per_dimension(p_dimension IN NUMBER)
325      RETURN NUMBER
326      DETERMINISTIC
327      PARALLEL_ENABLE
328    ;
329
330    /**
331    * Checks if a given side is an allowed side.
332    * @param p_side The side symbol to check.
333    * @return Returns 1 if side symbol equals usim_side_from, usim_side_to or usim_side_both, otherwise 0.
334    */
335    FUNCTION is_allowed_side(p_side IN VARCHAR2)
336      RETURN NUMBER
337      DETERMINISTIC
338      PARALLEL_ENABLE
339    ;
340
341    /**
342    * Checks if a given side is an allowed from or to side.
343    * @param p_side The side symbol to check.
344    * @return Returns 1 if side symbol equals usim_side_from or usim_side_to, otherwise 0.
345    */
346    FUNCTION is_allowed_fromto_side(p_side IN VARCHAR2)
347      RETURN NUMBER
348      DETERMINISTIC
349      PARALLEL_ENABLE
350    ;
351
352  END usim_static;
353  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_static
IS
  /** A Package containing static values and SQL functions for retrieving this values to be used with the application. Changing values
  * in this package may break the application.
  *
  * Package constants:
  * <b>usim_max_childs_per_dimension</b> - a constant value for the allowed amount of child nodes within a given dimension. Application relies on this value.
  * <b>usim_max_seeds</b> - a constant value for the maximum seeds a universe can have, means the maximum of points with dimension and position without a parent. Application relies on this value.
  * <b>usim_planck_time_seq_name</b> - a constant for the sequence name responsible for planck time ticks.
  * <b>usim_planck_aeon_seq_name</b> - a constant for the sequence name responsible for planck aeons.
  * <b>usim_not_available</b> - a constant name for filled char fields which are not Null, but have no usable content.
  * <b>usim_side_from</b> - a constant name for the from side of a volume in space.
  * <b>usim_side_to</b> - a constant name for the to side of a volume in space.
  * <b>usim_side_both</b> - a constant name for basic space universe nodes in dimension 0, position 0 and sign 0 which are parents to base and mirror at the same time.
  * <b>usim_status_success</b> - a constant for debug success.
  * <b>usim_status_error</b> - a constant for debug error.
  * <b>usim_status_warning</b> - a constant for debug warning.
  * <b>usim_multiverse_status_active</b> - a constant for the active status of a multiverse.
  * <b>usim_multiverse_status_inactive</b> - a constant for the inactive status of a multiverse (all energy equals NULL).
  * <b>usim_multiverse_status_dead</b> - a constant for the dead status of a multiverse (all energy equals 0).
  * <b>usim_multiverse_status_crashed</b> - a constant for the crashed status of a multiverse (energy not equilibrated between universe and mirror).
  * <b>PI</b> - a constant for PI definition with Oracle precision.
  * <b>PI_DOUBLE</b> - a constant for 2 * PI definition with Oracle precision.
  * <b>PI_QUARTER</b> - a constant for PI / 4 definition with Oracle precision.
  */
  usim_max_childs_per_dimension   CONSTANT INTEGER      := 1;
  usim_max_seeds                  CONSTANT INTEGER      := 1;
  usim_planck_time_seq_name       CONSTANT CHAR(20)     := 'USIM_PLANCK_TIME_SEQ';
  usim_planck_aeon_seq_name       CONSTANT CHAR(20)     := 'USIM_PLANCK_AEON_SEQ';
  usim_not_available              CONSTANT CHAR(3)      := 'N/A';
  usim_side_from                  CONSTANT CHAR(1)      := 'F';
  usim_side_to                    CONSTANT CHAR(1)      := 'T';
  usim_side_both                  CONSTANT CHAR(1)      := 'B';
  usim_status_success             CONSTANT NUMBER       := 1;
  usim_status_error               CONSTANT NUMBER       := -1;
  usim_status_warning             CONSTANT NUMBER       := 0;
  usim_multiverse_status_active   CONSTANT NUMBER       := 1;
  usim_multiverse_status_inactive CONSTANT NUMBER       := 0;
  usim_multiverse_status_dead     CONSTANT NUMBER       := -1;
  usim_multiverse_status_crashed  CONSTANT NUMBER       := -2;
  PI                              CONSTANT NUMBER       := ACOS(-1);
  PI_DOUBLE                       CONSTANT NUMBER       := ACOS(-1) * 2;
  PI_QUARTER                      CONSTANT NUMBER       := ACOS(-1) / 4;

  /**
  * Types
  */
  SUBTYPE usim_id IS CHAR(55);
  TYPE usim_ids_type IS TABLE OF usim_id INDEX BY PLS_INTEGER;

  /**
  * Get the maximum of childs a node within a dimension can have.
  * @return USIM_STATIC.USIM_MAX_CHILDS_PER_DIMENSION
  */
  FUNCTION get_max_childs_per_dimension
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the maximum of seeds a universe can have.
  * @return USIM_STATIC.USIM_MAX_SEEDS
  */
  FUNCTION get_max_seeds
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static PI value.
  * @return USIM_STATIC.PI
  */
  FUNCTION get_pi
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static PI_DOUBLE (2 * PI) value.
  * @return USIM_STATIC.PI_DOUBLE
  */
  FUNCTION get_pi_double
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static PI_QUARTER (PI / 4) value.
  * @return USIM_STATIC.PI_QUARTER
  */
  FUNCTION get_pi_quarter
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static name of the planck time sequence.
  * @return USIM_STATIC.USIM_PLANCK_TIME_SEQ_NAME
  */
  FUNCTION get_planck_time_seq_name
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static name of the planck time sequence.
  * @return USIM_STATIC.USIM_PLANCK_AEON_SEQ_NAME
  */
  FUNCTION get_planck_aeon_seq_name
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static name for not available.
  * @return USIM_STATIC.USIM_NOT_AVAILABLE
  */
  FUNCTION get_not_available
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static name for volume side from.
  * @return USIM_STATIC.USIM_SIDE_FROM
  */
  FUNCTION get_side_from
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static name for volume side to.
  * @return USIM_STATIC.USIM_SIDE_TO
  */
  FUNCTION get_side_to
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static name for volume side both.
  * @return USIM_STATIC.USIM_SIDE_BOTH
  */
  FUNCTION get_side_both
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the identifier number for success of debug operations.
  * @return USIM_STATIC.USIM_STATUS_SUCCESS
  */
  FUNCTION get_debug_success
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the identifier number for error of debug operations.
  * @return USIM_STATIC.USIM_STATUS_ERROR
  */
  FUNCTION get_debug_error
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the identifier number for warning of debug operations.
  * @return USIM_STATIC.USIM_STATUS_WARNING
  */
  FUNCTION get_debug_warning
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the active status of a multiverse.
  * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_ACTIVE
  */
  FUNCTION get_multiverse_active
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the inactive status of a multiverse.
  * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_INACTIVE
  */
  FUNCTION get_multiverse_inactive
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the dead status of a multiverse.
  * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_DEAD
  */
  FUNCTION get_multiverse_dead
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the crashed status of a multiverse.
  * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_CRASHED
  */
  FUNCTION get_multiverse_crashed
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get a text representation of the status of a multiverse.
  * @return ACTIVE, INACTIVE, DEAD, CRASHED or UNKOWN status of universe by number identifier.
  */
  FUNCTION get_multiverse_status(p_status IN NUMBER)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the identifier text for status of debug operations.
  * @param p_status - the debug status to get the text for.
  * @return SUCCESS, WARNING or ERROR
  */
  FUNCTION get_debug_status(p_status IN NUMBER)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get a text representation of a boolean value. Only for use in PL/SQL. Won't work with SQL statements.
  * @param p_boolean - the boolean expression or variable.
  * @return "TRUE" or "FALSE"
  */
  FUNCTION get_bool_str(p_boolean IN BOOLEAN)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Returns a VARCHAR2 of length 55 using current timestamp
  * and the number from a cycling sequence to build a generic
  * primary key which does not cause number overflows or end of
  * available sequence numbers.
  * @param p_sequence_number - the cycling sequence number to add to the key.
  * @return New primary key in format TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISSFF3') || LPAD([sequence], 38, '0').
  */
  FUNCTION get_big_pk(p_sequence_number IN NUMBER)
    RETURN VARCHAR2
  ;

  /**
  * Returns the date value of a big primary key.
  * @param p_primary_key - the primary key to get the date from.
  * @return Normal DATE including seconds of the given primary key.
  */
  FUNCTION get_big_pk_date(p_primary_key IN VARCHAR2)
    RETURN DATE
  ;

  /**
  * Returns the number value of a big primary key.
  * @param p_primary_key - the primary key to get the number value from.
  * @return Number value of the given primary key.
  */
  FUNCTION get_big_pk_number(p_primary_key IN VARCHAR2)
    RETURN NUMBER
  ;

  /**
  * Returns the next number based on given number and sign.
  * Adds 1 for sign +1 and subtract 1 for sign -1.
  * @param p_number The number to get the next number for.
  * @param p_sign The sign for the number to use. Only used if number is 0, otherwise sign is retrieved from given number. Sign 0 is interpreted positive.
  * @return The next number based on (given) sign of the number.
  */
  FUNCTION get_next_number( p_number IN NUMBER
                          , p_sign   IN NUMBER DEFAULT 1
                          )
    RETURN NUMBER
  ;

  /**
  * Calculates the nodes defining a volume by dimension.
  * Uses 2<sup>dimension</sup>.
  * @param p_dimension The dimension to calculate the amount of nodes. Must be >= 0, values < 0 are interpreted as 0.
  * @return The amount of nodes that define a volume for a given dimension.
  */
  FUNCTION nodes_per_dimension(p_dimension IN NUMBER)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Calculates the nodes missing for a given dimension, supposing that former dimensions and nodes already exist.
  * Uses nodes_per_dimension(dimension) - nodes_per_dimension(dimension - 1) with special case dimension 0 and 1.
  * @param p_dimension The dimension to calculate the amount of missing nodes. Must be >= 0, values < 0 are interpreted as 0.
  * @return The amount of missing nodes for a volume and a given dimension.
  */
  FUNCTION missing_nodes_per_dimension(p_dimension IN NUMBER)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Checks if a given side is an allowed side.
  * @param p_side The side symbol to check.
  * @return Returns 1 if side symbol equals usim_side_from, usim_side_to or usim_side_both, otherwise 0.
  */
  FUNCTION is_allowed_side(p_side IN VARCHAR2)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Checks if a given side is an allowed from or to side.
  * @param p_side The side symbol to check.
  * @return Returns 1 if side symbol equals usim_side_from or usim_side_to, otherwise 0.
  */
  FUNCTION is_allowed_fromto_side(p_side IN VARCHAR2)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

END usim_static;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_static
IS
  /** A Package containing static values and SQL functions for retrieving this values to be used with the application. Changing values
  * in this package may break the application.
  *
  * Package constants:
  * <b>usim_max_childs_per_dimension</b> - a constant value for the allowed amount of child nodes within a given dimension. Application relies on this value.
  * <b>usim_max_seeds</b> - a constant value for the maximum seeds a universe can have, means the maximum of points with dimension and position without a parent. Application relies on this value.
  * <b>usim_planck_time_seq_name</b> - a constant for the sequence name responsible for planck time ticks.
  * <b>usim_planck_aeon_seq_name</b> - a constant for the sequence name responsible for planck aeons.
  * <b>usim_not_available</b> - a constant name for filled char fields which are not Null, but have no usable content.
  * <b>usim_side_from</b> - a constant name for the from side of a volume in space.
  * <b>usim_side_to</b> - a constant name for the to side of a volume in space.
  * <b>usim_side_both</b> - a constant name for basic space universe nodes in dimension 0, position 0 and sign 0 which are parents to base and mirror at the same time.
  * <b>usim_status_success</b> - a constant for debug success.
  * <b>usim_status_error</b> - a constant for debug error.
  * <b>usim_status_warning</b> - a constant for debug warning.
  * <b>usim_multiverse_status_active</b> - a constant for the active status of a multiverse.
  * <b>usim_multiverse_status_inactive</b> - a constant for the inactive status of a multiverse (all energy equals NULL).
  * <b>usim_multiverse_status_dead</b> - a constant for the dead status of a multiverse (all energy equals 0).
  * <b>usim_multiverse_status_crashed</b> - a constant for the crashed status of a multiverse (energy not equilibrated between universe and mirror).
  * <b>PI</b> - a constant for PI definition with Oracle precision.
  * <b>PI_DOUBLE</b> - a constant for 2 * PI definition with Oracle precision.
  * <b>PI_QUARTER</b> - a constant for PI / 4 definition with Oracle precision.
  */
  usim_max_childs_per_dimension   CONSTANT INTEGER      := 1;
  usim_max_seeds                  CONSTANT INTEGER      := 1;
  usim_planck_time_seq_name       CONSTANT CHAR(20)     := 'USIM_PLANCK_TIME_SEQ';
  usim_planck_aeon_seq_name       CONSTANT CHAR(20)     := 'USIM_PLANCK_AEON_SEQ';
  usim_not_available              CONSTANT CHAR(3)      := 'N/A';
  usim_side_from                  CONSTANT CHAR(1)      := 'F';
  usim_side_to                    CONSTANT CHAR(1)      := 'T';
  usim_side_both                  CONSTANT CHAR(1)      := 'B';
  usim_status_success             CONSTANT NUMBER       := 1;
  usim_status_error               CONSTANT NUMBER       := -1;
  usim_status_warning             CONSTANT NUMBER       := 0;
  usim_multiverse_status_active   CONSTANT NUMBER       := 1;
  usim_multiverse_status_inactive CONSTANT NUMBER       := 0;
  usim_multiverse_status_dead     CONSTANT NUMBER       := -1;
  usim_multiverse_status_crashed  CONSTANT NUMBER       := -2;
  PI                              CONSTANT NUMBER       := ACOS(-1);
  PI_DOUBLE                       CONSTANT NUMBER       := ACOS(-1) * 2;
  PI_QUARTER                      CONSTANT NUMBER       := ACOS(-1) / 4;

  /**
  * Types
  */
  SUBTYPE usim_id IS CHAR(55);
  TYPE usim_ids_type IS TABLE OF usim_id INDEX BY PLS_INTEGER;

  /**
  * Get the maximum of childs a node within a dimension can have.
  * @return USIM_STATIC.USIM_MAX_CHILDS_PER_DIMENSION
  */
  FUNCTION get_max_childs_per_dimension
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the maximum of seeds a universe can have.
  * @return USIM_STATIC.USIM_MAX_SEEDS
  */
  FUNCTION get_max_seeds
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static PI value.
  * @return USIM_STATIC.PI
  */
  FUNCTION get_pi
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static PI_DOUBLE (2 * PI) value.
  * @return USIM_STATIC.PI_DOUBLE
  */
  FUNCTION get_pi_double
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static PI_QUARTER (PI / 4) value.
  * @return USIM_STATIC.PI_QUARTER
  */
  FUNCTION get_pi_quarter
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static name of the planck time sequence.
  * @return USIM_STATIC.USIM_PLANCK_TIME_SEQ_NAME
  */
  FUNCTION get_planck_time_seq_name
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static name of the planck time sequence.
  * @return USIM_STATIC.USIM_PLANCK_AEON_SEQ_NAME
  */
  FUNCTION get_planck_aeon_seq_name
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static name for not available.
  * @return USIM_STATIC.USIM_NOT_AVAILABLE
  */
  FUNCTION get_not_available
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static name for volume side from.
  * @return USIM_STATIC.USIM_SIDE_FROM
  */
  FUNCTION get_side_from
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static name for volume side to.
  * @return USIM_STATIC.USIM_SIDE_TO
  */
  FUNCTION get_side_to
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the static name for volume side both.
  * @return USIM_STATIC.USIM_SIDE_BOTH
  */
  FUNCTION get_side_both
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the identifier number for success of debug operations.
  * @return USIM_STATIC.USIM_STATUS_SUCCESS
  */
  FUNCTION get_debug_success
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the identifier number for error of debug operations.
  * @return USIM_STATIC.USIM_STATUS_ERROR
  */
  FUNCTION get_debug_error
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the identifier number for warning of debug operations.
  * @return USIM_STATIC.USIM_STATUS_WARNING
  */
  FUNCTION get_debug_warning
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the active status of a multiverse.
  * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_ACTIVE
  */
  FUNCTION get_multiverse_active
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the inactive status of a multiverse.
  * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_INACTIVE
  */
  FUNCTION get_multiverse_inactive
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the dead status of a multiverse.
  * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_DEAD
  */
  FUNCTION get_multiverse_dead
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the crashed status of a multiverse.
  * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_CRASHED
  */
  FUNCTION get_multiverse_crashed
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get a text representation of the status of a multiverse.
  * @return ACTIVE, INACTIVE, DEAD, CRASHED or UNKOWN status of universe by number identifier.
  */
  FUNCTION get_multiverse_status(p_status IN NUMBER)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get the identifier text for status of debug operations.
  * @param p_status - the debug status to get the text for.
  * @return SUCCESS, WARNING or ERROR
  */
  FUNCTION get_debug_status(p_status IN NUMBER)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Get a text representation of a boolean value. Only for use in PL/SQL. Won't work with SQL statements.
  * @param p_boolean - the boolean expression or variable.
  * @return "TRUE" or "FALSE"
  */
  FUNCTION get_bool_str(p_boolean IN BOOLEAN)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Returns a VARCHAR2 of length 55 using current timestamp
  * and the number from a cycling sequence to build a generic
  * primary key which does not cause number overflows or end of
  * available sequence numbers.
  * @param p_sequence_number - the cycling sequence number to add to the key.
  * @return New primary key in format TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISSFF3') || LPAD([sequence], 38, '0').
  */
  FUNCTION get_big_pk(p_sequence_number IN NUMBER)
    RETURN VARCHAR2
  ;

  /**
  * Returns the date value of a big primary key.
  * @param p_primary_key - the primary key to get the date from.
  * @return Normal DATE including seconds of the given primary key.
  */
  FUNCTION get_big_pk_date(p_primary_key IN VARCHAR2)
    RETURN DATE
  ;

  /**
  * Returns the number value of a big primary key.
  * @param p_primary_key - the primary key to get the number value from.
  * @return Number value of the given primary key.
  */
  FUNCTION get_big_pk_number(p_primary_key IN VARCHAR2)
    RETURN NUMBER
  ;

  /**
  * Returns the next number based on given number and sign.
  * Adds 1 for sign +1 and subtract 1 for sign -1.
  * @param p_number The number to get the next number for.
  * @param p_sign The sign for the number to use. Only used if number is 0, otherwise sign is retrieved from given number. Sign 0 is interpreted positive.
  * @return The next number based on (given) sign of the number.
  */
  FUNCTION get_next_number( p_number IN NUMBER
                          , p_sign   IN NUMBER DEFAULT 1
                          )
    RETURN NUMBER
  ;

  /**
  * Calculates the nodes defining a volume by dimension.
  * Uses 2<sup>dimension</sup>.
  * @param p_dimension The dimension to calculate the amount of nodes. Must be >= 0, values < 0 are interpreted as 0.
  * @return The amount of nodes that define a volume for a given dimension.
  */
  FUNCTION nodes_per_dimension(p_dimension IN NUMBER)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Calculates the nodes missing for a given dimension, supposing that former dimensions and nodes already exist.
  * Uses nodes_per_dimension(dimension) - nodes_per_dimension(dimension - 1) with special case dimension 0 and 1.
  * @param p_dimension The dimension to calculate the amount of missing nodes. Must be >= 0, values < 0 are interpreted as 0.
  * @return The amount of missing nodes for a volume and a given dimension.
  */
  FUNCTION missing_nodes_per_dimension(p_dimension IN NUMBER)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Checks if a given side is an allowed side.
  * @param p_side The side symbol to check.
  * @return Returns 1 if side symbol equals usim_side_from, usim_side_to or usim_side_both, otherwise 0.
  */
  FUNCTION is_allowed_side(p_side IN VARCHAR2)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

  /**
  * Checks if a given side is an allowed from or to side.
  * @param p_side The side symbol to check.
  * @return Returns 1 if side symbol equals usim_side_from or usim_side_to, otherwise 0.
  */
  FUNCTION is_allowed_fromto_side(p_side IN VARCHAR2)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  ;

END usim_static;

Package USIM_STATIC kompiliert

SQL> @@../PACKAGES/USIM_STATIC.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_static
  2  IS
  3    -- decription see header
  4    FUNCTION get_max_childs_per_dimension
  5      RETURN NUMBER
  6      DETERMINISTIC
  7      PARALLEL_ENABLE
  8    IS
  9    BEGIN
 10      RETURN usim_static.usim_max_childs_per_dimension;
 11    END get_max_childs_per_dimension
 12    ;
 13
 14    FUNCTION get_max_seeds
 15      RETURN NUMBER
 16      DETERMINISTIC
 17      PARALLEL_ENABLE
 18    IS
 19    BEGIN
 20      RETURN usim_static.usim_max_seeds;
 21    END get_max_seeds
 22    ;
 23
 24    FUNCTION get_pi
 25      RETURN NUMBER
 26      DETERMINISTIC
 27      PARALLEL_ENABLE
 28    IS
 29    BEGIN
 30      RETURN usim_static.PI;
 31    END get_pi
 32    ;
 33
 34    FUNCTION get_pi_double
 35      RETURN NUMBER
 36      DETERMINISTIC
 37      PARALLEL_ENABLE
 38    IS
 39    BEGIN
 40      RETURN usim_static.PI_DOUBLE;
 41    END get_pi_double
 42    ;
 43
 44    FUNCTION get_pi_quarter
 45      RETURN NUMBER
 46      DETERMINISTIC
 47      PARALLEL_ENABLE
 48    IS
 49    BEGIN
 50      RETURN usim_static.PI_QUARTER;
 51    END get_pi_quarter
 52    ;
 53
 54    FUNCTION get_planck_time_seq_name
 55      RETURN VARCHAR2
 56      DETERMINISTIC
 57      PARALLEL_ENABLE
 58    IS
 59    BEGIN
 60      RETURN usim_static.usim_planck_time_seq_name;
 61    END get_planck_time_seq_name
 62    ;
 63
 64    FUNCTION get_planck_aeon_seq_name
 65      RETURN VARCHAR2
 66      DETERMINISTIC
 67      PARALLEL_ENABLE
 68    IS
 69    BEGIN
 70      RETURN usim_static.usim_planck_aeon_seq_name;
 71    END get_planck_aeon_seq_name
 72    ;
 73
 74    FUNCTION get_not_available
 75      RETURN VARCHAR2
 76      DETERMINISTIC
 77      PARALLEL_ENABLE
 78    IS
 79    BEGIN
 80      RETURN usim_static.usim_not_available;
 81    END get_not_available
 82    ;
 83
 84    FUNCTION get_side_from
 85      RETURN VARCHAR2
 86      DETERMINISTIC
 87      PARALLEL_ENABLE
 88    IS
 89    BEGIN
 90      RETURN usim_static.usim_side_from;
 91    END get_side_from
 92    ;
 93
 94    FUNCTION get_side_to
 95      RETURN VARCHAR2
 96      DETERMINISTIC
 97      PARALLEL_ENABLE
 98    IS
 99    BEGIN
100      RETURN usim_static.usim_side_to;
101    END get_side_to
102    ;
103
104    FUNCTION get_side_both
105      RETURN VARCHAR2
106      DETERMINISTIC
107      PARALLEL_ENABLE
108    IS
109    BEGIN
110      RETURN usim_static.usim_side_both;
111    END get_side_both
112    ;
113
114    FUNCTION get_debug_success
115      RETURN NUMBER
116      DETERMINISTIC
117      PARALLEL_ENABLE
118    IS
119    BEGIN
120      RETURN usim_static.usim_status_success;
121    END get_debug_success
122    ;
123
124    FUNCTION get_debug_error
125      RETURN NUMBER
126      DETERMINISTIC
127      PARALLEL_ENABLE
128    IS
129    BEGIN
130      RETURN usim_static.usim_status_error;
131    END get_debug_error
132    ;
133
134    FUNCTION get_debug_warning
135      RETURN NUMBER
136      DETERMINISTIC
137      PARALLEL_ENABLE
138    IS
139    BEGIN
140      RETURN usim_static.usim_status_warning;
141    END get_debug_warning
142    ;
143
144    FUNCTION get_multiverse_active
145      RETURN NUMBER
146      DETERMINISTIC
147      PARALLEL_ENABLE
148    IS
149    BEGIN
150      RETURN usim_static.usim_multiverse_status_active;
151    END get_multiverse_active
152    ;
153
154    FUNCTION get_multiverse_inactive
155      RETURN NUMBER
156      DETERMINISTIC
157      PARALLEL_ENABLE
158    IS
159    BEGIN
160      RETURN usim_static.usim_multiverse_status_inactive;
161    END get_multiverse_inactive
162    ;
163
164    FUNCTION get_multiverse_dead
165      RETURN NUMBER
166      DETERMINISTIC
167      PARALLEL_ENABLE
168    IS
169    BEGIN
170      RETURN usim_static.usim_multiverse_status_dead;
171    END get_multiverse_dead
172    ;
173
174    FUNCTION get_multiverse_crashed
175      RETURN NUMBER
176      DETERMINISTIC
177      PARALLEL_ENABLE
178    IS
179    BEGIN
180      RETURN usim_static.usim_multiverse_status_crashed;
181    END get_multiverse_crashed
182    ;
183
184    FUNCTION get_multiverse_status(p_status IN NUMBER)
185      RETURN VARCHAR2
186      DETERMINISTIC
187      PARALLEL_ENABLE
188    IS
189    BEGIN
190      RETURN CASE
191               WHEN p_status = usim_multiverse_status_active
192               THEN 'ACTIVE'
193               WHEN p_status = usim_multiverse_status_inactive
194               THEN 'INACTIVE'
195               WHEN p_status = usim_multiverse_status_dead
196               THEN 'DEAD'
197               WHEN p_status = usim_multiverse_status_crashed
198               THEN 'CRASHED'
199               ELSE 'UNKNOWN'
200            END
201      ;
202    END get_multiverse_status
203    ;
204
205    FUNCTION get_debug_status(p_status  IN NUMBER)
206      RETURN VARCHAR2
207      DETERMINISTIC
208      PARALLEL_ENABLE
209    IS
210    BEGIN
211      RETURN CASE
212               WHEN p_status = usim_status_success
213               THEN 'SUCCESS'
214               WHEN p_status = usim_status_error
215               THEN 'ERROR'
216               WHEN p_status = usim_status_warning
217               THEN 'WARNING'
218               ELSE 'UNKNOWN'
219            END
220      ;
221    END get_debug_status
222    ;
223
224    FUNCTION get_bool_str(p_boolean IN BOOLEAN)
225      RETURN VARCHAR2
226      DETERMINISTIC
227      PARALLEL_ENABLE
228    IS
229    BEGIN
230      IF p_boolean
231      THEN
232        RETURN 'TRUE';
233      ELSE
234        RETURN 'FALSE';
235      END IF;
236    END get_bool_str
237    ;
238
239    FUNCTION get_big_pk(p_sequence_number IN NUMBER)
240      RETURN VARCHAR2
241    IS
242    BEGIN
243      RETURN TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISSFF3') || LPAD(TRIM(TO_CHAR(p_sequence_number)), 38, '0');
244    END get_big_pk
245    ;
246
247    FUNCTION get_big_pk_date(p_primary_key IN VARCHAR2)
248      RETURN DATE
249    IS
250    BEGIN
251      RETURN TO_DATE(SUBSTR(p_primary_key, 1, 14), 'YYYYMMDDHH24MISS');
252    END get_big_pk_date
253    ;
254
255    FUNCTION get_big_pk_number(p_primary_key IN VARCHAR2)
256      RETURN NUMBER
257    IS
258    BEGIN
259      RETURN TO_NUMBER(SUBSTR(p_primary_key, 18));
260    END get_big_pk_number
261    ;
262
263    FUNCTION get_next_number( p_number IN NUMBER
264                            , p_sign   IN NUMBER DEFAULT 1
265                            )
266      RETURN NUMBER
267    IS
268      l_sign    NUMBER;
269      l_result  NUMBER;
270      l_number  NUMBER;
271    BEGIN
272      IF NVL(p_number, 0) = 0
273      THEN
274        l_sign    := SIGN(NVL(p_sign, 0));
275        l_number  := NVL(p_number, 0);
276      ELSE
277        l_sign    := SIGN(p_number);
278        l_number  := p_number;
279      END IF;
280      IF l_sign >= 0
281      THEN
282        l_result := l_number + 1;
283      ELSE
284        l_result := l_number - 1;
285      END IF;
286      RETURN l_result;
287    END get_next_number
288    ;
289
290    FUNCTION nodes_per_dimension(p_dimension IN NUMBER)
291      RETURN NUMBER
292      DETERMINISTIC
293      PARALLEL_ENABLE
294    IS
295      l_dimension NUMBER;
296    BEGIN
297      IF p_dimension < 0
298      THEN
299        l_dimension := 0;
300      ELSE
301        l_dimension := p_dimension;
302      END IF;
303      RETURN POWER(2, l_dimension);
304    END nodes_per_dimension
305    ;
306
307    FUNCTION missing_nodes_per_dimension(p_dimension IN NUMBER)
308      RETURN NUMBER
309      DETERMINISTIC
310      PARALLEL_ENABLE
311    IS
312      l_dimension NUMBER;
313      l_result    NUMBER;
314    BEGIN
315      IF p_dimension < 0
316      THEN
317        l_dimension := 0;
318      ELSE
319        l_dimension := p_dimension;
320      END IF;
321      IF l_dimension <= 1
322      THEN
323        l_result := CASE WHEN l_dimension = 0 THEN 1 ELSE 2 END;
324      ELSE
325        l_result := usim_static.nodes_per_dimension(l_dimension) - usim_static.nodes_per_dimension(l_dimension - 1);
326      END IF;
327      RETURN l_result;
328    END missing_nodes_per_dimension
329    ;
330
331    FUNCTION is_allowed_side(p_side IN VARCHAR2)
332      RETURN NUMBER
333      DETERMINISTIC
334      PARALLEL_ENABLE
335    IS
336    BEGIN
337      IF p_side IN (usim_static.usim_side_from, usim_static.usim_side_to, usim_side_both)
338      THEN
339        RETURN 1;
340      ELSE
341        RETURN 0;
342      END IF;
343    END is_allowed_side
344    ;
345
346    FUNCTION is_allowed_fromto_side(p_side IN VARCHAR2)
347      RETURN NUMBER
348      DETERMINISTIC
349      PARALLEL_ENABLE
350    IS
351    BEGIN
352      IF p_side IN (usim_static.usim_side_from, usim_static.usim_side_to)
353      THEN
354        RETURN 1;
355      ELSE
356        RETURN 0;
357      END IF;
358    END is_allowed_fromto_side
359    ;
360
361  END usim_static;
362  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_static
IS
  -- decription see header
  FUNCTION get_max_childs_per_dimension
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_max_childs_per_dimension;
  END get_max_childs_per_dimension
  ;

  FUNCTION get_max_seeds
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_max_seeds;
  END get_max_seeds
  ;

  FUNCTION get_pi
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.PI;
  END get_pi
  ;

  FUNCTION get_pi_double
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.PI_DOUBLE;
  END get_pi_double
  ;

  FUNCTION get_pi_quarter
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.PI_QUARTER;
  END get_pi_quarter
  ;

  FUNCTION get_planck_time_seq_name
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_planck_time_seq_name;
  END get_planck_time_seq_name
  ;

  FUNCTION get_planck_aeon_seq_name
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_planck_aeon_seq_name;
  END get_planck_aeon_seq_name
  ;

  FUNCTION get_not_available
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_not_available;
  END get_not_available
  ;

  FUNCTION get_side_from
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_side_from;
  END get_side_from
  ;

  FUNCTION get_side_to
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_side_to;
  END get_side_to
  ;

  FUNCTION get_side_both
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_side_both;
  END get_side_both
  ;

  FUNCTION get_debug_success
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_status_success;
  END get_debug_success
  ;

  FUNCTION get_debug_error
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_status_error;
  END get_debug_error
  ;

  FUNCTION get_debug_warning
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_status_warning;
  END get_debug_warning
  ;

  FUNCTION get_multiverse_active
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_multiverse_status_active;
  END get_multiverse_active
  ;

  FUNCTION get_multiverse_inactive
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_multiverse_status_inactive;
  END get_multiverse_inactive
  ;

  FUNCTION get_multiverse_dead
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_multiverse_status_dead;
  END get_multiverse_dead
  ;

  FUNCTION get_multiverse_crashed
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_multiverse_status_crashed;
  END get_multiverse_crashed
  ;

  FUNCTION get_multiverse_status(p_status IN NUMBER)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN CASE
             WHEN p_status = usim_multiverse_status_active
             THEN 'ACTIVE'
             WHEN p_status = usim_multiverse_status_inactive
             THEN 'INACTIVE'
             WHEN p_status = usim_multiverse_status_dead
             THEN 'DEAD'
             WHEN p_status = usim_multiverse_status_crashed
             THEN 'CRASHED'
             ELSE 'UNKNOWN'
          END
    ;
  END get_multiverse_status
  ;

  FUNCTION get_debug_status(p_status  IN NUMBER)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN CASE
             WHEN p_status = usim_status_success
             THEN 'SUCCESS'
             WHEN p_status = usim_status_error
             THEN 'ERROR'
             WHEN p_status = usim_status_warning
             THEN 'WARNING'
             ELSE 'UNKNOWN'
          END
    ;
  END get_debug_status
  ;

  FUNCTION get_bool_str(p_boolean IN BOOLEAN)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    IF p_boolean
    THEN
      RETURN 'TRUE';
    ELSE
      RETURN 'FALSE';
    END IF;
  END get_bool_str
  ;

  FUNCTION get_big_pk(p_sequence_number IN NUMBER)
    RETURN VARCHAR2
  IS
  BEGIN
    RETURN TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISSFF3') || LPAD(TRIM(TO_CHAR(p_sequence_number)), 38, '0');
  END get_big_pk
  ;

  FUNCTION get_big_pk_date(p_primary_key IN VARCHAR2)
    RETURN DATE
  IS
  BEGIN
    RETURN TO_DATE(SUBSTR(p_primary_key, 1, 14), 'YYYYMMDDHH24MISS');
  END get_big_pk_date
  ;

  FUNCTION get_big_pk_number(p_primary_key IN VARCHAR2)
    RETURN NUMBER
  IS
  BEGIN
    RETURN TO_NUMBER(SUBSTR(p_primary_key, 18));
  END get_big_pk_number
  ;

  FUNCTION get_next_number( p_number IN NUMBER
                          , p_sign   IN NUMBER DEFAULT 1
                          )
    RETURN NUMBER
  IS
    l_sign    NUMBER;
    l_result  NUMBER;
    l_number  NUMBER;
  BEGIN
    IF NVL(p_number, 0) = 0
    THEN
      l_sign    := SIGN(NVL(p_sign, 0));
      l_number  := NVL(p_number, 0);
    ELSE
      l_sign    := SIGN(p_number);
      l_number  := p_number;
    END IF;
    IF l_sign >= 0
    THEN
      l_result := l_number + 1;
    ELSE
      l_result := l_number - 1;
    END IF;
    RETURN l_result;
  END get_next_number
  ;

  FUNCTION nodes_per_dimension(p_dimension IN NUMBER)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
    l_dimension NUMBER;
  BEGIN
    IF p_dimension < 0
    THEN
      l_dimension := 0;
    ELSE
      l_dimension := p_dimension;
    END IF;
    RETURN POWER(2, l_dimension);
  END nodes_per_dimension
  ;

  FUNCTION missing_nodes_per_dimension(p_dimension IN NUMBER)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
    l_dimension NUMBER;
    l_result    NUMBER;
  BEGIN
    IF p_dimension < 0
    THEN
      l_dimension := 0;
    ELSE
      l_dimension := p_dimension;
    END IF;
    IF l_dimension <= 1
    THEN
      l_result := CASE WHEN l_dimension = 0 THEN 1 ELSE 2 END;
    ELSE
      l_result := usim_static.nodes_per_dimension(l_dimension) - usim_static.nodes_per_dimension(l_dimension - 1);
    END IF;
    RETURN l_result;
  END missing_nodes_per_dimension
  ;

  FUNCTION is_allowed_side(p_side IN VARCHAR2)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    IF p_side IN (usim_static.usim_side_from, usim_static.usim_side_to, usim_side_both)
    THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  END is_allowed_side
  ;

  FUNCTION is_allowed_fromto_side(p_side IN VARCHAR2)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    IF p_side IN (usim_static.usim_side_from, usim_static.usim_side_to)
    THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  END is_allowed_fromto_side
  ;

END usim_static;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_static
IS
  -- decription see header
  FUNCTION get_max_childs_per_dimension
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_max_childs_per_dimension;
  END get_max_childs_per_dimension
  ;

  FUNCTION get_max_seeds
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_max_seeds;
  END get_max_seeds
  ;

  FUNCTION get_pi
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.PI;
  END get_pi
  ;

  FUNCTION get_pi_double
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.PI_DOUBLE;
  END get_pi_double
  ;

  FUNCTION get_pi_quarter
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.PI_QUARTER;
  END get_pi_quarter
  ;

  FUNCTION get_planck_time_seq_name
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_planck_time_seq_name;
  END get_planck_time_seq_name
  ;

  FUNCTION get_planck_aeon_seq_name
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_planck_aeon_seq_name;
  END get_planck_aeon_seq_name
  ;

  FUNCTION get_not_available
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_not_available;
  END get_not_available
  ;

  FUNCTION get_side_from
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_side_from;
  END get_side_from
  ;

  FUNCTION get_side_to
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_side_to;
  END get_side_to
  ;

  FUNCTION get_side_both
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_side_both;
  END get_side_both
  ;

  FUNCTION get_debug_success
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_status_success;
  END get_debug_success
  ;

  FUNCTION get_debug_error
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_status_error;
  END get_debug_error
  ;

  FUNCTION get_debug_warning
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_status_warning;
  END get_debug_warning
  ;

  FUNCTION get_multiverse_active
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_multiverse_status_active;
  END get_multiverse_active
  ;

  FUNCTION get_multiverse_inactive
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_multiverse_status_inactive;
  END get_multiverse_inactive
  ;

  FUNCTION get_multiverse_dead
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_multiverse_status_dead;
  END get_multiverse_dead
  ;

  FUNCTION get_multiverse_crashed
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN usim_static.usim_multiverse_status_crashed;
  END get_multiverse_crashed
  ;

  FUNCTION get_multiverse_status(p_status IN NUMBER)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN CASE
             WHEN p_status = usim_multiverse_status_active
             THEN 'ACTIVE'
             WHEN p_status = usim_multiverse_status_inactive
             THEN 'INACTIVE'
             WHEN p_status = usim_multiverse_status_dead
             THEN 'DEAD'
             WHEN p_status = usim_multiverse_status_crashed
             THEN 'CRASHED'
             ELSE 'UNKNOWN'
          END
    ;
  END get_multiverse_status
  ;

  FUNCTION get_debug_status(p_status  IN NUMBER)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    RETURN CASE
             WHEN p_status = usim_status_success
             THEN 'SUCCESS'
             WHEN p_status = usim_status_error
             THEN 'ERROR'
             WHEN p_status = usim_status_warning
             THEN 'WARNING'
             ELSE 'UNKNOWN'
          END
    ;
  END get_debug_status
  ;

  FUNCTION get_bool_str(p_boolean IN BOOLEAN)
    RETURN VARCHAR2
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    IF p_boolean
    THEN
      RETURN 'TRUE';
    ELSE
      RETURN 'FALSE';
    END IF;
  END get_bool_str
  ;

  FUNCTION get_big_pk(p_sequence_number IN NUMBER)
    RETURN VARCHAR2
  IS
  BEGIN
    RETURN TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISSFF3') || LPAD(TRIM(TO_CHAR(p_sequence_number)), 38, '0');
  END get_big_pk
  ;

  FUNCTION get_big_pk_date(p_primary_key IN VARCHAR2)
    RETURN DATE
  IS
  BEGIN
    RETURN TO_DATE(SUBSTR(p_primary_key, 1, 14), 'YYYYMMDDHH24MISS');
  END get_big_pk_date
  ;

  FUNCTION get_big_pk_number(p_primary_key IN VARCHAR2)
    RETURN NUMBER
  IS
  BEGIN
    RETURN TO_NUMBER(SUBSTR(p_primary_key, 18));
  END get_big_pk_number
  ;

  FUNCTION get_next_number( p_number IN NUMBER
                          , p_sign   IN NUMBER DEFAULT 1
                          )
    RETURN NUMBER
  IS
    l_sign    NUMBER;
    l_result  NUMBER;
    l_number  NUMBER;
  BEGIN
    IF NVL(p_number, 0) = 0
    THEN
      l_sign    := SIGN(NVL(p_sign, 0));
      l_number  := NVL(p_number, 0);
    ELSE
      l_sign    := SIGN(p_number);
      l_number  := p_number;
    END IF;
    IF l_sign >= 0
    THEN
      l_result := l_number + 1;
    ELSE
      l_result := l_number - 1;
    END IF;
    RETURN l_result;
  END get_next_number
  ;

  FUNCTION nodes_per_dimension(p_dimension IN NUMBER)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
    l_dimension NUMBER;
  BEGIN
    IF p_dimension < 0
    THEN
      l_dimension := 0;
    ELSE
      l_dimension := p_dimension;
    END IF;
    RETURN POWER(2, l_dimension);
  END nodes_per_dimension
  ;

  FUNCTION missing_nodes_per_dimension(p_dimension IN NUMBER)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
    l_dimension NUMBER;
    l_result    NUMBER;
  BEGIN
    IF p_dimension < 0
    THEN
      l_dimension := 0;
    ELSE
      l_dimension := p_dimension;
    END IF;
    IF l_dimension <= 1
    THEN
      l_result := CASE WHEN l_dimension = 0 THEN 1 ELSE 2 END;
    ELSE
      l_result := usim_static.nodes_per_dimension(l_dimension) - usim_static.nodes_per_dimension(l_dimension - 1);
    END IF;
    RETURN l_result;
  END missing_nodes_per_dimension
  ;

  FUNCTION is_allowed_side(p_side IN VARCHAR2)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    IF p_side IN (usim_static.usim_side_from, usim_static.usim_side_to, usim_side_both)
    THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  END is_allowed_side
  ;

  FUNCTION is_allowed_fromto_side(p_side IN VARCHAR2)
    RETURN NUMBER
    DETERMINISTIC
    PARALLEL_ENABLE
  IS
  BEGIN
    IF p_side IN (usim_static.usim_side_from, usim_static.usim_side_to)
    THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  END is_allowed_fromto_side
  ;

END usim_static;

Package Body USIM_STATIC kompiliert

SQL> @@../PACKAGES/USIM_MATHS.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_maths
  2  IS
  3    /** A package for all mathematical calculations in this multiverse which will not use any database access.
  4    * The universes itself don't care about units, their units are always based on 1, like the planck units. Units like seconds do only
  5    * make sense for an observer inside a universe, but not from the universe perspective.
  6    * There is a difference between, so called "outside planck units" and "inside planck units". Inside, every planck unit equals 1, outside
  7    * it is defined by the start parameters of an universe.
  8    * <b>Technical:</b> Oracle cuts numbers too large but still supported by PL/SQL. Calculations may raise number overflow/underflow. Using this
  9    * library should include to check numbers for "overflow" before to get reliable results. Exception handling is minimalistic, if something
 10    * fails, defaults are used. Exceptions itself are not checked or differentiated. Testing should proove that it works with numbers in range.
 11    */
 12
 13    /**
 14    * Calculates the planck speed c, which is an instantaneous velocity v by given planck length(minimal displacement) and planck time(minimal time frame). Using:</br>
 15    * v = delta x / delta t</br>
 16    " In this special case delta x equals the given outside planck length and delta t equals the outside planck time.
 17    * @param p_planck_length The outside planck definition for minimal displacement in a specific universe.
 18    * @param p_planck_time The outside planck definition for minimal time frames in a specific universe.
 19    * @return The planck speed for given time and displacement or 1 (default) if any of the parameters equals NULL/0.
 20    */
 21    FUNCTION init_planck_speed( p_planck_length IN NUMBER
 22                              , p_planck_time   IN NUMBER
 23                              )
 24      RETURN NUMBER
 25    ;
 26
 27    /**
 28    * Calculates the planck time by given planck length(minimal displacement) and planck speed(minimal speed). Using:</br>
 29    * t = delta x / delta v</br>
 30    " In this special case delta x equals the given outside planck length and delta v equals the outside planck speed.
 31    * @param p_planck_length The outside planck definition for minimal displacement in a specific universe.
 32    * @param p_planck_speed The outside planck definition for minimal speed in a specific universe.
 33    * @return The planck time for given speed and displacement or 1 (default) if any of the parameters equals NULL/0.
 34    */
 35    FUNCTION init_planck_time( p_planck_length  IN NUMBER
 36                             , p_planck_speed   IN NUMBER
 37                             )
 38      RETURN NUMBER
 39    ;
 40
 41    /**
 42    * Calculates the planck length by given planck speed(minimal speed) and planck time(minimal time frame). Using:</br>
 43    * x = delta t x delta v</br>
 44    " In this special case delta t equals the outside planck time and delta v equals the outside planck speed.
 45    * @param p_planck_speed The outside planck definition for minimal speed in a specific universe.
 46    * @param p_planck_time The outside planck definition for minimal time frames in a specific universe.
 47    * @return The planck length for given speed and time or 1 (default) if any of the parameters equals NULL/0.
 48    */
 49    FUNCTION init_planck_length( p_planck_speed IN NUMBER
 50                               , p_planck_time  IN NUMBER
 51                               )
 52      RETURN NUMBER
 53    ;
 54
 55    /**
 56    * Applies a universe specific outside planck definition like speed, length or time. Using:</br>
 57    * value x factor
 58    * @param p_value The value to apply a planck factor. NULL values are interpreted as 0.
 59    * @param p_planck_factor The outside planck attribute definition like speed, time and length to be used as a factor. NULL values are interpreted as 0.
 60    * @return The value multiplied by the given factor.
 61    */
 62    FUNCTION apply_planck( p_value         IN NUMBER
 63                         , p_planck_factor IN NUMBER
 64                         )
 65      RETURN NUMBER
 66    ;
 67
 68    /**
 69    * Calculate acceleration / hit energy for extending space based on source space node attributes.
 70    * Uses classical mechanics to calculate the acceleration that will hit a target space node from gravitational laws in a very reduced sense.
 71    * Uses a<sub>2</sub> = G * m<sub>1</sub> / r<sup>2</sup>. Only valid for extending space itself.
 72    * Extending space sees mass = energy as there exists no mass currently. Energy moving in internal planck steps r = 1 with c = 1 and t = 1.
 73    * As we have no mass yet and nodes can't move, acceleration transports the energy of one node to the next node. Acceleration is seen as the
 74    * energy that hits and reacts with another space nodes energy. Energy will travel until it reaches its defined borders and then travel back.
 75    * The reaction of a target space node is therefore not immediate. Once hit it will first emit the received energy as acceleration to the target
 76    * nodes within r = 1 until a border is reached. The same law is applied on the travel back, but now with the new energy levels of the target
 77    * nodes. If a node is not initialized yet (energy = NULL), it is treated as 1 leaving incoming acceleration and energy unchanged.
 78    * @param p_m1 The "mass" of the source space node represented by its energy value. NULL is interpreted as 0.
 79    * @param p_r The radius / distance between source and target space node. Internally always 1, but external values may differ. NULL is interpreted as 1.
 80    * @param p_G The gravitational constant used by the source space node to expand its energy. Use calc_dim_G with the dimension of the source space node to get the correct value. NULL is interpreted as 1.
 81    * @return The acceleration / hit energy for a target space node by source attributes. Overflow/underflow or any error has to be handled by caller.
 82    */
 83    FUNCTION calc_planck_a2( p_m1 IN NUMBER
 84                           , p_r  IN NUMBER
 85                           , p_G  IN NUMBER
 86                           )
 87      RETURN NUMBER
 88    ;
 89
 90    /**
 91    * Calculates the gravitational constant G for a given dimension for extending space in planck units using G = 1 / 8PI as a base,
 92    * but considers the current dimension instead of static 8 for 3 dimension. This G is not static. It is only valid in the given dimension.
 93    * The number for the PI multiplier is derived from maximum binary tree nodes per dimension. Formula:</br>
 94    * dn = nodes per dimension n = 2<sup>n</sup></br>
 95    * G<sub>dim</sub> = 1 / (dn * PI)</br>
 96    * Only valid for extending space itself.
 97    * @param p_dimension The n dimension to calculate G<sub>dim</sub> for. NULL values are interpreted as 0. Uses the absolute of the number, ignores negative dimensions and cuts any floating point decimals.
 98    * @return The calculated G<sub>dim</sub> for the given dimension.
 99    */
100    FUNCTION calc_dim_G(p_dimension IN NUMBER)
101      RETURN NUMBER
102    ;
103
104  END usim_maths;
105  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_maths
IS
  /** A package for all mathematical calculations in this multiverse which will not use any database access.
  * The universes itself don't care about units, their units are always based on 1, like the planck units. Units like seconds do only
  * make sense for an observer inside a universe, but not from the universe perspective.
  * There is a difference between, so called "outside planck units" and "inside planck units". Inside, every planck unit equals 1, outside
  * it is defined by the start parameters of an universe.
  * <b>Technical:</b> Oracle cuts numbers too large but still supported by PL/SQL. Calculations may raise number overflow/underflow. Using this
  * library should include to check numbers for "overflow" before to get reliable results. Exception handling is minimalistic, if something
  * fails, defaults are used. Exceptions itself are not checked or differentiated. Testing should proove that it works with numbers in range.
  */

  /**
  * Calculates the planck speed c, which is an instantaneous velocity v by given planck length(minimal displacement) and planck time(minimal time frame). Using:</br>
  * v = delta x / delta t</br>
  " In this special case delta x equals the given outside planck length and delta t equals the outside planck time.
  * @param p_planck_length The outside planck definition for minimal displacement in a specific universe.
  * @param p_planck_time The outside planck definition for minimal time frames in a specific universe.
  * @return The planck speed for given time and displacement or 1 (default) if any of the parameters equals NULL/0.
  */
  FUNCTION init_planck_speed( p_planck_length IN NUMBER
                            , p_planck_time   IN NUMBER
                            )
    RETURN NUMBER
  ;

  /**
  * Calculates the planck time by given planck length(minimal displacement) and planck speed(minimal speed). Using:</br>
  * t = delta x / delta v</br>
  " In this special case delta x equals the given outside planck length and delta v equals the outside planck speed.
  * @param p_planck_length The outside planck definition for minimal displacement in a specific universe.
  * @param p_planck_speed The outside planck definition for minimal speed in a specific universe.
  * @return The planck time for given speed and displacement or 1 (default) if any of the parameters equals NULL/0.
  */
  FUNCTION init_planck_time( p_planck_length  IN NUMBER
                           , p_planck_speed   IN NUMBER
                           )
    RETURN NUMBER
  ;

  /**
  * Calculates the planck length by given planck speed(minimal speed) and planck time(minimal time frame). Using:</br>
  * x = delta t x delta v</br>
  " In this special case delta t equals the outside planck time and delta v equals the outside planck speed.
  * @param p_planck_speed The outside planck definition for minimal speed in a specific universe.
  * @param p_planck_time The outside planck definition for minimal time frames in a specific universe.
  * @return The planck length for given speed and time or 1 (default) if any of the parameters equals NULL/0.
  */
  FUNCTION init_planck_length( p_planck_speed IN NUMBER
                             , p_planck_time  IN NUMBER
                             )
    RETURN NUMBER
  ;

  /**
  * Applies a universe specific outside planck definition like speed, length or time. Using:</br>
  * value x factor
  * @param p_value The value to apply a planck factor. NULL values are interpreted as 0.
  * @param p_planck_factor The outside planck attribute definition like speed, time and length to be used as a factor. NULL values are interpreted as 0.
  * @return The value multiplied by the given factor.
  */
  FUNCTION apply_planck( p_value         IN NUMBER
                       , p_planck_factor IN NUMBER
                       )
    RETURN NUMBER
  ;

  /**
  * Calculate acceleration / hit energy for extending space based on source space node attributes.
  * Uses classical mechanics to calculate the acceleration that will hit a target space node from gravitational laws in a very reduced sense.
  * Uses a<sub>2</sub> = G * m<sub>1</sub> / r<sup>2</sup>. Only valid for extending space itself.
  * Extending space sees mass = energy as there exists no mass currently. Energy moving in internal planck steps r = 1 with c = 1 and t = 1.
  * As we have no mass yet and nodes can't move, acceleration transports the energy of one node to the next node. Acceleration is seen as the
  * energy that hits and reacts with another space nodes energy. Energy will travel until it reaches its defined borders and then travel back.
  * The reaction of a target space node is therefore not immediate. Once hit it will first emit the received energy as acceleration to the target
  * nodes within r = 1 until a border is reached. The same law is applied on the travel back, but now with the new energy levels of the target
  * nodes. If a node is not initialized yet (energy = NULL), it is treated as 1 leaving incoming acceleration and energy unchanged.
  * @param p_m1 The "mass" of the source space node represented by its energy value. NULL is interpreted as 0.
  * @param p_r The radius / distance between source and target space node. Internally always 1, but external values may differ. NULL is interpreted as 1.
  * @param p_G The gravitational constant used by the source space node to expand its energy. Use calc_dim_G with the dimension of the source space node to get the correct value. NULL is interpreted as 1.
  * @return The acceleration / hit energy for a target space node by source attributes. Overflow/underflow or any error has to be handled by caller.
  */
  FUNCTION calc_planck_a2( p_m1 IN NUMBER
                         , p_r  IN NUMBER
                         , p_G  IN NUMBER
                         )
    RETURN NUMBER
  ;

  /**
  * Calculates the gravitational constant G for a given dimension for extending space in planck units using G = 1 / 8PI as a base,
  * but considers the current dimension instead of static 8 for 3 dimension. This G is not static. It is only valid in the given dimension.
  * The number for the PI multiplier is derived from maximum binary tree nodes per dimension. Formula:</br>
  * dn = nodes per dimension n = 2<sup>n</sup></br>
  * G<sub>dim</sub> = 1 / (dn * PI)</br>
  * Only valid for extending space itself.
  * @param p_dimension The n dimension to calculate G<sub>dim</sub> for. NULL values are interpreted as 0. Uses the absolute of the number, ignores negative dimensions and cuts any floating point decimals.
  * @return The calculated G<sub>dim</sub> for the given dimension.
  */
  FUNCTION calc_dim_G(p_dimension IN NUMBER)
    RETURN NUMBER
  ;

END usim_maths;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_maths
IS
  /** A package for all mathematical calculations in this multiverse which will not use any database access.
  * The universes itself don't care about units, their units are always based on 1, like the planck units. Units like seconds do only
  * make sense for an observer inside a universe, but not from the universe perspective.
  * There is a difference between, so called "outside planck units" and "inside planck units". Inside, every planck unit equals 1, outside
  * it is defined by the start parameters of an universe.
  * <b>Technical:</b> Oracle cuts numbers too large but still supported by PL/SQL. Calculations may raise number overflow/underflow. Using this
  * library should include to check numbers for "overflow" before to get reliable results. Exception handling is minimalistic, if something
  * fails, defaults are used. Exceptions itself are not checked or differentiated. Testing should proove that it works with numbers in range.
  */

  /**
  * Calculates the planck speed c, which is an instantaneous velocity v by given planck length(minimal displacement) and planck time(minimal time frame). Using:</br>
  * v = delta x / delta t</br>
  " In this special case delta x equals the given outside planck length and delta t equals the outside planck time.
  * @param p_planck_length The outside planck definition for minimal displacement in a specific universe.
  * @param p_planck_time The outside planck definition for minimal time frames in a specific universe.
  * @return The planck speed for given time and displacement or 1 (default) if any of the parameters equals NULL/0.
  */
  FUNCTION init_planck_speed( p_planck_length IN NUMBER
                            , p_planck_time   IN NUMBER
                            )
    RETURN NUMBER
  ;

  /**
  * Calculates the planck time by given planck length(minimal displacement) and planck speed(minimal speed). Using:</br>
  * t = delta x / delta v</br>
  " In this special case delta x equals the given outside planck length and delta v equals the outside planck speed.
  * @param p_planck_length The outside planck definition for minimal displacement in a specific universe.
  * @param p_planck_speed The outside planck definition for minimal speed in a specific universe.
  * @return The planck time for given speed and displacement or 1 (default) if any of the parameters equals NULL/0.
  */
  FUNCTION init_planck_time( p_planck_length  IN NUMBER
                           , p_planck_speed   IN NUMBER
                           )
    RETURN NUMBER
  ;

  /**
  * Calculates the planck length by given planck speed(minimal speed) and planck time(minimal time frame). Using:</br>
  * x = delta t x delta v</br>
  " In this special case delta t equals the outside planck time and delta v equals the outside planck speed.
  * @param p_planck_speed The outside planck definition for minimal speed in a specific universe.
  * @param p_planck_time The outside planck definition for minimal time frames in a specific universe.
  * @return The planck length for given speed and time or 1 (default) if any of the parameters equals NULL/0.
  */
  FUNCTION init_planck_length( p_planck_speed IN NUMBER
                             , p_planck_time  IN NUMBER
                             )
    RETURN NUMBER
  ;

  /**
  * Applies a universe specific outside planck definition like speed, length or time. Using:</br>
  * value x factor
  * @param p_value The value to apply a planck factor. NULL values are interpreted as 0.
  * @param p_planck_factor The outside planck attribute definition like speed, time and length to be used as a factor. NULL values are interpreted as 0.
  * @return The value multiplied by the given factor.
  */
  FUNCTION apply_planck( p_value         IN NUMBER
                       , p_planck_factor IN NUMBER
                       )
    RETURN NUMBER
  ;

  /**
  * Calculate acceleration / hit energy for extending space based on source space node attributes.
  * Uses classical mechanics to calculate the acceleration that will hit a target space node from gravitational laws in a very reduced sense.
  * Uses a<sub>2</sub> = G * m<sub>1</sub> / r<sup>2</sup>. Only valid for extending space itself.
  * Extending space sees mass = energy as there exists no mass currently. Energy moving in internal planck steps r = 1 with c = 1 and t = 1.
  * As we have no mass yet and nodes can't move, acceleration transports the energy of one node to the next node. Acceleration is seen as the
  * energy that hits and reacts with another space nodes energy. Energy will travel until it reaches its defined borders and then travel back.
  * The reaction of a target space node is therefore not immediate. Once hit it will first emit the received energy as acceleration to the target
  * nodes within r = 1 until a border is reached. The same law is applied on the travel back, but now with the new energy levels of the target
  * nodes. If a node is not initialized yet (energy = NULL), it is treated as 1 leaving incoming acceleration and energy unchanged.
  * @param p_m1 The "mass" of the source space node represented by its energy value. NULL is interpreted as 0.
  * @param p_r The radius / distance between source and target space node. Internally always 1, but external values may differ. NULL is interpreted as 1.
  * @param p_G The gravitational constant used by the source space node to expand its energy. Use calc_dim_G with the dimension of the source space node to get the correct value. NULL is interpreted as 1.
  * @return The acceleration / hit energy for a target space node by source attributes. Overflow/underflow or any error has to be handled by caller.
  */
  FUNCTION calc_planck_a2( p_m1 IN NUMBER
                         , p_r  IN NUMBER
                         , p_G  IN NUMBER
                         )
    RETURN NUMBER
  ;

  /**
  * Calculates the gravitational constant G for a given dimension for extending space in planck units using G = 1 / 8PI as a base,
  * but considers the current dimension instead of static 8 for 3 dimension. This G is not static. It is only valid in the given dimension.
  * The number for the PI multiplier is derived from maximum binary tree nodes per dimension. Formula:</br>
  * dn = nodes per dimension n = 2<sup>n</sup></br>
  * G<sub>dim</sub> = 1 / (dn * PI)</br>
  * Only valid for extending space itself.
  * @param p_dimension The n dimension to calculate G<sub>dim</sub> for. NULL values are interpreted as 0. Uses the absolute of the number, ignores negative dimensions and cuts any floating point decimals.
  * @return The calculated G<sub>dim</sub> for the given dimension.
  */
  FUNCTION calc_dim_G(p_dimension IN NUMBER)
    RETURN NUMBER
  ;

END usim_maths;

Package USIM_MATHS kompiliert

SQL> @@../PACKAGES/USIM_MATHS.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_maths
  2  IS
  3    -- see header for documentation
  4    FUNCTION init_planck_speed( p_planck_length IN NUMBER
  5                              , p_planck_time   IN NUMBER
  6                              )
  7      RETURN NUMBER
  8    IS
  9    BEGIN
 10      IF    NVL(p_planck_length, 0) = 0
 11         OR NVL(p_planck_time, 0)   = 0
 12      THEN
 13        -- fallback default value
 14        RETURN 1;
 15      ELSE
 16        RETURN (p_planck_length / p_planck_time);
 17      END IF;
 18    END init_planck_speed
 19    ;
 20
 21    FUNCTION init_planck_time( p_planck_length  IN NUMBER
 22                             , p_planck_speed   IN NUMBER
 23                             )
 24      RETURN NUMBER
 25    IS
 26    BEGIN
 27      IF    NVL(p_planck_length, 0) = 0
 28         OR NVL(p_planck_speed, 0)  = 0
 29      THEN
 30        -- fallback default value
 31        RETURN 1;
 32      ELSE
 33        RETURN (p_planck_length / p_planck_speed);
 34      END IF;
 35    END init_planck_time
 36    ;
 37
 38    FUNCTION init_planck_length( p_planck_speed IN NUMBER
 39                               , p_planck_time  IN NUMBER
 40                               )
 41      RETURN NUMBER
 42    IS
 43    BEGIN
 44      IF    NVL(p_planck_time, 0)   = 0
 45         OR NVL(p_planck_speed, 0)  = 0
 46      THEN
 47        -- fallback default value
 48        RETURN 1;
 49      ELSE
 50        RETURN (p_planck_speed * p_planck_time);
 51      END IF;
 52    END init_planck_length
 53    ;
 54
 55    FUNCTION apply_planck( p_value         IN NUMBER
 56                         , p_planck_factor IN NUMBER
 57                         )
 58      RETURN NUMBER
 59    IS
 60    BEGIN
 61      RETURN (NVL(p_value, 0) * NVL(p_planck_factor, 0));
 62    END apply_planck
 63    ;
 64
 65    FUNCTION calc_dim_G(p_dimension IN NUMBER)
 66      RETURN NUMBER
 67    IS
 68      l_result NUMBER;
 69    BEGIN
 70      l_result := 1 / usim_static.nodes_per_dimension(NVL(ABS(FLOOR(p_dimension)), 0));
 71      RETURN l_result;
 72    END calc_dim_G
 73    ;
 74
 75    FUNCTION calc_planck_a2( p_m1 IN NUMBER
 76                           , p_r  IN NUMBER
 77                           , p_G  IN NUMBER
 78                           )
 79      RETURN NUMBER
 80    IS
 81      l_result NUMBER;
 82    BEGIN
 83      l_result := NVL(p_G, 1) * (NVL(p_m1, 0) / POWER(NVL(p_r, 1), 2));
 84      RETURN l_result;
 85    END calc_planck_a2
 86    ;
 87
 88  END usim_maths;
 89  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_maths
IS
  -- see header for documentation
  FUNCTION init_planck_speed( p_planck_length IN NUMBER
                            , p_planck_time   IN NUMBER
                            )
    RETURN NUMBER
  IS
  BEGIN
    IF    NVL(p_planck_length, 0) = 0
       OR NVL(p_planck_time, 0)   = 0
    THEN
      -- fallback default value
      RETURN 1;
    ELSE
      RETURN (p_planck_length / p_planck_time);
    END IF;
  END init_planck_speed
  ;

  FUNCTION init_planck_time( p_planck_length  IN NUMBER
                           , p_planck_speed   IN NUMBER
                           )
    RETURN NUMBER
  IS
  BEGIN
    IF    NVL(p_planck_length, 0) = 0
       OR NVL(p_planck_speed, 0)  = 0
    THEN
      -- fallback default value
      RETURN 1;
    ELSE
      RETURN (p_planck_length / p_planck_speed);
    END IF;
  END init_planck_time
  ;

  FUNCTION init_planck_length( p_planck_speed IN NUMBER
                             , p_planck_time  IN NUMBER
                             )
    RETURN NUMBER
  IS
  BEGIN
    IF    NVL(p_planck_time, 0)   = 0
       OR NVL(p_planck_speed, 0)  = 0
    THEN
      -- fallback default value
      RETURN 1;
    ELSE
      RETURN (p_planck_speed * p_planck_time);
    END IF;
  END init_planck_length
  ;

  FUNCTION apply_planck( p_value         IN NUMBER
                       , p_planck_factor IN NUMBER
                       )
    RETURN NUMBER
  IS
  BEGIN
    RETURN (NVL(p_value, 0) * NVL(p_planck_factor, 0));
  END apply_planck
  ;

  FUNCTION calc_dim_G(p_dimension IN NUMBER)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := 1 / usim_static.nodes_per_dimension(NVL(ABS(FLOOR(p_dimension)), 0));
    RETURN l_result;
  END calc_dim_G
  ;

  FUNCTION calc_planck_a2( p_m1 IN NUMBER
                         , p_r  IN NUMBER
                         , p_G  IN NUMBER
                         )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := NVL(p_G, 1) * (NVL(p_m1, 0) / POWER(NVL(p_r, 1), 2));
    RETURN l_result;
  END calc_planck_a2
  ;

END usim_maths;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_maths
IS
  -- see header for documentation
  FUNCTION init_planck_speed( p_planck_length IN NUMBER
                            , p_planck_time   IN NUMBER
                            )
    RETURN NUMBER
  IS
  BEGIN
    IF    NVL(p_planck_length, 0) = 0
       OR NVL(p_planck_time, 0)   = 0
    THEN
      -- fallback default value
      RETURN 1;
    ELSE
      RETURN (p_planck_length / p_planck_time);
    END IF;
  END init_planck_speed
  ;

  FUNCTION init_planck_time( p_planck_length  IN NUMBER
                           , p_planck_speed   IN NUMBER
                           )
    RETURN NUMBER
  IS
  BEGIN
    IF    NVL(p_planck_length, 0) = 0
       OR NVL(p_planck_speed, 0)  = 0
    THEN
      -- fallback default value
      RETURN 1;
    ELSE
      RETURN (p_planck_length / p_planck_speed);
    END IF;
  END init_planck_time
  ;

  FUNCTION init_planck_length( p_planck_speed IN NUMBER
                             , p_planck_time  IN NUMBER
                             )
    RETURN NUMBER
  IS
  BEGIN
    IF    NVL(p_planck_time, 0)   = 0
       OR NVL(p_planck_speed, 0)  = 0
    THEN
      -- fallback default value
      RETURN 1;
    ELSE
      RETURN (p_planck_speed * p_planck_time);
    END IF;
  END init_planck_length
  ;

  FUNCTION apply_planck( p_value         IN NUMBER
                       , p_planck_factor IN NUMBER
                       )
    RETURN NUMBER
  IS
  BEGIN
    RETURN (NVL(p_value, 0) * NVL(p_planck_factor, 0));
  END apply_planck
  ;

  FUNCTION calc_dim_G(p_dimension IN NUMBER)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := 1 / usim_static.nodes_per_dimension(NVL(ABS(FLOOR(p_dimension)), 0));
    RETURN l_result;
  END calc_dim_G
  ;

  FUNCTION calc_planck_a2( p_m1 IN NUMBER
                         , p_r  IN NUMBER
                         , p_G  IN NUMBER
                         )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := NVL(p_G, 1) * (NVL(p_m1, 0) / POWER(NVL(p_r, 1), 2));
    RETURN l_result;
  END calc_planck_a2
  ;

END usim_maths;

Package Body USIM_MATHS kompiliert

SQL> --== basic packages end ==--
SQL>
SQL> --== sequences start ==--
SQL> -- USIM_MULTIVERSE (mlv) sequence
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../SEQUENCES/USIM_MLV_ID_SEQ.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_MLV_ID_SEQ still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MLV_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_MLV_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_MLV_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MLV_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_MLV_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_MLV_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MLV_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_MLV_ID_SEQ.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_MULTIVERSE (mlv) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_mlv_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    ORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
alt:CREATE SEQUENCE &USIM_SCHEMA..usim_mlv_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  ORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

neu:CREATE SEQUENCE USIM_TEST.usim_mlv_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  ORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

Sequence USIM_TEST.USIM_MLV_ID_SEQ erstellt.

SQL> -- USIM_PLANCK_TIME_SEQ
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../SEQUENCES/USIM_PLANCK_TIME_SEQ.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_PLANCK_TIME_SEQ still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_PLANCK_TIME_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_PLANCK_TIME_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_PLANCK_TIME_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_PLANCK_TIME_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_PLANCK_TIME_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_PLANCK_TIME_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_PLANCK_TIME_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------------------
../SEQUENCES/USIM_PLANCK_TIME_SEQ.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_planck_time_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    ORDER
  8    CYCLE
  9    KEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
alt:CREATE SEQUENCE &USIM_SCHEMA..usim_planck_time_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  ORDER
  CYCLE
  KEEP
  NOSCALE
  GLOBAL

neu:CREATE SEQUENCE USIM_TEST.usim_planck_time_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  ORDER
  CYCLE
  KEEP
  NOSCALE
  GLOBAL

Sequence USIM_TEST.USIM_PLANCK_TIME_SEQ erstellt.

SQL> -- USIM_PLANCK_AEON_SEQ
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../SEQUENCES/USIM_PLANCK_AEON_SEQ.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_PLANCK_AEON_SEQ still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_PLANCK_AEON_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_PLANCK_AEON_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_PLANCK_AEON_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_PLANCK_AEON_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_PLANCK_AEON_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_PLANCK_AEON_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_PLANCK_AEON_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------------------
../SEQUENCES/USIM_PLANCK_AEON_SEQ.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_planck_aeon_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    ORDER
  8    CYCLE
  9    KEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
alt:CREATE SEQUENCE &USIM_SCHEMA..usim_planck_aeon_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  ORDER
  CYCLE
  KEEP
  NOSCALE
  GLOBAL

neu:CREATE SEQUENCE USIM_TEST.usim_planck_aeon_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  ORDER
  CYCLE
  KEEP
  NOSCALE
  GLOBAL

Sequence USIM_TEST.USIM_PLANCK_AEON_SEQ erstellt.

SQL> -- USIM_DIMENSION (dim) sequence
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../SEQUENCES/USIM_DIM_ID_SEQ.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_DIM_ID_SEQ still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DIM_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_DIM_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_DIM_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DIM_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_DIM_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_DIM_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DIM_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_DIM_ID_SEQ.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_DIMENSION (dim)
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_dim_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
alt:CREATE SEQUENCE &USIM_SCHEMA..usim_dim_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

neu:CREATE SEQUENCE USIM_TEST.usim_dim_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

Sequence USIM_TEST.USIM_DIM_ID_SEQ erstellt.

SQL> -- USIM_POSITION (pos) sequence
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../SEQUENCES/USIM_POS_ID_SEQ.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_POS_ID_SEQ still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_POS_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_POS_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_POS_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_POS_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_POS_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_POS_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_POS_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_POS_ID_SEQ.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_POSITION (pos) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_pos_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
alt:CREATE SEQUENCE &USIM_SCHEMA..usim_pos_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

neu:CREATE SEQUENCE USIM_TEST.usim_pos_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

Sequence USIM_TEST.USIM_POS_ID_SEQ erstellt.

SQL> -- USIM_NODE (nod) sequence
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../SEQUENCES/USIM_NOD_ID_SEQ.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_NOD_ID_SEQ still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_NOD_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_NOD_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_NOD_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_NOD_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_NOD_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_NOD_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_NOD_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_NOD_ID_SEQ.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_NODE (nod) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_nod_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
alt:CREATE SEQUENCE &USIM_SCHEMA..usim_nod_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

neu:CREATE SEQUENCE USIM_TEST.usim_nod_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

Sequence USIM_TEST.USIM_NOD_ID_SEQ erstellt.

SQL> -- USIM_REL_MLV_DIM (rmd) sequence
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../SEQUENCES/USIM_RMD_ID_SEQ.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_RMD_ID_SEQ still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_RMD_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_RMD_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_RMD_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_RMD_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_RMD_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_RMD_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_RMD_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_RMD_ID_SEQ.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_REL_MLV_DIM (rmd) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_rmd_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
alt:CREATE SEQUENCE &USIM_SCHEMA..usim_rmd_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

neu:CREATE SEQUENCE USIM_TEST.usim_rmd_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

Sequence USIM_TEST.USIM_RMD_ID_SEQ erstellt.

SQL> -- USIM_SPACE (spc)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../SEQUENCES/USIM_SPC_ID_SEQ.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_SPC_ID_SEQ still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_SPC_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_SPC_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_SPC_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_SPC_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_SPC_ID_SEQ.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_SPACE (spc) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_spc_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
alt:CREATE SEQUENCE &USIM_SCHEMA..usim_spc_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

neu:CREATE SEQUENCE USIM_TEST.usim_spc_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

Sequence USIM_TEST.USIM_SPC_ID_SEQ erstellt.

SQL> -- USIM_SPC_PROCESS (spr)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../SEQUENCES/USIM_SPR_ID_SEQ.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_SPR_ID_SEQ still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPR_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_SPR_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_SPR_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPR_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_SPR_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_SPR_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPR_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_SPR_ID_SEQ.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_SPC_PROCESS (spr) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_spr_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
alt:CREATE SEQUENCE &USIM_SCHEMA..usim_spr_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

neu:CREATE SEQUENCE USIM_TEST.usim_spr_id_seq
  MINVALUE 1
  MAXVALUE 99999999999999999999999999999999999999
  INCREMENT BY 1
  START WITH 1
  NOCACHE
  NOORDER
  CYCLE
  NOKEEP
  NOSCALE
  GLOBAL

Sequence USIM_TEST.USIM_SPR_ID_SEQ erstellt.

SQL> --== sequences end ==--
SQL>
SQL> --== base data start ==--
SQL> -- USIM_BASEDATA (bda)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_BASEDATA_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_BASEDATA still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_BASEDATA'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_BASEDATA_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_BASEDATA still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_BASEDATA'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_BASEDATA_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_BASEDATA still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_BASEDATA'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------------
../TABLES/USIM_BASEDATA_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_BASEDATA (bda)
SQL> CREATE TABLE &USIM_SCHEMA..usim_basedata
  2    ( usim_id_bda                 NUMBER(1)       DEFAULT 1                                       NOT NULL ENABLE
  3    , usim_max_dimension          NUMBER(2, 0)    DEFAULT 42                                      NOT NULL ENABLE
  4    , usim_abs_max_number         NUMBER(38, 0)   DEFAULT 99999999999999999999999999999999999999  NOT NULL ENABLE
  5    , usim_overflow_node_seed     NUMBER(1, 0)    DEFAULT 0                                       NOT NULL ENABLE
  6    , usim_planck_time_seq_last   NUMBER          DEFAULT -1                                      NOT NULL ENABLE
  7    , usim_planck_time_seq_curr   NUMBER          DEFAULT -1                                      NOT NULL ENABLE
  8    , usim_planck_aeon_seq_last   CHAR(55)        DEFAULT 'N/A'                                   NOT NULL ENABLE
  9    , usim_planck_aeon_seq_curr   CHAR(55)        DEFAULT 'N/A'                                   NOT NULL ENABLE
 10    , usim_created                DATE            DEFAULT SYSDATE                                 NOT NULL ENABLE
 11    , usim_updated                DATE            DEFAULT SYSDATE                                 NOT NULL ENABLE
 12    , usim_created_by             VARCHAR2(128)   DEFAULT 'N/A'                                   NOT NULL ENABLE
 13    , usim_updated_by             VARCHAR2(128)   DEFAULT 'N/A'                                   NOT NULL ENABLE
 14    )
 15  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_basedata
  ( usim_id_bda                 NUMBER(1)       DEFAULT 1                                       NOT NULL ENABLE
  , usim_max_dimension          NUMBER(2, 0)    DEFAULT 42                                      NOT NULL ENABLE
  , usim_abs_max_number         NUMBER(38, 0)   DEFAULT 99999999999999999999999999999999999999  NOT NULL ENABLE
  , usim_overflow_node_seed     NUMBER(1, 0)    DEFAULT 0                                       NOT NULL ENABLE
  , usim_planck_time_seq_last   NUMBER          DEFAULT -1                                      NOT NULL ENABLE
  , usim_planck_time_seq_curr   NUMBER          DEFAULT -1                                      NOT NULL ENABLE
  , usim_planck_aeon_seq_last   CHAR(55)        DEFAULT 'N/A'                                   NOT NULL ENABLE
  , usim_planck_aeon_seq_curr   CHAR(55)        DEFAULT 'N/A'                                   NOT NULL ENABLE
  , usim_created                DATE            DEFAULT SYSDATE                                 NOT NULL ENABLE
  , usim_updated                DATE            DEFAULT SYSDATE                                 NOT NULL ENABLE
  , usim_created_by             VARCHAR2(128)   DEFAULT 'N/A'                                   NOT NULL ENABLE
  , usim_updated_by             VARCHAR2(128)   DEFAULT 'N/A'                                   NOT NULL ENABLE
  )

neu:CREATE TABLE USIM_TEST.usim_basedata
  ( usim_id_bda                 NUMBER(1)       DEFAULT 1                                       NOT NULL ENABLE
  , usim_max_dimension          NUMBER(2, 0)    DEFAULT 42                                      NOT NULL ENABLE
  , usim_abs_max_number         NUMBER(38, 0)   DEFAULT 99999999999999999999999999999999999999  NOT NULL ENABLE
  , usim_overflow_node_seed     NUMBER(1, 0)    DEFAULT 0                                       NOT NULL ENABLE
  , usim_planck_time_seq_last   NUMBER          DEFAULT -1                                      NOT NULL ENABLE
  , usim_planck_time_seq_curr   NUMBER          DEFAULT -1                                      NOT NULL ENABLE
  , usim_planck_aeon_seq_last   CHAR(55)        DEFAULT 'N/A'                                   NOT NULL ENABLE
  , usim_planck_aeon_seq_curr   CHAR(55)        DEFAULT 'N/A'                                   NOT NULL ENABLE
  , usim_created                DATE            DEFAULT SYSDATE                                 NOT NULL ENABLE
  , usim_updated                DATE            DEFAULT SYSDATE                                 NOT NULL ENABLE
  , usim_created_by             VARCHAR2(128)   DEFAULT 'N/A'                                   NOT NULL ENABLE
  , usim_updated_by             VARCHAR2(128)   DEFAULT 'N/A'                                   NOT NULL ENABLE
  )

Table USIM_TEST.USIM_BASEDATA erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_basedata IS 'Holds the basic data used by the multiverse simulation that belong to all universes. Will use the alias bda.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_basedata IS 'Holds the basic data used by the multiverse simulation that belong to all universes. Will use the alias bda.'
neu:COMMENT ON TABLE USIM_TEST.usim_basedata IS 'Holds the basic data used by the multiverse simulation that belong to all universes. Will use the alias bda.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_id_bda IS 'The unique id of the base data. Can only have the value 1 ensured by primary key and check constraint.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_id_bda IS 'The unique id of the base data. Can only have the value 1 ensured by primary key and check constraint.'
neu:COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_id_bda IS 'The unique id of the base data. Can only have the value 1 ensured by primary key and check constraint.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_max_dimension IS 'The maximum dimension supported for any universe in this multiverse. Must be set on insert, ignored on update.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_max_dimension IS 'The maximum dimension supported for any universe in this multiverse. Must be set on insert, ignored on update.'
neu:COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_max_dimension IS 'The maximum dimension supported for any universe in this multiverse. Must be set on insert, ignored on update.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_abs_max_number IS 'The absolute maximum number possible on the used system. Must be set on insert, ignored on update.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_abs_max_number IS 'The absolute maximum number possible on the used system. Must be set on insert, ignored on update.'
neu:COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_abs_max_number IS 'The absolute maximum number possible on the used system. Must be set on insert, ignored on update.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_overflow_node_seed IS 'Set to 1 if all new structures should start with parent in dimension n = 0. Set to 0, if new structures should use standard overflow handling. Must be set on insert, ignored on update.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_overflow_node_seed IS 'Set to 1 if all new structures should start with parent in dimension n = 0. Set to 0, if new structures should use standard overflow handling. Must be set on insert, ignored on update.'
neu:COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_overflow_node_seed IS 'Set to 1 if all new structures should start with parent in dimension n = 0. Set to 0, if new structures should use standard overflow handling. Must be set on insert, ignored on update.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_time_seq_last IS 'The last planck time tick or -1 if not known yet. Package usim_static holds the name of the used sequence.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_time_seq_last IS 'The last planck time tick or -1 if not known yet. Package usim_static holds the name of the used sequence.'
neu:COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_planck_time_seq_last IS 'The last planck time tick or -1 if not known yet. Package usim_static holds the name of the used sequence.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_time_seq_curr IS 'The current planck time tick or -1 if not known yet. Package usim_static holds the name of the used sequence.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_time_seq_curr IS 'The current planck time tick or -1 if not known yet. Package usim_static holds the name of the used sequence.'
neu:COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_planck_time_seq_curr IS 'The current planck time tick or -1 if not known yet. Package usim_static holds the name of the used sequence.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_aeon_seq_last IS 'The last planck aeon big id or N/A if not known yet. Package usim_static holds the name of the used sequence.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_aeon_seq_last IS 'The last planck aeon big id or N/A if not known yet. Package usim_static holds the name of the used sequence.'
neu:COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_planck_aeon_seq_last IS 'The last planck aeon big id or N/A if not known yet. Package usim_static holds the name of the used sequence.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_aeon_seq_curr IS 'The current planck aeon big id or N/A if not known yet. Package usim_static holds the name of the used sequence.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_aeon_seq_curr IS 'The current planck aeon big id or N/A if not known yet. Package usim_static holds the name of the used sequence.'
neu:COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_planck_aeon_seq_curr IS 'The current planck aeon big id or N/A if not known yet. Package usim_static holds the name of the used sequence.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_created IS 'Date of record creation. Automatically set, ignored on update';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_created IS 'Date of record creation. Automatically set, ignored on update'
neu:COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_created IS 'Date of record creation. Automatically set, ignored on update'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_updated IS 'Date of record update. Automatically set, ignored on update';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_updated IS 'Date of record update. Automatically set, ignored on update'
neu:COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_updated IS 'Date of record update. Automatically set, ignored on update'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_created_by IS 'OS user responsible for record creation. Automatically set, ignored on update';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_created_by IS 'OS user responsible for record creation. Automatically set, ignored on update'
neu:COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_created_by IS 'OS user responsible for record creation. Automatically set, ignored on update'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_updated IS 'OS user, schema owner or user (depending on situation of update) responsible for record update.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_updated IS 'OS user, schema owner or user (depending on situation of update) responsible for record update.'
neu:COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_updated IS 'OS user, schema owner or user (depending on situation of update) responsible for record update.'

Comment erstellt.

SQL>
SQL> -- pk (only to ensure not more than one entry)
SQL> ALTER TABLE &USIM_SCHEMA..usim_basedata
  2    ADD CONSTRAINT usim_bda_pk
  3    PRIMARY KEY (usim_id_bda)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_basedata
  ADD CONSTRAINT usim_bda_pk
  PRIMARY KEY (usim_id_bda)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_basedata
  ADD CONSTRAINT usim_bda_pk
  PRIMARY KEY (usim_id_bda)
  ENABLE

Table USIM_TEST.USIM_BASEDATA geändert.

SQL>
SQL> -- check id, means we limit records inserted to one record with id = 1 as we have a primary key unique constraint
SQL> ALTER TABLE &USIM_SCHEMA..usim_basedata
  2    ADD CONSTRAINT usim_id_bda_chk
  3    CHECK (usim_id_bda = 1)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_basedata
  ADD CONSTRAINT usim_id_bda_chk
  CHECK (usim_id_bda = 1)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_basedata
  ADD CONSTRAINT usim_id_bda_chk
  CHECK (usim_id_bda = 1)
  ENABLE

Table USIM_TEST.USIM_BASEDATA geändert.

SQL>
SQL> -- check overflow setting
SQL> ALTER TABLE &USIM_SCHEMA..usim_basedata
  2    ADD CONSTRAINT usim_ovr_bda_chk
  3    CHECK (usim_overflow_node_seed IN (0, 1))
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_basedata
  ADD CONSTRAINT usim_ovr_bda_chk
  CHECK (usim_overflow_node_seed IN (0, 1))
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_basedata
  ADD CONSTRAINT usim_ovr_bda_chk
  CHECK (usim_overflow_node_seed IN (0, 1))
  ENABLE

Table USIM_TEST.USIM_BASEDATA geändert.

SQL>
SQL> -- max dimensions >= 0
SQL> ALTER TABLE &USIM_SCHEMA..usim_basedata
  2    ADD CONSTRAINT usim_dim_bda_chk
  3    CHECK (usim_max_dimension >= 0)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_basedata
  ADD CONSTRAINT usim_dim_bda_chk
  CHECK (usim_max_dimension >= 0)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_basedata
  ADD CONSTRAINT usim_dim_bda_chk
  CHECK (usim_max_dimension >= 0)
  ENABLE

Table USIM_TEST.USIM_BASEDATA geändert.

SQL>
SQL> -- absolute max >= 0
SQL> ALTER TABLE &USIM_SCHEMA..usim_basedata
  2    ADD CONSTRAINT usim_maxn_bda_chk
  3    CHECK (usim_abs_max_number >= 0)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_basedata
  ADD CONSTRAINT usim_maxn_bda_chk
  CHECK (usim_abs_max_number >= 0)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_basedata
  ADD CONSTRAINT usim_maxn_bda_chk
  CHECK (usim_abs_max_number >= 0)
  ENABLE

Table USIM_TEST.USIM_BASEDATA geändert.

SQL>
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_bda_ins_trg
  2    -- check insert values and ensure default values where needed
  3    BEFORE INSERT ON &USIM_SCHEMA..usim_basedata
  4      FOR EACH ROW
  5      BEGIN
  6        IF :NEW.usim_id_bda IS NULL
  7        THEN
  8          -- ensure correct id
  9          :NEW.usim_id_bda := 1;
 10        END IF;
 11        -- we ignore input values which should not be set on insert and initialize them to the default
 12        :NEW.usim_planck_time_seq_last  := -1;
 13        :NEW.usim_planck_time_seq_curr  := -1;
 14        :NEW.usim_planck_aeon_seq_last  := usim_static.usim_not_available;
 15        :NEW.usim_planck_aeon_seq_curr  := usim_static.usim_not_available;
 16        -- set os user for create, ignore given values if any
 17        :NEW.usim_created               := SYSDATE;
 18        :NEW.usim_updated               := SYSDATE;
 19        :NEW.usim_created_by            := SYS_CONTEXT('USERENV', 'OS_USER');
 20        :NEW.usim_updated_by            := SYS_CONTEXT('USERENV', 'OS_USER');
 21      END;
 22  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_bda_ins_trg
  -- check insert values and ensure default values where needed
  BEFORE INSERT ON &USIM_SCHEMA..usim_basedata
    FOR EACH ROW
    BEGIN
      IF :NEW.usim_id_bda IS NULL
      THEN
        -- ensure correct id
        :NEW.usim_id_bda := 1;
      END IF;
      -- we ignore input values which should not be set on insert and initialize them to the default
      :NEW.usim_planck_time_seq_last  := -1;
      :NEW.usim_planck_time_seq_curr  := -1;
      :NEW.usim_planck_aeon_seq_last  := usim_static.usim_not_available;
      :NEW.usim_planck_aeon_seq_curr  := usim_static.usim_not_available;
      -- set os user for create, ignore given values if any
      :NEW.usim_created               := SYSDATE;
      :NEW.usim_updated               := SYSDATE;
      :NEW.usim_created_by            := SYS_CONTEXT('USERENV', 'OS_USER');
      :NEW.usim_updated_by            := SYS_CONTEXT('USERENV', 'OS_USER');
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_bda_ins_trg
  -- check insert values and ensure default values where needed
  BEFORE INSERT ON USIM_TEST.usim_basedata
    FOR EACH ROW
    BEGIN
      IF :NEW.usim_id_bda IS NULL
      THEN
        -- ensure correct id
        :NEW.usim_id_bda := 1;
      END IF;
      -- we ignore input values which should not be set on insert and initialize them to the default
      :NEW.usim_planck_time_seq_last  := -1;
      :NEW.usim_planck_time_seq_curr  := -1;
      :NEW.usim_planck_aeon_seq_last  := usim_static.usim_not_available;
      :NEW.usim_planck_aeon_seq_curr  := usim_static.usim_not_available;
      -- set os user for create, ignore given values if any
      :NEW.usim_created               := SYSDATE;
      :NEW.usim_updated               := SYSDATE;
      :NEW.usim_created_by            := SYS_CONTEXT('USERENV', 'OS_USER');
      :NEW.usim_updated_by            := SYS_CONTEXT('USERENV', 'OS_USER');
    END;

Trigger USIM_BDA_INS_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_bda_ins_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_bda_ins_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_bda_ins_trg ENABLE

Trigger USIM_TEST.USIM_BDA_INS_TRG geändert.

SQL>
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_bda_upd_trg
  2    -- check update values and ensure consistency
  3    BEFORE UPDATE ON &USIM_SCHEMA..usim_basedata
  4      FOR EACH ROW
  5      BEGIN
  6        -- check big sequences
  7        -- only allow updates on current sequences
  8        IF :NEW.usim_planck_time_seq_last IS NOT NULL
  9        THEN
 10          :NEW.usim_planck_time_seq_last := :OLD.usim_planck_time_seq_last;
 11        END IF;
 12        IF :NEW.usim_planck_aeon_seq_last IS NOT NULL
 13        THEN
 14          :NEW.usim_planck_aeon_seq_last := :OLD.usim_planck_aeon_seq_last;
 15        END IF;
 16        -- update current and last sequences if current is given
 17        IF :NEW.usim_planck_time_seq_curr IS NOT NULL
 18        THEN
 19          IF :NEW.usim_planck_time_seq_curr != :OLD.usim_planck_time_seq_curr
 20          THEN
 21            :NEW.usim_planck_time_seq_last := :OLD.usim_planck_time_seq_curr;
 22          END IF;
 23        END IF;
 24        IF :NEW.usim_planck_aeon_seq_curr IS NOT NULL
 25        THEN
 26          IF :NEW.usim_planck_aeon_seq_curr != :OLD.usim_planck_aeon_seq_curr
 27          THEN
 28            :NEW.usim_planck_aeon_seq_last := :OLD.usim_planck_aeon_seq_curr;
 29          END IF;
 30        END IF;
 31        -- no updates on basic design values
 32        IF :NEW.usim_overflow_node_seed IS NOT NULL
 33        THEN
 34          :NEW.usim_overflow_node_seed := :OLD.usim_overflow_node_seed;
 35        END IF;
 36        IF :NEW.usim_max_dimension IS NOT NULL
 37        THEN
 38          :NEW.usim_max_dimension := :OLD.usim_max_dimension;
 39        END IF;
 40        IF :NEW.usim_abs_max_number IS NOT NULL
 41        THEN
 42          :NEW.usim_abs_max_number := :OLD.usim_abs_max_number;
 43        END IF;
 44        -- no update of created only on updated
 45        IF :NEW.usim_created IS NOT NULL
 46        THEN
 47          :NEW.usim_created := :OLD.usim_created;
 48        END IF;
 49        IF :NEW.usim_created_by IS NOT NULL
 50        THEN
 51          :NEW.usim_created_by := :OLD.usim_created_by;
 52        END IF;
 53        :NEW.usim_updated     := SYSDATE;
 54        -- allow user override, if system updates the table, otherwise use OS user
 55        -- limit allowed users to either OS user or current schema owner
 56        IF :NEW.usim_updated_by NOT IN (SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'), SYS_CONTEXT('USERENV', 'OS_USER'))
 57        THEN
 58          :NEW.usim_updated_by  := SYS_CONTEXT('USERENV', 'OS_USER');
 59        END IF;
 60      END;
 61  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_bda_upd_trg
  -- check update values and ensure consistency
  BEFORE UPDATE ON &USIM_SCHEMA..usim_basedata
    FOR EACH ROW
    BEGIN
      -- check big sequences
      -- only allow updates on current sequences
      IF :NEW.usim_planck_time_seq_last IS NOT NULL
      THEN
        :NEW.usim_planck_time_seq_last := :OLD.usim_planck_time_seq_last;
      END IF;
      IF :NEW.usim_planck_aeon_seq_last IS NOT NULL
      THEN
        :NEW.usim_planck_aeon_seq_last := :OLD.usim_planck_aeon_seq_last;
      END IF;
      -- update current and last sequences if current is given
      IF :NEW.usim_planck_time_seq_curr IS NOT NULL
      THEN
        IF :NEW.usim_planck_time_seq_curr != :OLD.usim_planck_time_seq_curr
        THEN
          :NEW.usim_planck_time_seq_last := :OLD.usim_planck_time_seq_curr;
        END IF;
      END IF;
      IF :NEW.usim_planck_aeon_seq_curr IS NOT NULL
      THEN
        IF :NEW.usim_planck_aeon_seq_curr != :OLD.usim_planck_aeon_seq_curr
        THEN
          :NEW.usim_planck_aeon_seq_last := :OLD.usim_planck_aeon_seq_curr;
        END IF;
      END IF;
      -- no updates on basic design values
      IF :NEW.usim_overflow_node_seed IS NOT NULL
      THEN
        :NEW.usim_overflow_node_seed := :OLD.usim_overflow_node_seed;
      END IF;
      IF :NEW.usim_max_dimension IS NOT NULL
      THEN
        :NEW.usim_max_dimension := :OLD.usim_max_dimension;
      END IF;
      IF :NEW.usim_abs_max_number IS NOT NULL
      THEN
        :NEW.usim_abs_max_number := :OLD.usim_abs_max_number;
      END IF;
      -- no update of created only on updated
      IF :NEW.usim_created IS NOT NULL
      THEN
        :NEW.usim_created := :OLD.usim_created;
      END IF;
      IF :NEW.usim_created_by IS NOT NULL
      THEN
        :NEW.usim_created_by := :OLD.usim_created_by;
      END IF;
      :NEW.usim_updated     := SYSDATE;
      -- allow user override, if system updates the table, otherwise use OS user
      -- limit allowed users to either OS user or current schema owner
      IF :NEW.usim_updated_by NOT IN (SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'), SYS_CONTEXT('USERENV', 'OS_USER'))
      THEN
        :NEW.usim_updated_by  := SYS_CONTEXT('USERENV', 'OS_USER');
      END IF;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_bda_upd_trg
  -- check update values and ensure consistency
  BEFORE UPDATE ON USIM_TEST.usim_basedata
    FOR EACH ROW
    BEGIN
      -- check big sequences
      -- only allow updates on current sequences
      IF :NEW.usim_planck_time_seq_last IS NOT NULL
      THEN
        :NEW.usim_planck_time_seq_last := :OLD.usim_planck_time_seq_last;
      END IF;
      IF :NEW.usim_planck_aeon_seq_last IS NOT NULL
      THEN
        :NEW.usim_planck_aeon_seq_last := :OLD.usim_planck_aeon_seq_last;
      END IF;
      -- update current and last sequences if current is given
      IF :NEW.usim_planck_time_seq_curr IS NOT NULL
      THEN
        IF :NEW.usim_planck_time_seq_curr != :OLD.usim_planck_time_seq_curr
        THEN
          :NEW.usim_planck_time_seq_last := :OLD.usim_planck_time_seq_curr;
        END IF;
      END IF;
      IF :NEW.usim_planck_aeon_seq_curr IS NOT NULL
      THEN
        IF :NEW.usim_planck_aeon_seq_curr != :OLD.usim_planck_aeon_seq_curr
        THEN
          :NEW.usim_planck_aeon_seq_last := :OLD.usim_planck_aeon_seq_curr;
        END IF;
      END IF;
      -- no updates on basic design values
      IF :NEW.usim_overflow_node_seed IS NOT NULL
      THEN
        :NEW.usim_overflow_node_seed := :OLD.usim_overflow_node_seed;
      END IF;
      IF :NEW.usim_max_dimension IS NOT NULL
      THEN
        :NEW.usim_max_dimension := :OLD.usim_max_dimension;
      END IF;
      IF :NEW.usim_abs_max_number IS NOT NULL
      THEN
        :NEW.usim_abs_max_number := :OLD.usim_abs_max_number;
      END IF;
      -- no update of created only on updated
      IF :NEW.usim_created IS NOT NULL
      THEN
        :NEW.usim_created := :OLD.usim_created;
      END IF;
      IF :NEW.usim_created_by IS NOT NULL
      THEN
        :NEW.usim_created_by := :OLD.usim_created_by;
      END IF;
      :NEW.usim_updated     := SYSDATE;
      -- allow user override, if system updates the table, otherwise use OS user
      -- limit allowed users to either OS user or current schema owner
      IF :NEW.usim_updated_by NOT IN (SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'), SYS_CONTEXT('USERENV', 'OS_USER'))
      THEN
        :NEW.usim_updated_by  := SYS_CONTEXT('USERENV', 'OS_USER');
      END IF;
    END;

Trigger USIM_BDA_UPD_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_bda_upd_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_bda_upd_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_bda_upd_trg ENABLE

Trigger USIM_TEST.USIM_BDA_UPD_TRG geändert.

SQL> -- base data package
SQL> @@../PACKAGES/USIM_BASE.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_base
  2  IS
  3    /** A package for getting/setting values of USIM_BASEDATA table.
  4    */
  5
  6    /**
  7    * Checks if usim_basedata has already data.
  8    * @return Returns 1 if base data are available, otherwise 0.
  9    */
 10    FUNCTION has_basedata
 11      RETURN NUMBER
 12    ;
 13
 14    /**
 15    * Initializes the base data with the attributes that have to be set on insert if no base data
 16    * exist, otherwise do nothing. As this procedure mimics the constraints, adjusting the constraints needs package adjustment.
 17    * @param p_max_dimension The maximum dimensions possible for this multiverse.
 18    * @param p_usim_abs_max_number The absolute maximum number available for this multiverse.
 19    * @param p_usim_overflow_node_seed Defines the overflow behaviour, default 0 means standard overflow behaviour. If set to 1, all new nodes are created with the universe seed at coordinate 0 as the parent.
 20    */
 21    PROCEDURE init_basedata( p_max_dimension            IN NUMBER DEFAULT 42
 22                           , p_usim_abs_max_number      IN NUMBER DEFAULT 99999999999999999999999999999999999999
 23                           , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
 24                           )
 25    ;
 26
 27    /**
 28    * Retrieves the current maximum dimension.
 29    * @return The current value from column usim_max_dimension or NULL if not initialized.
 30    */
 31    FUNCTION get_max_dimension
 32      RETURN NUMBER
 33    ;
 34
 35    /**
 36    * Retrieves the current absolute maximum number allowed.
 37    * @return The current value from column usim_abs_max_number or NULL if not initialized.
 38    */
 39    FUNCTION get_abs_max_number
 40      RETURN NUMBER
 41    ;
 42
 43    /**
 44    * Retrieves the current minimum number allowed.
 45    * @return The current value from column usim_abs_max_number * -1 or NULL if not initialized.
 46    */
 47    FUNCTION get_min_number
 48      RETURN NUMBER
 49    ;
 50
 51    /**
 52    * Retrieves the current positive number for underflow situation (too close to zero).
 53    * @return The current positive underflow value derived from usim_abs_max_number length, symetric in scientific notation (e.g. 1E+1 / 1E-1) or NULL if not initialized.
 54    */
 55    FUNCTION get_max_underflow
 56      RETURN NUMBER
 57    ;
 58
 59    /**
 60    * Retrieves the current negative number for underflow situation (too close to zero).
 61    * @return The current negative underflow value derived from usim_abs_max_number length, symetric in scientific notation (e.g. 1E+1 / 1E-1) or NULL if not initialized.
 62    */
 63    FUNCTION get_min_underflow
 64      RETURN NUMBER
 65    ;
 66
 67    /**
 68    * Checks if given number if it has an overflow or underflow situation based on the maximum absolute number defined in base.
 69    * Infinity is always an overflow situation. Exceptions have to be checked on a higher level.
 70    * @param p_check_number The number to verify.
 71    * @return Returns 1 if overflow, 0 if not or NULL if base data not initialized.
 72    */
 73    FUNCTION num_has_overflow(p_check_number IN NUMBER)
 74      RETURN NUMBER
 75    ;
 76
 77    /**
 78    * Checks if a given number addition would cause an overflow or underflow situation based on the maximum absolute number defined in base.
 79    * Infinity is always an overflow situation. Exceptions have to be checked on a higher level.
 80    * @param p_check_number The first number of the addition.
 81    * @param p_add_number The second number of the addition.
 82    * @return Returns 1 if overflow, 0 if not or NULL if base data not initialized.
 83    */
 84    FUNCTION num_add_has_overflow( p_check_number IN NUMBER
 85                                 , p_add_number   IN NUMBER
 86                                 )
 87      RETURN NUMBER
 88    ;
 89
 90    /**
 91    * Retrieves the current setting for overflow behavior.
 92    * @return The current value from column usim_overflow_node_seed or NULL if not initialized.
 93    */
 94    FUNCTION get_overflow_node_seed
 95      RETURN NUMBER
 96    ;
 97
 98    /**
 99    * Checks if the defined planck time sequence exists.
100    * @return TRUE if the sequence exists, otherwise FALSE.
101    */
102    FUNCTION planck_time_seq_exists
103      RETURN BOOLEAN
104    ;
105
106    /**
107    * Retrieves the current planck time tick.
108    * @return The current value from column usim_planck_time_seq_curr or NULL if not initialized.
109    */
110    FUNCTION get_planck_time_current
111      RETURN NUMBER
112    ;
113
114    /**
115    * Retrieves the last planck time tick.
116    * @return The current value from column usim_planck_time_seq_last or NULL if not initialized.
117    */
118    FUNCTION get_planck_time_last
119      RETURN NUMBER
120    ;
121
122    /**
123    * Retrieves the next planck time tick. Will update current and last planck time as well as planck
124    * aeon if planck time sequence will cycle. If planck aeon is not set, it will be initialized.
125    * @return The next planck time tick number or NULL if not initialized/sequence does not exist.
126    */
127    FUNCTION get_planck_time_next
128      RETURN NUMBER
129    ;
130
131    /**
132    * CHecks if the defined planck aeon sequence exists.
133    * @return TRUE if the sequence exists, otherwise FALSE.
134    */
135    FUNCTION planck_aeon_seq_exists
136      RETURN BOOLEAN
137    ;
138
139    /**
140    * Retrieves the current planck aeon sequence big id.
141    * @return The current value from column usim_planck_aeon_seq_curr or usim_static.usim_not_available if not initialized.
142    */
143    FUNCTION get_planck_aeon_seq_current
144      RETURN VARCHAR2
145    ;
146
147    /**
148    * Retrieves the last planck aeon sequence big id before current.
149    * @return The current value from column usim_planck_aeon_seq_last or usim_static.usim_not_available if not initialized.
150    */
151    FUNCTION get_planck_aeon_seq_last
152      RETURN VARCHAR2
153    ;
154
155    /**
156    * Retrieves the next planck aeon sequence big id. Will update current and last planck aeon sequence.
157    * @return The next planck aeon sequence as a big id or NULL if not initialized/sequence does not exist.
158    */
159    FUNCTION get_planck_aeon_seq_next
160      RETURN VARCHAR2
161    ;
162
163  END usim_base;
164  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_base
IS
  /** A package for getting/setting values of USIM_BASEDATA table.
  */

  /**
  * Checks if usim_basedata has already data.
  * @return Returns 1 if base data are available, otherwise 0.
  */
  FUNCTION has_basedata
    RETURN NUMBER
  ;

  /**
  * Initializes the base data with the attributes that have to be set on insert if no base data
  * exist, otherwise do nothing. As this procedure mimics the constraints, adjusting the constraints needs package adjustment.
  * @param p_max_dimension The maximum dimensions possible for this multiverse.
  * @param p_usim_abs_max_number The absolute maximum number available for this multiverse.
  * @param p_usim_overflow_node_seed Defines the overflow behaviour, default 0 means standard overflow behaviour. If set to 1, all new nodes are created with the universe seed at coordinate 0 as the parent.
  */
  PROCEDURE init_basedata( p_max_dimension            IN NUMBER DEFAULT 42
                         , p_usim_abs_max_number      IN NUMBER DEFAULT 99999999999999999999999999999999999999
                         , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
                         )
  ;

  /**
  * Retrieves the current maximum dimension.
  * @return The current value from column usim_max_dimension or NULL if not initialized.
  */
  FUNCTION get_max_dimension
    RETURN NUMBER
  ;

  /**
  * Retrieves the current absolute maximum number allowed.
  * @return The current value from column usim_abs_max_number or NULL if not initialized.
  */
  FUNCTION get_abs_max_number
    RETURN NUMBER
  ;

  /**
  * Retrieves the current minimum number allowed.
  * @return The current value from column usim_abs_max_number * -1 or NULL if not initialized.
  */
  FUNCTION get_min_number
    RETURN NUMBER
  ;

  /**
  * Retrieves the current positive number for underflow situation (too close to zero).
  * @return The current positive underflow value derived from usim_abs_max_number length, symetric in scientific notation (e.g. 1E+1 / 1E-1) or NULL if not initialized.
  */
  FUNCTION get_max_underflow
    RETURN NUMBER
  ;

  /**
  * Retrieves the current negative number for underflow situation (too close to zero).
  * @return The current negative underflow value derived from usim_abs_max_number length, symetric in scientific notation (e.g. 1E+1 / 1E-1) or NULL if not initialized.
  */
  FUNCTION get_min_underflow
    RETURN NUMBER
  ;

  /**
  * Checks if given number if it has an overflow or underflow situation based on the maximum absolute number defined in base.
  * Infinity is always an overflow situation. Exceptions have to be checked on a higher level.
  * @param p_check_number The number to verify.
  * @return Returns 1 if overflow, 0 if not or NULL if base data not initialized.
  */
  FUNCTION num_has_overflow(p_check_number IN NUMBER)
    RETURN NUMBER
  ;

  /**
  * Checks if a given number addition would cause an overflow or underflow situation based on the maximum absolute number defined in base.
  * Infinity is always an overflow situation. Exceptions have to be checked on a higher level.
  * @param p_check_number The first number of the addition.
  * @param p_add_number The second number of the addition.
  * @return Returns 1 if overflow, 0 if not or NULL if base data not initialized.
  */
  FUNCTION num_add_has_overflow( p_check_number IN NUMBER
                               , p_add_number   IN NUMBER
                               )
    RETURN NUMBER
  ;

  /**
  * Retrieves the current setting for overflow behavior.
  * @return The current value from column usim_overflow_node_seed or NULL if not initialized.
  */
  FUNCTION get_overflow_node_seed
    RETURN NUMBER
  ;

  /**
  * Checks if the defined planck time sequence exists.
  * @return TRUE if the sequence exists, otherwise FALSE.
  */
  FUNCTION planck_time_seq_exists
    RETURN BOOLEAN
  ;

  /**
  * Retrieves the current planck time tick.
  * @return The current value from column usim_planck_time_seq_curr or NULL if not initialized.
  */
  FUNCTION get_planck_time_current
    RETURN NUMBER
  ;

  /**
  * Retrieves the last planck time tick.
  * @return The current value from column usim_planck_time_seq_last or NULL if not initialized.
  */
  FUNCTION get_planck_time_last
    RETURN NUMBER
  ;

  /**
  * Retrieves the next planck time tick. Will update current and last planck time as well as planck
  * aeon if planck time sequence will cycle. If planck aeon is not set, it will be initialized.
  * @return The next planck time tick number or NULL if not initialized/sequence does not exist.
  */
  FUNCTION get_planck_time_next
    RETURN NUMBER
  ;

  /**
  * CHecks if the defined planck aeon sequence exists.
  * @return TRUE if the sequence exists, otherwise FALSE.
  */
  FUNCTION planck_aeon_seq_exists
    RETURN BOOLEAN
  ;

  /**
  * Retrieves the current planck aeon sequence big id.
  * @return The current value from column usim_planck_aeon_seq_curr or usim_static.usim_not_available if not initialized.
  */
  FUNCTION get_planck_aeon_seq_current
    RETURN VARCHAR2
  ;

  /**
  * Retrieves the last planck aeon sequence big id before current.
  * @return The current value from column usim_planck_aeon_seq_last or usim_static.usim_not_available if not initialized.
  */
  FUNCTION get_planck_aeon_seq_last
    RETURN VARCHAR2
  ;

  /**
  * Retrieves the next planck aeon sequence big id. Will update current and last planck aeon sequence.
  * @return The next planck aeon sequence as a big id or NULL if not initialized/sequence does not exist.
  */
  FUNCTION get_planck_aeon_seq_next
    RETURN VARCHAR2
  ;

END usim_base;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_base
IS
  /** A package for getting/setting values of USIM_BASEDATA table.
  */

  /**
  * Checks if usim_basedata has already data.
  * @return Returns 1 if base data are available, otherwise 0.
  */
  FUNCTION has_basedata
    RETURN NUMBER
  ;

  /**
  * Initializes the base data with the attributes that have to be set on insert if no base data
  * exist, otherwise do nothing. As this procedure mimics the constraints, adjusting the constraints needs package adjustment.
  * @param p_max_dimension The maximum dimensions possible for this multiverse.
  * @param p_usim_abs_max_number The absolute maximum number available for this multiverse.
  * @param p_usim_overflow_node_seed Defines the overflow behaviour, default 0 means standard overflow behaviour. If set to 1, all new nodes are created with the universe seed at coordinate 0 as the parent.
  */
  PROCEDURE init_basedata( p_max_dimension            IN NUMBER DEFAULT 42
                         , p_usim_abs_max_number      IN NUMBER DEFAULT 99999999999999999999999999999999999999
                         , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
                         )
  ;

  /**
  * Retrieves the current maximum dimension.
  * @return The current value from column usim_max_dimension or NULL if not initialized.
  */
  FUNCTION get_max_dimension
    RETURN NUMBER
  ;

  /**
  * Retrieves the current absolute maximum number allowed.
  * @return The current value from column usim_abs_max_number or NULL if not initialized.
  */
  FUNCTION get_abs_max_number
    RETURN NUMBER
  ;

  /**
  * Retrieves the current minimum number allowed.
  * @return The current value from column usim_abs_max_number * -1 or NULL if not initialized.
  */
  FUNCTION get_min_number
    RETURN NUMBER
  ;

  /**
  * Retrieves the current positive number for underflow situation (too close to zero).
  * @return The current positive underflow value derived from usim_abs_max_number length, symetric in scientific notation (e.g. 1E+1 / 1E-1) or NULL if not initialized.
  */
  FUNCTION get_max_underflow
    RETURN NUMBER
  ;

  /**
  * Retrieves the current negative number for underflow situation (too close to zero).
  * @return The current negative underflow value derived from usim_abs_max_number length, symetric in scientific notation (e.g. 1E+1 / 1E-1) or NULL if not initialized.
  */
  FUNCTION get_min_underflow
    RETURN NUMBER
  ;

  /**
  * Checks if given number if it has an overflow or underflow situation based on the maximum absolute number defined in base.
  * Infinity is always an overflow situation. Exceptions have to be checked on a higher level.
  * @param p_check_number The number to verify.
  * @return Returns 1 if overflow, 0 if not or NULL if base data not initialized.
  */
  FUNCTION num_has_overflow(p_check_number IN NUMBER)
    RETURN NUMBER
  ;

  /**
  * Checks if a given number addition would cause an overflow or underflow situation based on the maximum absolute number defined in base.
  * Infinity is always an overflow situation. Exceptions have to be checked on a higher level.
  * @param p_check_number The first number of the addition.
  * @param p_add_number The second number of the addition.
  * @return Returns 1 if overflow, 0 if not or NULL if base data not initialized.
  */
  FUNCTION num_add_has_overflow( p_check_number IN NUMBER
                               , p_add_number   IN NUMBER
                               )
    RETURN NUMBER
  ;

  /**
  * Retrieves the current setting for overflow behavior.
  * @return The current value from column usim_overflow_node_seed or NULL if not initialized.
  */
  FUNCTION get_overflow_node_seed
    RETURN NUMBER
  ;

  /**
  * Checks if the defined planck time sequence exists.
  * @return TRUE if the sequence exists, otherwise FALSE.
  */
  FUNCTION planck_time_seq_exists
    RETURN BOOLEAN
  ;

  /**
  * Retrieves the current planck time tick.
  * @return The current value from column usim_planck_time_seq_curr or NULL if not initialized.
  */
  FUNCTION get_planck_time_current
    RETURN NUMBER
  ;

  /**
  * Retrieves the last planck time tick.
  * @return The current value from column usim_planck_time_seq_last or NULL if not initialized.
  */
  FUNCTION get_planck_time_last
    RETURN NUMBER
  ;

  /**
  * Retrieves the next planck time tick. Will update current and last planck time as well as planck
  * aeon if planck time sequence will cycle. If planck aeon is not set, it will be initialized.
  * @return The next planck time tick number or NULL if not initialized/sequence does not exist.
  */
  FUNCTION get_planck_time_next
    RETURN NUMBER
  ;

  /**
  * CHecks if the defined planck aeon sequence exists.
  * @return TRUE if the sequence exists, otherwise FALSE.
  */
  FUNCTION planck_aeon_seq_exists
    RETURN BOOLEAN
  ;

  /**
  * Retrieves the current planck aeon sequence big id.
  * @return The current value from column usim_planck_aeon_seq_curr or usim_static.usim_not_available if not initialized.
  */
  FUNCTION get_planck_aeon_seq_current
    RETURN VARCHAR2
  ;

  /**
  * Retrieves the last planck aeon sequence big id before current.
  * @return The current value from column usim_planck_aeon_seq_last or usim_static.usim_not_available if not initialized.
  */
  FUNCTION get_planck_aeon_seq_last
    RETURN VARCHAR2
  ;

  /**
  * Retrieves the next planck aeon sequence big id. Will update current and last planck aeon sequence.
  * @return The next planck aeon sequence as a big id or NULL if not initialized/sequence does not exist.
  */
  FUNCTION get_planck_aeon_seq_next
    RETURN VARCHAR2
  ;

END usim_base;

Package USIM_BASE kompiliert

SQL> @@../PACKAGES/USIM_BASE.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_base
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_basedata
  5      RETURN NUMBER
  6    IS
  7      l_result  NUMBER;
  8    BEGIN
  9      SELECT COUNT(*) INTO l_result FROM usim_basedata;
 10      RETURN l_result;
 11    END has_basedata
 12    ;
 13
 14    PROCEDURE init_basedata( p_max_dimension            IN NUMBER DEFAULT 42
 15                           , p_usim_abs_max_number      IN NUMBER DEFAULT 99999999999999999999999999999999999999
 16                           , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
 17                           )
 18    IS
 19      l_max_dimension           NUMBER := 42;
 20      l_usim_abs_max_number     NUMBER := 99999999999999999999999999999999999999;
 21      l_usim_overflow_node_seed NUMBER := 0;
 22    BEGIN
 23      IF usim_base.has_basedata = 0
 24      THEN
 25        IF      p_max_dimension IS NOT NULL
 26           AND  p_max_dimension >= 0
 27        THEN
 28          l_max_dimension := p_max_dimension;
 29        END IF;
 30        IF      p_usim_abs_max_number IS NOT NULL
 31           AND  p_usim_abs_max_number >= 0
 32        THEN
 33          l_usim_abs_max_number := p_usim_abs_max_number;
 34        END IF;
 35        IF p_usim_overflow_node_seed IN (0, 1)
 36        THEN
 37          l_usim_overflow_node_seed := p_usim_overflow_node_seed;
 38        END IF;
 39        INSERT INTO usim_basedata
 40          ( usim_max_dimension
 41          , usim_abs_max_number
 42          , usim_overflow_node_seed
 43          )
 44          VALUES
 45          ( l_max_dimension
 46          , l_usim_abs_max_number
 47          , l_usim_overflow_node_seed
 48          )
 49        ;
 50        COMMIT;
 51      END IF;
 52    END init_basedata
 53    ;
 54
 55    FUNCTION get_max_dimension
 56      RETURN NUMBER
 57    IS
 58      l_result  NUMBER;
 59    BEGIN
 60      IF usim_base.has_basedata = 1
 61      THEN
 62        SELECT usim_max_dimension INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
 63      ELSE
 64        usim_erl.log_error('usim_base.get_max_dimension', 'Used without initializing base data');
 65      END IF;
 66      RETURN l_result;
 67    END get_max_dimension
 68    ;
 69
 70    FUNCTION get_abs_max_number
 71      RETURN NUMBER
 72    IS
 73      l_result  NUMBER;
 74    BEGIN
 75      IF usim_base.has_basedata = 1
 76      THEN
 77        SELECT usim_abs_max_number INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
 78      ELSE
 79        usim_erl.log_error('usim_base.get_abs_max_number', 'Used without initializing base data');
 80      END IF;
 81      RETURN l_result;
 82    END get_abs_max_number
 83    ;
 84
 85    FUNCTION get_min_number
 86      RETURN NUMBER
 87    IS
 88    BEGIN
 89      RETURN usim_base.get_abs_max_number * -1;
 90    END get_min_number
 91    ;
 92
 93    FUNCTION get_max_underflow
 94      RETURN NUMBER
 95    IS
 96      l_result    NUMBER;
 97      l_decimals  INTEGER;
 98    BEGIN
 99      IF usim_base.has_basedata = 1
100      THEN
101        -- build number by number of digits
102        l_decimals := LENGTH(TRIM(TO_CHAR(usim_base.get_abs_max_number)));
103        l_result := TO_NUMBER(RPAD('0.', 1 + l_decimals, '0') || '1');
104        RETURN l_result;
105      ELSE
106        usim_erl.log_error('usim_base.get_max_underflow', 'Used without initializing base data');
107        RETURN NULL;
108      END IF;
109    END get_max_underflow
110    ;
111
112    FUNCTION get_min_underflow
113      RETURN NUMBER
114    IS
115      l_result NUMBER;
116    BEGIN
117      RETURN usim_base.get_max_underflow * -1;
118    END get_min_underflow
119    ;
120
121    FUNCTION num_has_overflow(p_check_number IN NUMBER)
122      RETURN NUMBER
123    IS
124    BEGIN
125      IF usim_base.has_basedata = 0
126      THEN
127        usim_erl.log_error('usim_base.num_has_overflow', 'Used without initializing base data');
128        RETURN NULL;
129      END IF;
130      IF p_check_number IS INFINITE
131      THEN
132        RETURN 0;
133      END IF;
134      IF ABS(p_check_number) >= 1
135      THEN
136        -- overflow
137        IF ABS(p_check_number) > usim_base.get_abs_max_number
138        THEN
139          RETURN 1;
140        ELSE
141          RETURN 0;
142        END IF;
143      ELSE
144        -- underflow
145        IF p_check_number > 0
146        THEN
147          IF p_check_number < usim_base.get_max_underflow
148          THEN
149            RETURN 1;
150          ELSE
151            RETURN 0;
152          END IF;
153        ELSIF p_check_number < 0
154        THEN
155          IF p_check_number > usim_base.get_min_underflow
156          THEN
157            RETURN 1;
158          ELSE
159            RETURN 0;
160          END IF;
161        ELSE
162          RETURN 0;
163        END IF;
164      END IF;
165    END num_has_overflow
166    ;
167
168    FUNCTION num_add_has_overflow( p_check_number IN NUMBER
169                                 , p_add_number   IN NUMBER
170                                 )
171      RETURN NUMBER
172    IS
173      l_result NUMBER;
174    BEGIN
175      l_result := p_check_number + p_add_number;
176      RETURN num_has_overflow(l_result);
177    END num_add_has_overflow
178    ;
179
180    FUNCTION get_overflow_node_seed
181      RETURN NUMBER
182    IS
183      l_result  NUMBER;
184    BEGIN
185      IF usim_base.has_basedata = 1
186      THEN
187        SELECT usim_overflow_node_seed INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
188      ELSE
189        usim_erl.log_error('usim_base.get_overflow_node_seed', 'Used without initializing base data');
190      END IF;
191      RETURN l_result;
192    END get_overflow_node_seed
193    ;
194
195    FUNCTION planck_time_seq_exists
196      RETURN BOOLEAN
197    IS
198      l_result  NUMBER;
199    BEGIN
200      SELECT COUNT(*)
201        INTO l_result
202        FROM user_sequences
203       WHERE sequence_name = usim_static.get_planck_time_seq_name
204      ;
205      RETURN (l_result = 1);
206    END planck_time_seq_exists
207    ;
208
209    FUNCTION get_planck_time_current
210      RETURN NUMBER
211    IS
212      l_result  NUMBER;
213    BEGIN
214      IF usim_base.has_basedata = 1
215      THEN
216        SELECT usim_planck_time_seq_curr INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
217      ELSE
218        usim_erl.log_error('usim_base.get_planck_time_current', 'Used without initializing base data');
219      END IF;
220      RETURN l_result;
221    END get_planck_time_current
222    ;
223
224    FUNCTION get_planck_time_last
225      RETURN NUMBER
226    IS
227      l_result NUMBER;
228    BEGIN
229      IF usim_base.has_basedata = 1
230      THEN
231        SELECT usim_planck_time_seq_last INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
232      ELSE
233        usim_erl.log_error('usim_base.get_planck_time_last', 'Used without initializing base data');
234      END IF;
235      RETURN l_result;
236    END get_planck_time_last
237    ;
238
239    FUNCTION get_planck_time_next
240      RETURN NUMBER
241    IS
242      PRAGMA AUTONOMOUS_TRANSACTION;
243      l_result      VARCHAR2(55);
244      l_statement     VARCHAR2(1000);
245      l_seq_number    NUMBER;
246      l_max_value     NUMBER;
247      l_current_tick  NUMBER;
248      l_current_aeon  CHAR(55);
249      l_update_aeon   BOOLEAN;
250    BEGIN
251      IF     usim_base.planck_time_seq_exists
252         AND usim_base.has_basedata = 1
253      THEN
254        -- if aeon and time initialized
255        l_current_aeon := usim_base.get_planck_aeon_seq_current;
256        IF l_current_aeon = usim_static.usim_not_available
257        THEN
258          -- initialize aeon by update
259          l_update_aeon := TRUE;
260        END IF;
261        l_current_tick := usim_base.get_planck_time_current;
262        IF l_current_tick IS NOT NULL
263        THEN
264          -- check tick overflow
265          SELECT max_value
266            INTO l_max_value
267            FROM user_sequences
268           WHERE sequence_name = usim_static.get_planck_time_seq_name
269          ;
270          IF l_current_tick = l_max_value
271          THEN
272            l_update_aeon := TRUE;
273          END IF;
274        ELSE
275          l_update_aeon := FALSE;
276        END IF;
277        -- get sequence
278        l_statement := 'SELECT ' || usim_static.get_planck_time_seq_name || '.NEXTVAL FROM dual';
279        EXECUTE IMMEDIATE l_statement INTO l_seq_number;
280        -- update base data
281        UPDATE usim_basedata
282           SET usim_planck_time_seq_curr  = l_seq_number
283             , usim_updated_by            = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')
284         WHERE usim_id_bda = 1
285        ;
286        COMMIT;
287        IF l_update_aeon
288        THEN
289          l_current_aeon := usim_base.get_planck_aeon_seq_next;
290        END IF;
291        -- return new current value
292        RETURN usim_base.get_planck_time_current;
293      ELSE
294        usim_erl.log_error('usim_base.get_planck_time_next', 'Used without initializing base data or planck time sequence does not exist.');
295        RETURN NULL;
296      END IF;
297    END get_planck_time_next
298    ;
299
300    FUNCTION planck_aeon_seq_exists
301      RETURN BOOLEAN
302    IS
303      l_result  NUMBER;
304    BEGIN
305      SELECT COUNT(*)
306        INTO l_result
307        FROM user_sequences
308       WHERE sequence_name = usim_static.get_planck_aeon_seq_name
309      ;
310      RETURN (l_result = 1);
311    END planck_aeon_seq_exists
312    ;
313
314    FUNCTION get_planck_aeon_seq_current
315      RETURN VARCHAR2
316    IS
317      l_result  VARCHAR2(55);
318    BEGIN
319      IF usim_base.has_basedata = 1
320      THEN
321        SELECT TRIM(usim_planck_aeon_seq_curr) INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
322      ELSE
323        usim_erl.log_error('usim_base.get_planck_aeon_seq_current', 'Used without initializing base data.');
324      END IF;
325      RETURN l_result;
326    END get_planck_aeon_seq_current
327    ;
328
329    FUNCTION get_planck_aeon_seq_last
330      RETURN VARCHAR2
331    IS
332      l_result  VARCHAR2(55);
333    BEGIN
334      IF usim_base.has_basedata = 1
335      THEN
336        SELECT TRIM(usim_planck_aeon_seq_last) INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
337      ELSE
338        usim_erl.log_error('usim_base.get_planck_aeon_seq_last', 'Used without initializing base data.');
339      END IF;
340      RETURN l_result;
341    END get_planck_aeon_seq_last
342    ;
343
344    FUNCTION get_planck_aeon_seq_next
345      RETURN VARCHAR2
346    IS
347      PRAGMA AUTONOMOUS_TRANSACTION;
348      l_result      VARCHAR2(55);
349      l_statement   VARCHAR2(1000);
350      l_seq_number  NUMBER;
351    BEGIN
352      IF     usim_base.planck_aeon_seq_exists
353         AND usim_base.has_basedata = 1
354      THEN
355        -- get sequence
356        l_statement := 'SELECT ' || usim_static.get_planck_aeon_seq_name || '.NEXTVAL FROM dual';
357        EXECUTE IMMEDIATE l_statement INTO l_seq_number;
358        -- build big planck time id
359        l_result := usim_static.get_big_pk(l_seq_number);
360        -- update base data
361        UPDATE usim_basedata
362           SET usim_planck_aeon_seq_curr = l_result
363             , usim_updated_by           = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')
364         WHERE usim_id_bda = 1
365        ;
366        COMMIT;
367        -- return new current value
368        RETURN usim_base.get_planck_aeon_seq_current;
369      ELSE
370        usim_erl.log_error('usim_base.get_planck_aeon_seq_next', 'Used without initializing base data or planck aeon sequence does not exist.');
371        RETURN NULL;
372      END IF;
373    END get_planck_aeon_seq_next
374    ;
375
376  END usim_base;
377  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_base
IS
  -- see header for documentation
  FUNCTION has_basedata
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_basedata;
    RETURN l_result;
  END has_basedata
  ;

  PROCEDURE init_basedata( p_max_dimension            IN NUMBER DEFAULT 42
                         , p_usim_abs_max_number      IN NUMBER DEFAULT 99999999999999999999999999999999999999
                         , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
                         )
  IS
    l_max_dimension           NUMBER := 42;
    l_usim_abs_max_number     NUMBER := 99999999999999999999999999999999999999;
    l_usim_overflow_node_seed NUMBER := 0;
  BEGIN
    IF usim_base.has_basedata = 0
    THEN
      IF      p_max_dimension IS NOT NULL
         AND  p_max_dimension >= 0
      THEN
        l_max_dimension := p_max_dimension;
      END IF;
      IF      p_usim_abs_max_number IS NOT NULL
         AND  p_usim_abs_max_number >= 0
      THEN
        l_usim_abs_max_number := p_usim_abs_max_number;
      END IF;
      IF p_usim_overflow_node_seed IN (0, 1)
      THEN
        l_usim_overflow_node_seed := p_usim_overflow_node_seed;
      END IF;
      INSERT INTO usim_basedata
        ( usim_max_dimension
        , usim_abs_max_number
        , usim_overflow_node_seed
        )
        VALUES
        ( l_max_dimension
        , l_usim_abs_max_number
        , l_usim_overflow_node_seed
        )
      ;
      COMMIT;
    END IF;
  END init_basedata
  ;

  FUNCTION get_max_dimension
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT usim_max_dimension INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_max_dimension', 'Used without initializing base data');
    END IF;
    RETURN l_result;
  END get_max_dimension
  ;

  FUNCTION get_abs_max_number
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT usim_abs_max_number INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_abs_max_number', 'Used without initializing base data');
    END IF;
    RETURN l_result;
  END get_abs_max_number
  ;

  FUNCTION get_min_number
    RETURN NUMBER
  IS
  BEGIN
    RETURN usim_base.get_abs_max_number * -1;
  END get_min_number
  ;

  FUNCTION get_max_underflow
    RETURN NUMBER
  IS
    l_result    NUMBER;
    l_decimals  INTEGER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      -- build number by number of digits
      l_decimals := LENGTH(TRIM(TO_CHAR(usim_base.get_abs_max_number)));
      l_result := TO_NUMBER(RPAD('0.', 1 + l_decimals, '0') || '1');
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_base.get_max_underflow', 'Used without initializing base data');
      RETURN NULL;
    END IF;
  END get_max_underflow
  ;

  FUNCTION get_min_underflow
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    RETURN usim_base.get_max_underflow * -1;
  END get_min_underflow
  ;

  FUNCTION num_has_overflow(p_check_number IN NUMBER)
    RETURN NUMBER
  IS
  BEGIN
    IF usim_base.has_basedata = 0
    THEN
      usim_erl.log_error('usim_base.num_has_overflow', 'Used without initializing base data');
      RETURN NULL;
    END IF;
    IF p_check_number IS INFINITE
    THEN
      RETURN 0;
    END IF;
    IF ABS(p_check_number) >= 1
    THEN
      -- overflow
      IF ABS(p_check_number) > usim_base.get_abs_max_number
      THEN
        RETURN 1;
      ELSE
        RETURN 0;
      END IF;
    ELSE
      -- underflow
      IF p_check_number > 0
      THEN
        IF p_check_number < usim_base.get_max_underflow
        THEN
          RETURN 1;
        ELSE
          RETURN 0;
        END IF;
      ELSIF p_check_number < 0
      THEN
        IF p_check_number > usim_base.get_min_underflow
        THEN
          RETURN 1;
        ELSE
          RETURN 0;
        END IF;
      ELSE
        RETURN 0;
      END IF;
    END IF;
  END num_has_overflow
  ;

  FUNCTION num_add_has_overflow( p_check_number IN NUMBER
                               , p_add_number   IN NUMBER
                               )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := p_check_number + p_add_number;
    RETURN num_has_overflow(l_result);
  END num_add_has_overflow
  ;

  FUNCTION get_overflow_node_seed
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT usim_overflow_node_seed INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_overflow_node_seed', 'Used without initializing base data');
    END IF;
    RETURN l_result;
  END get_overflow_node_seed
  ;

  FUNCTION planck_time_seq_exists
    RETURN BOOLEAN
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM user_sequences
     WHERE sequence_name = usim_static.get_planck_time_seq_name
    ;
    RETURN (l_result = 1);
  END planck_time_seq_exists
  ;

  FUNCTION get_planck_time_current
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT usim_planck_time_seq_curr INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_planck_time_current', 'Used without initializing base data');
    END IF;
    RETURN l_result;
  END get_planck_time_current
  ;

  FUNCTION get_planck_time_last
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT usim_planck_time_seq_last INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_planck_time_last', 'Used without initializing base data');
    END IF;
    RETURN l_result;
  END get_planck_time_last
  ;

  FUNCTION get_planck_time_next
    RETURN NUMBER
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    l_result      VARCHAR2(55);
    l_statement     VARCHAR2(1000);
    l_seq_number    NUMBER;
    l_max_value     NUMBER;
    l_current_tick  NUMBER;
    l_current_aeon  CHAR(55);
    l_update_aeon   BOOLEAN;
  BEGIN
    IF     usim_base.planck_time_seq_exists
       AND usim_base.has_basedata = 1
    THEN
      -- if aeon and time initialized
      l_current_aeon := usim_base.get_planck_aeon_seq_current;
      IF l_current_aeon = usim_static.usim_not_available
      THEN
        -- initialize aeon by update
        l_update_aeon := TRUE;
      END IF;
      l_current_tick := usim_base.get_planck_time_current;
      IF l_current_tick IS NOT NULL
      THEN
        -- check tick overflow
        SELECT max_value
          INTO l_max_value
          FROM user_sequences
         WHERE sequence_name = usim_static.get_planck_time_seq_name
        ;
        IF l_current_tick = l_max_value
        THEN
          l_update_aeon := TRUE;
        END IF;
      ELSE
        l_update_aeon := FALSE;
      END IF;
      -- get sequence
      l_statement := 'SELECT ' || usim_static.get_planck_time_seq_name || '.NEXTVAL FROM dual';
      EXECUTE IMMEDIATE l_statement INTO l_seq_number;
      -- update base data
      UPDATE usim_basedata
         SET usim_planck_time_seq_curr  = l_seq_number
           , usim_updated_by            = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')
       WHERE usim_id_bda = 1
      ;
      COMMIT;
      IF l_update_aeon
      THEN
        l_current_aeon := usim_base.get_planck_aeon_seq_next;
      END IF;
      -- return new current value
      RETURN usim_base.get_planck_time_current;
    ELSE
      usim_erl.log_error('usim_base.get_planck_time_next', 'Used without initializing base data or planck time sequence does not exist.');
      RETURN NULL;
    END IF;
  END get_planck_time_next
  ;

  FUNCTION planck_aeon_seq_exists
    RETURN BOOLEAN
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM user_sequences
     WHERE sequence_name = usim_static.get_planck_aeon_seq_name
    ;
    RETURN (l_result = 1);
  END planck_aeon_seq_exists
  ;

  FUNCTION get_planck_aeon_seq_current
    RETURN VARCHAR2
  IS
    l_result  VARCHAR2(55);
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT TRIM(usim_planck_aeon_seq_curr) INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_planck_aeon_seq_current', 'Used without initializing base data.');
    END IF;
    RETURN l_result;
  END get_planck_aeon_seq_current
  ;

  FUNCTION get_planck_aeon_seq_last
    RETURN VARCHAR2
  IS
    l_result  VARCHAR2(55);
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT TRIM(usim_planck_aeon_seq_last) INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_planck_aeon_seq_last', 'Used without initializing base data.');
    END IF;
    RETURN l_result;
  END get_planck_aeon_seq_last
  ;

  FUNCTION get_planck_aeon_seq_next
    RETURN VARCHAR2
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    l_result      VARCHAR2(55);
    l_statement   VARCHAR2(1000);
    l_seq_number  NUMBER;
  BEGIN
    IF     usim_base.planck_aeon_seq_exists
       AND usim_base.has_basedata = 1
    THEN
      -- get sequence
      l_statement := 'SELECT ' || usim_static.get_planck_aeon_seq_name || '.NEXTVAL FROM dual';
      EXECUTE IMMEDIATE l_statement INTO l_seq_number;
      -- build big planck time id
      l_result := usim_static.get_big_pk(l_seq_number);
      -- update base data
      UPDATE usim_basedata
         SET usim_planck_aeon_seq_curr = l_result
           , usim_updated_by           = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')
       WHERE usim_id_bda = 1
      ;
      COMMIT;
      -- return new current value
      RETURN usim_base.get_planck_aeon_seq_current;
    ELSE
      usim_erl.log_error('usim_base.get_planck_aeon_seq_next', 'Used without initializing base data or planck aeon sequence does not exist.');
      RETURN NULL;
    END IF;
  END get_planck_aeon_seq_next
  ;

END usim_base;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_base
IS
  -- see header for documentation
  FUNCTION has_basedata
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_basedata;
    RETURN l_result;
  END has_basedata
  ;

  PROCEDURE init_basedata( p_max_dimension            IN NUMBER DEFAULT 42
                         , p_usim_abs_max_number      IN NUMBER DEFAULT 99999999999999999999999999999999999999
                         , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
                         )
  IS
    l_max_dimension           NUMBER := 42;
    l_usim_abs_max_number     NUMBER := 99999999999999999999999999999999999999;
    l_usim_overflow_node_seed NUMBER := 0;
  BEGIN
    IF usim_base.has_basedata = 0
    THEN
      IF      p_max_dimension IS NOT NULL
         AND  p_max_dimension >= 0
      THEN
        l_max_dimension := p_max_dimension;
      END IF;
      IF      p_usim_abs_max_number IS NOT NULL
         AND  p_usim_abs_max_number >= 0
      THEN
        l_usim_abs_max_number := p_usim_abs_max_number;
      END IF;
      IF p_usim_overflow_node_seed IN (0, 1)
      THEN
        l_usim_overflow_node_seed := p_usim_overflow_node_seed;
      END IF;
      INSERT INTO usim_basedata
        ( usim_max_dimension
        , usim_abs_max_number
        , usim_overflow_node_seed
        )
        VALUES
        ( l_max_dimension
        , l_usim_abs_max_number
        , l_usim_overflow_node_seed
        )
      ;
      COMMIT;
    END IF;
  END init_basedata
  ;

  FUNCTION get_max_dimension
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT usim_max_dimension INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_max_dimension', 'Used without initializing base data');
    END IF;
    RETURN l_result;
  END get_max_dimension
  ;

  FUNCTION get_abs_max_number
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT usim_abs_max_number INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_abs_max_number', 'Used without initializing base data');
    END IF;
    RETURN l_result;
  END get_abs_max_number
  ;

  FUNCTION get_min_number
    RETURN NUMBER
  IS
  BEGIN
    RETURN usim_base.get_abs_max_number * -1;
  END get_min_number
  ;

  FUNCTION get_max_underflow
    RETURN NUMBER
  IS
    l_result    NUMBER;
    l_decimals  INTEGER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      -- build number by number of digits
      l_decimals := LENGTH(TRIM(TO_CHAR(usim_base.get_abs_max_number)));
      l_result := TO_NUMBER(RPAD('0.', 1 + l_decimals, '0') || '1');
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_base.get_max_underflow', 'Used without initializing base data');
      RETURN NULL;
    END IF;
  END get_max_underflow
  ;

  FUNCTION get_min_underflow
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    RETURN usim_base.get_max_underflow * -1;
  END get_min_underflow
  ;

  FUNCTION num_has_overflow(p_check_number IN NUMBER)
    RETURN NUMBER
  IS
  BEGIN
    IF usim_base.has_basedata = 0
    THEN
      usim_erl.log_error('usim_base.num_has_overflow', 'Used without initializing base data');
      RETURN NULL;
    END IF;
    IF p_check_number IS INFINITE
    THEN
      RETURN 0;
    END IF;
    IF ABS(p_check_number) >= 1
    THEN
      -- overflow
      IF ABS(p_check_number) > usim_base.get_abs_max_number
      THEN
        RETURN 1;
      ELSE
        RETURN 0;
      END IF;
    ELSE
      -- underflow
      IF p_check_number > 0
      THEN
        IF p_check_number < usim_base.get_max_underflow
        THEN
          RETURN 1;
        ELSE
          RETURN 0;
        END IF;
      ELSIF p_check_number < 0
      THEN
        IF p_check_number > usim_base.get_min_underflow
        THEN
          RETURN 1;
        ELSE
          RETURN 0;
        END IF;
      ELSE
        RETURN 0;
      END IF;
    END IF;
  END num_has_overflow
  ;

  FUNCTION num_add_has_overflow( p_check_number IN NUMBER
                               , p_add_number   IN NUMBER
                               )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := p_check_number + p_add_number;
    RETURN num_has_overflow(l_result);
  END num_add_has_overflow
  ;

  FUNCTION get_overflow_node_seed
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT usim_overflow_node_seed INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_overflow_node_seed', 'Used without initializing base data');
    END IF;
    RETURN l_result;
  END get_overflow_node_seed
  ;

  FUNCTION planck_time_seq_exists
    RETURN BOOLEAN
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM user_sequences
     WHERE sequence_name = usim_static.get_planck_time_seq_name
    ;
    RETURN (l_result = 1);
  END planck_time_seq_exists
  ;

  FUNCTION get_planck_time_current
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT usim_planck_time_seq_curr INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_planck_time_current', 'Used without initializing base data');
    END IF;
    RETURN l_result;
  END get_planck_time_current
  ;

  FUNCTION get_planck_time_last
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT usim_planck_time_seq_last INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_planck_time_last', 'Used without initializing base data');
    END IF;
    RETURN l_result;
  END get_planck_time_last
  ;

  FUNCTION get_planck_time_next
    RETURN NUMBER
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    l_result      VARCHAR2(55);
    l_statement     VARCHAR2(1000);
    l_seq_number    NUMBER;
    l_max_value     NUMBER;
    l_current_tick  NUMBER;
    l_current_aeon  CHAR(55);
    l_update_aeon   BOOLEAN;
  BEGIN
    IF     usim_base.planck_time_seq_exists
       AND usim_base.has_basedata = 1
    THEN
      -- if aeon and time initialized
      l_current_aeon := usim_base.get_planck_aeon_seq_current;
      IF l_current_aeon = usim_static.usim_not_available
      THEN
        -- initialize aeon by update
        l_update_aeon := TRUE;
      END IF;
      l_current_tick := usim_base.get_planck_time_current;
      IF l_current_tick IS NOT NULL
      THEN
        -- check tick overflow
        SELECT max_value
          INTO l_max_value
          FROM user_sequences
         WHERE sequence_name = usim_static.get_planck_time_seq_name
        ;
        IF l_current_tick = l_max_value
        THEN
          l_update_aeon := TRUE;
        END IF;
      ELSE
        l_update_aeon := FALSE;
      END IF;
      -- get sequence
      l_statement := 'SELECT ' || usim_static.get_planck_time_seq_name || '.NEXTVAL FROM dual';
      EXECUTE IMMEDIATE l_statement INTO l_seq_number;
      -- update base data
      UPDATE usim_basedata
         SET usim_planck_time_seq_curr  = l_seq_number
           , usim_updated_by            = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')
       WHERE usim_id_bda = 1
      ;
      COMMIT;
      IF l_update_aeon
      THEN
        l_current_aeon := usim_base.get_planck_aeon_seq_next;
      END IF;
      -- return new current value
      RETURN usim_base.get_planck_time_current;
    ELSE
      usim_erl.log_error('usim_base.get_planck_time_next', 'Used without initializing base data or planck time sequence does not exist.');
      RETURN NULL;
    END IF;
  END get_planck_time_next
  ;

  FUNCTION planck_aeon_seq_exists
    RETURN BOOLEAN
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM user_sequences
     WHERE sequence_name = usim_static.get_planck_aeon_seq_name
    ;
    RETURN (l_result = 1);
  END planck_aeon_seq_exists
  ;

  FUNCTION get_planck_aeon_seq_current
    RETURN VARCHAR2
  IS
    l_result  VARCHAR2(55);
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT TRIM(usim_planck_aeon_seq_curr) INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_planck_aeon_seq_current', 'Used without initializing base data.');
    END IF;
    RETURN l_result;
  END get_planck_aeon_seq_current
  ;

  FUNCTION get_planck_aeon_seq_last
    RETURN VARCHAR2
  IS
    l_result  VARCHAR2(55);
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      SELECT TRIM(usim_planck_aeon_seq_last) INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
    ELSE
      usim_erl.log_error('usim_base.get_planck_aeon_seq_last', 'Used without initializing base data.');
    END IF;
    RETURN l_result;
  END get_planck_aeon_seq_last
  ;

  FUNCTION get_planck_aeon_seq_next
    RETURN VARCHAR2
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    l_result      VARCHAR2(55);
    l_statement   VARCHAR2(1000);
    l_seq_number  NUMBER;
  BEGIN
    IF     usim_base.planck_aeon_seq_exists
       AND usim_base.has_basedata = 1
    THEN
      -- get sequence
      l_statement := 'SELECT ' || usim_static.get_planck_aeon_seq_name || '.NEXTVAL FROM dual';
      EXECUTE IMMEDIATE l_statement INTO l_seq_number;
      -- build big planck time id
      l_result := usim_static.get_big_pk(l_seq_number);
      -- update base data
      UPDATE usim_basedata
         SET usim_planck_aeon_seq_curr = l_result
           , usim_updated_by           = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')
       WHERE usim_id_bda = 1
      ;
      COMMIT;
      -- return new current value
      RETURN usim_base.get_planck_aeon_seq_current;
    ELSE
      usim_erl.log_error('usim_base.get_planck_aeon_seq_next', 'Used without initializing base data or planck aeon sequence does not exist.');
      RETURN NULL;
    END IF;
  END get_planck_aeon_seq_next
  ;

END usim_base;

Package Body USIM_BASE kompiliert

SQL> --== base data end ==--
SQL>
SQL> --== base tables start ==--
SQL> -- USIM_MULTIVERSE (mlv)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_MULTIVERSE_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_MULTIVERSE still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MULTIVERSE'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_MULTIVERSE_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_MULTIVERSE still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MULTIVERSE'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_MULTIVERSE_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_MULTIVERSE still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_MULTIVERSE'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------------
../TABLES/USIM_MULTIVERSE_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_MULTIVERSE (mlv)
SQL> CREATE TABLE &USIM_SCHEMA..usim_multiverse
  2    ( usim_id_mlv             CHAR(55)                  NOT NULL ENABLE
  3    , usim_universe_status    NUMBER(1, 0)  DEFAULT 0   NOT NULL ENABLE
  4    , usim_is_base_universe   NUMBER(1, 0)  DEFAULT 0   NOT NULL ENABLE
  5    , usim_energy_start_value NUMBER
  6    , usim_planck_aeon        CHAR(55)
  7    , usim_planck_time        NUMBER
  8    , usim_planck_time_unit   NUMBER        DEFAULT 1   NOT NULL ENABLE
  9    , usim_planck_length_unit NUMBER        DEFAULT 1   NOT NULL ENABLE
 10    , usim_planck_speed_unit  NUMBER        DEFAULT 1   NOT NULL ENABLE
 11    , usim_planck_stable      NUMBER(1, 0)  DEFAULT 1   NOT NULL ENABLE
 12    , usim_ultimate_border    NUMBER(1, 0)  DEFAULT 1   NOT NULL ENABLE
 13    )
 14  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_multiverse
  ( usim_id_mlv             CHAR(55)                  NOT NULL ENABLE
  , usim_universe_status    NUMBER(1, 0)  DEFAULT 0   NOT NULL ENABLE
  , usim_is_base_universe   NUMBER(1, 0)  DEFAULT 0   NOT NULL ENABLE
  , usim_energy_start_value NUMBER
  , usim_planck_aeon        CHAR(55)
  , usim_planck_time        NUMBER
  , usim_planck_time_unit   NUMBER        DEFAULT 1   NOT NULL ENABLE
  , usim_planck_length_unit NUMBER        DEFAULT 1   NOT NULL ENABLE
  , usim_planck_speed_unit  NUMBER        DEFAULT 1   NOT NULL ENABLE
  , usim_planck_stable      NUMBER(1, 0)  DEFAULT 1   NOT NULL ENABLE
  , usim_ultimate_border    NUMBER(1, 0)  DEFAULT 1   NOT NULL ENABLE
  )

neu:CREATE TABLE USIM_TEST.usim_multiverse
  ( usim_id_mlv             CHAR(55)                  NOT NULL ENABLE
  , usim_universe_status    NUMBER(1, 0)  DEFAULT 0   NOT NULL ENABLE
  , usim_is_base_universe   NUMBER(1, 0)  DEFAULT 0   NOT NULL ENABLE
  , usim_energy_start_value NUMBER
  , usim_planck_aeon        CHAR(55)
  , usim_planck_time        NUMBER
  , usim_planck_time_unit   NUMBER        DEFAULT 1   NOT NULL ENABLE
  , usim_planck_length_unit NUMBER        DEFAULT 1   NOT NULL ENABLE
  , usim_planck_speed_unit  NUMBER        DEFAULT 1   NOT NULL ENABLE
  , usim_planck_stable      NUMBER(1, 0)  DEFAULT 1   NOT NULL ENABLE
  , usim_ultimate_border    NUMBER(1, 0)  DEFAULT 1   NOT NULL ENABLE
  )

Table USIM_TEST.USIM_MULTIVERSE erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_multiverse IS 'A table to manage existing universes. Will use the alias mlv.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_multiverse IS 'A table to manage existing universes. Will use the alias mlv.'
neu:COMMENT ON TABLE USIM_TEST.usim_multiverse IS 'A table to manage existing universes. Will use the alias mlv.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_id_mlv IS 'The unique id for a universe in the multiverse. Automatically set on insert, update ignored.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_id_mlv IS 'The unique id for a universe in the multiverse. Automatically set on insert, update ignored.'
neu:COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_id_mlv IS 'The unique id for a universe in the multiverse. Automatically set on insert, update ignored.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_universe_status IS 'The current state of the associated universe at usim_planck_time. Either INACTIVE, ACTIVE, DEAD, CRASHED or UNKNOWN. Calculated, set to INACTIVE on insert, update ignored.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_universe_status IS 'The current state of the associated universe at usim_planck_time. Either INACTIVE, ACTIVE, DEAD, CRASHED or UNKNOWN. Calculated, set to INACTIVE on insert, update ignored.'
neu:COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_universe_status IS 'The current state of the associated universe at usim_planck_time. Either INACTIVE, ACTIVE, DEAD, CRASHED or UNKNOWN. Calculated, set to INACTIVE on insert, update ignored.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_is_base_universe IS 'Defines if the universe the base universe for the multiverse. 1 means base universe, 0 depending universe. Only one base allowed by application. Must be set on insert, update ignored';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_is_base_universe IS 'Defines if the universe the base universe for the multiverse. 1 means base universe, 0 depending universe. Only one base allowed by application. Must be set on insert, update ignored'
neu:COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_is_base_universe IS 'Defines if the universe the base universe for the multiverse. 1 means base universe, 0 depending universe. Only one base allowed by application. Must be set on insert, update ignored'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_energy_start_value IS 'The energy start value for the associated universe. Must be set on insert, update ignored.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_energy_start_value IS 'The energy start value for the associated universe. Must be set on insert, update ignored.'
neu:COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_energy_start_value IS 'The energy start value for the associated universe. Must be set on insert, update ignored.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_aeon IS 'The planck aeon big id at insert or update of energy and universe state. Automatically set, insert and update ignored.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_aeon IS 'The planck aeon big id at insert or update of energy and universe state. Automatically set, insert and update ignored.'
neu:COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_planck_aeon IS 'The planck aeon big id at insert or update of energy and universe state. Automatically set, insert and update ignored.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_time IS 'The planck time tick at insert or update of energy and universe state. Automatically set, insert and update ignored.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_time IS 'The planck time tick at insert or update of energy and universe state. Automatically set, insert and update ignored.'
neu:COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_planck_time IS 'The planck time tick at insert or update of energy and universe state. Automatically set, insert and update ignored.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_time_unit IS 'The relative time unit of planck time for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_time_unit IS 'The relative time unit of planck time for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.'
neu:COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_planck_time_unit IS 'The relative time unit of planck time for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_length_unit IS 'The relative length unit of planck length for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_length_unit IS 'The relative length unit of planck length for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.'
neu:COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_planck_length_unit IS 'The relative length unit of planck length for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_speed_unit IS 'The relative speed (c) unit of planck speed for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_speed_unit IS 'The relative speed (c) unit of planck speed for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.'
neu:COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_planck_speed_unit IS 'The relative speed (c) unit of planck speed for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_stable IS 'The indicator if planck values may change over time (0) or are constant (1). Must be set on insert, ignored on update.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_stable IS 'The indicator if planck values may change over time (0) or are constant (1). Must be set on insert, ignored on update.'
neu:COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_planck_stable IS 'The indicator if planck values may change over time (0) or are constant (1). Must be set on insert, ignored on update.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_ultimate_border IS 'The indicator if energy flow is returned on any dimension border (0) or at the ultimate border, where no child connections are available (1). Must be set on insert, ignored on update.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_ultimate_border IS 'The indicator if energy flow is returned on any dimension border (0) or at the ultimate border, where no child connections are available (1). Must be set on insert, ignored on update.'
neu:COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_ultimate_border IS 'The indicator if energy flow is returned on any dimension border (0) or at the ultimate border, where no child connections are available (1). Must be set on insert, ignored on update.'

Comment erstellt.

SQL>
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_multiverse
  2    ADD CONSTRAINT usim_mlv_pk
  3    PRIMARY KEY (usim_id_mlv)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_multiverse
  ADD CONSTRAINT usim_mlv_pk
  PRIMARY KEY (usim_id_mlv)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_multiverse
  ADD CONSTRAINT usim_mlv_pk
  PRIMARY KEY (usim_id_mlv)
  ENABLE

Table USIM_TEST.USIM_MULTIVERSE geändert.

SQL>
SQL> -- chk planck stable
SQL> ALTER TABLE &USIM_SCHEMA..usim_multiverse
  2    ADD CONSTRAINT usim_mlv_planck_chk
  3    CHECK (usim_planck_stable IN (0, 1))
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_multiverse
  ADD CONSTRAINT usim_mlv_planck_chk
  CHECK (usim_planck_stable IN (0, 1))
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_multiverse
  ADD CONSTRAINT usim_mlv_planck_chk
  CHECK (usim_planck_stable IN (0, 1))
  ENABLE

Table USIM_TEST.USIM_MULTIVERSE geändert.

SQL>
SQL> -- chk base universe values
SQL> ALTER TABLE &USIM_SCHEMA..usim_multiverse
  2    ADD CONSTRAINT usim_mlv_base_chk
  3    CHECK (usim_is_base_universe IN (0, 1))
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_multiverse
  ADD CONSTRAINT usim_mlv_base_chk
  CHECK (usim_is_base_universe IN (0, 1))
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_multiverse
  ADD CONSTRAINT usim_mlv_base_chk
  CHECK (usim_is_base_universe IN (0, 1))
  ENABLE

Table USIM_TEST.USIM_MULTIVERSE geändert.

SQL>
SQL> -- check sign setting
SQL> ALTER TABLE &USIM_SCHEMA..usim_multiverse
  2    ADD CONSTRAINT usim_border_mlv_chk
  3    CHECK (usim_ultimate_border IN (0, 1))
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_multiverse
  ADD CONSTRAINT usim_border_mlv_chk
  CHECK (usim_ultimate_border IN (0, 1))
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_multiverse
  ADD CONSTRAINT usim_border_mlv_chk
  CHECK (usim_ultimate_border IN (0, 1))
  ENABLE

Table USIM_TEST.USIM_MULTIVERSE geändert.

SQL>
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_mlv_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_multiverse
  3      FOR EACH ROW
  4      BEGIN
  5        IF usim_base.has_basedata = 0
  6        THEN
  7          RAISE_APPLICATION_ERROR( num => -20000
  8                                 , msg => 'Insert requirement not fulfilled. Base data must exist before inserting a universe.'
  9                                 )
 10          ;
 11        END IF;
 12        -- always set this values on insert, do not care about input
 13        :NEW.usim_id_mlv := usim_static.get_big_pk(usim_mlv_id_seq.NEXTVAL);
 14        -- inherit current values from base data
 15        :NEW.usim_planck_time := usim_base.get_planck_time_current;
 16        :NEW.usim_planck_aeon := usim_base.get_planck_aeon_seq_current;
 17        -- set default status INACTIVE on insert
 18        :NEW.usim_universe_status := usim_static.usim_multiverse_status_inactive;
 19        -- if not given, set to 1 as default
 20        IF :NEW.usim_energy_start_value IS NULL
 21        THEN
 22          :NEW.usim_energy_start_value := 1;
 23        END IF;
 24        IF :NEW.usim_planck_stable IS NULL
 25        THEN
 26          :NEW.usim_planck_stable := 1;
 27        END IF;
 28        IF :NEW.usim_ultimate_border IS NULL
 29        THEN
 30          :NEW.usim_ultimate_border := 1;
 31        END IF;
 32      END;
 33  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_mlv_ins_trg
  BEFORE INSERT ON &USIM_SCHEMA..usim_multiverse
    FOR EACH ROW
    BEGIN
      IF usim_base.has_basedata = 0
      THEN
        RAISE_APPLICATION_ERROR( num => -20000
                               , msg => 'Insert requirement not fulfilled. Base data must exist before inserting a universe.'
                               )
        ;
      END IF;
      -- always set this values on insert, do not care about input
      :NEW.usim_id_mlv := usim_static.get_big_pk(usim_mlv_id_seq.NEXTVAL);
      -- inherit current values from base data
      :NEW.usim_planck_time := usim_base.get_planck_time_current;
      :NEW.usim_planck_aeon := usim_base.get_planck_aeon_seq_current;
      -- set default status INACTIVE on insert
      :NEW.usim_universe_status := usim_static.usim_multiverse_status_inactive;
      -- if not given, set to 1 as default
      IF :NEW.usim_energy_start_value IS NULL
      THEN
        :NEW.usim_energy_start_value := 1;
      END IF;
      IF :NEW.usim_planck_stable IS NULL
      THEN
        :NEW.usim_planck_stable := 1;
      END IF;
      IF :NEW.usim_ultimate_border IS NULL
      THEN
        :NEW.usim_ultimate_border := 1;
      END IF;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_mlv_ins_trg
  BEFORE INSERT ON USIM_TEST.usim_multiverse
    FOR EACH ROW
    BEGIN
      IF usim_base.has_basedata = 0
      THEN
        RAISE_APPLICATION_ERROR( num => -20000
                               , msg => 'Insert requirement not fulfilled. Base data must exist before inserting a universe.'
                               )
        ;
      END IF;
      -- always set this values on insert, do not care about input
      :NEW.usim_id_mlv := usim_static.get_big_pk(usim_mlv_id_seq.NEXTVAL);
      -- inherit current values from base data
      :NEW.usim_planck_time := usim_base.get_planck_time_current;
      :NEW.usim_planck_aeon := usim_base.get_planck_aeon_seq_current;
      -- set default status INACTIVE on insert
      :NEW.usim_universe_status := usim_static.usim_multiverse_status_inactive;
      -- if not given, set to 1 as default
      IF :NEW.usim_energy_start_value IS NULL
      THEN
        :NEW.usim_energy_start_value := 1;
      END IF;
      IF :NEW.usim_planck_stable IS NULL
      THEN
        :NEW.usim_planck_stable := 1;
      END IF;
      IF :NEW.usim_ultimate_border IS NULL
      THEN
        :NEW.usim_ultimate_border := 1;
      END IF;
    END;

Trigger USIM_MLV_INS_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_mlv_ins_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_mlv_ins_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_mlv_ins_trg ENABLE

Trigger USIM_TEST.USIM_MLV_INS_TRG geändert.

SQL>
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_mlv_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_multiverse
  3      FOR EACH ROW
  4      BEGIN
  5        -- handle values that should not be updated
  6        IF :NEW.usim_id_mlv != :OLD.usim_id_mlv
  7        THEN
  8          :NEW.usim_id_mlv := :OLD.usim_id_mlv;
  9        END IF;
 10        -- not allowed, must be set on insert
 11        IF :NEW.usim_energy_start_value != :OLD.usim_energy_start_value
 12        THEN
 13          :NEW.usim_energy_start_value := :OLD.usim_energy_start_value;
 14        END IF;
 15        -- not allowed, must be set on insert
 16        IF :NEW.usim_is_base_universe != :OLD.usim_is_base_universe
 17        THEN
 18          :NEW.usim_is_base_universe := :OLD.usim_is_base_universe;
 19        END IF;
 20        IF :NEW.usim_ultimate_border != :OLD.usim_ultimate_border
 21        THEN
 22          :NEW.usim_ultimate_border := :OLD.usim_ultimate_border;
 23        END IF;
 24        IF :NEW.usim_planck_stable != :OLD.usim_planck_stable
 25        THEN
 26          :NEW.usim_planck_stable := :OLD.usim_planck_stable;
 27        END IF;
 28        -- ignore input for planck time
 29        :NEW.usim_planck_time := usim_base.get_planck_time_current;
 30        :NEW.usim_planck_aeon := usim_base.get_planck_aeon_seq_current;
 31        -- avoid set status if invalid
 32        IF :NEW.usim_universe_status != :OLD.usim_universe_status
 33        THEN
 34          IF :NEW.usim_universe_status NOT IN (usim_static.usim_multiverse_status_dead
 35                                              , usim_static.usim_multiverse_status_crashed
 36                                              , usim_static.usim_multiverse_status_active
 37                                              , usim_static.usim_multiverse_status_inactive
 38                                              )
 39          THEN
 40            :NEW.usim_universe_status := :OLD.usim_universe_status;
 41          END IF;
 42        END IF;
 43        -- set planck values only, if they differ from 0 and usim_planck_stable = 0
 44        IF    :NEW.usim_planck_time_unit = 0
 45           OR :OLD.usim_planck_stable = 1
 46        THEN
 47          :NEW.usim_planck_time_unit := :OLD.usim_planck_time_unit;
 48        END IF;
 49        IF    :NEW.usim_planck_speed_unit = 0
 50           OR :OLD.usim_planck_stable = 1
 51        THEN
 52          :NEW.usim_planck_speed_unit := :OLD.usim_planck_speed_unit;
 53        END IF;
 54        IF    :NEW.usim_planck_length_unit = 0
 55           OR :OLD.usim_planck_stable = 1
 56        THEN
 57          :NEW.usim_planck_length_unit := :OLD.usim_planck_length_unit;
 58        END IF;
 59      END;
 60  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_mlv_upd_trg
  BEFORE UPDATE ON &USIM_SCHEMA..usim_multiverse
    FOR EACH ROW
    BEGIN
      -- handle values that should not be updated
      IF :NEW.usim_id_mlv != :OLD.usim_id_mlv
      THEN
        :NEW.usim_id_mlv := :OLD.usim_id_mlv;
      END IF;
      -- not allowed, must be set on insert
      IF :NEW.usim_energy_start_value != :OLD.usim_energy_start_value
      THEN
        :NEW.usim_energy_start_value := :OLD.usim_energy_start_value;
      END IF;
      -- not allowed, must be set on insert
      IF :NEW.usim_is_base_universe != :OLD.usim_is_base_universe
      THEN
        :NEW.usim_is_base_universe := :OLD.usim_is_base_universe;
      END IF;
      IF :NEW.usim_ultimate_border != :OLD.usim_ultimate_border
      THEN
        :NEW.usim_ultimate_border := :OLD.usim_ultimate_border;
      END IF;
      IF :NEW.usim_planck_stable != :OLD.usim_planck_stable
      THEN
        :NEW.usim_planck_stable := :OLD.usim_planck_stable;
      END IF;
      -- ignore input for planck time
      :NEW.usim_planck_time := usim_base.get_planck_time_current;
      :NEW.usim_planck_aeon := usim_base.get_planck_aeon_seq_current;
      -- avoid set status if invalid
      IF :NEW.usim_universe_status != :OLD.usim_universe_status
      THEN
        IF :NEW.usim_universe_status NOT IN (usim_static.usim_multiverse_status_dead
                                            , usim_static.usim_multiverse_status_crashed
                                            , usim_static.usim_multiverse_status_active
                                            , usim_static.usim_multiverse_status_inactive
                                            )
        THEN
          :NEW.usim_universe_status := :OLD.usim_universe_status;
        END IF;
      END IF;
      -- set planck values only, if they differ from 0 and usim_planck_stable = 0
      IF    :NEW.usim_planck_time_unit = 0
         OR :OLD.usim_planck_stable = 1
      THEN
        :NEW.usim_planck_time_unit := :OLD.usim_planck_time_unit;
      END IF;
      IF    :NEW.usim_planck_speed_unit = 0
         OR :OLD.usim_planck_stable = 1
      THEN
        :NEW.usim_planck_speed_unit := :OLD.usim_planck_speed_unit;
      END IF;
      IF    :NEW.usim_planck_length_unit = 0
         OR :OLD.usim_planck_stable = 1
      THEN
        :NEW.usim_planck_length_unit := :OLD.usim_planck_length_unit;
      END IF;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_mlv_upd_trg
  BEFORE UPDATE ON USIM_TEST.usim_multiverse
    FOR EACH ROW
    BEGIN
      -- handle values that should not be updated
      IF :NEW.usim_id_mlv != :OLD.usim_id_mlv
      THEN
        :NEW.usim_id_mlv := :OLD.usim_id_mlv;
      END IF;
      -- not allowed, must be set on insert
      IF :NEW.usim_energy_start_value != :OLD.usim_energy_start_value
      THEN
        :NEW.usim_energy_start_value := :OLD.usim_energy_start_value;
      END IF;
      -- not allowed, must be set on insert
      IF :NEW.usim_is_base_universe != :OLD.usim_is_base_universe
      THEN
        :NEW.usim_is_base_universe := :OLD.usim_is_base_universe;
      END IF;
      IF :NEW.usim_ultimate_border != :OLD.usim_ultimate_border
      THEN
        :NEW.usim_ultimate_border := :OLD.usim_ultimate_border;
      END IF;
      IF :NEW.usim_planck_stable != :OLD.usim_planck_stable
      THEN
        :NEW.usim_planck_stable := :OLD.usim_planck_stable;
      END IF;
      -- ignore input for planck time
      :NEW.usim_planck_time := usim_base.get_planck_time_current;
      :NEW.usim_planck_aeon := usim_base.get_planck_aeon_seq_current;
      -- avoid set status if invalid
      IF :NEW.usim_universe_status != :OLD.usim_universe_status
      THEN
        IF :NEW.usim_universe_status NOT IN (usim_static.usim_multiverse_status_dead
                                            , usim_static.usim_multiverse_status_crashed
                                            , usim_static.usim_multiverse_status_active
                                            , usim_static.usim_multiverse_status_inactive
                                            )
        THEN
          :NEW.usim_universe_status := :OLD.usim_universe_status;
        END IF;
      END IF;
      -- set planck values only, if they differ from 0 and usim_planck_stable = 0
      IF    :NEW.usim_planck_time_unit = 0
         OR :OLD.usim_planck_stable = 1
      THEN
        :NEW.usim_planck_time_unit := :OLD.usim_planck_time_unit;
      END IF;
      IF    :NEW.usim_planck_speed_unit = 0
         OR :OLD.usim_planck_stable = 1
      THEN
        :NEW.usim_planck_speed_unit := :OLD.usim_planck_speed_unit;
      END IF;
      IF    :NEW.usim_planck_length_unit = 0
         OR :OLD.usim_planck_stable = 1
      THEN
        :NEW.usim_planck_length_unit := :OLD.usim_planck_length_unit;
      END IF;
    END;

Trigger USIM_MLV_UPD_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_mlv_upd_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_mlv_upd_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_mlv_upd_trg ENABLE

Trigger USIM_TEST.USIM_MLV_UPD_TRG geändert.

SQL> -- usim_multiverse package
SQL> @@../PACKAGES/USIM_MLV.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_mlv
  2  IS
  3    /**A low level package for actions on table usim_multiverse and its associated
  4    * view. No other dependencies apart from USIM_STATIC. Package may throw exceptions
  5    * from constraints, triggers and foreign keys. Caller is responsible to handle
  6    * possible exceptions.
  7    */
  8
  9    /**
 10    * Checks if usim_multiverse has already data.
 11    * @return Returns 1 if data are available, otherwise 0.
 12    */
 13    FUNCTION has_data
 14      RETURN NUMBER
 15    ;
 16
 17    /**
 18    * Checks if a given usim_multiverse id exists.
 19    * @param p_usim_id_mlv The id of the universe to check.
 20    * @return Returns 1 if universe exists, otherwise 0.
 21    */
 22   FUNCTION has_data(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 23      RETURN NUMBER
 24    ;
 25
 26    /**
 27    * Determines if a base universe already exists in usim_multiverse.
 28    * @return Returns 1 if a base universe exists, otherwise 0.
 29    */
 30    FUNCTION has_base
 31      RETURN NUMBER
 32    ;
 33
 34    /**
 35    * Checks if a given universe is a base universe.
 36    * @param p_usim_id_mlv The id of the universe to get usim_planck_stable from.
 37    * @return Returns 1 if universe is base, otherwise 0 or NULL, if universe does not exist.
 38    */
 39    FUNCTION is_base(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 40      RETURN NUMBER
 41    ;
 42
 43    /**
 44    * Gets the current state of the universe. See USIM_STATIC for allowed state.
 45    * @param p_usim_id_mlv The id of the universe to get usim_planck_stable from.
 46    * @return Returns the current state of the universe or NULL, if universe does not exist.
 47    */
 48    FUNCTION get_state(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 49      RETURN usim_multiverse.usim_universe_status%TYPE
 50    ;
 51
 52    /**
 53    * Gets the current value of usim_planck_stable for the given universe.
 54    * @param p_usim_id_mlv The id of the universe to get usim_planck_stable from.
 55    * @return Returns usim_planck_stable if given universe exists, otherwise -1.
 56    */
 57    FUNCTION get_planck_stable(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 58      RETURN NUMBER
 59    ;
 60
 61    /**
 62    * Gets the rule for ultimate or any border for a given universe.
 63    * @param p_usim_id_mlv The id of the universe to get usim_ultimate_border from.
 64    * @return Returns 1, rule for ultimate border or 0, rule for any border if given universe exists, otherwise -1.
 65    */
 66    FUNCTION get_ultimate_border(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 67      RETURN usim_multiverse.usim_ultimate_border%TYPE
 68    ;
 69
 70    /**
 71    * Inserts a new universe with the given values. Does not check if a base universe already exists. USIM_UNIVERSE_STATUS is automatically set
 72    * to inactive on insert. USIM_IS_BASE_UNIVERSE is determined by existance of data. If no base universe exist, the universe gets the base universe, otherwise
 73    * the universe will be a sub-universe of the existing base universe.
 74    * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used or default if NULL or 0.
 75    * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value or default if NULL or 0.
 76    * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value or default if NULL or 0.
 77    * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value or default if NULL or 0.
 78    * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct.
 79    * @param p_usim_ultimate_border The ultimate border rule for this universe. 1 is ultimate border reached, no childs left, 0 is any border at dimensions axis even with childs left.
 80    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 81    * @return The new universe big id or NULL if insert failed.
 82    */
 83    FUNCTION insert_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
 84                            , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
 85                            , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
 86                            , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
 87                            , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
 88                            , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
 89                            , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
 90                            )
 91      RETURN usim_multiverse.usim_id_mlv%TYPE
 92    ;
 93
 94    /**
 95    * Updates the universe state for the given universe id.
 96    * @param p_usim_id_mlv The id of the universe, that should update its state.
 97    * @param p_usim_universe_status The new state of the universe. Must match usim_static's usim_multiverse_status_dead, usim_multiverse_status_crashed, usim_multiverse_status_active or usim_multiverse_status_inactive.
 98    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 99    * @return Returns the new state or NULL on errors.
100    */
101    FUNCTION update_state( p_usim_id_mlv          IN usim_multiverse.usim_id_mlv%TYPE
102                         , p_usim_universe_status IN usim_multiverse.usim_universe_status%TYPE
103                         , p_do_commit            IN BOOLEAN                                   DEFAULT TRUE
104                         )
105      RETURN usim_multiverse.usim_universe_status%TYPE
106    ;
107
108    /**
109    * Updates all planck units by new time and speed unit if usim_planck_stable = 0 for the given universe and the universe exists.
110    * @param p_usim_id_mlv The id of the universe, that should update planck units.
111    * @param p_usim_planck_time_unit The new planck time unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
112    * @param p_usim_planck_speed_unit The new planck speed unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
113    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
114    * @return Returns 1 if update was possible, otherwise 0.
115    */
116    FUNCTION update_planck_unit_time_speed( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
117                                          , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
118                                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
119                                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
120                                          )
121      RETURN NUMBER
122    ;
123
124    /**
125    * Updates all planck units by new time and length unit if usim_planck_stable = 0 for the given universe and the universe exists.
126    * @param p_usim_id_mlv The id of the universe, that should update planck units.
127    * @param p_usim_planck_time_unit The new planck time unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
128    * @param p_usim_planck_length_unit The new planck length unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
129    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
130    * @return Returns 1 if update was possible, otherwise 0.
131    */
132    FUNCTION update_planck_unit_time_length( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
133                                           , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
134                                           , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
135                                           , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
136                                           )
137      RETURN NUMBER
138    ;
139
140    /**
141    * Updates all planck units by new speed and length unit if usim_planck_stable = 0 for the given universe and the universe exists.
142    * @param p_usim_id_mlv The id of the universe, that should update planck units.
143    * @param p_usim_planck_speed_unit The new planck speed unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
144    * @param p_usim_planck_length_unit The new planck length unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
145    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
146    * @return Returns 1 if update was possible, otherwise 0.
147    */
148    FUNCTION update_planck_unit_speed_length( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
149                                            , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
150                                            , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
151                                            , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
152                                           )
153      RETURN NUMBER
154    ;
155
156  END usim_mlv;
157  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_mlv
IS
  /**A low level package for actions on table usim_multiverse and its associated
  * view. No other dependencies apart from USIM_STATIC. Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_multiverse has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if a given usim_multiverse id exists.
  * @param p_usim_id_mlv The id of the universe to check.
  * @return Returns 1 if universe exists, otherwise 0.
  */
 FUNCTION has_data(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  ;

  /**
  * Determines if a base universe already exists in usim_multiverse.
  * @return Returns 1 if a base universe exists, otherwise 0.
  */
  FUNCTION has_base
    RETURN NUMBER
  ;

  /**
  * Checks if a given universe is a base universe.
  * @param p_usim_id_mlv The id of the universe to get usim_planck_stable from.
  * @return Returns 1 if universe is base, otherwise 0 or NULL, if universe does not exist.
  */
  FUNCTION is_base(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the current state of the universe. See USIM_STATIC for allowed state.
  * @param p_usim_id_mlv The id of the universe to get usim_planck_stable from.
  * @return Returns the current state of the universe or NULL, if universe does not exist.
  */
  FUNCTION get_state(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN usim_multiverse.usim_universe_status%TYPE
  ;

  /**
  * Gets the current value of usim_planck_stable for the given universe.
  * @param p_usim_id_mlv The id of the universe to get usim_planck_stable from.
  * @return Returns usim_planck_stable if given universe exists, otherwise -1.
  */
  FUNCTION get_planck_stable(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the rule for ultimate or any border for a given universe.
  * @param p_usim_id_mlv The id of the universe to get usim_ultimate_border from.
  * @return Returns 1, rule for ultimate border or 0, rule for any border if given universe exists, otherwise -1.
  */
  FUNCTION get_ultimate_border(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN usim_multiverse.usim_ultimate_border%TYPE
  ;

  /**
  * Inserts a new universe with the given values. Does not check if a base universe already exists. USIM_UNIVERSE_STATUS is automatically set
  * to inactive on insert. USIM_IS_BASE_UNIVERSE is determined by existance of data. If no base universe exist, the universe gets the base universe, otherwise
  * the universe will be a sub-universe of the existing base universe.
  * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used or default if NULL or 0.
  * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value or default if NULL or 0.
  * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value or default if NULL or 0.
  * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value or default if NULL or 0.
  * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct.
  * @param p_usim_ultimate_border The ultimate border rule for this universe. 1 is ultimate border reached, no childs left, 0 is any border at dimensions axis even with childs left.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return The new universe big id or NULL if insert failed.
  */
  FUNCTION insert_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                          , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                          , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                          , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                          , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                          )
    RETURN usim_multiverse.usim_id_mlv%TYPE
  ;

  /**
  * Updates the universe state for the given universe id.
  * @param p_usim_id_mlv The id of the universe, that should update its state.
  * @param p_usim_universe_status The new state of the universe. Must match usim_static's usim_multiverse_status_dead, usim_multiverse_status_crashed, usim_multiverse_status_active or usim_multiverse_status_inactive.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new state or NULL on errors.
  */
  FUNCTION update_state( p_usim_id_mlv          IN usim_multiverse.usim_id_mlv%TYPE
                       , p_usim_universe_status IN usim_multiverse.usim_universe_status%TYPE
                       , p_do_commit            IN BOOLEAN                                   DEFAULT TRUE
                       )
    RETURN usim_multiverse.usim_universe_status%TYPE
  ;

  /**
  * Updates all planck units by new time and speed unit if usim_planck_stable = 0 for the given universe and the universe exists.
  * @param p_usim_id_mlv The id of the universe, that should update planck units.
  * @param p_usim_planck_time_unit The new planck time unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
  * @param p_usim_planck_speed_unit The new planck speed unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if update was possible, otherwise 0.
  */
  FUNCTION update_planck_unit_time_speed( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
                                        , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
                                        , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
                                        , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                                        )
    RETURN NUMBER
  ;

  /**
  * Updates all planck units by new time and length unit if usim_planck_stable = 0 for the given universe and the universe exists.
  * @param p_usim_id_mlv The id of the universe, that should update planck units.
  * @param p_usim_planck_time_unit The new planck time unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
  * @param p_usim_planck_length_unit The new planck length unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if update was possible, otherwise 0.
  */
  FUNCTION update_planck_unit_time_length( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
                                         , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
                                         , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
                                         , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                                         )
    RETURN NUMBER
  ;

  /**
  * Updates all planck units by new speed and length unit if usim_planck_stable = 0 for the given universe and the universe exists.
  * @param p_usim_id_mlv The id of the universe, that should update planck units.
  * @param p_usim_planck_speed_unit The new planck speed unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
  * @param p_usim_planck_length_unit The new planck length unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if update was possible, otherwise 0.
  */
  FUNCTION update_planck_unit_speed_length( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
                                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
                                          , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
                                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                                         )
    RETURN NUMBER
  ;

END usim_mlv;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_mlv
IS
  /**A low level package for actions on table usim_multiverse and its associated
  * view. No other dependencies apart from USIM_STATIC. Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_multiverse has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if a given usim_multiverse id exists.
  * @param p_usim_id_mlv The id of the universe to check.
  * @return Returns 1 if universe exists, otherwise 0.
  */
 FUNCTION has_data(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  ;

  /**
  * Determines if a base universe already exists in usim_multiverse.
  * @return Returns 1 if a base universe exists, otherwise 0.
  */
  FUNCTION has_base
    RETURN NUMBER
  ;

  /**
  * Checks if a given universe is a base universe.
  * @param p_usim_id_mlv The id of the universe to get usim_planck_stable from.
  * @return Returns 1 if universe is base, otherwise 0 or NULL, if universe does not exist.
  */
  FUNCTION is_base(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the current state of the universe. See USIM_STATIC for allowed state.
  * @param p_usim_id_mlv The id of the universe to get usim_planck_stable from.
  * @return Returns the current state of the universe or NULL, if universe does not exist.
  */
  FUNCTION get_state(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN usim_multiverse.usim_universe_status%TYPE
  ;

  /**
  * Gets the current value of usim_planck_stable for the given universe.
  * @param p_usim_id_mlv The id of the universe to get usim_planck_stable from.
  * @return Returns usim_planck_stable if given universe exists, otherwise -1.
  */
  FUNCTION get_planck_stable(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the rule for ultimate or any border for a given universe.
  * @param p_usim_id_mlv The id of the universe to get usim_ultimate_border from.
  * @return Returns 1, rule for ultimate border or 0, rule for any border if given universe exists, otherwise -1.
  */
  FUNCTION get_ultimate_border(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN usim_multiverse.usim_ultimate_border%TYPE
  ;

  /**
  * Inserts a new universe with the given values. Does not check if a base universe already exists. USIM_UNIVERSE_STATUS is automatically set
  * to inactive on insert. USIM_IS_BASE_UNIVERSE is determined by existance of data. If no base universe exist, the universe gets the base universe, otherwise
  * the universe will be a sub-universe of the existing base universe.
  * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used or default if NULL or 0.
  * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value or default if NULL or 0.
  * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value or default if NULL or 0.
  * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value or default if NULL or 0.
  * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct.
  * @param p_usim_ultimate_border The ultimate border rule for this universe. 1 is ultimate border reached, no childs left, 0 is any border at dimensions axis even with childs left.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return The new universe big id or NULL if insert failed.
  */
  FUNCTION insert_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                          , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                          , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                          , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                          , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                          )
    RETURN usim_multiverse.usim_id_mlv%TYPE
  ;

  /**
  * Updates the universe state for the given universe id.
  * @param p_usim_id_mlv The id of the universe, that should update its state.
  * @param p_usim_universe_status The new state of the universe. Must match usim_static's usim_multiverse_status_dead, usim_multiverse_status_crashed, usim_multiverse_status_active or usim_multiverse_status_inactive.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new state or NULL on errors.
  */
  FUNCTION update_state( p_usim_id_mlv          IN usim_multiverse.usim_id_mlv%TYPE
                       , p_usim_universe_status IN usim_multiverse.usim_universe_status%TYPE
                       , p_do_commit            IN BOOLEAN                                   DEFAULT TRUE
                       )
    RETURN usim_multiverse.usim_universe_status%TYPE
  ;

  /**
  * Updates all planck units by new time and speed unit if usim_planck_stable = 0 for the given universe and the universe exists.
  * @param p_usim_id_mlv The id of the universe, that should update planck units.
  * @param p_usim_planck_time_unit The new planck time unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
  * @param p_usim_planck_speed_unit The new planck speed unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if update was possible, otherwise 0.
  */
  FUNCTION update_planck_unit_time_speed( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
                                        , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
                                        , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
                                        , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                                        )
    RETURN NUMBER
  ;

  /**
  * Updates all planck units by new time and length unit if usim_planck_stable = 0 for the given universe and the universe exists.
  * @param p_usim_id_mlv The id of the universe, that should update planck units.
  * @param p_usim_planck_time_unit The new planck time unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
  * @param p_usim_planck_length_unit The new planck length unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if update was possible, otherwise 0.
  */
  FUNCTION update_planck_unit_time_length( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
                                         , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
                                         , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
                                         , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                                         )
    RETURN NUMBER
  ;

  /**
  * Updates all planck units by new speed and length unit if usim_planck_stable = 0 for the given universe and the universe exists.
  * @param p_usim_id_mlv The id of the universe, that should update planck units.
  * @param p_usim_planck_speed_unit The new planck speed unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
  * @param p_usim_planck_length_unit The new planck length unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if update was possible, otherwise 0.
  */
  FUNCTION update_planck_unit_speed_length( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
                                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
                                          , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
                                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                                         )
    RETURN NUMBER
  ;

END usim_mlv;

Package USIM_MLV kompiliert

SQL> @@../PACKAGES/USIM_MLV.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_mlv
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_data
  5      RETURN NUMBER
  6    IS
  7      l_result  NUMBER;
  8    BEGIN
  9      SELECT COUNT(*) INTO l_result FROM usim_multiverse;
 10      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 11    END has_data
 12    ;
 13
 14    FUNCTION has_data(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 15      RETURN NUMBER
 16    IS
 17      l_result  NUMBER;
 18    BEGIN
 19      SELECT COUNT(*) INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
 20      RETURN l_result;
 21    END has_data
 22    ;
 23
 24    FUNCTION has_base
 25      RETURN NUMBER
 26    IS
 27      l_result  NUMBER;
 28    BEGIN
 29      SELECT COUNT(*) INTO l_result FROM usim_multiverse WHERE usim_is_base_universe = 1;
 30      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 31    END has_base
 32    ;
 33
 34    FUNCTION is_base(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 35      RETURN NUMBER
 36    IS
 37      l_result NUMBER;
 38    BEGIN
 39      IF usim_mlv.has_data(p_usim_id_mlv) = 1
 40      THEN
 41        SELECT usim_is_base_universe INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
 42        RETURN l_result;
 43      ELSE
 44        usim_erl.log_error('usim_mlv.is_base', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
 45        RETURN NULL;
 46      END IF;
 47    END is_base
 48    ;
 49
 50    FUNCTION get_state(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 51      RETURN usim_multiverse.usim_universe_status%TYPE
 52    IS
 53      l_result usim_multiverse.usim_universe_status%TYPE;
 54    BEGIN
 55      IF usim_mlv.has_data(p_usim_id_mlv) = 1
 56      THEN
 57        SELECT usim_universe_status INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
 58        RETURN l_result;
 59      ELSE
 60        usim_erl.log_error('usim_mlv.get_state', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
 61        RETURN NULL;
 62      END IF;
 63    END get_state
 64    ;
 65
 66    FUNCTION get_planck_stable(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 67      RETURN NUMBER
 68    IS
 69      l_result usim_multiverse.usim_planck_stable%TYPE;
 70    BEGIN
 71      l_result := -1;
 72      IF usim_mlv.has_data(p_usim_id_mlv) = 1
 73      THEN
 74        SELECT usim_planck_stable INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
 75      ELSE
 76        usim_erl.log_error('usim_mlv.get_planck_stable', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
 77      END IF;
 78      RETURN l_result;
 79    END get_planck_stable
 80    ;
 81
 82    FUNCTION get_ultimate_border(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 83      RETURN usim_multiverse.usim_ultimate_border%TYPE
 84    IS
 85      l_result usim_multiverse.usim_ultimate_border%TYPE;
 86    BEGIN
 87      l_result := -1;
 88      IF usim_mlv.has_data(p_usim_id_mlv) = 1
 89      THEN
 90        SELECT usim_ultimate_border INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
 91      ELSE
 92        usim_erl.log_error('usim_mlv.get_ultimate_border', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
 93      END IF;
 94      RETURN l_result;
 95    END get_ultimate_border
 96    ;
 97
 98    FUNCTION insert_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
 99                            , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
100                            , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
101                            , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
102                            , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
103                            , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
104                            , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
105                            )
106      RETURN usim_multiverse.usim_id_mlv%TYPE
107    IS
108      l_usim_energy_start_value usim_multiverse.usim_energy_start_value%TYPE;
109      l_usim_planck_time_unit   usim_multiverse.usim_planck_time_unit%TYPE;
110      l_usim_planck_length_unit usim_multiverse.usim_planck_length_unit%TYPE;
111      l_usim_planck_speed_unit  usim_multiverse.usim_planck_speed_unit%TYPE;
112      l_usim_planck_stable      usim_multiverse.usim_planck_stable%TYPE;
113      l_usim_ultimate_border    usim_multiverse.usim_ultimate_border%TYPE;
114      l_usim_is_base_universe   usim_multiverse.usim_is_base_universe%TYPE;
115      l_usim_id_mlv             usim_multiverse.usim_id_mlv%TYPE;
116    BEGIN
117      l_usim_id_mlv := NULL;
118      -- check value constraints and set defaults
119      IF usim_mlv.has_base = 1
120      THEN
121        l_usim_is_base_universe := 0;
122      ELSE
123        l_usim_is_base_universe := 1;
124      END IF;
125      IF p_usim_ultimate_border IN (0, 1)
126      THEN
127        l_usim_ultimate_border := p_usim_ultimate_border;
128      ELSE
129        l_usim_ultimate_border := 1;
130      END IF;
131      IF p_usim_planck_stable IN (0, 1)
132      THEN
133        l_usim_planck_stable := p_usim_planck_stable;
134      ELSE
135        l_usim_planck_stable := 1;
136      END IF;
137      IF NVL(p_usim_planck_time_unit, 0) = 0
138      THEN
139        l_usim_planck_time_unit := 1;
140      ELSE
141        l_usim_planck_time_unit := ABS(p_usim_planck_time_unit);
142      END IF;
143      IF NVL(p_usim_planck_length_unit, 0) = 0
144      THEN
145        l_usim_planck_length_unit := 1;
146      ELSE
147        l_usim_planck_length_unit := ABS(p_usim_planck_length_unit);
148      END IF;
149      IF NVL(p_usim_planck_speed_unit, 0) = 0
150      THEN
151        l_usim_planck_speed_unit := 1;
152      ELSE
153        l_usim_planck_speed_unit := ABS(p_usim_planck_speed_unit);
154      END IF;
155      IF NVL(p_usim_energy_start_value, 0) = 0
156      THEN
157        l_usim_energy_start_value := 1;
158      ELSE
159        l_usim_energy_start_value := ABS(p_usim_energy_start_value);
160      END IF;
161      -- insert the found values
162      INSERT INTO usim_multiverse
163        ( usim_is_base_universe
164        , usim_energy_start_value
165        , usim_planck_time_unit
166        , usim_planck_length_unit
167        , usim_planck_speed_unit
168        , usim_planck_stable
169        , usim_ultimate_border
170        )
171        VALUES
172        ( l_usim_is_base_universe
173        , l_usim_energy_start_value
174        , l_usim_planck_time_unit
175        , l_usim_planck_length_unit
176        , l_usim_planck_speed_unit
177        , l_usim_planck_stable
178        , l_usim_ultimate_border
179        )
180        RETURNING usim_id_mlv INTO l_usim_id_mlv
181      ;
182      IF p_do_commit
183      THEN
184        COMMIT;
185      END IF;
186      RETURN l_usim_id_mlv;
187    END insert_universe
188    ;
189
190    FUNCTION update_state( p_usim_id_mlv          IN usim_multiverse.usim_id_mlv%TYPE
191                         , p_usim_universe_status IN usim_multiverse.usim_universe_status%TYPE
192                         , p_do_commit            IN BOOLEAN                                   DEFAULT TRUE
193                         )
194      RETURN usim_multiverse.usim_universe_status%TYPE
195    IS
196    BEGIN
197      IF     usim_mlv.has_data(p_usim_id_mlv)  = 1
198         AND p_usim_universe_status           IN ( usim_static.usim_multiverse_status_dead
199                                                 , usim_static.usim_multiverse_status_crashed
200                                                 , usim_static.usim_multiverse_status_active
201                                                 , usim_static.usim_multiverse_status_inactive
202                                                 )
203      THEN
204        UPDATE usim_multiverse
205           SET usim_universe_status = p_usim_universe_status
206         WHERE usim_id_mlv = p_usim_id_mlv
207        ;
208        IF p_do_commit
209        THEN
210          COMMIT;
211        END IF;
212        RETURN p_usim_universe_status;
213      ELSE
214        usim_erl.log_error('usim_mlv.update_state', 'Used with not existing universe id [' || p_usim_id_mlv || '] or wrong state [' || p_usim_universe_status || '].');
215        RETURN NULL;
216      END IF;
217    END update_state
218    ;
219
220    FUNCTION update_planck_unit_time_speed( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
221                                          , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
222                                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
223                                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
224                                          )
225      RETURN NUMBER
226    IS
227      l_velocity  NUMBER;
228      l_length    NUMBER;
229      l_time      NUMBER;
230    BEGIN
231      IF     usim_mlv.has_data(p_usim_id_mlv)   = 1
232         AND usim_mlv.get_planck_stable(p_usim_id_mlv) = 0
233      THEN
234        IF NVL(p_usim_planck_time_unit, 0) = 0
235        THEN
236          l_time := 1;
237        ELSE
238          l_time := ABS(p_usim_planck_time_unit);
239        END IF;
240        IF NVL(p_usim_planck_speed_unit, 0) = 0
241        THEN
242          l_velocity := 1;
243        ELSE
244          l_velocity := ABS(p_usim_planck_speed_unit);
245        END IF;
246        l_length := l_velocity * l_time;
247        UPDATE usim_multiverse
248           SET usim_planck_time_unit    = l_time
249             , usim_planck_length_unit  = l_length
250             , usim_planck_speed_unit   = l_velocity
251         WHERE usim_id_mlv = p_usim_id_mlv
252        ;
253        IF p_do_commit
254        THEN
255          COMMIT;
256        END IF;
257        RETURN 1;
258      ELSE
259        usim_erl.log_error('usim_mlv.update_planck_unit_time_speed', 'Used with not existing universe id [' || p_usim_id_mlv || '] or planck stable is set.');
260        RETURN 0;
261      END IF;
262    END update_planck_unit_time_speed
263    ;
264
265    FUNCTION update_planck_unit_time_length( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
266                                           , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
267                                           , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
268                                           , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
269                                           )
270      RETURN NUMBER
271    IS
272      l_velocity  NUMBER;
273      l_length    NUMBER;
274      l_time      NUMBER;
275    BEGIN
276      IF     usim_mlv.has_data(p_usim_id_mlv)   = 1
277         AND usim_mlv.get_planck_stable(p_usim_id_mlv) = 0
278      THEN
279        IF NVL(p_usim_planck_time_unit, 0) = 0
280        THEN
281          l_time := 1;
282        ELSE
283          l_time := ABS(p_usim_planck_time_unit);
284        END IF;
285        IF NVL(p_usim_planck_length_unit, 0) = 0
286        THEN
287          l_length := 1;
288        ELSE
289          l_length := ABS(p_usim_planck_length_unit);
290        END IF;
291        l_velocity := l_length / l_time;
292        UPDATE usim_multiverse
293           SET usim_planck_time_unit    = l_time
294             , usim_planck_length_unit  = l_length
295             , usim_planck_speed_unit   = l_velocity
296         WHERE usim_id_mlv = p_usim_id_mlv
297        ;
298        IF p_do_commit
299        THEN
300          COMMIT;
301        END IF;
302        RETURN 1;
303      ELSE
304        usim_erl.log_error('usim_mlv.update_planck_unit_time_length', 'Used with not existing universe id [' || p_usim_id_mlv || '] or planck stable is set.');
305        RETURN 0;
306      END IF;
307    END update_planck_unit_time_length
308    ;
309
310    FUNCTION update_planck_unit_speed_length( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
311                                            , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
312                                            , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
313                                            , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
314                                           )
315      RETURN NUMBER
316    IS
317      l_velocity  NUMBER;
318      l_length    NUMBER;
319      l_time      NUMBER;
320    BEGIN
321      IF     usim_mlv.has_data(p_usim_id_mlv)   = 1
322         AND usim_mlv.get_planck_stable(p_usim_id_mlv) = 0
323      THEN
324        IF NVL(p_usim_planck_speed_unit, 0) = 0
325        THEN
326          l_velocity := 1;
327        ELSE
328          l_velocity := ABS(p_usim_planck_speed_unit);
329        END IF;
330        IF NVL(p_usim_planck_length_unit, 0) = 0
331        THEN
332          l_length := 1;
333        ELSE
334          l_length := ABS(p_usim_planck_length_unit);
335        END IF;
336        l_time := l_length / l_velocity;
337        UPDATE usim_multiverse
338           SET usim_planck_time_unit    = l_time
339             , usim_planck_length_unit  = l_length
340             , usim_planck_speed_unit   = l_velocity
341         WHERE usim_id_mlv = p_usim_id_mlv
342        ;
343        IF p_do_commit
344        THEN
345          COMMIT;
346        END IF;
347        RETURN 1;
348      ELSE
349        usim_erl.log_error('usim_mlv.update_planck_unit_speed_length', 'Used with not existing universe id [' || p_usim_id_mlv || '] or planck stable is set.');
350        RETURN 0;
351      END IF;
352    END update_planck_unit_speed_length
353    ;
354
355  END usim_mlv;
356  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_mlv
IS
  -- see header for documentation
  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_multiverse;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_base
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_multiverse WHERE usim_is_base_universe = 1;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_base
  ;

  FUNCTION is_base(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      SELECT usim_is_base_universe INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_mlv.is_base', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
      RETURN NULL;
    END IF;
  END is_base
  ;

  FUNCTION get_state(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN usim_multiverse.usim_universe_status%TYPE
  IS
    l_result usim_multiverse.usim_universe_status%TYPE;
  BEGIN
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      SELECT usim_universe_status INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_mlv.get_state', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
      RETURN NULL;
    END IF;
  END get_state
  ;

  FUNCTION get_planck_stable(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  IS
    l_result usim_multiverse.usim_planck_stable%TYPE;
  BEGIN
    l_result := -1;
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      SELECT usim_planck_stable INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
    ELSE
      usim_erl.log_error('usim_mlv.get_planck_stable', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
    END IF;
    RETURN l_result;
  END get_planck_stable
  ;

  FUNCTION get_ultimate_border(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN usim_multiverse.usim_ultimate_border%TYPE
  IS
    l_result usim_multiverse.usim_ultimate_border%TYPE;
  BEGIN
    l_result := -1;
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      SELECT usim_ultimate_border INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
    ELSE
      usim_erl.log_error('usim_mlv.get_ultimate_border', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
    END IF;
    RETURN l_result;
  END get_ultimate_border
  ;

  FUNCTION insert_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                          , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                          , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                          , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                          , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                          )
    RETURN usim_multiverse.usim_id_mlv%TYPE
  IS
    l_usim_energy_start_value usim_multiverse.usim_energy_start_value%TYPE;
    l_usim_planck_time_unit   usim_multiverse.usim_planck_time_unit%TYPE;
    l_usim_planck_length_unit usim_multiverse.usim_planck_length_unit%TYPE;
    l_usim_planck_speed_unit  usim_multiverse.usim_planck_speed_unit%TYPE;
    l_usim_planck_stable      usim_multiverse.usim_planck_stable%TYPE;
    l_usim_ultimate_border    usim_multiverse.usim_ultimate_border%TYPE;
    l_usim_is_base_universe   usim_multiverse.usim_is_base_universe%TYPE;
    l_usim_id_mlv             usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    l_usim_id_mlv := NULL;
    -- check value constraints and set defaults
    IF usim_mlv.has_base = 1
    THEN
      l_usim_is_base_universe := 0;
    ELSE
      l_usim_is_base_universe := 1;
    END IF;
    IF p_usim_ultimate_border IN (0, 1)
    THEN
      l_usim_ultimate_border := p_usim_ultimate_border;
    ELSE
      l_usim_ultimate_border := 1;
    END IF;
    IF p_usim_planck_stable IN (0, 1)
    THEN
      l_usim_planck_stable := p_usim_planck_stable;
    ELSE
      l_usim_planck_stable := 1;
    END IF;
    IF NVL(p_usim_planck_time_unit, 0) = 0
    THEN
      l_usim_planck_time_unit := 1;
    ELSE
      l_usim_planck_time_unit := ABS(p_usim_planck_time_unit);
    END IF;
    IF NVL(p_usim_planck_length_unit, 0) = 0
    THEN
      l_usim_planck_length_unit := 1;
    ELSE
      l_usim_planck_length_unit := ABS(p_usim_planck_length_unit);
    END IF;
    IF NVL(p_usim_planck_speed_unit, 0) = 0
    THEN
      l_usim_planck_speed_unit := 1;
    ELSE
      l_usim_planck_speed_unit := ABS(p_usim_planck_speed_unit);
    END IF;
    IF NVL(p_usim_energy_start_value, 0) = 0
    THEN
      l_usim_energy_start_value := 1;
    ELSE
      l_usim_energy_start_value := ABS(p_usim_energy_start_value);
    END IF;
    -- insert the found values
    INSERT INTO usim_multiverse
      ( usim_is_base_universe
      , usim_energy_start_value
      , usim_planck_time_unit
      , usim_planck_length_unit
      , usim_planck_speed_unit
      , usim_planck_stable
      , usim_ultimate_border
      )
      VALUES
      ( l_usim_is_base_universe
      , l_usim_energy_start_value
      , l_usim_planck_time_unit
      , l_usim_planck_length_unit
      , l_usim_planck_speed_unit
      , l_usim_planck_stable
      , l_usim_ultimate_border
      )
      RETURNING usim_id_mlv INTO l_usim_id_mlv
    ;
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN l_usim_id_mlv;
  END insert_universe
  ;

  FUNCTION update_state( p_usim_id_mlv          IN usim_multiverse.usim_id_mlv%TYPE
                       , p_usim_universe_status IN usim_multiverse.usim_universe_status%TYPE
                       , p_do_commit            IN BOOLEAN                                   DEFAULT TRUE
                       )
    RETURN usim_multiverse.usim_universe_status%TYPE
  IS
  BEGIN
    IF     usim_mlv.has_data(p_usim_id_mlv)  = 1
       AND p_usim_universe_status           IN ( usim_static.usim_multiverse_status_dead
                                               , usim_static.usim_multiverse_status_crashed
                                               , usim_static.usim_multiverse_status_active
                                               , usim_static.usim_multiverse_status_inactive
                                               )
    THEN
      UPDATE usim_multiverse
         SET usim_universe_status = p_usim_universe_status
       WHERE usim_id_mlv = p_usim_id_mlv
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN p_usim_universe_status;
    ELSE
      usim_erl.log_error('usim_mlv.update_state', 'Used with not existing universe id [' || p_usim_id_mlv || '] or wrong state [' || p_usim_universe_status || '].');
      RETURN NULL;
    END IF;
  END update_state
  ;

  FUNCTION update_planck_unit_time_speed( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
                                        , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
                                        , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
                                        , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                                        )
    RETURN NUMBER
  IS
    l_velocity  NUMBER;
    l_length    NUMBER;
    l_time      NUMBER;
  BEGIN
    IF     usim_mlv.has_data(p_usim_id_mlv)   = 1
       AND usim_mlv.get_planck_stable(p_usim_id_mlv) = 0
    THEN
      IF NVL(p_usim_planck_time_unit, 0) = 0
      THEN
        l_time := 1;
      ELSE
        l_time := ABS(p_usim_planck_time_unit);
      END IF;
      IF NVL(p_usim_planck_speed_unit, 0) = 0
      THEN
        l_velocity := 1;
      ELSE
        l_velocity := ABS(p_usim_planck_speed_unit);
      END IF;
      l_length := l_velocity * l_time;
      UPDATE usim_multiverse
         SET usim_planck_time_unit    = l_time
           , usim_planck_length_unit  = l_length
           , usim_planck_speed_unit   = l_velocity
       WHERE usim_id_mlv = p_usim_id_mlv
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_mlv.update_planck_unit_time_speed', 'Used with not existing universe id [' || p_usim_id_mlv || '] or planck stable is set.');
      RETURN 0;
    END IF;
  END update_planck_unit_time_speed
  ;

  FUNCTION update_planck_unit_time_length( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
                                         , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
                                         , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
                                         , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                                         )
    RETURN NUMBER
  IS
    l_velocity  NUMBER;
    l_length    NUMBER;
    l_time      NUMBER;
  BEGIN
    IF     usim_mlv.has_data(p_usim_id_mlv)   = 1
       AND usim_mlv.get_planck_stable(p_usim_id_mlv) = 0
    THEN
      IF NVL(p_usim_planck_time_unit, 0) = 0
      THEN
        l_time := 1;
      ELSE
        l_time := ABS(p_usim_planck_time_unit);
      END IF;
      IF NVL(p_usim_planck_length_unit, 0) = 0
      THEN
        l_length := 1;
      ELSE
        l_length := ABS(p_usim_planck_length_unit);
      END IF;
      l_velocity := l_length / l_time;
      UPDATE usim_multiverse
         SET usim_planck_time_unit    = l_time
           , usim_planck_length_unit  = l_length
           , usim_planck_speed_unit   = l_velocity
       WHERE usim_id_mlv = p_usim_id_mlv
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_mlv.update_planck_unit_time_length', 'Used with not existing universe id [' || p_usim_id_mlv || '] or planck stable is set.');
      RETURN 0;
    END IF;
  END update_planck_unit_time_length
  ;

  FUNCTION update_planck_unit_speed_length( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
                                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
                                          , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
                                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                                         )
    RETURN NUMBER
  IS
    l_velocity  NUMBER;
    l_length    NUMBER;
    l_time      NUMBER;
  BEGIN
    IF     usim_mlv.has_data(p_usim_id_mlv)   = 1
       AND usim_mlv.get_planck_stable(p_usim_id_mlv) = 0
    THEN
      IF NVL(p_usim_planck_speed_unit, 0) = 0
      THEN
        l_velocity := 1;
      ELSE
        l_velocity := ABS(p_usim_planck_speed_unit);
      END IF;
      IF NVL(p_usim_planck_length_unit, 0) = 0
      THEN
        l_length := 1;
      ELSE
        l_length := ABS(p_usim_planck_length_unit);
      END IF;
      l_time := l_length / l_velocity;
      UPDATE usim_multiverse
         SET usim_planck_time_unit    = l_time
           , usim_planck_length_unit  = l_length
           , usim_planck_speed_unit   = l_velocity
       WHERE usim_id_mlv = p_usim_id_mlv
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_mlv.update_planck_unit_speed_length', 'Used with not existing universe id [' || p_usim_id_mlv || '] or planck stable is set.');
      RETURN 0;
    END IF;
  END update_planck_unit_speed_length
  ;

END usim_mlv;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_mlv
IS
  -- see header for documentation
  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_multiverse;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_base
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_multiverse WHERE usim_is_base_universe = 1;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_base
  ;

  FUNCTION is_base(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      SELECT usim_is_base_universe INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_mlv.is_base', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
      RETURN NULL;
    END IF;
  END is_base
  ;

  FUNCTION get_state(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN usim_multiverse.usim_universe_status%TYPE
  IS
    l_result usim_multiverse.usim_universe_status%TYPE;
  BEGIN
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      SELECT usim_universe_status INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_mlv.get_state', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
      RETURN NULL;
    END IF;
  END get_state
  ;

  FUNCTION get_planck_stable(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  IS
    l_result usim_multiverse.usim_planck_stable%TYPE;
  BEGIN
    l_result := -1;
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      SELECT usim_planck_stable INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
    ELSE
      usim_erl.log_error('usim_mlv.get_planck_stable', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
    END IF;
    RETURN l_result;
  END get_planck_stable
  ;

  FUNCTION get_ultimate_border(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN usim_multiverse.usim_ultimate_border%TYPE
  IS
    l_result usim_multiverse.usim_ultimate_border%TYPE;
  BEGIN
    l_result := -1;
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      SELECT usim_ultimate_border INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
    ELSE
      usim_erl.log_error('usim_mlv.get_ultimate_border', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
    END IF;
    RETURN l_result;
  END get_ultimate_border
  ;

  FUNCTION insert_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                          , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                          , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                          , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                          , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                          )
    RETURN usim_multiverse.usim_id_mlv%TYPE
  IS
    l_usim_energy_start_value usim_multiverse.usim_energy_start_value%TYPE;
    l_usim_planck_time_unit   usim_multiverse.usim_planck_time_unit%TYPE;
    l_usim_planck_length_unit usim_multiverse.usim_planck_length_unit%TYPE;
    l_usim_planck_speed_unit  usim_multiverse.usim_planck_speed_unit%TYPE;
    l_usim_planck_stable      usim_multiverse.usim_planck_stable%TYPE;
    l_usim_ultimate_border    usim_multiverse.usim_ultimate_border%TYPE;
    l_usim_is_base_universe   usim_multiverse.usim_is_base_universe%TYPE;
    l_usim_id_mlv             usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    l_usim_id_mlv := NULL;
    -- check value constraints and set defaults
    IF usim_mlv.has_base = 1
    THEN
      l_usim_is_base_universe := 0;
    ELSE
      l_usim_is_base_universe := 1;
    END IF;
    IF p_usim_ultimate_border IN (0, 1)
    THEN
      l_usim_ultimate_border := p_usim_ultimate_border;
    ELSE
      l_usim_ultimate_border := 1;
    END IF;
    IF p_usim_planck_stable IN (0, 1)
    THEN
      l_usim_planck_stable := p_usim_planck_stable;
    ELSE
      l_usim_planck_stable := 1;
    END IF;
    IF NVL(p_usim_planck_time_unit, 0) = 0
    THEN
      l_usim_planck_time_unit := 1;
    ELSE
      l_usim_planck_time_unit := ABS(p_usim_planck_time_unit);
    END IF;
    IF NVL(p_usim_planck_length_unit, 0) = 0
    THEN
      l_usim_planck_length_unit := 1;
    ELSE
      l_usim_planck_length_unit := ABS(p_usim_planck_length_unit);
    END IF;
    IF NVL(p_usim_planck_speed_unit, 0) = 0
    THEN
      l_usim_planck_speed_unit := 1;
    ELSE
      l_usim_planck_speed_unit := ABS(p_usim_planck_speed_unit);
    END IF;
    IF NVL(p_usim_energy_start_value, 0) = 0
    THEN
      l_usim_energy_start_value := 1;
    ELSE
      l_usim_energy_start_value := ABS(p_usim_energy_start_value);
    END IF;
    -- insert the found values
    INSERT INTO usim_multiverse
      ( usim_is_base_universe
      , usim_energy_start_value
      , usim_planck_time_unit
      , usim_planck_length_unit
      , usim_planck_speed_unit
      , usim_planck_stable
      , usim_ultimate_border
      )
      VALUES
      ( l_usim_is_base_universe
      , l_usim_energy_start_value
      , l_usim_planck_time_unit
      , l_usim_planck_length_unit
      , l_usim_planck_speed_unit
      , l_usim_planck_stable
      , l_usim_ultimate_border
      )
      RETURNING usim_id_mlv INTO l_usim_id_mlv
    ;
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN l_usim_id_mlv;
  END insert_universe
  ;

  FUNCTION update_state( p_usim_id_mlv          IN usim_multiverse.usim_id_mlv%TYPE
                       , p_usim_universe_status IN usim_multiverse.usim_universe_status%TYPE
                       , p_do_commit            IN BOOLEAN                                   DEFAULT TRUE
                       )
    RETURN usim_multiverse.usim_universe_status%TYPE
  IS
  BEGIN
    IF     usim_mlv.has_data(p_usim_id_mlv)  = 1
       AND p_usim_universe_status           IN ( usim_static.usim_multiverse_status_dead
                                               , usim_static.usim_multiverse_status_crashed
                                               , usim_static.usim_multiverse_status_active
                                               , usim_static.usim_multiverse_status_inactive
                                               )
    THEN
      UPDATE usim_multiverse
         SET usim_universe_status = p_usim_universe_status
       WHERE usim_id_mlv = p_usim_id_mlv
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN p_usim_universe_status;
    ELSE
      usim_erl.log_error('usim_mlv.update_state', 'Used with not existing universe id [' || p_usim_id_mlv || '] or wrong state [' || p_usim_universe_status || '].');
      RETURN NULL;
    END IF;
  END update_state
  ;

  FUNCTION update_planck_unit_time_speed( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
                                        , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
                                        , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
                                        , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                                        )
    RETURN NUMBER
  IS
    l_velocity  NUMBER;
    l_length    NUMBER;
    l_time      NUMBER;
  BEGIN
    IF     usim_mlv.has_data(p_usim_id_mlv)   = 1
       AND usim_mlv.get_planck_stable(p_usim_id_mlv) = 0
    THEN
      IF NVL(p_usim_planck_time_unit, 0) = 0
      THEN
        l_time := 1;
      ELSE
        l_time := ABS(p_usim_planck_time_unit);
      END IF;
      IF NVL(p_usim_planck_speed_unit, 0) = 0
      THEN
        l_velocity := 1;
      ELSE
        l_velocity := ABS(p_usim_planck_speed_unit);
      END IF;
      l_length := l_velocity * l_time;
      UPDATE usim_multiverse
         SET usim_planck_time_unit    = l_time
           , usim_planck_length_unit  = l_length
           , usim_planck_speed_unit   = l_velocity
       WHERE usim_id_mlv = p_usim_id_mlv
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_mlv.update_planck_unit_time_speed', 'Used with not existing universe id [' || p_usim_id_mlv || '] or planck stable is set.');
      RETURN 0;
    END IF;
  END update_planck_unit_time_speed
  ;

  FUNCTION update_planck_unit_time_length( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
                                         , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
                                         , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
                                         , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                                         )
    RETURN NUMBER
  IS
    l_velocity  NUMBER;
    l_length    NUMBER;
    l_time      NUMBER;
  BEGIN
    IF     usim_mlv.has_data(p_usim_id_mlv)   = 1
       AND usim_mlv.get_planck_stable(p_usim_id_mlv) = 0
    THEN
      IF NVL(p_usim_planck_time_unit, 0) = 0
      THEN
        l_time := 1;
      ELSE
        l_time := ABS(p_usim_planck_time_unit);
      END IF;
      IF NVL(p_usim_planck_length_unit, 0) = 0
      THEN
        l_length := 1;
      ELSE
        l_length := ABS(p_usim_planck_length_unit);
      END IF;
      l_velocity := l_length / l_time;
      UPDATE usim_multiverse
         SET usim_planck_time_unit    = l_time
           , usim_planck_length_unit  = l_length
           , usim_planck_speed_unit   = l_velocity
       WHERE usim_id_mlv = p_usim_id_mlv
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_mlv.update_planck_unit_time_length', 'Used with not existing universe id [' || p_usim_id_mlv || '] or planck stable is set.');
      RETURN 0;
    END IF;
  END update_planck_unit_time_length
  ;

  FUNCTION update_planck_unit_speed_length( p_usim_id_mlv             IN usim_multiverse.usim_id_mlv%TYPE
                                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
                                          , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
                                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                                         )
    RETURN NUMBER
  IS
    l_velocity  NUMBER;
    l_length    NUMBER;
    l_time      NUMBER;
  BEGIN
    IF     usim_mlv.has_data(p_usim_id_mlv)   = 1
       AND usim_mlv.get_planck_stable(p_usim_id_mlv) = 0
    THEN
      IF NVL(p_usim_planck_speed_unit, 0) = 0
      THEN
        l_velocity := 1;
      ELSE
        l_velocity := ABS(p_usim_planck_speed_unit);
      END IF;
      IF NVL(p_usim_planck_length_unit, 0) = 0
      THEN
        l_length := 1;
      ELSE
        l_length := ABS(p_usim_planck_length_unit);
      END IF;
      l_time := l_length / l_velocity;
      UPDATE usim_multiverse
         SET usim_planck_time_unit    = l_time
           , usim_planck_length_unit  = l_length
           , usim_planck_speed_unit   = l_velocity
       WHERE usim_id_mlv = p_usim_id_mlv
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_mlv.update_planck_unit_speed_length', 'Used with not existing universe id [' || p_usim_id_mlv || '] or planck stable is set.');
      RETURN 0;
    END IF;
  END update_planck_unit_speed_length
  ;

END usim_mlv;

Package Body USIM_MLV kompiliert

SQL> -- USIM_POSITION (pos)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_POSITION_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_POSITION still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_POSITION'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_POSITION_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_POSITION still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_POSITION'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_POSITION_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_POSITION still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_POSITION'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------------
../TABLES/USIM_POSITION_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_POSITION (pos)
SQL> CREATE TABLE &USIM_SCHEMA..usim_position
  2    ( usim_id_pos     CHAR(55)      NOT NULL ENABLE
  3    , usim_coordinate NUMBER        NOT NULL ENABLE
  4    )
  5  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_position
  ( usim_id_pos     CHAR(55)      NOT NULL ENABLE
  , usim_coordinate NUMBER        NOT NULL ENABLE
  )

neu:CREATE TABLE USIM_TEST.usim_position
  ( usim_id_pos     CHAR(55)      NOT NULL ENABLE
  , usim_coordinate NUMBER        NOT NULL ENABLE
  )

Table USIM_TEST.USIM_POSITION erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_position IS 'A table holding the possible coordinates for reuse by different universes. Will use the alias pos.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_position IS 'A table holding the possible coordinates for reuse by different universes. Will use the alias pos.'
neu:COMMENT ON TABLE USIM_TEST.usim_position IS 'A table holding the possible coordinates for reuse by different universes. Will use the alias pos.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_position.usim_id_pos IS 'The unique id of the coordinate. Automatically set, update not allowed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_position.usim_id_pos IS 'The unique id of the coordinate. Automatically set, update not allowed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_position.usim_id_pos IS 'The unique id of the coordinate. Automatically set, update not allowed.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_position.usim_coordinate IS 'The coordinate value between -max and +max of available number space. Must be set on insert, update not allowed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_position.usim_coordinate IS 'The coordinate value between -max and +max of available number space. Must be set on insert, update not allowed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_position.usim_coordinate IS 'The coordinate value between -max and +max of available number space. Must be set on insert, update not allowed.'

Comment erstellt.

SQL>
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_position
  2    ADD CONSTRAINT usim_pos_pk
  3    PRIMARY KEY (usim_id_pos)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_position
  ADD CONSTRAINT usim_pos_pk
  PRIMARY KEY (usim_id_pos)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_position
  ADD CONSTRAINT usim_pos_pk
  PRIMARY KEY (usim_id_pos)
  ENABLE

Table USIM_TEST.USIM_POSITION geändert.

SQL>
SQL> -- uk
SQL> ALTER TABLE &USIM_SCHEMA..usim_position
  2    ADD CONSTRAINT usim_pos_uk
  3    UNIQUE (usim_coordinate)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_position
  ADD CONSTRAINT usim_pos_uk
  UNIQUE (usim_coordinate)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_position
  ADD CONSTRAINT usim_pos_uk
  UNIQUE (usim_coordinate)
  ENABLE

Table USIM_TEST.USIM_POSITION geändert.

SQL>
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_pos_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_position
  3      FOR EACH ROW
  4      BEGIN
  5        -- verify insert value
  6        IF ABS(:NEW.usim_coordinate) > usim_base.get_abs_max_number
  7        THEN
  8          RAISE_APPLICATION_ERROR( num => -20000
  9                                 , msg => 'Insert requirement not fulfilled. Absolute coordinate must be >= 0 and <= usim_base.get_abs_max_number.'
 10                                 )
 11          ;
 12        END IF;
 13        -- ignore input on pk
 14        :NEW.usim_id_pos := usim_static.get_big_pk(usim_pos_id_seq.NEXTVAL);
 15      END;
 16  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_pos_ins_trg
  BEFORE INSERT ON &USIM_SCHEMA..usim_position
    FOR EACH ROW
    BEGIN
      -- verify insert value
      IF ABS(:NEW.usim_coordinate) > usim_base.get_abs_max_number
      THEN
        RAISE_APPLICATION_ERROR( num => -20000
                               , msg => 'Insert requirement not fulfilled. Absolute coordinate must be >= 0 and <= usim_base.get_abs_max_number.'
                               )
        ;
      END IF;
      -- ignore input on pk
      :NEW.usim_id_pos := usim_static.get_big_pk(usim_pos_id_seq.NEXTVAL);
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_pos_ins_trg
  BEFORE INSERT ON USIM_TEST.usim_position
    FOR EACH ROW
    BEGIN
      -- verify insert value
      IF ABS(:NEW.usim_coordinate) > usim_base.get_abs_max_number
      THEN
        RAISE_APPLICATION_ERROR( num => -20000
                               , msg => 'Insert requirement not fulfilled. Absolute coordinate must be >= 0 and <= usim_base.get_abs_max_number.'
                               )
        ;
      END IF;
      -- ignore input on pk
      :NEW.usim_id_pos := usim_static.get_big_pk(usim_pos_id_seq.NEXTVAL);
    END;

Trigger USIM_POS_INS_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_pos_ins_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_pos_ins_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_pos_ins_trg ENABLE

Trigger USIM_TEST.USIM_POS_INS_TRG geändert.

SQL>
SQL> -- update trigger to prevent updates
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_pos_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_position
  3      FOR EACH ROW
  4      BEGIN
  5        RAISE_APPLICATION_ERROR( num => -20001
  6                               , msg => 'Update requirement not fulfilled. No update allowed.'
  7                               )
  8        ;
  9      END;
 10  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_pos_upd_trg
  BEFORE UPDATE ON &USIM_SCHEMA..usim_position
    FOR EACH ROW
    BEGIN
      RAISE_APPLICATION_ERROR( num => -20001
                             , msg => 'Update requirement not fulfilled. No update allowed.'
                             )
      ;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_pos_upd_trg
  BEFORE UPDATE ON USIM_TEST.usim_position
    FOR EACH ROW
    BEGIN
      RAISE_APPLICATION_ERROR( num => -20001
                             , msg => 'Update requirement not fulfilled. No update allowed.'
                             )
      ;
    END;

Trigger USIM_POS_UPD_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_pos_upd_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_pos_upd_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_pos_upd_trg ENABLE

Trigger USIM_TEST.USIM_POS_UPD_TRG geändert.

SQL> -- usim_position package
SQL> @@../PACKAGES/USIM_POS.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_pos
  2  IS
  3    /**A low level package for actions on table usim_position and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9
 10    /**
 11    * Checks if usim_position has already data.
 12    * @return Returns 1 if data are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15      RETURN NUMBER
 16    ;
 17
 18    /**
 19    * Checks if usim_position has the given position id.
 20    * @param p_usim_id_pos The position id to verify.
 21    * @return Returns 1 if position id exists, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 24      RETURN NUMBER
 25    ;
 26
 27    /**
 28    * Checks if usim_position has the given position.
 29    * @param p_usim_coordinate The position coordinate to verify.
 30    * @return Returns 1 if position exists, otherwise 0.
 31    */
 32    FUNCTION has_data(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
 33      RETURN NUMBER
 34    ;
 35
 36    /**
 37    * Checks if usim_position has all coordinates for a dimension axis volume (line). For a given position the next position with
 38    * distance 1 must be available in positive and negative number space, e.g. +1, +2, -1, -2.
 39    * Coordinates are calculated by given ABS(coordinate).
 40    * @param p_usim_coordinate The coordinate for the start value with a positive sign of a volume. Always interpreted as positive value.
 41    * @return Returns 1 if dimension axis volume positions exist, otherwise 0.
 42    */
 43    FUNCTION has_dim_pair(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
 44      RETURN NUMBER
 45    ;
 46
 47    /**
 48    * Checks if usim_position has all coordinates for a dimension axis volume (line). For a given position the next position with
 49    * distance 1 must be available in positive and negative number space, e.g. +1, +2, -1, -2.
 50    * Coordinates are calculated by given ABS(coordinate).
 51    * @param p_usim_id_pos The coordinate id for the from value with a positive sign of a volume. Always interpreted as positive coordinate value.
 52    * @return Returns 1 if dimension axis volume positions exist, otherwise 0.
 53    */
 54    FUNCTION has_dim_pair(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 55      RETURN NUMBER
 56    ;
 57
 58    /**
 59    * Gets the maximum coordinate for a given sign.
 60    * @param p_sign The sign of the max coordinate (1, -1). Position 0 is always included in both number spaces.
 61    * @return Returns max usim_coordinate for given sign or NULL if no coordinates exists or wrong sign.
 62    */
 63    FUNCTION get_max_coordinate(p_sign IN NUMBER DEFAULT 1)
 64      RETURN usim_position.usim_coordinate%TYPE
 65    ;
 66
 67    /**
 68    * Gets the coordinate for a given position id.
 69    * @param p_usim_id_pos The position id to get the coordinate for.
 70    * @return Returns usim_coordinate for given id or NULL if position id does not exists.
 71    */
 72    FUNCTION get_coordinate(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 73      RETURN usim_position.usim_coordinate%TYPE
 74    ;
 75
 76    /**
 77    * Gets the sign of the coordinate for a given position id.
 78    * @param p_usim_id_pos The position id to get the sign of the coordinate for.
 79    * @return Returns the sign of the coordinate for a given id or NULL if position id does not exists.
 80    */
 81    FUNCTION get_coord_sign(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 82      RETURN NUMBER
 83    ;
 84
 85    /**
 86    * Gets the position id for a given coordinate.
 87    * @param p_usim_coordinate The coordinate to get the position id for.
 88    * @return Returns usim_id_pos for given coordinate or NULL if coordinate with sign does not exists.
 89    */
 90    FUNCTION get_id_pos(p_usim_coordinate  IN usim_position.usim_coordinate%TYPE)
 91      RETURN usim_position.usim_id_pos%TYPE
 92    ;
 93
 94    /**
 95    * Retrieve the related to position id with the same sign for a given from position id, if the dimension axis volume to position
 96    * exists. Special situation 0, with sign zero which has two possible relations.
 97    * @param p_usim_id_pos The supposed from coordinate id.
 98    * @param p_zero_sign Only used for coordinate zero to decide, which relation to retrieve. Only -1 or +1 allowed if used. Default 1.
 99    * @return Returns the dimension axis volume to position id with the same sign, if it exists, otherwise NULL.
100    */
101    FUNCTION get_dim_pos_rel( p_usim_id_pos IN usim_position.usim_id_pos%TYPE
102                            , p_zero_sign   IN NUMBER                         DEFAULT 1
103                            )
104      RETURN usim_position.usim_id_pos%TYPE
105    ;
106
107    /**
108    * Retrieve the position id with the opposite sign for a given position id, if the position
109    * exists. Special situation 0, as the opposite of zero is 0.
110    * @param p_usim_id_pos The coordinate id to get the mirror for.
111    * @return Returns the mirror position id with the opposite sign, if it exists, otherwise NULL.
112    */
113    FUNCTION get_pos_mirror(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
114      RETURN usim_position.usim_id_pos%TYPE
115    ;
116
117    /**
118    * Inserts a new coordinate if it does not exist.
119    * @param p_usim_coordinate The coordinate to insert.
120    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use). Should be given to avoid signature conflicts.
121    * @return Returns the new/existing position id for the coordinate or NULL if insert fails.
122    */
123    FUNCTION insert_position( p_usim_coordinate IN usim_position.usim_coordinate%TYPE
124                            , p_do_commit       IN BOOLEAN                            DEFAULT TRUE
125                            )
126      RETURN usim_position.usim_id_pos%TYPE
127    ;
128
129    /**
130    * Creates all coordinates including given max coordinate. Inserts positive and negative coordinates.
131    * Can be used to initialize the available positions for a multiverse.
132    * @param p_max_coordinate The maximum coordinate to insert. Valid for positive and negative numbers.
133    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
134    * @return Returns 1 one success 0 on errors.
135    */
136    FUNCTION init_positions( p_max_coordinate IN usim_position.usim_coordinate%TYPE
137                           , p_do_commit      IN BOOLEAN                            DEFAULT TRUE
138                           )
139      RETURN NUMBER
140    ;
141
142  END usim_pos;
143  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_pos
IS
  /**A low level package for actions on table usim_position and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_position has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_position has the given position id.
  * @param p_usim_id_pos The position id to verify.
  * @return Returns 1 if position id exists, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_position has the given position.
  * @param p_usim_coordinate The position coordinate to verify.
  * @return Returns 1 if position exists, otherwise 0.
  */
  FUNCTION has_data(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_position has all coordinates for a dimension axis volume (line). For a given position the next position with
  * distance 1 must be available in positive and negative number space, e.g. +1, +2, -1, -2.
  * Coordinates are calculated by given ABS(coordinate).
  * @param p_usim_coordinate The coordinate for the start value with a positive sign of a volume. Always interpreted as positive value.
  * @return Returns 1 if dimension axis volume positions exist, otherwise 0.
  */
  FUNCTION has_dim_pair(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_position has all coordinates for a dimension axis volume (line). For a given position the next position with
  * distance 1 must be available in positive and negative number space, e.g. +1, +2, -1, -2.
  * Coordinates are calculated by given ABS(coordinate).
  * @param p_usim_id_pos The coordinate id for the from value with a positive sign of a volume. Always interpreted as positive coordinate value.
  * @return Returns 1 if dimension axis volume positions exist, otherwise 0.
  */
  FUNCTION has_dim_pair(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the maximum coordinate for a given sign.
  * @param p_sign The sign of the max coordinate (1, -1). Position 0 is always included in both number spaces.
  * @return Returns max usim_coordinate for given sign or NULL if no coordinates exists or wrong sign.
  */
  FUNCTION get_max_coordinate(p_sign IN NUMBER DEFAULT 1)
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Gets the coordinate for a given position id.
  * @param p_usim_id_pos The position id to get the coordinate for.
  * @return Returns usim_coordinate for given id or NULL if position id does not exists.
  */
  FUNCTION get_coordinate(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Gets the sign of the coordinate for a given position id.
  * @param p_usim_id_pos The position id to get the sign of the coordinate for.
  * @return Returns the sign of the coordinate for a given id or NULL if position id does not exists.
  */
  FUNCTION get_coord_sign(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the position id for a given coordinate.
  * @param p_usim_coordinate The coordinate to get the position id for.
  * @return Returns usim_id_pos for given coordinate or NULL if coordinate with sign does not exists.
  */
  FUNCTION get_id_pos(p_usim_coordinate  IN usim_position.usim_coordinate%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Retrieve the related to position id with the same sign for a given from position id, if the dimension axis volume to position
  * exists. Special situation 0, with sign zero which has two possible relations.
  * @param p_usim_id_pos The supposed from coordinate id.
  * @param p_zero_sign Only used for coordinate zero to decide, which relation to retrieve. Only -1 or +1 allowed if used. Default 1.
  * @return Returns the dimension axis volume to position id with the same sign, if it exists, otherwise NULL.
  */
  FUNCTION get_dim_pos_rel( p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                          , p_zero_sign   IN NUMBER                         DEFAULT 1
                          )
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Retrieve the position id with the opposite sign for a given position id, if the position
  * exists. Special situation 0, as the opposite of zero is 0.
  * @param p_usim_id_pos The coordinate id to get the mirror for.
  * @return Returns the mirror position id with the opposite sign, if it exists, otherwise NULL.
  */
  FUNCTION get_pos_mirror(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Inserts a new coordinate if it does not exist.
  * @param p_usim_coordinate The coordinate to insert.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use). Should be given to avoid signature conflicts.
  * @return Returns the new/existing position id for the coordinate or NULL if insert fails.
  */
  FUNCTION insert_position( p_usim_coordinate IN usim_position.usim_coordinate%TYPE
                          , p_do_commit       IN BOOLEAN                            DEFAULT TRUE
                          )
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Creates all coordinates including given max coordinate. Inserts positive and negative coordinates.
  * Can be used to initialize the available positions for a multiverse.
  * @param p_max_coordinate The maximum coordinate to insert. Valid for positive and negative numbers.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 one success 0 on errors.
  */
  FUNCTION init_positions( p_max_coordinate IN usim_position.usim_coordinate%TYPE
                         , p_do_commit      IN BOOLEAN                            DEFAULT TRUE
                         )
    RETURN NUMBER
  ;

END usim_pos;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_pos
IS
  /**A low level package for actions on table usim_position and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_position has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_position has the given position id.
  * @param p_usim_id_pos The position id to verify.
  * @return Returns 1 if position id exists, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_position has the given position.
  * @param p_usim_coordinate The position coordinate to verify.
  * @return Returns 1 if position exists, otherwise 0.
  */
  FUNCTION has_data(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_position has all coordinates for a dimension axis volume (line). For a given position the next position with
  * distance 1 must be available in positive and negative number space, e.g. +1, +2, -1, -2.
  * Coordinates are calculated by given ABS(coordinate).
  * @param p_usim_coordinate The coordinate for the start value with a positive sign of a volume. Always interpreted as positive value.
  * @return Returns 1 if dimension axis volume positions exist, otherwise 0.
  */
  FUNCTION has_dim_pair(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_position has all coordinates for a dimension axis volume (line). For a given position the next position with
  * distance 1 must be available in positive and negative number space, e.g. +1, +2, -1, -2.
  * Coordinates are calculated by given ABS(coordinate).
  * @param p_usim_id_pos The coordinate id for the from value with a positive sign of a volume. Always interpreted as positive coordinate value.
  * @return Returns 1 if dimension axis volume positions exist, otherwise 0.
  */
  FUNCTION has_dim_pair(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the maximum coordinate for a given sign.
  * @param p_sign The sign of the max coordinate (1, -1). Position 0 is always included in both number spaces.
  * @return Returns max usim_coordinate for given sign or NULL if no coordinates exists or wrong sign.
  */
  FUNCTION get_max_coordinate(p_sign IN NUMBER DEFAULT 1)
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Gets the coordinate for a given position id.
  * @param p_usim_id_pos The position id to get the coordinate for.
  * @return Returns usim_coordinate for given id or NULL if position id does not exists.
  */
  FUNCTION get_coordinate(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Gets the sign of the coordinate for a given position id.
  * @param p_usim_id_pos The position id to get the sign of the coordinate for.
  * @return Returns the sign of the coordinate for a given id or NULL if position id does not exists.
  */
  FUNCTION get_coord_sign(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the position id for a given coordinate.
  * @param p_usim_coordinate The coordinate to get the position id for.
  * @return Returns usim_id_pos for given coordinate or NULL if coordinate with sign does not exists.
  */
  FUNCTION get_id_pos(p_usim_coordinate  IN usim_position.usim_coordinate%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Retrieve the related to position id with the same sign for a given from position id, if the dimension axis volume to position
  * exists. Special situation 0, with sign zero which has two possible relations.
  * @param p_usim_id_pos The supposed from coordinate id.
  * @param p_zero_sign Only used for coordinate zero to decide, which relation to retrieve. Only -1 or +1 allowed if used. Default 1.
  * @return Returns the dimension axis volume to position id with the same sign, if it exists, otherwise NULL.
  */
  FUNCTION get_dim_pos_rel( p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                          , p_zero_sign   IN NUMBER                         DEFAULT 1
                          )
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Retrieve the position id with the opposite sign for a given position id, if the position
  * exists. Special situation 0, as the opposite of zero is 0.
  * @param p_usim_id_pos The coordinate id to get the mirror for.
  * @return Returns the mirror position id with the opposite sign, if it exists, otherwise NULL.
  */
  FUNCTION get_pos_mirror(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Inserts a new coordinate if it does not exist.
  * @param p_usim_coordinate The coordinate to insert.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use). Should be given to avoid signature conflicts.
  * @return Returns the new/existing position id for the coordinate or NULL if insert fails.
  */
  FUNCTION insert_position( p_usim_coordinate IN usim_position.usim_coordinate%TYPE
                          , p_do_commit       IN BOOLEAN                            DEFAULT TRUE
                          )
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Creates all coordinates including given max coordinate. Inserts positive and negative coordinates.
  * Can be used to initialize the available positions for a multiverse.
  * @param p_max_coordinate The maximum coordinate to insert. Valid for positive and negative numbers.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 one success 0 on errors.
  */
  FUNCTION init_positions( p_max_coordinate IN usim_position.usim_coordinate%TYPE
                         , p_do_commit      IN BOOLEAN                            DEFAULT TRUE
                         )
    RETURN NUMBER
  ;

END usim_pos;

Package USIM_POS kompiliert

SQL> @@../PACKAGES/USIM_POS.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_pos
  2  IS
  3    -- see header for documentation
  4
  5    FUNCTION has_data
  6      RETURN NUMBER
  7    IS
  8      l_result NUMBER;
  9    BEGIN
 10      SELECT COUNT(*) INTO l_result FROM usim_position;
 11      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 12    END has_data
 13    ;
 14
 15    FUNCTION has_data(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 16      RETURN NUMBER
 17    IS
 18      l_result NUMBER;
 19    BEGIN
 20      SELECT COUNT(*) INTO l_result FROM usim_position WHERE usim_id_pos = p_usim_id_pos;
 21      RETURN l_result;
 22    END has_data
 23    ;
 24
 25    FUNCTION has_data(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
 26      RETURN NUMBER
 27    IS
 28      l_result NUMBER;
 29    BEGIN
 30      SELECT COUNT(*) INTO l_result FROM usim_position WHERE usim_coordinate = p_usim_coordinate;
 31      RETURN l_result;
 32    END has_data
 33    ;
 34
 35    FUNCTION has_dim_pair(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
 36      RETURN NUMBER
 37    IS
 38    BEGIN
 39      IF      usim_pos.has_data(ABS(p_usim_coordinate))            = 1
 40         AND  usim_pos.has_data(ABS(p_usim_coordinate) + 1)        = 1
 41         AND  usim_pos.has_data(ABS(p_usim_coordinate) * -1)       = 1
 42         AND  usim_pos.has_data((ABS(p_usim_coordinate) + 1) * -1) = 1
 43      THEN
 44        RETURN 1;
 45      ELSE
 46        RETURN 0;
 47      END IF;
 48    END has_dim_pair
 49    ;
 50
 51    FUNCTION has_dim_pair(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 52      RETURN NUMBER
 53    IS
 54    BEGIN
 55      RETURN usim_pos.has_dim_pair(usim_pos.get_coordinate(p_usim_id_pos));
 56    END has_dim_pair
 57    ;
 58
 59    FUNCTION get_max_coordinate(p_sign IN NUMBER DEFAULT 1)
 60      RETURN usim_position.usim_coordinate%TYPE
 61    IS
 62      l_result  usim_position.usim_coordinate%TYPE;
 63    BEGIN
 64      IF     usim_pos.has_data = 1
 65         AND p_sign           IN (1, -1)
 66      THEN
 67        IF p_sign > 0
 68        THEN
 69          SELECT MAX(usim_coordinate) INTO l_result FROM usim_position WHERE SIGN(usim_coordinate) IN (0, 1);
 70        ELSE
 71          SELECT MIN(usim_coordinate) INTO l_result FROM usim_position WHERE SIGN(usim_coordinate) IN (0, -1);
 72        END IF;
 73        RETURN l_result;
 74      ELSE
 75        usim_erl.log_error('usim_pos.get_max_coordinate', 'Used without position data or wrong sign [' || p_sign || '].');
 76        RETURN NULL;
 77      END IF;
 78    END get_max_coordinate
 79    ;
 80
 81    FUNCTION get_coordinate(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 82      RETURN usim_position.usim_coordinate%TYPE
 83    IS
 84      l_result usim_position.usim_coordinate%TYPE;
 85    BEGIN
 86      IF usim_pos.has_data(p_usim_id_pos) = 1
 87      THEN
 88        SELECT usim_coordinate INTO l_result FROM usim_position WHERE usim_id_pos = p_usim_id_pos;
 89        RETURN l_result;
 90      ELSE
 91        usim_erl.log_error('usim_pos.get_coordinate', 'Used with not existing pos id [' || p_usim_id_pos || '].');
 92        RETURN NULL;
 93      END IF;
 94    END get_coordinate
 95    ;
 96
 97    FUNCTION get_coord_sign(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 98      RETURN NUMBER
 99    IS
100      l_result INTEGER;
101    BEGIN
102      IF usim_pos.has_data(p_usim_id_pos) = 1
103      THEN
104        SELECT SIGN(usim_coordinate) INTO l_result FROM usim_position WHERE usim_id_pos = p_usim_id_pos;
105        RETURN l_result;
106      ELSE
107        usim_erl.log_error('usim_pos.get_coord_sign', 'Used with not existing pos id [' || p_usim_id_pos || '].');
108        RETURN NULL;
109      END IF;
110    END get_coord_sign
111    ;
112
113    FUNCTION get_id_pos(p_usim_coordinate  IN usim_position.usim_coordinate%TYPE)
114      RETURN usim_position.usim_id_pos%TYPE
115    IS
116      l_result  usim_position.usim_id_pos%TYPE;
117    BEGIN
118      IF usim_pos.has_data(p_usim_coordinate) = 1
119      THEN
120        SELECT usim_id_pos INTO l_result FROM usim_position WHERE usim_coordinate = p_usim_coordinate;
121        RETURN l_result;
122      ELSE
123        usim_erl.log_error('usim_pos.get_id_pos', 'Used with not existing coordinate [' || p_usim_coordinate || '].');
124        RETURN NULL;
125      END IF;
126    END get_id_pos
127    ;
128
129    FUNCTION get_dim_pos_rel( p_usim_id_pos IN usim_position.usim_id_pos%TYPE
130                            , p_zero_sign   IN NUMBER                         DEFAULT 1
131                            )
132      RETURN usim_position.usim_id_pos%TYPE
133    IS
134      l_sign   NUMBER;
135      l_coord  usim_position.usim_coordinate%TYPE;
136      l_result usim_position.usim_id_pos%TYPE;
137    BEGIN
138      IF      usim_pos.has_dim_pair(p_usim_id_pos) = 1
139         AND  p_zero_sign                         IN (1, -1)
140      THEN
141        l_sign  := usim_pos.get_coord_sign(p_usim_id_pos);
142        l_coord := usim_pos.get_coordinate(p_usim_id_pos);
143        -- handle sign by position
144        IF l_sign = 1
145        THEN
146          l_result := usim_pos.get_id_pos(l_coord + 1);
147        ELSIF l_sign = -1
148        THEN
149          l_result := usim_pos.get_id_pos(l_coord - 1);
150        ELSE
151          -- zero case
152          l_result := usim_pos.get_id_pos(p_zero_sign);
153        END IF;
154        RETURN l_result;
155      ELSE
156        usim_erl.log_error('usim_pos.get_vol_pos_rel', 'Position id has no dimension axis volume to position [' || p_usim_id_pos || '] or wrong zero sign [' || p_zero_sign || '].');
157        RETURN NULL;
158      END IF;
159    END get_dim_pos_rel
160    ;
161
162    FUNCTION get_pos_mirror(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
163      RETURN usim_position.usim_id_pos%TYPE
164    IS
165      l_coord  usim_position.usim_coordinate%TYPE;
166      l_result usim_position.usim_id_pos%TYPE;
167    BEGIN
168      IF usim_pos.has_data(p_usim_id_pos) = 1
169      THEN
170        l_coord  := usim_pos.get_coordinate(p_usim_id_pos) * -1;
171        IF usim_pos.has_data(l_coord) = 1
172        THEN
173          l_result := usim_pos.get_id_pos(l_coord);
174          RETURN l_result;
175        ELSE
176          usim_erl.log_error('usim_pos.get_pos_mirror', 'Position id does not exist for coordinate [' || l_coord || '].');
177          RETURN NULL;
178        END IF;
179      ELSE
180        usim_erl.log_error('usim_pos.get_pos_mirror', 'Position id does not exist [' || p_usim_id_pos || '].');
181        RETURN NULL;
182      END IF;
183    END get_pos_mirror
184    ;
185
186    FUNCTION insert_position( p_usim_coordinate IN usim_position.usim_coordinate%TYPE
187                            , p_do_commit       IN BOOLEAN                            DEFAULT TRUE
188                            )
189      RETURN usim_position.usim_id_pos%TYPE
190    IS
191      l_result          usim_position.usim_id_pos%TYPE;
192    BEGIN
193      IF usim_pos.has_data(p_usim_coordinate) = 1
194      THEN
195        RETURN usim_pos.get_id_pos(p_usim_coordinate);
196      ELSIF p_usim_coordinate IS NOT NULL
197      THEN
198        INSERT INTO usim_position (usim_coordinate) VALUES (p_usim_coordinate) RETURNING usim_id_pos INTO l_result;
199        IF p_do_commit
200        THEN
201          COMMIT;
202        END IF;
203        RETURN l_result;
204      ELSE
205        usim_erl.log_error('usim_pos.insert_position', 'Used with invalid position coordinate [' || p_usim_coordinate || '].');
206        RETURN NULL;
207      END IF;
208    END insert_position
209    ;
210
211    FUNCTION init_positions( p_max_coordinate IN usim_position.usim_coordinate%TYPE
212                           , p_do_commit      IN BOOLEAN                            DEFAULT TRUE
213                           )
214      RETURN NUMBER
215    IS
216      l_usim_id_pos usim_position.usim_id_pos%TYPE;
217    BEGIN
218      IF p_max_coordinate IS NULL
219      THEN
220        usim_erl.log_error('usim_dim.init_positions', 'Used with invalid max position [' || p_max_coordinate || '].');
221        RETURN 0;
222      END IF;
223      FOR l_pos IN 0..ABS(p_max_coordinate)
224      LOOP
225        l_usim_id_pos := usim_pos.insert_position(l_pos, p_do_commit);
226        IF l_usim_id_pos IS NULL
227        THEN
228          usim_erl.log_error('usim_dim.init_positions', 'Error inserting position [' || l_pos || '].');
229          RETURN 0;
230        END IF;
231        IF l_pos != 0
232        THEN
233          -- insert negative value
234          l_usim_id_pos := usim_pos.insert_position(-l_pos, p_do_commit);
235          IF l_usim_id_pos IS NULL
236          THEN
237            usim_erl.log_error('usim_dim.init_positions', 'Error inserting position [' || -l_pos || '].');
238            RETURN 0;
239          END IF;
240        END IF;
241      END LOOP;
242      RETURN 1;
243    END init_positions
244    ;
245
246  END usim_pos;
247  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_pos
IS
  -- see header for documentation

  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_position;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_position WHERE usim_id_pos = p_usim_id_pos;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_data(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_position WHERE usim_coordinate = p_usim_coordinate;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_dim_pair(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    IF      usim_pos.has_data(ABS(p_usim_coordinate))            = 1
       AND  usim_pos.has_data(ABS(p_usim_coordinate) + 1)        = 1
       AND  usim_pos.has_data(ABS(p_usim_coordinate) * -1)       = 1
       AND  usim_pos.has_data((ABS(p_usim_coordinate) + 1) * -1) = 1
    THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  END has_dim_pair
  ;

  FUNCTION has_dim_pair(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    RETURN usim_pos.has_dim_pair(usim_pos.get_coordinate(p_usim_id_pos));
  END has_dim_pair
  ;

  FUNCTION get_max_coordinate(p_sign IN NUMBER DEFAULT 1)
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_result  usim_position.usim_coordinate%TYPE;
  BEGIN
    IF     usim_pos.has_data = 1
       AND p_sign           IN (1, -1)
    THEN
      IF p_sign > 0
      THEN
        SELECT MAX(usim_coordinate) INTO l_result FROM usim_position WHERE SIGN(usim_coordinate) IN (0, 1);
      ELSE
        SELECT MIN(usim_coordinate) INTO l_result FROM usim_position WHERE SIGN(usim_coordinate) IN (0, -1);
      END IF;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_pos.get_max_coordinate', 'Used without position data or wrong sign [' || p_sign || '].');
      RETURN NULL;
    END IF;
  END get_max_coordinate
  ;

  FUNCTION get_coordinate(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_result usim_position.usim_coordinate%TYPE;
  BEGIN
    IF usim_pos.has_data(p_usim_id_pos) = 1
    THEN
      SELECT usim_coordinate INTO l_result FROM usim_position WHERE usim_id_pos = p_usim_id_pos;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_pos.get_coordinate', 'Used with not existing pos id [' || p_usim_id_pos || '].');
      RETURN NULL;
    END IF;
  END get_coordinate
  ;

  FUNCTION get_coord_sign(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN NUMBER
  IS
    l_result INTEGER;
  BEGIN
    IF usim_pos.has_data(p_usim_id_pos) = 1
    THEN
      SELECT SIGN(usim_coordinate) INTO l_result FROM usim_position WHERE usim_id_pos = p_usim_id_pos;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_pos.get_coord_sign', 'Used with not existing pos id [' || p_usim_id_pos || '].');
      RETURN NULL;
    END IF;
  END get_coord_sign
  ;

  FUNCTION get_id_pos(p_usim_coordinate  IN usim_position.usim_coordinate%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_result  usim_position.usim_id_pos%TYPE;
  BEGIN
    IF usim_pos.has_data(p_usim_coordinate) = 1
    THEN
      SELECT usim_id_pos INTO l_result FROM usim_position WHERE usim_coordinate = p_usim_coordinate;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_pos.get_id_pos', 'Used with not existing coordinate [' || p_usim_coordinate || '].');
      RETURN NULL;
    END IF;
  END get_id_pos
  ;

  FUNCTION get_dim_pos_rel( p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                          , p_zero_sign   IN NUMBER                         DEFAULT 1
                          )
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_sign   NUMBER;
    l_coord  usim_position.usim_coordinate%TYPE;
    l_result usim_position.usim_id_pos%TYPE;
  BEGIN
    IF      usim_pos.has_dim_pair(p_usim_id_pos) = 1
       AND  p_zero_sign                         IN (1, -1)
    THEN
      l_sign  := usim_pos.get_coord_sign(p_usim_id_pos);
      l_coord := usim_pos.get_coordinate(p_usim_id_pos);
      -- handle sign by position
      IF l_sign = 1
      THEN
        l_result := usim_pos.get_id_pos(l_coord + 1);
      ELSIF l_sign = -1
      THEN
        l_result := usim_pos.get_id_pos(l_coord - 1);
      ELSE
        -- zero case
        l_result := usim_pos.get_id_pos(p_zero_sign);
      END IF;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_pos.get_vol_pos_rel', 'Position id has no dimension axis volume to position [' || p_usim_id_pos || '] or wrong zero sign [' || p_zero_sign || '].');
      RETURN NULL;
    END IF;
  END get_dim_pos_rel
  ;

  FUNCTION get_pos_mirror(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_coord  usim_position.usim_coordinate%TYPE;
    l_result usim_position.usim_id_pos%TYPE;
  BEGIN
    IF usim_pos.has_data(p_usim_id_pos) = 1
    THEN
      l_coord  := usim_pos.get_coordinate(p_usim_id_pos) * -1;
      IF usim_pos.has_data(l_coord) = 1
      THEN
        l_result := usim_pos.get_id_pos(l_coord);
        RETURN l_result;
      ELSE
        usim_erl.log_error('usim_pos.get_pos_mirror', 'Position id does not exist for coordinate [' || l_coord || '].');
        RETURN NULL;
      END IF;
    ELSE
      usim_erl.log_error('usim_pos.get_pos_mirror', 'Position id does not exist [' || p_usim_id_pos || '].');
      RETURN NULL;
    END IF;
  END get_pos_mirror
  ;

  FUNCTION insert_position( p_usim_coordinate IN usim_position.usim_coordinate%TYPE
                          , p_do_commit       IN BOOLEAN                            DEFAULT TRUE
                          )
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_result          usim_position.usim_id_pos%TYPE;
  BEGIN
    IF usim_pos.has_data(p_usim_coordinate) = 1
    THEN
      RETURN usim_pos.get_id_pos(p_usim_coordinate);
    ELSIF p_usim_coordinate IS NOT NULL
    THEN
      INSERT INTO usim_position (usim_coordinate) VALUES (p_usim_coordinate) RETURNING usim_id_pos INTO l_result;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_pos.insert_position', 'Used with invalid position coordinate [' || p_usim_coordinate || '].');
      RETURN NULL;
    END IF;
  END insert_position
  ;

  FUNCTION init_positions( p_max_coordinate IN usim_position.usim_coordinate%TYPE
                         , p_do_commit      IN BOOLEAN                            DEFAULT TRUE
                         )
    RETURN NUMBER
  IS
    l_usim_id_pos usim_position.usim_id_pos%TYPE;
  BEGIN
    IF p_max_coordinate IS NULL
    THEN
      usim_erl.log_error('usim_dim.init_positions', 'Used with invalid max position [' || p_max_coordinate || '].');
      RETURN 0;
    END IF;
    FOR l_pos IN 0..ABS(p_max_coordinate)
    LOOP
      l_usim_id_pos := usim_pos.insert_position(l_pos, p_do_commit);
      IF l_usim_id_pos IS NULL
      THEN
        usim_erl.log_error('usim_dim.init_positions', 'Error inserting position [' || l_pos || '].');
        RETURN 0;
      END IF;
      IF l_pos != 0
      THEN
        -- insert negative value
        l_usim_id_pos := usim_pos.insert_position(-l_pos, p_do_commit);
        IF l_usim_id_pos IS NULL
        THEN
          usim_erl.log_error('usim_dim.init_positions', 'Error inserting position [' || -l_pos || '].');
          RETURN 0;
        END IF;
      END IF;
    END LOOP;
    RETURN 1;
  END init_positions
  ;

END usim_pos;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_pos
IS
  -- see header for documentation

  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_position;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_position WHERE usim_id_pos = p_usim_id_pos;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_data(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_position WHERE usim_coordinate = p_usim_coordinate;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_dim_pair(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    IF      usim_pos.has_data(ABS(p_usim_coordinate))            = 1
       AND  usim_pos.has_data(ABS(p_usim_coordinate) + 1)        = 1
       AND  usim_pos.has_data(ABS(p_usim_coordinate) * -1)       = 1
       AND  usim_pos.has_data((ABS(p_usim_coordinate) + 1) * -1) = 1
    THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  END has_dim_pair
  ;

  FUNCTION has_dim_pair(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    RETURN usim_pos.has_dim_pair(usim_pos.get_coordinate(p_usim_id_pos));
  END has_dim_pair
  ;

  FUNCTION get_max_coordinate(p_sign IN NUMBER DEFAULT 1)
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_result  usim_position.usim_coordinate%TYPE;
  BEGIN
    IF     usim_pos.has_data = 1
       AND p_sign           IN (1, -1)
    THEN
      IF p_sign > 0
      THEN
        SELECT MAX(usim_coordinate) INTO l_result FROM usim_position WHERE SIGN(usim_coordinate) IN (0, 1);
      ELSE
        SELECT MIN(usim_coordinate) INTO l_result FROM usim_position WHERE SIGN(usim_coordinate) IN (0, -1);
      END IF;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_pos.get_max_coordinate', 'Used without position data or wrong sign [' || p_sign || '].');
      RETURN NULL;
    END IF;
  END get_max_coordinate
  ;

  FUNCTION get_coordinate(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_result usim_position.usim_coordinate%TYPE;
  BEGIN
    IF usim_pos.has_data(p_usim_id_pos) = 1
    THEN
      SELECT usim_coordinate INTO l_result FROM usim_position WHERE usim_id_pos = p_usim_id_pos;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_pos.get_coordinate', 'Used with not existing pos id [' || p_usim_id_pos || '].');
      RETURN NULL;
    END IF;
  END get_coordinate
  ;

  FUNCTION get_coord_sign(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN NUMBER
  IS
    l_result INTEGER;
  BEGIN
    IF usim_pos.has_data(p_usim_id_pos) = 1
    THEN
      SELECT SIGN(usim_coordinate) INTO l_result FROM usim_position WHERE usim_id_pos = p_usim_id_pos;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_pos.get_coord_sign', 'Used with not existing pos id [' || p_usim_id_pos || '].');
      RETURN NULL;
    END IF;
  END get_coord_sign
  ;

  FUNCTION get_id_pos(p_usim_coordinate  IN usim_position.usim_coordinate%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_result  usim_position.usim_id_pos%TYPE;
  BEGIN
    IF usim_pos.has_data(p_usim_coordinate) = 1
    THEN
      SELECT usim_id_pos INTO l_result FROM usim_position WHERE usim_coordinate = p_usim_coordinate;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_pos.get_id_pos', 'Used with not existing coordinate [' || p_usim_coordinate || '].');
      RETURN NULL;
    END IF;
  END get_id_pos
  ;

  FUNCTION get_dim_pos_rel( p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                          , p_zero_sign   IN NUMBER                         DEFAULT 1
                          )
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_sign   NUMBER;
    l_coord  usim_position.usim_coordinate%TYPE;
    l_result usim_position.usim_id_pos%TYPE;
  BEGIN
    IF      usim_pos.has_dim_pair(p_usim_id_pos) = 1
       AND  p_zero_sign                         IN (1, -1)
    THEN
      l_sign  := usim_pos.get_coord_sign(p_usim_id_pos);
      l_coord := usim_pos.get_coordinate(p_usim_id_pos);
      -- handle sign by position
      IF l_sign = 1
      THEN
        l_result := usim_pos.get_id_pos(l_coord + 1);
      ELSIF l_sign = -1
      THEN
        l_result := usim_pos.get_id_pos(l_coord - 1);
      ELSE
        -- zero case
        l_result := usim_pos.get_id_pos(p_zero_sign);
      END IF;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_pos.get_vol_pos_rel', 'Position id has no dimension axis volume to position [' || p_usim_id_pos || '] or wrong zero sign [' || p_zero_sign || '].');
      RETURN NULL;
    END IF;
  END get_dim_pos_rel
  ;

  FUNCTION get_pos_mirror(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_coord  usim_position.usim_coordinate%TYPE;
    l_result usim_position.usim_id_pos%TYPE;
  BEGIN
    IF usim_pos.has_data(p_usim_id_pos) = 1
    THEN
      l_coord  := usim_pos.get_coordinate(p_usim_id_pos) * -1;
      IF usim_pos.has_data(l_coord) = 1
      THEN
        l_result := usim_pos.get_id_pos(l_coord);
        RETURN l_result;
      ELSE
        usim_erl.log_error('usim_pos.get_pos_mirror', 'Position id does not exist for coordinate [' || l_coord || '].');
        RETURN NULL;
      END IF;
    ELSE
      usim_erl.log_error('usim_pos.get_pos_mirror', 'Position id does not exist [' || p_usim_id_pos || '].');
      RETURN NULL;
    END IF;
  END get_pos_mirror
  ;

  FUNCTION insert_position( p_usim_coordinate IN usim_position.usim_coordinate%TYPE
                          , p_do_commit       IN BOOLEAN                            DEFAULT TRUE
                          )
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_result          usim_position.usim_id_pos%TYPE;
  BEGIN
    IF usim_pos.has_data(p_usim_coordinate) = 1
    THEN
      RETURN usim_pos.get_id_pos(p_usim_coordinate);
    ELSIF p_usim_coordinate IS NOT NULL
    THEN
      INSERT INTO usim_position (usim_coordinate) VALUES (p_usim_coordinate) RETURNING usim_id_pos INTO l_result;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_pos.insert_position', 'Used with invalid position coordinate [' || p_usim_coordinate || '].');
      RETURN NULL;
    END IF;
  END insert_position
  ;

  FUNCTION init_positions( p_max_coordinate IN usim_position.usim_coordinate%TYPE
                         , p_do_commit      IN BOOLEAN                            DEFAULT TRUE
                         )
    RETURN NUMBER
  IS
    l_usim_id_pos usim_position.usim_id_pos%TYPE;
  BEGIN
    IF p_max_coordinate IS NULL
    THEN
      usim_erl.log_error('usim_dim.init_positions', 'Used with invalid max position [' || p_max_coordinate || '].');
      RETURN 0;
    END IF;
    FOR l_pos IN 0..ABS(p_max_coordinate)
    LOOP
      l_usim_id_pos := usim_pos.insert_position(l_pos, p_do_commit);
      IF l_usim_id_pos IS NULL
      THEN
        usim_erl.log_error('usim_dim.init_positions', 'Error inserting position [' || l_pos || '].');
        RETURN 0;
      END IF;
      IF l_pos != 0
      THEN
        -- insert negative value
        l_usim_id_pos := usim_pos.insert_position(-l_pos, p_do_commit);
        IF l_usim_id_pos IS NULL
        THEN
          usim_erl.log_error('usim_dim.init_positions', 'Error inserting position [' || -l_pos || '].');
          RETURN 0;
        END IF;
      END IF;
    END LOOP;
    RETURN 1;
  END init_positions
  ;

END usim_pos;

Package Body USIM_POS kompiliert

SQL> -- USIM_DIMENSION (dim)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_DIMENSION_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_DIMENSION still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DIMENSION'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_DIMENSION_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_DIMENSION still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DIMENSION'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_DIMENSION_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_DIMENSION still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_DIMENSION'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../TABLES/USIM_DIMENSION_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE TABLE &USIM_SCHEMA..usim_dimension
  2    ( usim_id_dim       CHAR(55)     NOT NULL ENABLE
  3    , usim_n_dimension  NUMBER(2, 0) NOT NULL ENABLE
  4    )
  5  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_dimension
  ( usim_id_dim       CHAR(55)     NOT NULL ENABLE
  , usim_n_dimension  NUMBER(2, 0) NOT NULL ENABLE
  )

neu:CREATE TABLE USIM_TEST.usim_dimension
  ( usim_id_dim       CHAR(55)     NOT NULL ENABLE
  , usim_n_dimension  NUMBER(2, 0) NOT NULL ENABLE
  )

Table USIM_TEST.USIM_DIMENSION erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_dimension IS 'Contains the dimensions available for the multiverse. Will use the alias dim.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_dimension IS 'Contains the dimensions available for the multiverse. Will use the alias dim.'
neu:COMMENT ON TABLE USIM_TEST.usim_dimension IS 'Contains the dimensions available for the multiverse. Will use the alias dim.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_dimension.usim_id_dim IS 'The unique id for the associated dimension. Update not allowed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_dimension.usim_id_dim IS 'The unique id for the associated dimension. Update not allowed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_dimension.usim_id_dim IS 'The unique id for the associated dimension. Update not allowed.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_dimension.usim_n_dimension IS 'The n-sphere supported dimension for space simulation. Must be >= 0 and <= usim_basedata.usim_max_dimension. Must be set on insert. Update not allowed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_dimension.usim_n_dimension IS 'The n-sphere supported dimension for space simulation. Must be >= 0 and <= usim_basedata.usim_max_dimension. Must be set on insert. Update not allowed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_dimension.usim_n_dimension IS 'The n-sphere supported dimension for space simulation. Must be >= 0 and <= usim_basedata.usim_max_dimension. Must be set on insert. Update not allowed.'

Comment erstellt.

SQL>
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_dimension
  2    ADD CONSTRAINT usim_dim_pk
  3    PRIMARY KEY (usim_id_dim)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_dimension
  ADD CONSTRAINT usim_dim_pk
  PRIMARY KEY (usim_id_dim)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_dimension
  ADD CONSTRAINT usim_dim_pk
  PRIMARY KEY (usim_id_dim)
  ENABLE

Table USIM_TEST.USIM_DIMENSION geändert.

SQL>
SQL> -- uk
SQL> ALTER TABLE &USIM_SCHEMA..usim_dimension
  2    ADD CONSTRAINT usim_dim_uk
  3    UNIQUE (usim_n_dimension)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_dimension
  ADD CONSTRAINT usim_dim_uk
  UNIQUE (usim_n_dimension)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_dimension
  ADD CONSTRAINT usim_dim_uk
  UNIQUE (usim_n_dimension)
  ENABLE

Table USIM_TEST.USIM_DIMENSION geändert.

SQL>
SQL> -- chk
SQL> ALTER TABLE &USIM_SCHEMA..usim_dimension
  2    ADD CONSTRAINT usim_dim_dimension_chk
  3    CHECK (usim_n_dimension >= 0)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_dimension
  ADD CONSTRAINT usim_dim_dimension_chk
  CHECK (usim_n_dimension >= 0)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_dimension
  ADD CONSTRAINT usim_dim_dimension_chk
  CHECK (usim_n_dimension >= 0)
  ENABLE

Table USIM_TEST.USIM_DIMENSION geändert.

SQL>
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_dim_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_dimension
  3      FOR EACH ROW
  4      BEGIN
  5        -- verify insert value
  6        IF :NEW.usim_n_dimension > usim_base.get_max_dimension
  7        THEN
  8          RAISE_APPLICATION_ERROR( num => -20000
  9                                 , msg => 'Insert requirement not fulfilled. Dimension must be >= 0 and <= usim_base.get_max_dimension.'
 10                                 )
 11          ;
 12        END IF;
 13        -- ignore input on pk
 14        :NEW.usim_id_dim := usim_static.get_big_pk(usim_dim_id_seq.NEXTVAL);
 15      END;
 16  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_dim_ins_trg
  BEFORE INSERT ON &USIM_SCHEMA..usim_dimension
    FOR EACH ROW
    BEGIN
      -- verify insert value
      IF :NEW.usim_n_dimension > usim_base.get_max_dimension
      THEN
        RAISE_APPLICATION_ERROR( num => -20000
                               , msg => 'Insert requirement not fulfilled. Dimension must be >= 0 and <= usim_base.get_max_dimension.'
                               )
        ;
      END IF;
      -- ignore input on pk
      :NEW.usim_id_dim := usim_static.get_big_pk(usim_dim_id_seq.NEXTVAL);
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_dim_ins_trg
  BEFORE INSERT ON USIM_TEST.usim_dimension
    FOR EACH ROW
    BEGIN
      -- verify insert value
      IF :NEW.usim_n_dimension > usim_base.get_max_dimension
      THEN
        RAISE_APPLICATION_ERROR( num => -20000
                               , msg => 'Insert requirement not fulfilled. Dimension must be >= 0 and <= usim_base.get_max_dimension.'
                               )
        ;
      END IF;
      -- ignore input on pk
      :NEW.usim_id_dim := usim_static.get_big_pk(usim_dim_id_seq.NEXTVAL);
    END;

Trigger USIM_DIM_INS_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_dim_ins_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_dim_ins_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_dim_ins_trg ENABLE

Trigger USIM_TEST.USIM_DIM_INS_TRG geändert.

SQL>
SQL> -- update trigger to prevent updates
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_dim_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_dimension
  3      FOR EACH ROW
  4      BEGIN
  5        RAISE_APPLICATION_ERROR( num => -20001
  6                               , msg => 'Update requirement not fulfilled. No update allowed.'
  7                               )
  8        ;
  9      END;
 10  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_dim_upd_trg
  BEFORE UPDATE ON &USIM_SCHEMA..usim_dimension
    FOR EACH ROW
    BEGIN
      RAISE_APPLICATION_ERROR( num => -20001
                             , msg => 'Update requirement not fulfilled. No update allowed.'
                             )
      ;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_dim_upd_trg
  BEFORE UPDATE ON USIM_TEST.usim_dimension
    FOR EACH ROW
    BEGIN
      RAISE_APPLICATION_ERROR( num => -20001
                             , msg => 'Update requirement not fulfilled. No update allowed.'
                             )
      ;
    END;

Trigger USIM_DIM_UPD_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_dim_upd_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_dim_upd_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_dim_upd_trg ENABLE

Trigger USIM_TEST.USIM_DIM_UPD_TRG geändert.

SQL> -- usim_dimension package
SQL> @@../PACKAGES/USIM_DIM.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_dim
  2  IS
  3    /**A low level package for actions on table usim_dimension and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9
 10    /**
 11    * Checks if usim_dimension has already data.
 12    * @return Returns 1 if dimensions are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15      RETURN NUMBER
 16    ;
 17
 18    /**
 19    * Checks if given dimension id exists.
 20    * @param p_usim_id_dim The id of the dimension.
 21    * @return Returns 1 if id exists, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
 24      RETURN NUMBER
 25    ;
 26
 27    /**
 28    * Checks if given dimension exists.
 29    * @param p_usim_n_dimension The dimension to verify.
 30    * @return Returns 1 if id exists, otherwise 0.
 31    */
 32    FUNCTION has_data(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
 33      RETURN NUMBER
 34    ;
 35
 36    /**
 37    * Gets the maximum dimension available.
 38    * @return Returns max usim_n_dimension or -1 if no dimension exists.
 39    */
 40    FUNCTION get_max_dimension
 41      RETURN usim_dimension.usim_n_dimension%TYPE
 42    ;
 43
 44    /**
 45    * Gets the dimension id for a given dimension.
 46    * @param p_usim_n_dimension The dimension to get the dimension id for.
 47    * @return Returns related usim_id_dim or NULL if it does not exist.
 48    */
 49    FUNCTION get_id_dim(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
 50      RETURN usim_dimension.usim_id_dim%TYPE
 51    ;
 52
 53    /**
 54    * Gets the dimension for a given dimension id.
 55    * @param p_usim_id_dim The id of the dimension.
 56    * @return Returns usim_n_dimension for given dimension id or -1 if dimension id does not exist.
 57    */
 58    FUNCTION get_dimension(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
 59      RETURN usim_dimension.usim_n_dimension%TYPE
 60    ;
 61
 62    /**
 63    * Inserts a dimension into usim_dimension.
 64    * @param p_usim_n_dimension The dimension to insert. Always absolute value is used, no negative dimensions possible.
 65    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 66    * @return Returns the new/existing dimension id or NULL on errors.
 67    */
 68    FUNCTION insert_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 69                             , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
 70                             )
 71      RETURN usim_dimension.usim_id_dim%TYPE
 72    ;
 73
 74    /**
 75    * Creates all dimensions including given max dimension. Can be used to initialize the available
 76    * dimensions in a multiverse.
 77    * @param p_max_dimension The maximum dimensions to insert. Always absolute value is used, no negative dimensions possible.
 78    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 79    * @return Returns 1 one success 0 on errors.
 80    */
 81    FUNCTION init_dimensions( p_max_dimension IN usim_dimension.usim_n_dimension%TYPE
 82                            , p_do_commit     IN BOOLEAN                              DEFAULT TRUE
 83                            )
 84      RETURN NUMBER
 85    ;
 86
 87  END usim_dim;
 88  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_dim
IS
  /**A low level package for actions on table usim_dimension and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_dimension has already data.
  * @return Returns 1 if dimensions are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if given dimension id exists.
  * @param p_usim_id_dim The id of the dimension.
  * @return Returns 1 if id exists, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if given dimension exists.
  * @param p_usim_n_dimension The dimension to verify.
  * @return Returns 1 if id exists, otherwise 0.
  */
  FUNCTION has_data(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the maximum dimension available.
  * @return Returns max usim_n_dimension or -1 if no dimension exists.
  */
  FUNCTION get_max_dimension
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Gets the dimension id for a given dimension.
  * @param p_usim_n_dimension The dimension to get the dimension id for.
  * @return Returns related usim_id_dim or NULL if it does not exist.
  */
  FUNCTION get_id_dim(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
    RETURN usim_dimension.usim_id_dim%TYPE
  ;

  /**
  * Gets the dimension for a given dimension id.
  * @param p_usim_id_dim The id of the dimension.
  * @return Returns usim_n_dimension for given dimension id or -1 if dimension id does not exist.
  */
  FUNCTION get_dimension(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Inserts a dimension into usim_dimension.
  * @param p_usim_n_dimension The dimension to insert. Always absolute value is used, no negative dimensions possible.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new/existing dimension id or NULL on errors.
  */
  FUNCTION insert_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                           , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                           )
    RETURN usim_dimension.usim_id_dim%TYPE
  ;

  /**
  * Creates all dimensions including given max dimension. Can be used to initialize the available
  * dimensions in a multiverse.
  * @param p_max_dimension The maximum dimensions to insert. Always absolute value is used, no negative dimensions possible.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 one success 0 on errors.
  */
  FUNCTION init_dimensions( p_max_dimension IN usim_dimension.usim_n_dimension%TYPE
                          , p_do_commit     IN BOOLEAN                              DEFAULT TRUE
                          )
    RETURN NUMBER
  ;

END usim_dim;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_dim
IS
  /**A low level package for actions on table usim_dimension and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_dimension has already data.
  * @return Returns 1 if dimensions are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if given dimension id exists.
  * @param p_usim_id_dim The id of the dimension.
  * @return Returns 1 if id exists, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if given dimension exists.
  * @param p_usim_n_dimension The dimension to verify.
  * @return Returns 1 if id exists, otherwise 0.
  */
  FUNCTION has_data(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the maximum dimension available.
  * @return Returns max usim_n_dimension or -1 if no dimension exists.
  */
  FUNCTION get_max_dimension
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Gets the dimension id for a given dimension.
  * @param p_usim_n_dimension The dimension to get the dimension id for.
  * @return Returns related usim_id_dim or NULL if it does not exist.
  */
  FUNCTION get_id_dim(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
    RETURN usim_dimension.usim_id_dim%TYPE
  ;

  /**
  * Gets the dimension for a given dimension id.
  * @param p_usim_id_dim The id of the dimension.
  * @return Returns usim_n_dimension for given dimension id or -1 if dimension id does not exist.
  */
  FUNCTION get_dimension(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Inserts a dimension into usim_dimension.
  * @param p_usim_n_dimension The dimension to insert. Always absolute value is used, no negative dimensions possible.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new/existing dimension id or NULL on errors.
  */
  FUNCTION insert_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                           , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                           )
    RETURN usim_dimension.usim_id_dim%TYPE
  ;

  /**
  * Creates all dimensions including given max dimension. Can be used to initialize the available
  * dimensions in a multiverse.
  * @param p_max_dimension The maximum dimensions to insert. Always absolute value is used, no negative dimensions possible.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 one success 0 on errors.
  */
  FUNCTION init_dimensions( p_max_dimension IN usim_dimension.usim_n_dimension%TYPE
                          , p_do_commit     IN BOOLEAN                              DEFAULT TRUE
                          )
    RETURN NUMBER
  ;

END usim_dim;

Package USIM_DIM kompiliert

SQL> @@../PACKAGES/USIM_DIM.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_dim
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_data
  5      RETURN NUMBER
  6    IS
  7      l_result  NUMBER;
  8    BEGIN
  9      SELECT COUNT(*) INTO l_result FROM usim_dimension;
 10      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 11    END has_data
 12    ;
 13
 14    FUNCTION has_data(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
 15      RETURN NUMBER
 16    IS
 17      l_result  NUMBER;
 18    BEGIN
 19      SELECT COUNT(*) INTO l_result FROM usim_dimension WHERE usim_id_dim = p_usim_id_dim;
 20      RETURN l_result;
 21    END has_data
 22    ;
 23
 24    FUNCTION has_data(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
 25      RETURN NUMBER
 26    IS
 27      l_result  NUMBER;
 28    BEGIN
 29      SELECT COUNT(*) INTO l_result FROM usim_dimension WHERE usim_n_dimension = p_usim_n_dimension;
 30      RETURN l_result;
 31    END has_data
 32    ;
 33
 34    FUNCTION get_max_dimension
 35      RETURN usim_dimension.usim_n_dimension%TYPE
 36    IS
 37      l_result  NUMBER;
 38    BEGIN
 39      IF usim_dim.has_data = 1
 40      THEN
 41        SELECT MAX(usim_n_dimension) INTO l_result FROM usim_dimension;
 42        RETURN l_result;
 43      ELSE
 44        RETURN -1;
 45      END IF;
 46    END get_max_dimension
 47    ;
 48
 49    FUNCTION get_id_dim(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
 50      RETURN usim_dimension.usim_id_dim%TYPE
 51    IS
 52      l_usim_id_dim   usim_dimension.usim_id_dim%TYPE;
 53    BEGIN
 54      IF usim_dim.has_data(p_usim_n_dimension) = 1
 55      THEN
 56        SELECT usim_id_dim INTO l_usim_id_dim FROM usim_dimension WHERE usim_n_dimension = p_usim_n_dimension;
 57        RETURN l_usim_id_dim;
 58      ELSE
 59        usim_erl.log_error('usim_dim.get_id_dim', 'Used with not existing dimension [' || p_usim_n_dimension || '].');
 60        RETURN NULL;
 61      END IF;
 62    END get_id_dim
 63    ;
 64
 65    FUNCTION get_dimension(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
 66      RETURN usim_dimension.usim_n_dimension%TYPE
 67    IS
 68      l_result usim_dimension.usim_n_dimension%TYPE;
 69    BEGIN
 70      IF usim_dim.has_data(p_usim_id_dim) = 1
 71      THEN
 72        SELECT usim_n_dimension INTO l_result FROM usim_dimension WHERE usim_id_dim = p_usim_id_dim;
 73        RETURN l_result;
 74      ELSE
 75        RETURN -1;
 76      END IF;
 77    END get_dimension
 78    ;
 79
 80    FUNCTION insert_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 81                             , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
 82                             )
 83      RETURN usim_dimension.usim_id_dim%TYPE
 84    IS
 85      l_new_dimension NUMBER;
 86      l_result        usim_dimension.usim_id_dim%TYPE;
 87    BEGIN
 88      IF usim_dim.has_data(p_usim_n_dimension) = 1
 89      THEN
 90        RETURN usim_dim.get_id_dim(p_usim_n_dimension);
 91      ELSIF p_usim_n_dimension IS NOT NULL
 92      THEN
 93        INSERT INTO usim_dimension (usim_n_dimension) VALUES (ABS(p_usim_n_dimension))
 94          RETURNING usim_id_dim INTO l_result
 95        ;
 96        IF p_do_commit
 97        THEN
 98          COMMIT;
 99        END IF;
100        RETURN l_result;
101      ELSE
102        usim_erl.log_error('usim_dim.insert_dimension', 'Used with invalid dimension [' || p_usim_n_dimension || '].');
103        RETURN NULL;
104      END IF;
105    END insert_dimension
106    ;
107
108    FUNCTION init_dimensions( p_max_dimension IN usim_dimension.usim_n_dimension%TYPE
109                            , p_do_commit     IN BOOLEAN                              DEFAULT TRUE
110                            )
111      RETURN NUMBER
112    IS
113      l_usim_id_dim usim_dimension.usim_id_dim%TYPE;
114    BEGIN
115      IF p_max_dimension IS NULL
116      THEN
117        usim_erl.log_error('usim_dim.init_dimensions', 'Used with invalid max dimension [' || p_max_dimension || '].');
118        RETURN 0;
119      END IF;
120      FOR l_dim IN 0..ABS(p_max_dimension)
121      LOOP
122        l_usim_id_dim := usim_dim.insert_dimension(l_dim, p_do_commit);
123        IF l_usim_id_dim IS NULL
124        THEN
125          usim_erl.log_error('usim_dim.init_dimensions', 'Error inserting dimension [' || l_dim || '].');
126          RETURN 0;
127        END IF;
128      END LOOP;
129      RETURN 1;
130    END init_dimensions
131    ;
132
133  END usim_dim;
134  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_dim
IS
  -- see header for documentation
  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_dimension;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_dimension WHERE usim_id_dim = p_usim_id_dim;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_data(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_dimension WHERE usim_n_dimension = p_usim_n_dimension;
    RETURN l_result;
  END has_data
  ;

  FUNCTION get_max_dimension
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result  NUMBER;
  BEGIN
    IF usim_dim.has_data = 1
    THEN
      SELECT MAX(usim_n_dimension) INTO l_result FROM usim_dimension;
      RETURN l_result;
    ELSE
      RETURN -1;
    END IF;
  END get_max_dimension
  ;

  FUNCTION get_id_dim(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
    RETURN usim_dimension.usim_id_dim%TYPE
  IS
    l_usim_id_dim   usim_dimension.usim_id_dim%TYPE;
  BEGIN
    IF usim_dim.has_data(p_usim_n_dimension) = 1
    THEN
      SELECT usim_id_dim INTO l_usim_id_dim FROM usim_dimension WHERE usim_n_dimension = p_usim_n_dimension;
      RETURN l_usim_id_dim;
    ELSE
      usim_erl.log_error('usim_dim.get_id_dim', 'Used with not existing dimension [' || p_usim_n_dimension || '].');
      RETURN NULL;
    END IF;
  END get_id_dim
  ;

  FUNCTION get_dimension(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result usim_dimension.usim_n_dimension%TYPE;
  BEGIN
    IF usim_dim.has_data(p_usim_id_dim) = 1
    THEN
      SELECT usim_n_dimension INTO l_result FROM usim_dimension WHERE usim_id_dim = p_usim_id_dim;
      RETURN l_result;
    ELSE
      RETURN -1;
    END IF;
  END get_dimension
  ;

  FUNCTION insert_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                           , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                           )
    RETURN usim_dimension.usim_id_dim%TYPE
  IS
    l_new_dimension NUMBER;
    l_result        usim_dimension.usim_id_dim%TYPE;
  BEGIN
    IF usim_dim.has_data(p_usim_n_dimension) = 1
    THEN
      RETURN usim_dim.get_id_dim(p_usim_n_dimension);
    ELSIF p_usim_n_dimension IS NOT NULL
    THEN
      INSERT INTO usim_dimension (usim_n_dimension) VALUES (ABS(p_usim_n_dimension))
        RETURNING usim_id_dim INTO l_result
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_dim.insert_dimension', 'Used with invalid dimension [' || p_usim_n_dimension || '].');
      RETURN NULL;
    END IF;
  END insert_dimension
  ;

  FUNCTION init_dimensions( p_max_dimension IN usim_dimension.usim_n_dimension%TYPE
                          , p_do_commit     IN BOOLEAN                              DEFAULT TRUE
                          )
    RETURN NUMBER
  IS
    l_usim_id_dim usim_dimension.usim_id_dim%TYPE;
  BEGIN
    IF p_max_dimension IS NULL
    THEN
      usim_erl.log_error('usim_dim.init_dimensions', 'Used with invalid max dimension [' || p_max_dimension || '].');
      RETURN 0;
    END IF;
    FOR l_dim IN 0..ABS(p_max_dimension)
    LOOP
      l_usim_id_dim := usim_dim.insert_dimension(l_dim, p_do_commit);
      IF l_usim_id_dim IS NULL
      THEN
        usim_erl.log_error('usim_dim.init_dimensions', 'Error inserting dimension [' || l_dim || '].');
        RETURN 0;
      END IF;
    END LOOP;
    RETURN 1;
  END init_dimensions
  ;

END usim_dim;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_dim
IS
  -- see header for documentation
  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_dimension;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_dimension WHERE usim_id_dim = p_usim_id_dim;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_data(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_dimension WHERE usim_n_dimension = p_usim_n_dimension;
    RETURN l_result;
  END has_data
  ;

  FUNCTION get_max_dimension
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result  NUMBER;
  BEGIN
    IF usim_dim.has_data = 1
    THEN
      SELECT MAX(usim_n_dimension) INTO l_result FROM usim_dimension;
      RETURN l_result;
    ELSE
      RETURN -1;
    END IF;
  END get_max_dimension
  ;

  FUNCTION get_id_dim(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
    RETURN usim_dimension.usim_id_dim%TYPE
  IS
    l_usim_id_dim   usim_dimension.usim_id_dim%TYPE;
  BEGIN
    IF usim_dim.has_data(p_usim_n_dimension) = 1
    THEN
      SELECT usim_id_dim INTO l_usim_id_dim FROM usim_dimension WHERE usim_n_dimension = p_usim_n_dimension;
      RETURN l_usim_id_dim;
    ELSE
      usim_erl.log_error('usim_dim.get_id_dim', 'Used with not existing dimension [' || p_usim_n_dimension || '].');
      RETURN NULL;
    END IF;
  END get_id_dim
  ;

  FUNCTION get_dimension(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result usim_dimension.usim_n_dimension%TYPE;
  BEGIN
    IF usim_dim.has_data(p_usim_id_dim) = 1
    THEN
      SELECT usim_n_dimension INTO l_result FROM usim_dimension WHERE usim_id_dim = p_usim_id_dim;
      RETURN l_result;
    ELSE
      RETURN -1;
    END IF;
  END get_dimension
  ;

  FUNCTION insert_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                           , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                           )
    RETURN usim_dimension.usim_id_dim%TYPE
  IS
    l_new_dimension NUMBER;
    l_result        usim_dimension.usim_id_dim%TYPE;
  BEGIN
    IF usim_dim.has_data(p_usim_n_dimension) = 1
    THEN
      RETURN usim_dim.get_id_dim(p_usim_n_dimension);
    ELSIF p_usim_n_dimension IS NOT NULL
    THEN
      INSERT INTO usim_dimension (usim_n_dimension) VALUES (ABS(p_usim_n_dimension))
        RETURNING usim_id_dim INTO l_result
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_dim.insert_dimension', 'Used with invalid dimension [' || p_usim_n_dimension || '].');
      RETURN NULL;
    END IF;
  END insert_dimension
  ;

  FUNCTION init_dimensions( p_max_dimension IN usim_dimension.usim_n_dimension%TYPE
                          , p_do_commit     IN BOOLEAN                              DEFAULT TRUE
                          )
    RETURN NUMBER
  IS
    l_usim_id_dim usim_dimension.usim_id_dim%TYPE;
  BEGIN
    IF p_max_dimension IS NULL
    THEN
      usim_erl.log_error('usim_dim.init_dimensions', 'Used with invalid max dimension [' || p_max_dimension || '].');
      RETURN 0;
    END IF;
    FOR l_dim IN 0..ABS(p_max_dimension)
    LOOP
      l_usim_id_dim := usim_dim.insert_dimension(l_dim, p_do_commit);
      IF l_usim_id_dim IS NULL
      THEN
        usim_erl.log_error('usim_dim.init_dimensions', 'Error inserting dimension [' || l_dim || '].');
        RETURN 0;
      END IF;
    END LOOP;
    RETURN 1;
  END init_dimensions
  ;

END usim_dim;

Package Body USIM_DIM kompiliert

SQL> -- USIM_NODE (nod)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_NODE_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_NODE still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_NODE'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_NODE_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_NODE still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_NODE'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_NODE_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_NODE still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_NODE'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../TABLES/USIM_NODE_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_NODE (nod)
SQL> CREATE TABLE &USIM_SCHEMA..usim_node
  2    ( usim_id_nod     CHAR(55)  NOT NULL ENABLE
  3    , usim_energy     NUMBER
  4    )
  5  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_node
  ( usim_id_nod     CHAR(55)  NOT NULL ENABLE
  , usim_energy     NUMBER
  )

neu:CREATE TABLE USIM_TEST.usim_node
  ( usim_id_nod     CHAR(55)  NOT NULL ENABLE
  , usim_energy     NUMBER
  )

Table USIM_TEST.USIM_NODE erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_node IS 'Contains all nodes of all universes that form volumes holding a potential energy. Will use the alias nod.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_node IS 'Contains all nodes of all universes that form volumes holding a potential energy. Will use the alias nod.'
neu:COMMENT ON TABLE USIM_TEST.usim_node IS 'Contains all nodes of all universes that form volumes holding a potential energy. Will use the alias nod.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_node.usim_id_nod IS 'The unique id for this node. Automatically set, update ignored.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_node.usim_id_nod IS 'The unique id for this node. Automatically set, update ignored.'
neu:COMMENT ON COLUMN USIM_TEST.usim_node.usim_id_nod IS 'The unique id for this node. Automatically set, update ignored.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_node.usim_id_nod IS 'The potential energy of the node. Set to NULL on insert. Only updates allowed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_node.usim_id_nod IS 'The potential energy of the node. Set to NULL on insert. Only updates allowed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_node.usim_id_nod IS 'The potential energy of the node. Set to NULL on insert. Only updates allowed.'

Comment erstellt.

SQL>
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_node
  2    ADD CONSTRAINT usim_nod_pk
  3    PRIMARY KEY (usim_id_nod)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_node
  ADD CONSTRAINT usim_nod_pk
  PRIMARY KEY (usim_id_nod)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_node
  ADD CONSTRAINT usim_nod_pk
  PRIMARY KEY (usim_id_nod)
  ENABLE

Table USIM_TEST.USIM_NODE geändert.

SQL>
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_node_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_node
  3      FOR EACH ROW
  4      BEGIN
  5        -- ignore input on pk and energy
  6        :NEW.usim_id_nod := usim_static.get_big_pk(usim_nod_id_seq.NEXTVAL);
  7        :NEW.usim_energy := NULL;
  8      END;
  9  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_node_ins_trg
  BEFORE INSERT ON &USIM_SCHEMA..usim_node
    FOR EACH ROW
    BEGIN
      -- ignore input on pk and energy
      :NEW.usim_id_nod := usim_static.get_big_pk(usim_nod_id_seq.NEXTVAL);
      :NEW.usim_energy := NULL;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_node_ins_trg
  BEFORE INSERT ON USIM_TEST.usim_node
    FOR EACH ROW
    BEGIN
      -- ignore input on pk and energy
      :NEW.usim_id_nod := usim_static.get_big_pk(usim_nod_id_seq.NEXTVAL);
      :NEW.usim_energy := NULL;
    END;

Trigger USIM_NODE_INS_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_node_ins_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_node_ins_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_node_ins_trg ENABLE

Trigger USIM_TEST.USIM_NODE_INS_TRG geändert.

SQL>
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_node_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_node
  3      FOR EACH ROW
  4      BEGIN
  5        -- ignore update on pk
  6        :NEW.usim_id_nod := :OLD.usim_id_nod;
  7      END;
  8  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_node_upd_trg
  BEFORE UPDATE ON &USIM_SCHEMA..usim_node
    FOR EACH ROW
    BEGIN
      -- ignore update on pk
      :NEW.usim_id_nod := :OLD.usim_id_nod;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_node_upd_trg
  BEFORE UPDATE ON USIM_TEST.usim_node
    FOR EACH ROW
    BEGIN
      -- ignore update on pk
      :NEW.usim_id_nod := :OLD.usim_id_nod;
    END;

Trigger USIM_NODE_UPD_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_node_upd_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_node_upd_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_node_upd_trg ENABLE

Trigger USIM_TEST.USIM_NODE_UPD_TRG geändert.

SQL> -- usim_node packages
SQL> @@../PACKAGES/USIM_NOD.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_nod
  2  IS
  3    /**A low level package for actions on table usim_node and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9
 10    /**
 11    * Checks if usim_node has already data.
 12    * @return Returns 1 if data are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15      RETURN NUMBER
 16    ;
 17
 18    /**
 19    * Checks if usim_node has the given node id.
 20    * @param p_usim_id_nod The node id to verify.
 21    * @return Returns 1 if node id exists, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
 24      RETURN NUMBER
 25    ;
 26
 27    /**
 28    * Retrieves the energy of a given node, which can be NULL. Use
 29    * has_data to verify, if a node id exists.
 30    * @param p_usim_id_nod The node id to get the energy for.
 31    * @return Returns usim_energy if node id exists, otherwise NULL. Using NUMBER not TYPE as calculations behave different if TYPE is used and max is reached.
 32    */
 33    FUNCTION get_energy(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
 34      RETURN NUMBER
 35    ;
 36
 37    /**
 38    * Inserts a new node. Energy is set to NULL on insert and can only
 39    * be changed by update. As a node is a very simple structure, it may
 40    * be difficult to identify a specific node, if it is not assigned
 41    * to a universe, dimension, position, node structure after creating it.
 42    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 43    * @return Returns the new created node id with energy default NULL.
 44    */
 45    FUNCTION insert_node(p_do_commit  IN BOOLEAN  DEFAULT TRUE)
 46      RETURN usim_node.usim_id_nod%TYPE
 47    ;
 48
 49    /**
 50    * Updates the energy of a given node.
 51    * @param p_usim_energy The the energy to set on the node.
 52    * @param p_usim_id_pos The node id to update the energy.
 53    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 54    * @return Returns current usim_energy after update or NULL if node does not exist.
 55    */
 56    FUNCTION update_energy( p_usim_energy  IN usim_node.usim_energy%TYPE
 57                          , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
 58                          , p_do_commit    IN BOOLEAN                    DEFAULT TRUE
 59                          )
 60      RETURN usim_node.usim_energy%TYPE
 61    ;
 62
 63    /**
 64    * Updates the energy of a given node by adding the given energy value to the existing energy value.
 65    * @param p_usim_energy The the energy to add to the node. Using NUMBER not TYPE as calculations behave different if TYPE is used and max is reached.
 66    * @param p_usim_id_pos The node id to update the energy.
 67    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 68    * @return Returns current usim_energy after update.
 69    */
 70    FUNCTION add_energy( p_usim_energy  IN NUMBER
 71                       , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
 72                       , p_do_commit    IN BOOLEAN                    DEFAULT TRUE
 73                       )
 74      RETURN usim_node.usim_energy%TYPE
 75    ;
 76
 77  END usim_nod;
 78  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_nod
IS
  /**A low level package for actions on table usim_node and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_node has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_node has the given node id.
  * @param p_usim_id_nod The node id to verify.
  * @return Returns 1 if node id exists, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the energy of a given node, which can be NULL. Use
  * has_data to verify, if a node id exists.
  * @param p_usim_id_nod The node id to get the energy for.
  * @return Returns usim_energy if node id exists, otherwise NULL. Using NUMBER not TYPE as calculations behave different if TYPE is used and max is reached.
  */
  FUNCTION get_energy(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
    RETURN NUMBER
  ;

  /**
  * Inserts a new node. Energy is set to NULL on insert and can only
  * be changed by update. As a node is a very simple structure, it may
  * be difficult to identify a specific node, if it is not assigned
  * to a universe, dimension, position, node structure after creating it.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new created node id with energy default NULL.
  */
  FUNCTION insert_node(p_do_commit  IN BOOLEAN  DEFAULT TRUE)
    RETURN usim_node.usim_id_nod%TYPE
  ;

  /**
  * Updates the energy of a given node.
  * @param p_usim_energy The the energy to set on the node.
  * @param p_usim_id_pos The node id to update the energy.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns current usim_energy after update or NULL if node does not exist.
  */
  FUNCTION update_energy( p_usim_energy  IN usim_node.usim_energy%TYPE
                        , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
                        , p_do_commit    IN BOOLEAN                    DEFAULT TRUE
                        )
    RETURN usim_node.usim_energy%TYPE
  ;

  /**
  * Updates the energy of a given node by adding the given energy value to the existing energy value.
  * @param p_usim_energy The the energy to add to the node. Using NUMBER not TYPE as calculations behave different if TYPE is used and max is reached.
  * @param p_usim_id_pos The node id to update the energy.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns current usim_energy after update.
  */
  FUNCTION add_energy( p_usim_energy  IN NUMBER
                     , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
                     , p_do_commit    IN BOOLEAN                    DEFAULT TRUE
                     )
    RETURN usim_node.usim_energy%TYPE
  ;

END usim_nod;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_nod
IS
  /**A low level package for actions on table usim_node and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_node has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_node has the given node id.
  * @param p_usim_id_nod The node id to verify.
  * @return Returns 1 if node id exists, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the energy of a given node, which can be NULL. Use
  * has_data to verify, if a node id exists.
  * @param p_usim_id_nod The node id to get the energy for.
  * @return Returns usim_energy if node id exists, otherwise NULL. Using NUMBER not TYPE as calculations behave different if TYPE is used and max is reached.
  */
  FUNCTION get_energy(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
    RETURN NUMBER
  ;

  /**
  * Inserts a new node. Energy is set to NULL on insert and can only
  * be changed by update. As a node is a very simple structure, it may
  * be difficult to identify a specific node, if it is not assigned
  * to a universe, dimension, position, node structure after creating it.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new created node id with energy default NULL.
  */
  FUNCTION insert_node(p_do_commit  IN BOOLEAN  DEFAULT TRUE)
    RETURN usim_node.usim_id_nod%TYPE
  ;

  /**
  * Updates the energy of a given node.
  * @param p_usim_energy The the energy to set on the node.
  * @param p_usim_id_pos The node id to update the energy.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns current usim_energy after update or NULL if node does not exist.
  */
  FUNCTION update_energy( p_usim_energy  IN usim_node.usim_energy%TYPE
                        , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
                        , p_do_commit    IN BOOLEAN                    DEFAULT TRUE
                        )
    RETURN usim_node.usim_energy%TYPE
  ;

  /**
  * Updates the energy of a given node by adding the given energy value to the existing energy value.
  * @param p_usim_energy The the energy to add to the node. Using NUMBER not TYPE as calculations behave different if TYPE is used and max is reached.
  * @param p_usim_id_pos The node id to update the energy.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns current usim_energy after update.
  */
  FUNCTION add_energy( p_usim_energy  IN NUMBER
                     , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
                     , p_do_commit    IN BOOLEAN                    DEFAULT TRUE
                     )
    RETURN usim_node.usim_energy%TYPE
  ;

END usim_nod;

Package USIM_NOD kompiliert

SQL> @@../PACKAGES/USIM_NOD.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_nod
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_data
  5      RETURN NUMBER
  6    IS
  7      l_result NUMBER;
  8    BEGIN
  9      SELECT COUNT(*) INTO l_result FROM usim_node;
 10      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 11    END has_data
 12    ;
 13
 14    FUNCTION has_data(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
 15      RETURN NUMBER
 16    IS
 17      l_result NUMBER;
 18    BEGIN
 19      SELECT COUNT(*) INTO l_result FROM usim_node WHERE usim_id_nod = p_usim_id_nod;
 20      RETURN l_result;
 21    END has_data
 22    ;
 23
 24    FUNCTION get_energy(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
 25      RETURN NUMBER
 26    IS
 27      l_result NUMBER;
 28    BEGIN
 29      IF usim_nod.has_data(p_usim_id_nod) = 1
 30      THEN
 31        SELECT usim_energy INTO l_result FROM usim_node WHERE usim_id_nod = p_usim_id_nod;
 32        RETURN l_result;
 33      ELSE
 34        usim_erl.log_error('usim_nod.get_energy', 'Used with not existing node id [' || p_usim_id_nod || '].');
 35        RETURN NULL;
 36      END IF;
 37    END get_energy
 38    ;
 39
 40    FUNCTION insert_node(p_do_commit  IN BOOLEAN  DEFAULT TRUE)
 41      RETURN usim_node.usim_id_nod%TYPE
 42    IS
 43      l_result usim_node.usim_id_nod%TYPE;
 44    BEGIN
 45      INSERT INTO usim_node (usim_energy) VALUES (NULL) RETURNING usim_id_nod INTO l_result;
 46      IF p_do_commit
 47      THEN
 48        COMMIT;
 49      END IF;
 50      RETURN l_result;
 51    END insert_node
 52    ;
 53
 54    FUNCTION update_energy( p_usim_energy  IN usim_node.usim_energy%TYPE
 55                          , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
 56                          , p_do_commit    IN BOOLEAN                    DEFAULT TRUE
 57                          )
 58      RETURN usim_node.usim_energy%TYPE
 59    IS
 60      l_result usim_node.usim_energy%TYPE;
 61    BEGIN
 62      IF usim_nod.has_data(p_usim_id_nod) = 1
 63      THEN
 64        UPDATE usim_node SET usim_energy = p_usim_energy WHERE usim_id_nod = p_usim_id_nod RETURNING usim_energy INTO l_result;
 65        IF p_do_commit
 66        THEN
 67          COMMIT;
 68        END IF;
 69        RETURN l_result;
 70      ELSE
 71        usim_erl.log_error('usim_nod.update_energy', 'Used with not existing node id [' || p_usim_id_nod || '].');
 72        RETURN NULL;
 73      END IF;
 74    END update_energy
 75    ;
 76
 77    FUNCTION add_energy( p_usim_energy  IN NUMBER
 78                       , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
 79                       , p_do_commit    IN BOOLEAN                    DEFAULT TRUE
 80                       )
 81      RETURN usim_node.usim_energy%TYPE
 82    IS
 83      l_energy NUMBER;
 84    BEGIN
 85      l_energy := NVL(p_usim_energy, 0) + NVL(usim_nod.get_energy(p_usim_id_nod), 0);
 86      RETURN usim_nod.update_energy(l_energy, p_usim_id_nod, p_do_commit);
 87    END add_energy
 88    ;
 89
 90  END usim_nod;
 91  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_nod
IS
  -- see header for documentation
  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_node;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_node WHERE usim_id_nod = p_usim_id_nod;
    RETURN l_result;
  END has_data
  ;

  FUNCTION get_energy(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_nod.has_data(p_usim_id_nod) = 1
    THEN
      SELECT usim_energy INTO l_result FROM usim_node WHERE usim_id_nod = p_usim_id_nod;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_nod.get_energy', 'Used with not existing node id [' || p_usim_id_nod || '].');
      RETURN NULL;
    END IF;
  END get_energy
  ;

  FUNCTION insert_node(p_do_commit  IN BOOLEAN  DEFAULT TRUE)
    RETURN usim_node.usim_id_nod%TYPE
  IS
    l_result usim_node.usim_id_nod%TYPE;
  BEGIN
    INSERT INTO usim_node (usim_energy) VALUES (NULL) RETURNING usim_id_nod INTO l_result;
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN l_result;
  END insert_node
  ;

  FUNCTION update_energy( p_usim_energy  IN usim_node.usim_energy%TYPE
                        , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
                        , p_do_commit    IN BOOLEAN                    DEFAULT TRUE
                        )
    RETURN usim_node.usim_energy%TYPE
  IS
    l_result usim_node.usim_energy%TYPE;
  BEGIN
    IF usim_nod.has_data(p_usim_id_nod) = 1
    THEN
      UPDATE usim_node SET usim_energy = p_usim_energy WHERE usim_id_nod = p_usim_id_nod RETURNING usim_energy INTO l_result;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_nod.update_energy', 'Used with not existing node id [' || p_usim_id_nod || '].');
      RETURN NULL;
    END IF;
  END update_energy
  ;

  FUNCTION add_energy( p_usim_energy  IN NUMBER
                     , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
                     , p_do_commit    IN BOOLEAN                    DEFAULT TRUE
                     )
    RETURN usim_node.usim_energy%TYPE
  IS
    l_energy NUMBER;
  BEGIN
    l_energy := NVL(p_usim_energy, 0) + NVL(usim_nod.get_energy(p_usim_id_nod), 0);
    RETURN usim_nod.update_energy(l_energy, p_usim_id_nod, p_do_commit);
  END add_energy
  ;

END usim_nod;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_nod
IS
  -- see header for documentation
  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_node;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_node WHERE usim_id_nod = p_usim_id_nod;
    RETURN l_result;
  END has_data
  ;

  FUNCTION get_energy(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_nod.has_data(p_usim_id_nod) = 1
    THEN
      SELECT usim_energy INTO l_result FROM usim_node WHERE usim_id_nod = p_usim_id_nod;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_nod.get_energy', 'Used with not existing node id [' || p_usim_id_nod || '].');
      RETURN NULL;
    END IF;
  END get_energy
  ;

  FUNCTION insert_node(p_do_commit  IN BOOLEAN  DEFAULT TRUE)
    RETURN usim_node.usim_id_nod%TYPE
  IS
    l_result usim_node.usim_id_nod%TYPE;
  BEGIN
    INSERT INTO usim_node (usim_energy) VALUES (NULL) RETURNING usim_id_nod INTO l_result;
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN l_result;
  END insert_node
  ;

  FUNCTION update_energy( p_usim_energy  IN usim_node.usim_energy%TYPE
                        , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
                        , p_do_commit    IN BOOLEAN                    DEFAULT TRUE
                        )
    RETURN usim_node.usim_energy%TYPE
  IS
    l_result usim_node.usim_energy%TYPE;
  BEGIN
    IF usim_nod.has_data(p_usim_id_nod) = 1
    THEN
      UPDATE usim_node SET usim_energy = p_usim_energy WHERE usim_id_nod = p_usim_id_nod RETURNING usim_energy INTO l_result;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_nod.update_energy', 'Used with not existing node id [' || p_usim_id_nod || '].');
      RETURN NULL;
    END IF;
  END update_energy
  ;

  FUNCTION add_energy( p_usim_energy  IN NUMBER
                     , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
                     , p_do_commit    IN BOOLEAN                    DEFAULT TRUE
                     )
    RETURN usim_node.usim_energy%TYPE
  IS
    l_energy NUMBER;
  BEGIN
    l_energy := NVL(p_usim_energy, 0) + NVL(usim_nod.get_energy(p_usim_id_nod), 0);
    RETURN usim_nod.update_energy(l_energy, p_usim_id_nod, p_do_commit);
  END add_energy
  ;

END usim_nod;

Package Body USIM_NOD kompiliert

SQL> --== base tables end ==--
SQL>
SQL> --== relation tables start ==--
SQL> -- USIM_REL_MLV_DIM (rmd)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_REL_MLV_DIM_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_REL_MLV_DIM still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_REL_MLV_DIM'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_REL_MLV_DIM_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_REL_MLV_DIM still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_REL_MLV_DIM'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_REL_MLV_DIM_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_REL_MLV_DIM still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_REL_MLV_DIM'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------------
../TABLES/USIM_REL_MLV_DIM_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_REL_MLV_DIM (rmd)
SQL> CREATE TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  2    ( usim_id_rmd  CHAR(55)      NOT NULL ENABLE
  3    , usim_id_mlv  CHAR(55)      NOT NULL ENABLE
  4    , usim_id_dim  CHAR(55)      NOT NULL ENABLE
  5    , usim_sign    NUMBER(1, 0)  NOT NULL ENABLE
  6    , usim_n1_sign NUMBER(1, 0)
  7    )
  8  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  ( usim_id_rmd  CHAR(55)      NOT NULL ENABLE
  , usim_id_mlv  CHAR(55)      NOT NULL ENABLE
  , usim_id_dim  CHAR(55)      NOT NULL ENABLE
  , usim_sign    NUMBER(1, 0)  NOT NULL ENABLE
  , usim_n1_sign NUMBER(1, 0)
  )

neu:CREATE TABLE USIM_TEST.usim_rel_mlv_dim
  ( usim_id_rmd  CHAR(55)      NOT NULL ENABLE
  , usim_id_mlv  CHAR(55)      NOT NULL ENABLE
  , usim_id_dim  CHAR(55)      NOT NULL ENABLE
  , usim_sign    NUMBER(1, 0)  NOT NULL ENABLE
  , usim_n1_sign NUMBER(1, 0)
  )

Table USIM_TEST.USIM_REL_MLV_DIM erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_rel_mlv_dim IS 'A table describing the relation between dimension and a specific universe. Will use the alias rmd.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_rel_mlv_dim IS 'A table describing the relation between dimension and a specific universe. Will use the alias rmd.'
neu:COMMENT ON TABLE USIM_TEST.usim_rel_mlv_dim IS 'A table describing the relation between dimension and a specific universe. Will use the alias rmd.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_id_rmd IS 'The unique id of the relation between universe and dimension. Automatically set, ignored on update';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_id_rmd IS 'The unique id of the relation between universe and dimension. Automatically set, ignored on update'
neu:COMMENT ON COLUMN USIM_TEST.usim_rel_mlv_dim.usim_id_rmd IS 'The unique id of the relation between universe and dimension. Automatically set, ignored on update'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_id_mlv IS 'The universe id to relate to a dimension. Must be set on insert, ignored on update.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_id_mlv IS 'The universe id to relate to a dimension. Must be set on insert, ignored on update.'
neu:COMMENT ON COLUMN USIM_TEST.usim_rel_mlv_dim.usim_id_mlv IS 'The universe id to relate to a dimension. Must be set on insert, ignored on update.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_id_dim IS 'The dimension id to relate to a universe. Must be set on insert, ignored on update.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_id_dim IS 'The dimension id to relate to a universe. Must be set on insert, ignored on update.'
neu:COMMENT ON COLUMN USIM_TEST.usim_rel_mlv_dim.usim_id_dim IS 'The dimension id to relate to a universe. Must be set on insert, ignored on update.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_sign IS 'The sign of the dimension axis to relate to a universe. Only 0, 1 and -1 allowed. Must be set on insert, ignored on update.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_sign IS 'The sign of the dimension axis to relate to a universe. Only 0, 1 and -1 allowed. Must be set on insert, ignored on update.'
neu:COMMENT ON COLUMN USIM_TEST.usim_rel_mlv_dim.usim_sign IS 'The sign of the dimension axis to relate to a universe. Only 0, 1 and -1 allowed. Must be set on insert, ignored on update.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_n1_sign IS 'The sign of the ancestor dimension axis at n = 1. NULL, 1 and -1 allowed. Must be set on insert, ignored on update.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_n1_sign IS 'The sign of the ancestor dimension axis at n = 1. NULL, 1 and -1 allowed. Must be set on insert, ignored on update.'
neu:COMMENT ON COLUMN USIM_TEST.usim_rel_mlv_dim.usim_n1_sign IS 'The sign of the ancestor dimension axis at n = 1. NULL, 1 and -1 allowed. Must be set on insert, ignored on update.'

Comment erstellt.

SQL>
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  2    ADD CONSTRAINT usim_rmd_pk
  3    PRIMARY KEY (usim_id_rmd)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  ADD CONSTRAINT usim_rmd_pk
  PRIMARY KEY (usim_id_rmd)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_rel_mlv_dim
  ADD CONSTRAINT usim_rmd_pk
  PRIMARY KEY (usim_id_rmd)
  ENABLE

Table USIM_TEST.USIM_REL_MLV_DIM geändert.

SQL>
SQL> -- uk universe/dim/sign/n1 sign is unique
SQL> ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  2    ADD CONSTRAINT usim_rmd_uk
  3    UNIQUE (usim_id_mlv, usim_id_dim, usim_sign, usim_n1_sign)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  ADD CONSTRAINT usim_rmd_uk
  UNIQUE (usim_id_mlv, usim_id_dim, usim_sign, usim_n1_sign)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_rel_mlv_dim
  ADD CONSTRAINT usim_rmd_uk
  UNIQUE (usim_id_mlv, usim_id_dim, usim_sign, usim_n1_sign)
  ENABLE

Table USIM_TEST.USIM_REL_MLV_DIM geändert.

SQL>
SQL> -- uk universe/dim/sign is unique
SQL> ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  2    ADD CONSTRAINT usim_rmd_chk_sign
  3    CHECK (usim_sign IN (0, 1, -1))
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  ADD CONSTRAINT usim_rmd_chk_sign
  CHECK (usim_sign IN (0, 1, -1))
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_rel_mlv_dim
  ADD CONSTRAINT usim_rmd_chk_sign
  CHECK (usim_sign IN (0, 1, -1))
  ENABLE

Table USIM_TEST.USIM_REL_MLV_DIM geändert.

SQL>
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rmd_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_rel_mlv_dim
  3      FOR EACH ROW
  4      BEGIN
  5        -- ignore input on pk
  6        :NEW.usim_id_rmd := usim_static.get_big_pk(usim_rmd_id_seq.NEXTVAL);
  7        -- check sign
  8        IF usim_dim.get_dimension(:NEW.usim_id_dim) = 0
  9        THEN
 10          IF :NEW.usim_sign != 0
 11          THEN
 12            RAISE_APPLICATION_ERROR( num => -20000
 13                                  , msg => 'Insert requirement not fulfilled. USIM_SIGN must be 0 for dimension 0.'
 14                                  )
 15            ;
 16          END IF;
 17        ELSE
 18          IF     usim_dim.get_dimension(:NEW.usim_id_dim) > 1
 19             AND :NEW.usim_n1_sign NOT IN (1, -1)
 20          THEN
 21            RAISE_APPLICATION_ERROR( num => -20000
 22                                  , msg => 'Insert requirement not fulfilled. USIM_N1_SIGN must be 1 or -1 for dimension > 1.'
 23                                  )
 24            ;
 25          END IF;
 26          IF :NEW.usim_sign NOT IN (1, -1)
 27          THEN
 28            RAISE_APPLICATION_ERROR( num => -20000
 29                                  , msg => 'Insert requirement not fulfilled. USIM_SIGN must be +1 or -1 for dimension > 0.'
 30                                  )
 31            ;
 32          END IF;
 33        END IF;
 34      END;
 35  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rmd_ins_trg
  BEFORE INSERT ON &USIM_SCHEMA..usim_rel_mlv_dim
    FOR EACH ROW
    BEGIN
      -- ignore input on pk
      :NEW.usim_id_rmd := usim_static.get_big_pk(usim_rmd_id_seq.NEXTVAL);
      -- check sign
      IF usim_dim.get_dimension(:NEW.usim_id_dim) = 0
      THEN
        IF :NEW.usim_sign != 0
        THEN
          RAISE_APPLICATION_ERROR( num => -20000
                                , msg => 'Insert requirement not fulfilled. USIM_SIGN must be 0 for dimension 0.'
                                )
          ;
        END IF;
      ELSE
        IF     usim_dim.get_dimension(:NEW.usim_id_dim) > 1
           AND :NEW.usim_n1_sign NOT IN (1, -1)
        THEN
          RAISE_APPLICATION_ERROR( num => -20000
                                , msg => 'Insert requirement not fulfilled. USIM_N1_SIGN must be 1 or -1 for dimension > 1.'
                                )
          ;
        END IF;
        IF :NEW.usim_sign NOT IN (1, -1)
        THEN
          RAISE_APPLICATION_ERROR( num => -20000
                                , msg => 'Insert requirement not fulfilled. USIM_SIGN must be +1 or -1 for dimension > 0.'
                                )
          ;
        END IF;
      END IF;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_rmd_ins_trg
  BEFORE INSERT ON USIM_TEST.usim_rel_mlv_dim
    FOR EACH ROW
    BEGIN
      -- ignore input on pk
      :NEW.usim_id_rmd := usim_static.get_big_pk(usim_rmd_id_seq.NEXTVAL);
      -- check sign
      IF usim_dim.get_dimension(:NEW.usim_id_dim) = 0
      THEN
        IF :NEW.usim_sign != 0
        THEN
          RAISE_APPLICATION_ERROR( num => -20000
                                , msg => 'Insert requirement not fulfilled. USIM_SIGN must be 0 for dimension 0.'
                                )
          ;
        END IF;
      ELSE
        IF     usim_dim.get_dimension(:NEW.usim_id_dim) > 1
           AND :NEW.usim_n1_sign NOT IN (1, -1)
        THEN
          RAISE_APPLICATION_ERROR( num => -20000
                                , msg => 'Insert requirement not fulfilled. USIM_N1_SIGN must be 1 or -1 for dimension > 1.'
                                )
          ;
        END IF;
        IF :NEW.usim_sign NOT IN (1, -1)
        THEN
          RAISE_APPLICATION_ERROR( num => -20000
                                , msg => 'Insert requirement not fulfilled. USIM_SIGN must be +1 or -1 for dimension > 0.'
                                )
          ;
        END IF;
      END IF;
    END;

Trigger USIM_RMD_INS_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_rmd_ins_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_rmd_ins_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_rmd_ins_trg ENABLE

Trigger USIM_TEST.USIM_RMD_INS_TRG geändert.

SQL>
SQL> -- update trigger to prevent updates
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rmd_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_rel_mlv_dim
  3      FOR EACH ROW
  4      BEGIN
  5        RAISE_APPLICATION_ERROR( num => -20001
  6                               , msg => 'Update requirement not fulfilled. No update allowed.'
  7                               )
  8        ;
  9      END;
 10  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rmd_upd_trg
  BEFORE UPDATE ON &USIM_SCHEMA..usim_rel_mlv_dim
    FOR EACH ROW
    BEGIN
      RAISE_APPLICATION_ERROR( num => -20001
                             , msg => 'Update requirement not fulfilled. No update allowed.'
                             )
      ;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_rmd_upd_trg
  BEFORE UPDATE ON USIM_TEST.usim_rel_mlv_dim
    FOR EACH ROW
    BEGIN
      RAISE_APPLICATION_ERROR( num => -20001
                             , msg => 'Update requirement not fulfilled. No update allowed.'
                             )
      ;
    END;

Trigger USIM_RMD_UPD_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_rmd_upd_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_rmd_upd_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_rmd_upd_trg ENABLE

Trigger USIM_TEST.USIM_RMD_UPD_TRG geändert.

SQL> -- foreign keys
SQL> @@../FK/USIM_RMD_MLV_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk relation universe/dimension for universe (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  2    ADD CONSTRAINT usim_rmd_mlv_fk
  3    FOREIGN KEY (usim_id_mlv) REFERENCES usim_multiverse (usim_id_mlv) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  ADD CONSTRAINT usim_rmd_mlv_fk
  FOREIGN KEY (usim_id_mlv) REFERENCES usim_multiverse (usim_id_mlv) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_rel_mlv_dim
  ADD CONSTRAINT usim_rmd_mlv_fk
  FOREIGN KEY (usim_id_mlv) REFERENCES usim_multiverse (usim_id_mlv) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_REL_MLV_DIM geändert.

SQL> @@../FK/USIM_RMD_DIM_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk relation universe/dimension for dimensions (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  2    ADD CONSTRAINT usim_rmd_dim_fk
  3    FOREIGN KEY (usim_id_dim) REFERENCES usim_dimension (usim_id_dim) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  ADD CONSTRAINT usim_rmd_dim_fk
  FOREIGN KEY (usim_id_dim) REFERENCES usim_dimension (usim_id_dim) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_rel_mlv_dim
  ADD CONSTRAINT usim_rmd_dim_fk
  FOREIGN KEY (usim_id_dim) REFERENCES usim_dimension (usim_id_dim) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_REL_MLV_DIM geändert.

SQL> -- views
SQL> @@../VIEW/USIM_RMD_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_RMD_V (rmdv)
SQL> -- minimal joining to get universe basics and dimension for the relation table usim_rel_mlv_dim
SQL> CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_rmd_v AS
  2    SELECT rmd.usim_id_rmd
  3         , rmd.usim_id_mlv
  4         , rmd.usim_id_dim
  5         , rmd.usim_sign
  6         , rmd.usim_n1_sign
  7         , dim.usim_n_dimension
  8         , mlv.usim_universe_status
  9         , mlv.usim_is_base_universe
 10         , CASE
 11             WHEN dim.usim_n_dimension = 0
 12             THEN mlv.usim_energy_start_value
 13             ELSE NULL
 14           END AS usim_energy_start_value
 15         , mlv.usim_ultimate_border
 16      FROM usim_rel_mlv_dim rmd
 17     INNER JOIN usim_dimension dim
 18        ON rmd.usim_id_dim = dim.usim_id_dim
 19     INNER JOIN usim_multiverse mlv
 20        ON rmd.usim_id_mlv = mlv.usim_id_mlv
 21  ;
alt:CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_rmd_v AS
  SELECT rmd.usim_id_rmd
       , rmd.usim_id_mlv
       , rmd.usim_id_dim
       , rmd.usim_sign
       , rmd.usim_n1_sign
       , dim.usim_n_dimension
       , mlv.usim_universe_status
       , mlv.usim_is_base_universe
       , CASE
           WHEN dim.usim_n_dimension = 0
           THEN mlv.usim_energy_start_value
           ELSE NULL
         END AS usim_energy_start_value
       , mlv.usim_ultimate_border
    FROM usim_rel_mlv_dim rmd
   INNER JOIN usim_dimension dim
      ON rmd.usim_id_dim = dim.usim_id_dim
   INNER JOIN usim_multiverse mlv
      ON rmd.usim_id_mlv = mlv.usim_id_mlv

neu:CREATE OR REPLACE FORCE VIEW USIM_TEST.usim_rmd_v AS
  SELECT rmd.usim_id_rmd
       , rmd.usim_id_mlv
       , rmd.usim_id_dim
       , rmd.usim_sign
       , rmd.usim_n1_sign
       , dim.usim_n_dimension
       , mlv.usim_universe_status
       , mlv.usim_is_base_universe
       , CASE
           WHEN dim.usim_n_dimension = 0
           THEN mlv.usim_energy_start_value
           ELSE NULL
         END AS usim_energy_start_value
       , mlv.usim_ultimate_border
    FROM usim_rel_mlv_dim rmd
   INNER JOIN usim_dimension dim
      ON rmd.usim_id_dim = dim.usim_id_dim
   INNER JOIN usim_multiverse mlv
      ON rmd.usim_id_mlv = mlv.usim_id_mlv

View USIM_TEST.USIM_RMD_V erstellt.

SQL> -- usim_rel_mlv_dim package
SQL> @@../PACKAGES/USIM_RMD.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_rmd
  2  IS
  3    /**A low level package for actions on table usim_rel_mlv_dim and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9
 10    /**
 11    * Checks if usim_rel_mlv_dim has already data.
 12    * @return Returns 1 if data are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15      RETURN NUMBER
 16    ;
 17
 18    /**
 19    * Checks if usim_rel_mlv_dim has already data for a given relation id.
 20    * @param p_usim_id_rmd The relation id of universe/dimension.
 21    * @return Returns 1 if data are available, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 24      RETURN NUMBER
 25    ;
 26
 27    /**
 28    * Checks if usim_rel_mlv_dim has already data for a dimension axis and universe.
 29    * @param p_usim_id_mlv The universe id of the relation.
 30    * @param p_usim_id_dim The dimension id of the relation.
 31    * @param p_usim_sign The sign of the dimension axis.
 32    * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
 33    * @return Returns 1 if data are available, otherwise 0.
 34    */
 35    FUNCTION has_data( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
 36                     , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
 37                     , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
 38                     , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
 39                     )
 40      RETURN NUMBER
 41    ;
 42
 43    /**
 44    * Checks if usim_rel_mlv_dim has already data for a dimension axis and universe.
 45    * @param p_usim_id_mlv The universe id of the relation.
 46    * @param p_usim_n_dimension The dimension of the relation.
 47    * @param p_usim_sign The sign of the dimension axis.
 48    * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
 49    * @return Returns 1 if data are available, otherwise 0.
 50    */
 51    FUNCTION has_data( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
 52                     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 53                     , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
 54                     , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
 55                     )
 56      RETURN NUMBER
 57    ;
 58
 59    /**
 60    * Retrieves the maximum dimension for a given universe.
 61    * @return Returns usim_n_dimension or -1 if no dimension for this universe exist.
 62    */
 63    FUNCTION get_max_dimension(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 64      RETURN usim_dimension.usim_n_dimension%TYPE
 65    ;
 66
 67    /**
 68    * Retrieve the dimension for a given universe/dimension relation.
 69    * @param p_usim_id_rmd The universe/dimension id.
 70    * @return The related dimension for the given id or NULL if id does not exist.
 71    */
 72    FUNCTION get_dimension(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 73      RETURN usim_dimension.usim_n_dimension%TYPE
 74    ;
 75
 76    /**
 77    * Retrieve the dimension sign for a given universe/dimension relation.
 78    * @param p_usim_id_rmd The universe/dimension id.
 79    * @return The related dimension sign for the given id or NULL if id does not exist.
 80    */
 81    FUNCTION get_dim_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 82      RETURN usim_rel_mlv_dim.usim_sign%TYPE
 83    ;
 84
 85    /**
 86    * Retrieve the dimension sign of the n=1 ancestor for a given universe/dimension relation.
 87    * @param p_usim_id_rmd The universe/dimension id.
 88    * @return The related dimension sign of the n=1 ancestor for the given id or 0 if id does not exist (NULL is a valid return value).
 89    */
 90    FUNCTION get_dim_n1_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 91      RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
 92    ;
 93
 94    /**
 95    * Retrieve the universe id for a given universe/dimension relation.
 96    * @param p_usim_id_rmd The universe/dimension id.
 97    * @return The related universe id for the given id or NULL if id does not exist.
 98    */
 99    FUNCTION get_id_mlv(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
100      RETURN usim_multiverse.usim_id_mlv%TYPE
101    ;
102
103    /**
104    * Retrieve the dimension id for a given universe/dimension relation.
105    * @param p_usim_id_rmd The universe/dimension id.
106    * @return The related dimension id for the given id or NULL if id does not exist.
107    */
108    FUNCTION get_id_dim(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
109      RETURN usim_dimension.usim_id_dim%TYPE
110    ;
111
112    /**
113    * Retrieve details a given universe/dimension relation without the universe id.
114    * @param p_usim_id_rmd The universe/dimension id.
115    * @param p_usim_id_dim Return the related dimension id.
116    * @param p_usim_sign Return the related dimension sign.
117    * @param p_usim_n1_sign Return the related n=1 dimension ancestor sign.
118    * @return Return 1 if data could be fetched otherwise 0.
119    */
120    FUNCTION get_rmd_details( p_usim_id_rmd  IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
121                            , p_usim_id_dim  OUT usim_dimension.usim_id_dim%TYPE
122                            , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
123                            , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
124                            )
125      RETURN NUMBER
126    ;
127
128    /**
129    * Retrieve details a given universe/dimension relation without the universe id.
130    * @param p_usim_id_rmd The universe/dimension id.
131    * @param p_usim_n_dimension Return the related dimension.
132    * @param p_usim_sign Return the related dimension sign.
133    * @param p_usim_n1_sign Return the related n=1 dimension ancestor sign.
134    * @return Return 1 if data could be fetched otherwise 0.
135    */
136    FUNCTION get_rmd_details( p_usim_id_rmd       IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
137                            , p_usim_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
138                            , p_usim_sign         OUT usim_rel_mlv_dim.usim_sign%TYPE
139                            , p_usim_n1_sign      OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
140                            )
141      RETURN NUMBER
142    ;
143
144    /**
145    * Retrieve details a given universe/dimension relation.
146    * @param p_usim_id_rmd The universe/dimension id.
147    * @param p_usim_id_mlv Return the related universe id.
148    * @param p_usim_id_dim Return the related dimension id.
149    * @param p_usim_sign Return the related dimension sign.
150    * @param p_usim_n1_sign Return the related n=1 dimension ancestor sign.
151    * @return The related dimension id for the given id or NULL if id does not exist.
152    */
153    FUNCTION get_rmd_details( p_usim_id_rmd  IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
154                            , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
155                            , p_usim_id_dim  OUT usim_dimension.usim_id_dim%TYPE
156                            , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
157                            , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
158                            )
159      RETURN NUMBER
160    ;
161
162    /**
163    * Retrieve the rule for ulimate or any border of the associated dimension.
164    * @param p_usim_id_rmd The universe/dimension id.
165    * @return Returns 1, rule for ultimate border or 0, rule for any border if given universe exists, otherwise -1.
166    */
167    FUNCTION get_ultimate_border(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
168      RETURN usim_multiverse.usim_ultimate_border%TYPE
169    ;
170
171    /**
172    * Gets the relation id for a universe and dimension id.
173    * @param p_usim_id_mlv The universe id of the relation.
174    * @param p_usim_id_dim The dimension id of the relation.
175    * @param p_usim_sign The sign of the dimension axis.
176    * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
177    * @return Returns usim_id_rmd for given parameters or NULL if relation does not exists.
178    */
179    FUNCTION get_id_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
180                       , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
181                       , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE   DEFAULT 1
182                       , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
183                       )
184      RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
185    ;
186
187    /**
188    * Gets the relation id for a universe id and a dimension.
189    * @param p_usim_id_mlv The universe id of the relation.
190    * @param p_usim_n_dimension The dimension of the relation.
191    * @param p_usim_sign The sign of the dimension axis.
192    * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
193    * @return Returns usim_id_rmd for given parameters or NULL if relation does not exists.
194    */
195    FUNCTION get_id_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
196                       , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
197                       , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE      DEFAULT 1
198                       , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
199                       )
200      RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
201    ;
202
203    /**
204    * Inserts a new relation for a universe and dimension id describing one side of the dimension axis if n > 0.
205    * @param p_usim_id_mlv The universe id of the relation.
206    * @param p_usim_id_dim The dimension id of the relation.
207    * @param p_usim_sign The sign of the dimension axis.
208    * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
209    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
210    * @return Returns the new/existing usim_id_rmd or NULL if universe/dimension does not exists / overflow reached.
211    */
212    FUNCTION insert_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
213                       , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
214                       , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
215                       , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
216                       , p_do_commit    IN BOOLEAN                           DEFAULT TRUE
217                       )
218      RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
219    ;
220
221    /**
222    * Inserts a new relation for a universe id and a dimension describing one side of the dimension axis if n > 0.
223    * @param p_usim_id_mlv The universe id of the relation.
224    * @param p_usim_n_dimension The dimension of the relation.
225    * @param p_usim_sign The sign of the dimension axis.
226    * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
227    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
228    * @return Returns the new/existing usim_id_rmd or NULL if universe/dimension does not exists / overflow reached.
229    */
230    FUNCTION insert_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
231                       , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
232                       , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
233                       , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
234                       , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
235                       )
236      RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
237    ;
238
239  END usim_rmd;
240  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_rmd
IS
  /**A low level package for actions on table usim_rel_mlv_dim and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_rel_mlv_dim has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_rel_mlv_dim has already data for a given relation id.
  * @param p_usim_id_rmd The relation id of universe/dimension.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_rel_mlv_dim has already data for a dimension axis and universe.
  * @param p_usim_id_mlv The universe id of the relation.
  * @param p_usim_id_dim The dimension id of the relation.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
                   , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
                   , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
                   , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                   )
    RETURN NUMBER
  ;

  /**
  * Checks if usim_rel_mlv_dim has already data for a dimension axis and universe.
  * @param p_usim_id_mlv The universe id of the relation.
  * @param p_usim_n_dimension The dimension of the relation.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                   , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                   , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
                   , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                   )
    RETURN NUMBER
  ;

  /**
  * Retrieves the maximum dimension for a given universe.
  * @return Returns usim_n_dimension or -1 if no dimension for this universe exist.
  */
  FUNCTION get_max_dimension(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Retrieve the dimension for a given universe/dimension relation.
  * @param p_usim_id_rmd The universe/dimension id.
  * @return The related dimension for the given id or NULL if id does not exist.
  */
  FUNCTION get_dimension(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Retrieve the dimension sign for a given universe/dimension relation.
  * @param p_usim_id_rmd The universe/dimension id.
  * @return The related dimension sign for the given id or NULL if id does not exist.
  */
  FUNCTION get_dim_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  ;

  /**
  * Retrieve the dimension sign of the n=1 ancestor for a given universe/dimension relation.
  * @param p_usim_id_rmd The universe/dimension id.
  * @return The related dimension sign of the n=1 ancestor for the given id or 0 if id does not exist (NULL is a valid return value).
  */
  FUNCTION get_dim_n1_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
  ;

  /**
  * Retrieve the universe id for a given universe/dimension relation.
  * @param p_usim_id_rmd The universe/dimension id.
  * @return The related universe id for the given id or NULL if id does not exist.
  */
  FUNCTION get_id_mlv(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_multiverse.usim_id_mlv%TYPE
  ;

  /**
  * Retrieve the dimension id for a given universe/dimension relation.
  * @param p_usim_id_rmd The universe/dimension id.
  * @return The related dimension id for the given id or NULL if id does not exist.
  */
  FUNCTION get_id_dim(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_dimension.usim_id_dim%TYPE
  ;

  /**
  * Retrieve details a given universe/dimension relation without the universe id.
  * @param p_usim_id_rmd The universe/dimension id.
  * @param p_usim_id_dim Return the related dimension id.
  * @param p_usim_sign Return the related dimension sign.
  * @param p_usim_n1_sign Return the related n=1 dimension ancestor sign.
  * @return Return 1 if data could be fetched otherwise 0.
  */
  FUNCTION get_rmd_details( p_usim_id_rmd  IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_dim  OUT usim_dimension.usim_id_dim%TYPE
                          , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          )
    RETURN NUMBER
  ;

  /**
  * Retrieve details a given universe/dimension relation without the universe id.
  * @param p_usim_id_rmd The universe/dimension id.
  * @param p_usim_n_dimension Return the related dimension.
  * @param p_usim_sign Return the related dimension sign.
  * @param p_usim_n1_sign Return the related n=1 dimension ancestor sign.
  * @return Return 1 if data could be fetched otherwise 0.
  */
  FUNCTION get_rmd_details( p_usim_id_rmd       IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
                          , p_usim_sign         OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_usim_n1_sign      OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          )
    RETURN NUMBER
  ;

  /**
  * Retrieve details a given universe/dimension relation.
  * @param p_usim_id_rmd The universe/dimension id.
  * @param p_usim_id_mlv Return the related universe id.
  * @param p_usim_id_dim Return the related dimension id.
  * @param p_usim_sign Return the related dimension sign.
  * @param p_usim_n1_sign Return the related n=1 dimension ancestor sign.
  * @return The related dimension id for the given id or NULL if id does not exist.
  */
  FUNCTION get_rmd_details( p_usim_id_rmd  IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
                          , p_usim_id_dim  OUT usim_dimension.usim_id_dim%TYPE
                          , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          )
    RETURN NUMBER
  ;

  /**
  * Retrieve the rule for ulimate or any border of the associated dimension.
  * @param p_usim_id_rmd The universe/dimension id.
  * @return Returns 1, rule for ultimate border or 0, rule for any border if given universe exists, otherwise -1.
  */
  FUNCTION get_ultimate_border(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_multiverse.usim_ultimate_border%TYPE
  ;

  /**
  * Gets the relation id for a universe and dimension id.
  * @param p_usim_id_mlv The universe id of the relation.
  * @param p_usim_id_dim The dimension id of the relation.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
  * @return Returns usim_id_rmd for given parameters or NULL if relation does not exists.
  */
  FUNCTION get_id_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
                     , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE   DEFAULT 1
                     , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  ;

  /**
  * Gets the relation id for a universe id and a dimension.
  * @param p_usim_id_mlv The universe id of the relation.
  * @param p_usim_n_dimension The dimension of the relation.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
  * @return Returns usim_id_rmd for given parameters or NULL if relation does not exists.
  */
  FUNCTION get_id_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                     , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE      DEFAULT 1
                     , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  ;

  /**
  * Inserts a new relation for a universe and dimension id describing one side of the dimension axis if n > 0.
  * @param p_usim_id_mlv The universe id of the relation.
  * @param p_usim_id_dim The dimension id of the relation.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new/existing usim_id_rmd or NULL if universe/dimension does not exists / overflow reached.
  */
  FUNCTION insert_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
                     , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
                     , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     , p_do_commit    IN BOOLEAN                           DEFAULT TRUE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  ;

  /**
  * Inserts a new relation for a universe id and a dimension describing one side of the dimension axis if n > 0.
  * @param p_usim_id_mlv The universe id of the relation.
  * @param p_usim_n_dimension The dimension of the relation.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new/existing usim_id_rmd or NULL if universe/dimension does not exists / overflow reached.
  */
  FUNCTION insert_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                     , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
                     , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  ;

END usim_rmd;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_rmd
IS
  /**A low level package for actions on table usim_rel_mlv_dim and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_rel_mlv_dim has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_rel_mlv_dim has already data for a given relation id.
  * @param p_usim_id_rmd The relation id of universe/dimension.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_rel_mlv_dim has already data for a dimension axis and universe.
  * @param p_usim_id_mlv The universe id of the relation.
  * @param p_usim_id_dim The dimension id of the relation.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
                   , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
                   , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
                   , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                   )
    RETURN NUMBER
  ;

  /**
  * Checks if usim_rel_mlv_dim has already data for a dimension axis and universe.
  * @param p_usim_id_mlv The universe id of the relation.
  * @param p_usim_n_dimension The dimension of the relation.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                   , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                   , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
                   , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                   )
    RETURN NUMBER
  ;

  /**
  * Retrieves the maximum dimension for a given universe.
  * @return Returns usim_n_dimension or -1 if no dimension for this universe exist.
  */
  FUNCTION get_max_dimension(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Retrieve the dimension for a given universe/dimension relation.
  * @param p_usim_id_rmd The universe/dimension id.
  * @return The related dimension for the given id or NULL if id does not exist.
  */
  FUNCTION get_dimension(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Retrieve the dimension sign for a given universe/dimension relation.
  * @param p_usim_id_rmd The universe/dimension id.
  * @return The related dimension sign for the given id or NULL if id does not exist.
  */
  FUNCTION get_dim_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  ;

  /**
  * Retrieve the dimension sign of the n=1 ancestor for a given universe/dimension relation.
  * @param p_usim_id_rmd The universe/dimension id.
  * @return The related dimension sign of the n=1 ancestor for the given id or 0 if id does not exist (NULL is a valid return value).
  */
  FUNCTION get_dim_n1_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
  ;

  /**
  * Retrieve the universe id for a given universe/dimension relation.
  * @param p_usim_id_rmd The universe/dimension id.
  * @return The related universe id for the given id or NULL if id does not exist.
  */
  FUNCTION get_id_mlv(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_multiverse.usim_id_mlv%TYPE
  ;

  /**
  * Retrieve the dimension id for a given universe/dimension relation.
  * @param p_usim_id_rmd The universe/dimension id.
  * @return The related dimension id for the given id or NULL if id does not exist.
  */
  FUNCTION get_id_dim(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_dimension.usim_id_dim%TYPE
  ;

  /**
  * Retrieve details a given universe/dimension relation without the universe id.
  * @param p_usim_id_rmd The universe/dimension id.
  * @param p_usim_id_dim Return the related dimension id.
  * @param p_usim_sign Return the related dimension sign.
  * @param p_usim_n1_sign Return the related n=1 dimension ancestor sign.
  * @return Return 1 if data could be fetched otherwise 0.
  */
  FUNCTION get_rmd_details( p_usim_id_rmd  IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_dim  OUT usim_dimension.usim_id_dim%TYPE
                          , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          )
    RETURN NUMBER
  ;

  /**
  * Retrieve details a given universe/dimension relation without the universe id.
  * @param p_usim_id_rmd The universe/dimension id.
  * @param p_usim_n_dimension Return the related dimension.
  * @param p_usim_sign Return the related dimension sign.
  * @param p_usim_n1_sign Return the related n=1 dimension ancestor sign.
  * @return Return 1 if data could be fetched otherwise 0.
  */
  FUNCTION get_rmd_details( p_usim_id_rmd       IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
                          , p_usim_sign         OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_usim_n1_sign      OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          )
    RETURN NUMBER
  ;

  /**
  * Retrieve details a given universe/dimension relation.
  * @param p_usim_id_rmd The universe/dimension id.
  * @param p_usim_id_mlv Return the related universe id.
  * @param p_usim_id_dim Return the related dimension id.
  * @param p_usim_sign Return the related dimension sign.
  * @param p_usim_n1_sign Return the related n=1 dimension ancestor sign.
  * @return The related dimension id for the given id or NULL if id does not exist.
  */
  FUNCTION get_rmd_details( p_usim_id_rmd  IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
                          , p_usim_id_dim  OUT usim_dimension.usim_id_dim%TYPE
                          , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          )
    RETURN NUMBER
  ;

  /**
  * Retrieve the rule for ulimate or any border of the associated dimension.
  * @param p_usim_id_rmd The universe/dimension id.
  * @return Returns 1, rule for ultimate border or 0, rule for any border if given universe exists, otherwise -1.
  */
  FUNCTION get_ultimate_border(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_multiverse.usim_ultimate_border%TYPE
  ;

  /**
  * Gets the relation id for a universe and dimension id.
  * @param p_usim_id_mlv The universe id of the relation.
  * @param p_usim_id_dim The dimension id of the relation.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
  * @return Returns usim_id_rmd for given parameters or NULL if relation does not exists.
  */
  FUNCTION get_id_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
                     , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE   DEFAULT 1
                     , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  ;

  /**
  * Gets the relation id for a universe id and a dimension.
  * @param p_usim_id_mlv The universe id of the relation.
  * @param p_usim_n_dimension The dimension of the relation.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
  * @return Returns usim_id_rmd for given parameters or NULL if relation does not exists.
  */
  FUNCTION get_id_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                     , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE      DEFAULT 1
                     , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  ;

  /**
  * Inserts a new relation for a universe and dimension id describing one side of the dimension axis if n > 0.
  * @param p_usim_id_mlv The universe id of the relation.
  * @param p_usim_id_dim The dimension id of the relation.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new/existing usim_id_rmd or NULL if universe/dimension does not exists / overflow reached.
  */
  FUNCTION insert_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
                     , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
                     , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     , p_do_commit    IN BOOLEAN                           DEFAULT TRUE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  ;

  /**
  * Inserts a new relation for a universe id and a dimension describing one side of the dimension axis if n > 0.
  * @param p_usim_id_mlv The universe id of the relation.
  * @param p_usim_n_dimension The dimension of the relation.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new/existing usim_id_rmd or NULL if universe/dimension does not exists / overflow reached.
  */
  FUNCTION insert_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                     , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
                     , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  ;

END usim_rmd;

Package USIM_RMD kompiliert

SQL> @@../PACKAGES/USIM_RMD.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_rmd
  2  IS
  3    -- see header for documentation
  4
  5    FUNCTION has_data
  6      RETURN NUMBER
  7    IS
  8      l_result NUMBER;
  9    BEGIN
 10      SELECT COUNT(*) INTO l_result FROM usim_rel_mlv_dim;
 11      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 12    END has_data
 13    ;
 14
 15    FUNCTION has_data(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 16      RETURN NUMBER
 17    IS
 18      l_result NUMBER;
 19    BEGIN
 20      -- we expect one axis or nothing
 21      SELECT COUNT(*) INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
 22      RETURN l_result;
 23    END has_data
 24    ;
 25
 26    FUNCTION has_data( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
 27                     , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
 28                     , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
 29                     , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
 30                     )
 31      RETURN NUMBER
 32    IS
 33      l_result NUMBER;
 34    BEGIN
 35      -- we expect one axis or nothing
 36      SELECT COUNT(*)
 37        INTO l_result
 38        FROM usim_rel_mlv_dim
 39       WHERE usim_id_mlv          = p_usim_id_mlv
 40         AND usim_id_dim          = p_usim_id_dim
 41         AND usim_sign            = p_usim_sign
 42             -- deal with 0 dimension
 43         AND NVL(usim_n1_sign, 0) = NVL(p_usim_n1_sign, 0)
 44      ;
 45      RETURN l_result;
 46    END has_data
 47    ;
 48
 49    FUNCTION has_data( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
 50                     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 51                     , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
 52                     , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
 53                     )
 54      RETURN NUMBER
 55    IS
 56      l_result NUMBER;
 57    BEGIN
 58      -- we expect one axis or nothing
 59      SELECT COUNT(*)
 60        INTO l_result
 61        FROM usim_rmd_v
 62       WHERE usim_id_mlv          = p_usim_id_mlv
 63         AND usim_n_dimension     = p_usim_n_dimension
 64         AND usim_sign            = p_usim_sign
 65             -- deal with 0 dimension
 66         AND NVL(usim_n1_sign, 0) = NVL(p_usim_n1_sign, 0)
 67      ;
 68      RETURN l_result;
 69    END has_data
 70    ;
 71
 72    FUNCTION get_max_dimension(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 73      RETURN usim_dimension.usim_n_dimension%TYPE
 74    IS
 75      l_result usim_dimension.usim_n_dimension%TYPE;
 76    BEGIN
 77        SELECT MAX(usim_n_dimension) INTO l_result FROM usim_rmd_v WHERE usim_id_mlv = p_usim_id_mlv;
 78        RETURN NVL(l_result, -1);
 79    END get_max_dimension
 80    ;
 81
 82    FUNCTION get_dimension(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 83      RETURN usim_dimension.usim_n_dimension%TYPE
 84    IS
 85      l_result usim_dimension.usim_n_dimension%TYPE;
 86    BEGIN
 87      IF usim_rmd.has_data(p_usim_id_rmd) = 1
 88      THEN
 89        SELECT usim_n_dimension INTO l_result FROM usim_rmd_v WHERE usim_id_rmd = p_usim_id_rmd;
 90        RETURN l_result;
 91      ELSE
 92        usim_erl.log_error('usim_rmd.get_dimension', 'Used with not existing id [' || p_usim_id_rmd || '].');
 93        RETURN NULL;
 94      END IF;
 95    END get_dimension
 96    ;
 97
 98    FUNCTION get_dim_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 99      RETURN usim_rel_mlv_dim.usim_sign%TYPE
100    IS
101      l_result usim_rel_mlv_dim.usim_sign%TYPE;
102    BEGIN
103      IF usim_rmd.has_data(p_usim_id_rmd) = 1
104      THEN
105        SELECT usim_sign INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
106        RETURN l_result;
107      ELSE
108        usim_erl.log_error('usim_rmd.get_dim_sign', 'Used with not existing id [' || p_usim_id_rmd || '].');
109        RETURN NULL;
110      END IF;
111    END get_dim_sign
112    ;
113
114    FUNCTION get_dim_n1_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
115      RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
116    IS
117      l_result usim_rel_mlv_dim.usim_n1_sign%TYPE;
118    BEGIN
119      IF usim_rmd.has_data(p_usim_id_rmd) = 1
120      THEN
121        SELECT usim_n1_sign INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
122        RETURN l_result;
123      ELSE
124        usim_erl.log_error('usim_rmd.get_dim_n1_sign', 'Used with not existing id [' || p_usim_id_rmd || '].');
125        RETURN NULL;
126      END IF;
127    END get_dim_n1_sign
128    ;
129
130    FUNCTION get_id_mlv(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
131      RETURN usim_multiverse.usim_id_mlv%TYPE
132    IS
133      l_result usim_multiverse.usim_id_mlv%TYPE;
134    BEGIN
135      IF usim_rmd.has_data(p_usim_id_rmd) = 1
136      THEN
137        SELECT usim_id_mlv INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
138        RETURN l_result;
139      ELSE
140        usim_erl.log_error('usim_rmd.get_id_mlv', 'Used with not existing id [' || p_usim_id_rmd || '].');
141        RETURN NULL;
142      END IF;
143    END get_id_mlv
144    ;
145
146    FUNCTION get_id_dim(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
147      RETURN usim_dimension.usim_id_dim%TYPE
148    IS
149      l_result usim_dimension.usim_id_dim%TYPE;
150    BEGIN
151      IF usim_rmd.has_data(p_usim_id_rmd) = 1
152      THEN
153        SELECT usim_id_dim INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
154        RETURN l_result;
155      ELSE
156        usim_erl.log_error('usim_rmd.get_id_dim', 'Used with not existing id [' || p_usim_id_rmd || '].');
157        RETURN NULL;
158      END IF;
159    END get_id_dim
160    ;
161
162    FUNCTION get_rmd_details( p_usim_id_rmd  IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
163                            , p_usim_id_dim  OUT usim_dimension.usim_id_dim%TYPE
164                            , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
165                            , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
166                            )
167      RETURN NUMBER
168    IS
169    BEGIN
170      IF usim_rmd.has_data(p_usim_id_rmd) = 1
171      THEN
172        SELECT usim_id_dim
173             , usim_sign
174             , usim_n1_sign
175          INTO p_usim_id_dim
176             , p_usim_sign
177             , p_usim_n1_sign
178          FROM usim_rel_mlv_dim
179         WHERE usim_id_rmd = p_usim_id_rmd
180        ;
181        RETURN 1;
182      ELSE
183        usim_erl.log_error('usim_rmd.get_rmd_details', 'Used with not existing id [' || p_usim_id_rmd || '].');
184        RETURN 0;
185      END IF;
186    END get_rmd_details
187    ;
188
189    FUNCTION get_rmd_details( p_usim_id_rmd       IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
190                            , p_usim_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
191                            , p_usim_sign         OUT usim_rel_mlv_dim.usim_sign%TYPE
192                            , p_usim_n1_sign      OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
193                            )
194      RETURN NUMBER
195    IS
196    BEGIN
197      IF usim_rmd.has_data(p_usim_id_rmd) = 1
198      THEN
199        SELECT usim_n_dimension
200             , usim_sign
201             , usim_n1_sign
202          INTO p_usim_n_dimension
203             , p_usim_sign
204             , p_usim_n1_sign
205          FROM usim_rmd_v
206         WHERE usim_id_rmd = p_usim_id_rmd
207        ;
208        RETURN 1;
209      ELSE
210        usim_erl.log_error('usim_rmd.get_rmd_details', 'Used with not existing id [' || p_usim_id_rmd || '].');
211        RETURN 0;
212      END IF;
213    END get_rmd_details
214    ;
215
216    FUNCTION get_rmd_details( p_usim_id_rmd  IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
217                            , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
218                            , p_usim_id_dim  OUT usim_dimension.usim_id_dim%TYPE
219                            , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
220                            , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
221                            )
222      RETURN NUMBER
223    IS
224    BEGIN
225      IF usim_rmd.has_data(p_usim_id_rmd) = 1
226      THEN
227        SELECT usim_id_mlv
228             , usim_id_dim
229             , usim_sign
230             , usim_n1_sign
231          INTO p_usim_id_mlv
232             , p_usim_id_dim
233             , p_usim_sign
234             , p_usim_n1_sign
235          FROM usim_rel_mlv_dim
236         WHERE usim_id_rmd = p_usim_id_rmd
237        ;
238        RETURN 1;
239      ELSE
240        usim_erl.log_error('usim_rmd.get_rmd_details', 'Used with not existing id [' || p_usim_id_rmd || '].');
241        RETURN 0;
242      END IF;
243    END get_rmd_details
244    ;
245
246    FUNCTION get_ultimate_border(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
247      RETURN usim_multiverse.usim_ultimate_border%TYPE
248    IS
249      l_result usim_multiverse.usim_id_mlv%TYPE;
250    BEGIN
251      IF usim_rmd.has_data(p_usim_id_rmd) = 1
252      THEN
253        SELECT usim_id_mlv INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
254        RETURN usim_mlv.get_ultimate_border(l_result);
255      ELSE
256        usim_erl.log_error('usim_rmd.get_ultimate_border', 'Used with not existing id [' || p_usim_id_rmd || '].');
257        RETURN -1;
258      END IF;
259    END get_ultimate_border
260    ;
261
262    FUNCTION get_id_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
263                       , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
264                       , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE   DEFAULT 1
265                       , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
266                       )
267      RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
268    IS
269      l_result usim_rel_mlv_dim.usim_id_rmd%TYPE;
270    BEGIN
271      IF usim_rmd.has_data(p_usim_id_mlv, p_usim_id_dim, p_usim_sign, p_usim_n1_sign) = 1
272      THEN
273        SELECT usim_id_rmd
274          INTO l_result
275          FROM usim_rel_mlv_dim
276         WHERE usim_id_mlv          = p_usim_id_mlv
277           AND usim_id_dim          = p_usim_id_dim
278           AND usim_sign            = p_usim_sign
279               -- deal with 0 dimension
280           AND NVL(usim_n1_sign, 0) = NVL(p_usim_n1_sign, 0)
281        ;
282        RETURN l_result;
283      ELSE
284        usim_erl.log_error('usim_rmd.get_id_rmd', 'Used with not existing universe id [' || p_usim_id_mlv || '] and dimension id [' || p_usim_id_dim || '].');
285        RETURN NULL;
286      END IF;
287    END get_id_rmd
288    ;
289
290    FUNCTION get_id_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
291                       , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
292                       , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE      DEFAULT 1
293                       , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
294                       )
295      RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
296    IS
297      l_result usim_rel_mlv_dim.usim_id_rmd%TYPE;
298      l_id_dim usim_dimension.usim_id_dim%TYPE;
299    BEGIN
300      IF usim_dim.has_data(p_usim_n_dimension) = 1
301      THEN
302        l_id_dim := usim_dim.get_id_dim(p_usim_n_dimension);
303        RETURN usim_rmd.get_id_rmd(p_usim_id_mlv, l_id_dim, p_usim_sign, p_usim_n1_sign);
304      ELSE
305        usim_erl.log_error('usim_rmd.get_id_rmd', 'Used with not existing dimension [' || p_usim_n_dimension || '].');
306        RETURN NULL;
307      END IF;
308    END get_id_rmd
309    ;
310
311    FUNCTION insert_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
312                       , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
313                       , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
314                       , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
315                       , p_do_commit    IN BOOLEAN                           DEFAULT TRUE
316                       )
317      RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
318    IS
319      l_result  usim_rel_mlv_dim.usim_id_rmd%TYPE;
320      l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
321    BEGIN
322      IF     usim_dim.get_dimension(p_usim_id_dim) = 0
323         AND p_usim_sign                          != 0
324      THEN
325        usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension id [' || p_usim_id_dim || '] for sign [' || p_usim_sign || '].');
326        RETURN NULL;
327      END IF;
328      IF (    usim_dim.get_dimension(p_usim_id_dim) > 0
329          AND p_usim_n1_sign                   NOT IN (1, -1)
330         ) OR
331         (    usim_dim.get_dimension(p_usim_id_dim) = 0
332          AND p_usim_n1_sign                        IS NOT NULL
333         )
334      THEN
335        usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension id [' || p_usim_id_dim || '] for ancestor sign n = 1 [' || p_usim_n1_sign || '].');
336        RETURN NULL;
337      END IF;
338      IF usim_dim.get_dimension(p_usim_id_dim) = 1
339      THEN
340        l_n1_sign := p_usim_sign;
341      ELSE
342        l_n1_sign := p_usim_n1_sign;
343      END IF;
344      IF usim_rmd.has_data(p_usim_id_mlv, p_usim_id_dim, p_usim_sign, l_n1_sign) = 1
345      THEN
346        RETURN usim_rmd.get_id_rmd(p_usim_id_mlv, p_usim_id_dim, p_usim_sign, l_n1_sign);
347      ELSE
348        IF     usim_mlv.has_data(p_usim_id_mlv)         = 1
349           AND usim_dim.has_data(p_usim_id_dim)         = 1
350           AND p_usim_sign                             IN (0, 1, -1)
351        THEN
352          INSERT INTO usim_rel_mlv_dim
353            ( usim_id_mlv
354            , usim_id_dim
355            , usim_sign
356            , usim_n1_sign
357            )
358            VALUES
359            ( p_usim_id_mlv
360            , p_usim_id_dim
361            , p_usim_sign
362            , l_n1_sign
363            )
364            RETURNING usim_id_rmd INTO l_result
365          ;
366          IF p_do_commit
367          THEN
368            COMMIT;
369          END IF;
370          RETURN l_result;
371        ELSE
372          usim_erl.log_error('usim_rmd.insert_rmd', 'Used with not existing universe id [' || p_usim_id_mlv || '],  dimension id [' || p_usim_id_dim || '] or sign [' || p_usim_sign || '].');
373          RETURN NULL;
374        END IF;
375      END IF;
376    END insert_rmd
377    ;
378
379    FUNCTION insert_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
380                       , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
381                       , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
382                       , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
383                       , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
384                       )
385      RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
386    IS
387      l_result      usim_rel_mlv_dim.usim_id_rmd%TYPE;
388      l_usim_id_dim usim_dimension.usim_id_dim%TYPE;
389    BEGIN
390      IF     p_usim_n_dimension = 0
391         AND p_usim_sign       != 0
392      THEN
393        usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension [' || p_usim_n_dimension || '] for sign [' || p_usim_sign || '].');
394        RETURN NULL;
395      END IF;
396      IF (    p_usim_n_dimension > 0
397          AND p_usim_n1_sign NOT IN (1, -1)
398         ) OR
399         (    p_usim_n_dimension = 0
400          AND p_usim_n1_sign IS NOT NULL
401         )
402      THEN
403        usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension [' || p_usim_n_dimension || '] for ancestor sign n = 1 [' || p_usim_n1_sign || '].');
404        RETURN NULL;
405      END IF;
406      IF usim_rmd.has_data(p_usim_id_mlv, p_usim_n_dimension, p_usim_sign, p_usim_n1_sign) = 1
407      THEN
408        RETURN usim_rmd.get_id_rmd(p_usim_id_mlv, p_usim_n_dimension, p_usim_sign, p_usim_n1_sign);
409      ELSE
410        IF     usim_mlv.has_data(p_usim_id_mlv)              = 1
411           AND usim_dim.has_data(p_usim_n_dimension)         = 1
412           AND p_usim_sign                                  IN (0, 1, -1)
413        THEN
414          l_usim_id_dim := usim_dim.get_id_dim(p_usim_n_dimension);
415          RETURN usim_rmd.insert_rmd(p_usim_id_mlv, l_usim_id_dim, p_usim_sign, p_usim_n1_sign, p_do_commit);
416        ELSE
417          usim_erl.log_error('usim_rmd.insert_rmd', 'Used with not existing universe id [' || p_usim_id_mlv || '], dimension [' || p_usim_n_dimension || '] or sign [' || p_usim_sign || '].');
418          RETURN NULL;
419        END IF;
420      END IF;
421    END insert_rmd
422    ;
423
424  END usim_rmd;
425  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_rmd
IS
  -- see header for documentation

  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_rel_mlv_dim;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    -- we expect one axis or nothing
    SELECT COUNT(*) INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_data( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
                   , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
                   , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
                   , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                   )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    -- we expect one axis or nothing
    SELECT COUNT(*)
      INTO l_result
      FROM usim_rel_mlv_dim
     WHERE usim_id_mlv          = p_usim_id_mlv
       AND usim_id_dim          = p_usim_id_dim
       AND usim_sign            = p_usim_sign
           -- deal with 0 dimension
       AND NVL(usim_n1_sign, 0) = NVL(p_usim_n1_sign, 0)
    ;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_data( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                   , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                   , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
                   , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                   )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    -- we expect one axis or nothing
    SELECT COUNT(*)
      INTO l_result
      FROM usim_rmd_v
     WHERE usim_id_mlv          = p_usim_id_mlv
       AND usim_n_dimension     = p_usim_n_dimension
       AND usim_sign            = p_usim_sign
           -- deal with 0 dimension
       AND NVL(usim_n1_sign, 0) = NVL(p_usim_n1_sign, 0)
    ;
    RETURN l_result;
  END has_data
  ;

  FUNCTION get_max_dimension(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result usim_dimension.usim_n_dimension%TYPE;
  BEGIN
      SELECT MAX(usim_n_dimension) INTO l_result FROM usim_rmd_v WHERE usim_id_mlv = p_usim_id_mlv;
      RETURN NVL(l_result, -1);
  END get_max_dimension
  ;

  FUNCTION get_dimension(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result usim_dimension.usim_n_dimension%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_n_dimension INTO l_result FROM usim_rmd_v WHERE usim_id_rmd = p_usim_id_rmd;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_rmd.get_dimension', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN NULL;
    END IF;
  END get_dimension
  ;

  FUNCTION get_dim_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_sign%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_sign INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_rmd.get_dim_sign', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN NULL;
    END IF;
  END get_dim_sign
  ;

  FUNCTION get_dim_n1_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_n1_sign%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_n1_sign INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_rmd.get_dim_n1_sign', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN NULL;
    END IF;
  END get_dim_n1_sign
  ;

  FUNCTION get_id_mlv(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_multiverse.usim_id_mlv%TYPE
  IS
    l_result usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_id_mlv INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_rmd.get_id_mlv', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN NULL;
    END IF;
  END get_id_mlv
  ;

  FUNCTION get_id_dim(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_dimension.usim_id_dim%TYPE
  IS
    l_result usim_dimension.usim_id_dim%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_id_dim INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_rmd.get_id_dim', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN NULL;
    END IF;
  END get_id_dim
  ;

  FUNCTION get_rmd_details( p_usim_id_rmd  IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_dim  OUT usim_dimension.usim_id_dim%TYPE
                          , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_id_dim
           , usim_sign
           , usim_n1_sign
        INTO p_usim_id_dim
           , p_usim_sign
           , p_usim_n1_sign
        FROM usim_rel_mlv_dim
       WHERE usim_id_rmd = p_usim_id_rmd
      ;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_rmd.get_rmd_details', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN 0;
    END IF;
  END get_rmd_details
  ;

  FUNCTION get_rmd_details( p_usim_id_rmd       IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
                          , p_usim_sign         OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_usim_n1_sign      OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_n_dimension
           , usim_sign
           , usim_n1_sign
        INTO p_usim_n_dimension
           , p_usim_sign
           , p_usim_n1_sign
        FROM usim_rmd_v
       WHERE usim_id_rmd = p_usim_id_rmd
      ;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_rmd.get_rmd_details', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN 0;
    END IF;
  END get_rmd_details
  ;

  FUNCTION get_rmd_details( p_usim_id_rmd  IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
                          , p_usim_id_dim  OUT usim_dimension.usim_id_dim%TYPE
                          , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_id_mlv
           , usim_id_dim
           , usim_sign
           , usim_n1_sign
        INTO p_usim_id_mlv
           , p_usim_id_dim
           , p_usim_sign
           , p_usim_n1_sign
        FROM usim_rel_mlv_dim
       WHERE usim_id_rmd = p_usim_id_rmd
      ;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_rmd.get_rmd_details', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN 0;
    END IF;
  END get_rmd_details
  ;

  FUNCTION get_ultimate_border(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_multiverse.usim_ultimate_border%TYPE
  IS
    l_result usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_id_mlv INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
      RETURN usim_mlv.get_ultimate_border(l_result);
    ELSE
      usim_erl.log_error('usim_rmd.get_ultimate_border', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN -1;
    END IF;
  END get_ultimate_border
  ;

  FUNCTION get_id_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
                     , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE   DEFAULT 1
                     , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_id_rmd%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_mlv, p_usim_id_dim, p_usim_sign, p_usim_n1_sign) = 1
    THEN
      SELECT usim_id_rmd
        INTO l_result
        FROM usim_rel_mlv_dim
       WHERE usim_id_mlv          = p_usim_id_mlv
         AND usim_id_dim          = p_usim_id_dim
         AND usim_sign            = p_usim_sign
             -- deal with 0 dimension
         AND NVL(usim_n1_sign, 0) = NVL(p_usim_n1_sign, 0)
      ;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_rmd.get_id_rmd', 'Used with not existing universe id [' || p_usim_id_mlv || '] and dimension id [' || p_usim_id_dim || '].');
      RETURN NULL;
    END IF;
  END get_id_rmd
  ;

  FUNCTION get_id_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                     , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE      DEFAULT 1
                     , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_id_dim usim_dimension.usim_id_dim%TYPE;
  BEGIN
    IF usim_dim.has_data(p_usim_n_dimension) = 1
    THEN
      l_id_dim := usim_dim.get_id_dim(p_usim_n_dimension);
      RETURN usim_rmd.get_id_rmd(p_usim_id_mlv, l_id_dim, p_usim_sign, p_usim_n1_sign);
    ELSE
      usim_erl.log_error('usim_rmd.get_id_rmd', 'Used with not existing dimension [' || p_usim_n_dimension || '].');
      RETURN NULL;
    END IF;
  END get_id_rmd
  ;

  FUNCTION insert_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
                     , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
                     , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     , p_do_commit    IN BOOLEAN                           DEFAULT TRUE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  IS
    l_result  usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
  BEGIN
    IF     usim_dim.get_dimension(p_usim_id_dim) = 0
       AND p_usim_sign                          != 0
    THEN
      usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension id [' || p_usim_id_dim || '] for sign [' || p_usim_sign || '].');
      RETURN NULL;
    END IF;
    IF (    usim_dim.get_dimension(p_usim_id_dim) > 0
        AND p_usim_n1_sign                   NOT IN (1, -1)
       ) OR
       (    usim_dim.get_dimension(p_usim_id_dim) = 0
        AND p_usim_n1_sign                        IS NOT NULL
       )
    THEN
      usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension id [' || p_usim_id_dim || '] for ancestor sign n = 1 [' || p_usim_n1_sign || '].');
      RETURN NULL;
    END IF;
    IF usim_dim.get_dimension(p_usim_id_dim) = 1
    THEN
      l_n1_sign := p_usim_sign;
    ELSE
      l_n1_sign := p_usim_n1_sign;
    END IF;
    IF usim_rmd.has_data(p_usim_id_mlv, p_usim_id_dim, p_usim_sign, l_n1_sign) = 1
    THEN
      RETURN usim_rmd.get_id_rmd(p_usim_id_mlv, p_usim_id_dim, p_usim_sign, l_n1_sign);
    ELSE
      IF     usim_mlv.has_data(p_usim_id_mlv)         = 1
         AND usim_dim.has_data(p_usim_id_dim)         = 1
         AND p_usim_sign                             IN (0, 1, -1)
      THEN
        INSERT INTO usim_rel_mlv_dim
          ( usim_id_mlv
          , usim_id_dim
          , usim_sign
          , usim_n1_sign
          )
          VALUES
          ( p_usim_id_mlv
          , p_usim_id_dim
          , p_usim_sign
          , l_n1_sign
          )
          RETURNING usim_id_rmd INTO l_result
        ;
        IF p_do_commit
        THEN
          COMMIT;
        END IF;
        RETURN l_result;
      ELSE
        usim_erl.log_error('usim_rmd.insert_rmd', 'Used with not existing universe id [' || p_usim_id_mlv || '],  dimension id [' || p_usim_id_dim || '] or sign [' || p_usim_sign || '].');
        RETURN NULL;
      END IF;
    END IF;
  END insert_rmd
  ;

  FUNCTION insert_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                     , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
                     , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  IS
    l_result      usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_usim_id_dim usim_dimension.usim_id_dim%TYPE;
  BEGIN
    IF     p_usim_n_dimension = 0
       AND p_usim_sign       != 0
    THEN
      usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension [' || p_usim_n_dimension || '] for sign [' || p_usim_sign || '].');
      RETURN NULL;
    END IF;
    IF (    p_usim_n_dimension > 0
        AND p_usim_n1_sign NOT IN (1, -1)
       ) OR
       (    p_usim_n_dimension = 0
        AND p_usim_n1_sign IS NOT NULL
       )
    THEN
      usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension [' || p_usim_n_dimension || '] for ancestor sign n = 1 [' || p_usim_n1_sign || '].');
      RETURN NULL;
    END IF;
    IF usim_rmd.has_data(p_usim_id_mlv, p_usim_n_dimension, p_usim_sign, p_usim_n1_sign) = 1
    THEN
      RETURN usim_rmd.get_id_rmd(p_usim_id_mlv, p_usim_n_dimension, p_usim_sign, p_usim_n1_sign);
    ELSE
      IF     usim_mlv.has_data(p_usim_id_mlv)              = 1
         AND usim_dim.has_data(p_usim_n_dimension)         = 1
         AND p_usim_sign                                  IN (0, 1, -1)
      THEN
        l_usim_id_dim := usim_dim.get_id_dim(p_usim_n_dimension);
        RETURN usim_rmd.insert_rmd(p_usim_id_mlv, l_usim_id_dim, p_usim_sign, p_usim_n1_sign, p_do_commit);
      ELSE
        usim_erl.log_error('usim_rmd.insert_rmd', 'Used with not existing universe id [' || p_usim_id_mlv || '], dimension [' || p_usim_n_dimension || '] or sign [' || p_usim_sign || '].');
        RETURN NULL;
      END IF;
    END IF;
  END insert_rmd
  ;

END usim_rmd;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_rmd
IS
  -- see header for documentation

  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_rel_mlv_dim;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    -- we expect one axis or nothing
    SELECT COUNT(*) INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_data( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
                   , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
                   , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
                   , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                   )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    -- we expect one axis or nothing
    SELECT COUNT(*)
      INTO l_result
      FROM usim_rel_mlv_dim
     WHERE usim_id_mlv          = p_usim_id_mlv
       AND usim_id_dim          = p_usim_id_dim
       AND usim_sign            = p_usim_sign
           -- deal with 0 dimension
       AND NVL(usim_n1_sign, 0) = NVL(p_usim_n1_sign, 0)
    ;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_data( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                   , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                   , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
                   , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                   )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    -- we expect one axis or nothing
    SELECT COUNT(*)
      INTO l_result
      FROM usim_rmd_v
     WHERE usim_id_mlv          = p_usim_id_mlv
       AND usim_n_dimension     = p_usim_n_dimension
       AND usim_sign            = p_usim_sign
           -- deal with 0 dimension
       AND NVL(usim_n1_sign, 0) = NVL(p_usim_n1_sign, 0)
    ;
    RETURN l_result;
  END has_data
  ;

  FUNCTION get_max_dimension(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result usim_dimension.usim_n_dimension%TYPE;
  BEGIN
      SELECT MAX(usim_n_dimension) INTO l_result FROM usim_rmd_v WHERE usim_id_mlv = p_usim_id_mlv;
      RETURN NVL(l_result, -1);
  END get_max_dimension
  ;

  FUNCTION get_dimension(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result usim_dimension.usim_n_dimension%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_n_dimension INTO l_result FROM usim_rmd_v WHERE usim_id_rmd = p_usim_id_rmd;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_rmd.get_dimension', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN NULL;
    END IF;
  END get_dimension
  ;

  FUNCTION get_dim_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_sign%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_sign INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_rmd.get_dim_sign', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN NULL;
    END IF;
  END get_dim_sign
  ;

  FUNCTION get_dim_n1_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_n1_sign%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_n1_sign INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_rmd.get_dim_n1_sign', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN NULL;
    END IF;
  END get_dim_n1_sign
  ;

  FUNCTION get_id_mlv(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_multiverse.usim_id_mlv%TYPE
  IS
    l_result usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_id_mlv INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_rmd.get_id_mlv', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN NULL;
    END IF;
  END get_id_mlv
  ;

  FUNCTION get_id_dim(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_dimension.usim_id_dim%TYPE
  IS
    l_result usim_dimension.usim_id_dim%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_id_dim INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_rmd.get_id_dim', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN NULL;
    END IF;
  END get_id_dim
  ;

  FUNCTION get_rmd_details( p_usim_id_rmd  IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_dim  OUT usim_dimension.usim_id_dim%TYPE
                          , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_id_dim
           , usim_sign
           , usim_n1_sign
        INTO p_usim_id_dim
           , p_usim_sign
           , p_usim_n1_sign
        FROM usim_rel_mlv_dim
       WHERE usim_id_rmd = p_usim_id_rmd
      ;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_rmd.get_rmd_details', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN 0;
    END IF;
  END get_rmd_details
  ;

  FUNCTION get_rmd_details( p_usim_id_rmd       IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
                          , p_usim_sign         OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_usim_n1_sign      OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_n_dimension
           , usim_sign
           , usim_n1_sign
        INTO p_usim_n_dimension
           , p_usim_sign
           , p_usim_n1_sign
        FROM usim_rmd_v
       WHERE usim_id_rmd = p_usim_id_rmd
      ;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_rmd.get_rmd_details', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN 0;
    END IF;
  END get_rmd_details
  ;

  FUNCTION get_rmd_details( p_usim_id_rmd  IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
                          , p_usim_id_dim  OUT usim_dimension.usim_id_dim%TYPE
                          , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_id_mlv
           , usim_id_dim
           , usim_sign
           , usim_n1_sign
        INTO p_usim_id_mlv
           , p_usim_id_dim
           , p_usim_sign
           , p_usim_n1_sign
        FROM usim_rel_mlv_dim
       WHERE usim_id_rmd = p_usim_id_rmd
      ;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_rmd.get_rmd_details', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN 0;
    END IF;
  END get_rmd_details
  ;

  FUNCTION get_ultimate_border(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
    RETURN usim_multiverse.usim_ultimate_border%TYPE
  IS
    l_result usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_rmd) = 1
    THEN
      SELECT usim_id_mlv INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
      RETURN usim_mlv.get_ultimate_border(l_result);
    ELSE
      usim_erl.log_error('usim_rmd.get_ultimate_border', 'Used with not existing id [' || p_usim_id_rmd || '].');
      RETURN -1;
    END IF;
  END get_ultimate_border
  ;

  FUNCTION get_id_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
                     , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE   DEFAULT 1
                     , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_id_rmd%TYPE;
  BEGIN
    IF usim_rmd.has_data(p_usim_id_mlv, p_usim_id_dim, p_usim_sign, p_usim_n1_sign) = 1
    THEN
      SELECT usim_id_rmd
        INTO l_result
        FROM usim_rel_mlv_dim
       WHERE usim_id_mlv          = p_usim_id_mlv
         AND usim_id_dim          = p_usim_id_dim
         AND usim_sign            = p_usim_sign
             -- deal with 0 dimension
         AND NVL(usim_n1_sign, 0) = NVL(p_usim_n1_sign, 0)
      ;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_rmd.get_id_rmd', 'Used with not existing universe id [' || p_usim_id_mlv || '] and dimension id [' || p_usim_id_dim || '].');
      RETURN NULL;
    END IF;
  END get_id_rmd
  ;

  FUNCTION get_id_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                     , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE      DEFAULT 1
                     , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_id_dim usim_dimension.usim_id_dim%TYPE;
  BEGIN
    IF usim_dim.has_data(p_usim_n_dimension) = 1
    THEN
      l_id_dim := usim_dim.get_id_dim(p_usim_n_dimension);
      RETURN usim_rmd.get_id_rmd(p_usim_id_mlv, l_id_dim, p_usim_sign, p_usim_n1_sign);
    ELSE
      usim_erl.log_error('usim_rmd.get_id_rmd', 'Used with not existing dimension [' || p_usim_n_dimension || '].');
      RETURN NULL;
    END IF;
  END get_id_rmd
  ;

  FUNCTION insert_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
                     , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
                     , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     , p_do_commit    IN BOOLEAN                           DEFAULT TRUE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  IS
    l_result  usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
  BEGIN
    IF     usim_dim.get_dimension(p_usim_id_dim) = 0
       AND p_usim_sign                          != 0
    THEN
      usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension id [' || p_usim_id_dim || '] for sign [' || p_usim_sign || '].');
      RETURN NULL;
    END IF;
    IF (    usim_dim.get_dimension(p_usim_id_dim) > 0
        AND p_usim_n1_sign                   NOT IN (1, -1)
       ) OR
       (    usim_dim.get_dimension(p_usim_id_dim) = 0
        AND p_usim_n1_sign                        IS NOT NULL
       )
    THEN
      usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension id [' || p_usim_id_dim || '] for ancestor sign n = 1 [' || p_usim_n1_sign || '].');
      RETURN NULL;
    END IF;
    IF usim_dim.get_dimension(p_usim_id_dim) = 1
    THEN
      l_n1_sign := p_usim_sign;
    ELSE
      l_n1_sign := p_usim_n1_sign;
    END IF;
    IF usim_rmd.has_data(p_usim_id_mlv, p_usim_id_dim, p_usim_sign, l_n1_sign) = 1
    THEN
      RETURN usim_rmd.get_id_rmd(p_usim_id_mlv, p_usim_id_dim, p_usim_sign, l_n1_sign);
    ELSE
      IF     usim_mlv.has_data(p_usim_id_mlv)         = 1
         AND usim_dim.has_data(p_usim_id_dim)         = 1
         AND p_usim_sign                             IN (0, 1, -1)
      THEN
        INSERT INTO usim_rel_mlv_dim
          ( usim_id_mlv
          , usim_id_dim
          , usim_sign
          , usim_n1_sign
          )
          VALUES
          ( p_usim_id_mlv
          , p_usim_id_dim
          , p_usim_sign
          , l_n1_sign
          )
          RETURNING usim_id_rmd INTO l_result
        ;
        IF p_do_commit
        THEN
          COMMIT;
        END IF;
        RETURN l_result;
      ELSE
        usim_erl.log_error('usim_rmd.insert_rmd', 'Used with not existing universe id [' || p_usim_id_mlv || '],  dimension id [' || p_usim_id_dim || '] or sign [' || p_usim_sign || '].');
        RETURN NULL;
      END IF;
    END IF;
  END insert_rmd
  ;

  FUNCTION insert_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                     , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
                     , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
                     , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                     )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  IS
    l_result      usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_usim_id_dim usim_dimension.usim_id_dim%TYPE;
  BEGIN
    IF     p_usim_n_dimension = 0
       AND p_usim_sign       != 0
    THEN
      usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension [' || p_usim_n_dimension || '] for sign [' || p_usim_sign || '].');
      RETURN NULL;
    END IF;
    IF (    p_usim_n_dimension > 0
        AND p_usim_n1_sign NOT IN (1, -1)
       ) OR
       (    p_usim_n_dimension = 0
        AND p_usim_n1_sign IS NOT NULL
       )
    THEN
      usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension [' || p_usim_n_dimension || '] for ancestor sign n = 1 [' || p_usim_n1_sign || '].');
      RETURN NULL;
    END IF;
    IF usim_rmd.has_data(p_usim_id_mlv, p_usim_n_dimension, p_usim_sign, p_usim_n1_sign) = 1
    THEN
      RETURN usim_rmd.get_id_rmd(p_usim_id_mlv, p_usim_n_dimension, p_usim_sign, p_usim_n1_sign);
    ELSE
      IF     usim_mlv.has_data(p_usim_id_mlv)              = 1
         AND usim_dim.has_data(p_usim_n_dimension)         = 1
         AND p_usim_sign                                  IN (0, 1, -1)
      THEN
        l_usim_id_dim := usim_dim.get_id_dim(p_usim_n_dimension);
        RETURN usim_rmd.insert_rmd(p_usim_id_mlv, l_usim_id_dim, p_usim_sign, p_usim_n1_sign, p_do_commit);
      ELSE
        usim_erl.log_error('usim_rmd.insert_rmd', 'Used with not existing universe id [' || p_usim_id_mlv || '], dimension [' || p_usim_n_dimension || '] or sign [' || p_usim_sign || '].');
        RETURN NULL;
      END IF;
    END IF;
  END insert_rmd
  ;

END usim_rmd;

Package Body USIM_RMD kompiliert

SQL> -- USIM_RMD_CHILD (rchi)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_RMD_CHILD_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_RMD_CHILD still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_RMD_CHILD'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_RMD_CHILD_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_RMD_CHILD still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_RMD_CHILD'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_RMD_CHILD_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_RMD_CHILD still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_RMD_CHILD'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../TABLES/USIM_RMD_CHILD_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_RMD_CHILD (rchi)
SQL> CREATE TABLE &USIM_SCHEMA..usim_rmd_child
  2    ( usim_id_rmd        CHAR(55) NOT NULL ENABLE
  3    , usim_id_rmd_child  CHAR(55) NOT NULL ENABLE
  4    )
  5  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_rmd_child
  ( usim_id_rmd        CHAR(55) NOT NULL ENABLE
  , usim_id_rmd_child  CHAR(55) NOT NULL ENABLE
  )

neu:CREATE TABLE USIM_TEST.usim_rmd_child
  ( usim_id_rmd        CHAR(55) NOT NULL ENABLE
  , usim_id_rmd_child  CHAR(55) NOT NULL ENABLE
  )

Table USIM_TEST.USIM_RMD_CHILD erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_rmd_child IS 'Describes the parent-child relation between dimension axis. Will use the alias rchi.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_rmd_child IS 'Describes the parent-child relation between dimension axis. Will use the alias rchi.'
neu:COMMENT ON TABLE USIM_TEST.usim_rmd_child IS 'Describes the parent-child relation between dimension axis. Will use the alias rchi.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rmd_child.usim_id_rmd IS 'The parent id from usim_rel_mlv_dim.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_rmd_child.usim_id_rmd IS 'The parent id from usim_rel_mlv_dim.'
neu:COMMENT ON COLUMN USIM_TEST.usim_rmd_child.usim_id_rmd IS 'The parent id from usim_rel_mlv_dim.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rmd_child.usim_id_rmd_child IS 'The child id from usim_rel_mlv_dim. Only two childs possible';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_rmd_child.usim_id_rmd_child IS 'The child id from usim_rel_mlv_dim. Only two childs possible'
neu:COMMENT ON COLUMN USIM_TEST.usim_rmd_child.usim_id_rmd_child IS 'The child id from usim_rel_mlv_dim. Only two childs possible'

Comment erstellt.

SQL>
SQL> -- uk
SQL> ALTER TABLE &USIM_SCHEMA..usim_rmd_child
  2    ADD CONSTRAINT usim_rchi_uk
  3    UNIQUE (usim_id_rmd, usim_id_rmd_child)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_rmd_child
  ADD CONSTRAINT usim_rchi_uk
  UNIQUE (usim_id_rmd, usim_id_rmd_child)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_rmd_child
  ADD CONSTRAINT usim_rchi_uk
  UNIQUE (usim_id_rmd, usim_id_rmd_child)
  ENABLE

Table USIM_TEST.USIM_RMD_CHILD geändert.

SQL>
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rchi_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_rmd_child
  3      FOR EACH ROW
  4      BEGIN
  5        IF :NEW.usim_id_rmd = :NEW.usim_id_rmd_child
  6        THEN
  7          RAISE_APPLICATION_ERROR( num => -20000
  8                                 , msg => 'Insert requirement not fulfilled. Parent and child cannot be equal.'
  9                                 )
 10          ;
 11        END IF;
 12      END;
 13  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rchi_ins_trg
  BEFORE INSERT ON &USIM_SCHEMA..usim_rmd_child
    FOR EACH ROW
    BEGIN
      IF :NEW.usim_id_rmd = :NEW.usim_id_rmd_child
      THEN
        RAISE_APPLICATION_ERROR( num => -20000
                               , msg => 'Insert requirement not fulfilled. Parent and child cannot be equal.'
                               )
        ;
      END IF;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_rchi_ins_trg
  BEFORE INSERT ON USIM_TEST.usim_rmd_child
    FOR EACH ROW
    BEGIN
      IF :NEW.usim_id_rmd = :NEW.usim_id_rmd_child
      THEN
        RAISE_APPLICATION_ERROR( num => -20000
                               , msg => 'Insert requirement not fulfilled. Parent and child cannot be equal.'
                               )
        ;
      END IF;
    END;

Trigger USIM_RCHI_INS_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_rchi_ins_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_rchi_ins_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_rchi_ins_trg ENABLE

Trigger USIM_TEST.USIM_RCHI_INS_TRG geändert.

SQL>
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rchi_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_rmd_child
  3      FOR EACH ROW
  4      BEGIN
  5        RAISE_APPLICATION_ERROR( num => -20001
  6                               , msg => 'Update requirement not fulfilled. No update allowed.'
  7                               )
  8        ;
  9      END;
 10  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rchi_upd_trg
  BEFORE UPDATE ON &USIM_SCHEMA..usim_rmd_child
    FOR EACH ROW
    BEGIN
      RAISE_APPLICATION_ERROR( num => -20001
                             , msg => 'Update requirement not fulfilled. No update allowed.'
                             )
      ;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_rchi_upd_trg
  BEFORE UPDATE ON USIM_TEST.usim_rmd_child
    FOR EACH ROW
    BEGIN
      RAISE_APPLICATION_ERROR( num => -20001
                             , msg => 'Update requirement not fulfilled. No update allowed.'
                             )
      ;
    END;

Trigger USIM_RCHI_UPD_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_rchi_upd_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_rchi_upd_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_rchi_upd_trg ENABLE

Trigger USIM_TEST.USIM_RCHI_UPD_TRG geändert.

SQL> -- foreign keys
SQL> @@../FK/USIM_RCHI_PARENT_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk parent-child relation between dimension axis in usim_rel_mlv_dim (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_rmd_child
  2    ADD CONSTRAINT usim_rchi_parent_fk
  3    FOREIGN KEY (usim_id_rmd) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_rmd_child
  ADD CONSTRAINT usim_rchi_parent_fk
  FOREIGN KEY (usim_id_rmd) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_rmd_child
  ADD CONSTRAINT usim_rchi_parent_fk
  FOREIGN KEY (usim_id_rmd) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_RMD_CHILD geändert.

SQL> @@../FK/USIM_RCHI_CHILD_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk parent-child relation between dimensions in usim_rel_mlv_dim (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_rmd_child
  2    ADD CONSTRAINT usim_rchi_child_fk
  3    FOREIGN KEY (usim_id_rmd_child) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_rmd_child
  ADD CONSTRAINT usim_rchi_child_fk
  FOREIGN KEY (usim_id_rmd_child) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_rmd_child
  ADD CONSTRAINT usim_rchi_child_fk
  FOREIGN KEY (usim_id_rmd_child) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_RMD_CHILD geändert.

SQL>
SQL> -- USIM_SPACE (spc)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_SPACE_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPACE still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPACE'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_SPACE_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPACE still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPACE'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_SPACE_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPACE still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPACE'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../TABLES/USIM_SPACE_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_SPACE (spc)
SQL> CREATE TABLE &USIM_SCHEMA..usim_space
  2    ( usim_id_spc       CHAR(55)    NOT NULL ENABLE
  3    , usim_id_rmd       CHAR(55)    NOT NULL ENABLE
  4    , usim_id_pos       CHAR(55)    NOT NULL ENABLE
  5    , usim_id_nod       CHAR(55)    NOT NULL ENABLE
  6    , usim_process_spin NUMBER(1,0) NOT NULL ENABLE
  7    )
  8  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_space
  ( usim_id_spc       CHAR(55)    NOT NULL ENABLE
  , usim_id_rmd       CHAR(55)    NOT NULL ENABLE
  , usim_id_pos       CHAR(55)    NOT NULL ENABLE
  , usim_id_nod       CHAR(55)    NOT NULL ENABLE
  , usim_process_spin NUMBER(1,0) NOT NULL ENABLE
  )

neu:CREATE TABLE USIM_TEST.usim_space
  ( usim_id_spc       CHAR(55)    NOT NULL ENABLE
  , usim_id_rmd       CHAR(55)    NOT NULL ENABLE
  , usim_id_pos       CHAR(55)    NOT NULL ENABLE
  , usim_id_nod       CHAR(55)    NOT NULL ENABLE
  , usim_process_spin NUMBER(1,0) NOT NULL ENABLE
  )

Table USIM_TEST.USIM_SPACE erstellt.

SQL> COMMENT ON TABLE usim_space IS 'A table describing the space of the universes by universe, dimension, position, node and volume. Will use the alias spc.';

Comment erstellt.

SQL> COMMENT ON COLUMN usim_space.usim_id_spc IS 'The id for a node in space. Automatically set, update not allowed.';

Comment erstellt.

SQL> COMMENT ON COLUMN usim_space.usim_id_rmd IS 'The id for the universe / dimension relation. Must exist and be set on insert, update not allowed.';

Comment erstellt.

SQL> COMMENT ON COLUMN usim_space.usim_id_pos IS 'The id for the position relation. Must exist and be set on insert, update not allowed.';

Comment erstellt.

SQL> COMMENT ON COLUMN usim_space.usim_id_nod IS 'The id for the node relation. Must exist and be set on insert, update not allowed.';

Comment erstellt.

SQL> COMMENT ON COLUMN usim_space.usim_process_spin IS 'The direction to emit energy to. 1 is direction childs, -1 direction parents. Nodes in dimension 0 will always have direction childs.';

Comment erstellt.

SQL>
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_pk
  3    PRIMARY KEY (usim_id_spc)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_space
  ADD CONSTRAINT usim_spc_pk
  PRIMARY KEY (usim_id_spc)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_space
  ADD CONSTRAINT usim_spc_pk
  PRIMARY KEY (usim_id_spc)
  ENABLE

Table USIM_TEST.USIM_SPACE geändert.

SQL>
SQL> -- uk universe/dim/position/node is unique
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_uk
  3    UNIQUE (usim_id_rmd, usim_id_pos, usim_id_nod)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_space
  ADD CONSTRAINT usim_spc_uk
  UNIQUE (usim_id_rmd, usim_id_pos, usim_id_nod)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_space
  ADD CONSTRAINT usim_spc_uk
  UNIQUE (usim_id_rmd, usim_id_pos, usim_id_nod)
  ENABLE

Table USIM_TEST.USIM_SPACE geändert.

SQL>
SQL> -- uk node is unique
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_nod_uk
  3    UNIQUE (usim_id_nod)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_space
  ADD CONSTRAINT usim_spc_nod_uk
  UNIQUE (usim_id_nod)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_space
  ADD CONSTRAINT usim_spc_nod_uk
  UNIQUE (usim_id_nod)
  ENABLE

Table USIM_TEST.USIM_SPACE geändert.

SQL>
SQL> -- check usim_process_spin
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_spin_chk
  3    CHECK (usim_process_spin IN (-1, 1))
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_space
  ADD CONSTRAINT usim_spc_spin_chk
  CHECK (usim_process_spin IN (-1, 1))
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_space
  ADD CONSTRAINT usim_spc_spin_chk
  CHECK (usim_process_spin IN (-1, 1))
  ENABLE

Table USIM_TEST.USIM_SPACE geändert.

SQL>
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spc_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_space
  3      FOR EACH ROW
  4      BEGIN
  5        -- ignore input on pk
  6        :NEW.usim_id_spc := usim_static.get_big_pk(usim_spc_id_seq.NEXTVAL);
  7      END;
  8  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spc_ins_trg
  BEFORE INSERT ON &USIM_SCHEMA..usim_space
    FOR EACH ROW
    BEGIN
      -- ignore input on pk
      :NEW.usim_id_spc := usim_static.get_big_pk(usim_spc_id_seq.NEXTVAL);
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_spc_ins_trg
  BEFORE INSERT ON USIM_TEST.usim_space
    FOR EACH ROW
    BEGIN
      -- ignore input on pk
      :NEW.usim_id_spc := usim_static.get_big_pk(usim_spc_id_seq.NEXTVAL);
    END;

Trigger USIM_SPC_INS_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_spc_ins_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_spc_ins_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_spc_ins_trg ENABLE

Trigger USIM_TEST.USIM_SPC_INS_TRG geändert.

SQL>
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spc_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_space
  3      FOR EACH ROW
  4      BEGIN
  5        IF :NEW.usim_process_spin = :OLD.usim_process_spin
  6        THEN
  7          RAISE_APPLICATION_ERROR( num => -20001
  8                                 , msg => 'Update requirement not fulfilled. Only changing update of usim_process_spin allowed.'
  9                                 )
 10          ;
 11        END IF;
 12      END;
 13  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spc_upd_trg
  BEFORE UPDATE ON &USIM_SCHEMA..usim_space
    FOR EACH ROW
    BEGIN
      IF :NEW.usim_process_spin = :OLD.usim_process_spin
      THEN
        RAISE_APPLICATION_ERROR( num => -20001
                               , msg => 'Update requirement not fulfilled. Only changing update of usim_process_spin allowed.'
                               )
        ;
      END IF;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_spc_upd_trg
  BEFORE UPDATE ON USIM_TEST.usim_space
    FOR EACH ROW
    BEGIN
      IF :NEW.usim_process_spin = :OLD.usim_process_spin
      THEN
        RAISE_APPLICATION_ERROR( num => -20001
                               , msg => 'Update requirement not fulfilled. Only changing update of usim_process_spin allowed.'
                               )
        ;
      END IF;
    END;

Trigger USIM_SPC_UPD_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_spc_upd_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_spc_upd_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_spc_upd_trg ENABLE

Trigger USIM_TEST.USIM_SPC_UPD_TRG geändert.

SQL> -- foreign keys
SQL> @@../FK/USIM_SPC_RMD_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk relation space for relation universe/dimension (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_rmd_fk
  3    FOREIGN KEY (usim_id_rmd) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_space
  ADD CONSTRAINT usim_spc_rmd_fk
  FOREIGN KEY (usim_id_rmd) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_space
  ADD CONSTRAINT usim_spc_rmd_fk
  FOREIGN KEY (usim_id_rmd) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_SPACE geändert.

SQL> @@../FK/USIM_SPC_POS_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk relation space for position (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_pos_fk
  3    FOREIGN KEY (usim_id_pos) REFERENCES usim_position (usim_id_pos) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_space
  ADD CONSTRAINT usim_spc_pos_fk
  FOREIGN KEY (usim_id_pos) REFERENCES usim_position (usim_id_pos) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_space
  ADD CONSTRAINT usim_spc_pos_fk
  FOREIGN KEY (usim_id_pos) REFERENCES usim_position (usim_id_pos) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_SPACE geändert.

SQL> @@../FK/USIM_SPC_NOD_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk relation space for node (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_nod_fk
  3    FOREIGN KEY (usim_id_nod) REFERENCES usim_node (usim_id_nod) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_space
  ADD CONSTRAINT usim_spc_nod_fk
  FOREIGN KEY (usim_id_nod) REFERENCES usim_node (usim_id_nod) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_space
  ADD CONSTRAINT usim_spc_nod_fk
  FOREIGN KEY (usim_id_nod) REFERENCES usim_node (usim_id_nod) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_SPACE geändert.

SQL> --@@../FK/USIM_SPC_VOL_FK.sql
SQL> -- views
SQL> @@../VIEW/USIM_SPC_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_SPC_V (spcv)
SQL> -- minimal joining
SQL> CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_spc_v AS
  2    SELECT rmd.usim_id_mlv
  3         , spc.usim_id_spc
  4         , spc.usim_id_rmd
  5         , spc.usim_id_pos
  6         , spc.usim_id_nod
  7         , spc.usim_process_spin
  8         , dim.usim_id_dim
  9         , dim.usim_n_dimension
 10         , rmd.usim_sign AS dim_sign
 11         , rmd.usim_n1_sign AS dim_n1_sign
 12         , pos.usim_coordinate
 13         , nod.usim_energy
 14         , mlv.usim_universe_status
 15         , mlv.usim_is_base_universe
 16         , CASE
 17             WHEN usim_spc.is_universe_base(spc.usim_id_spc) = 1
 18             THEN mlv.usim_energy_start_value
 19             ELSE NULL
 20           END                                      AS usim_energy_start_value
 21         , mlv.usim_ultimate_border
 22         , mlv.usim_planck_stable
 23         , mlv.usim_planck_length_unit
 24      FROM usim_space spc
 25     INNER JOIN usim_rel_mlv_dim rmd
 26        ON spc.usim_id_rmd = rmd.usim_id_rmd
 27     INNER JOIN usim_dimension dim
 28        ON rmd.usim_id_dim = dim.usim_id_dim
 29     INNER JOIN usim_multiverse mlv
 30        ON rmd.usim_id_mlv = mlv.usim_id_mlv
 31     INNER JOIN usim_position pos
 32        ON spc.usim_id_pos = pos.usim_id_pos
 33     INNER JOIN usim_node nod
 34        ON spc.usim_id_nod = nod.usim_id_nod
 35  ;
alt:CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_spc_v AS
  SELECT rmd.usim_id_mlv
       , spc.usim_id_spc
       , spc.usim_id_rmd
       , spc.usim_id_pos
       , spc.usim_id_nod
       , spc.usim_process_spin
       , dim.usim_id_dim
       , dim.usim_n_dimension
       , rmd.usim_sign AS dim_sign
       , rmd.usim_n1_sign AS dim_n1_sign
       , pos.usim_coordinate
       , nod.usim_energy
       , mlv.usim_universe_status
       , mlv.usim_is_base_universe
       , CASE
           WHEN usim_spc.is_universe_base(spc.usim_id_spc) = 1
           THEN mlv.usim_energy_start_value
           ELSE NULL
         END                                      AS usim_energy_start_value
       , mlv.usim_ultimate_border
       , mlv.usim_planck_stable
       , mlv.usim_planck_length_unit
    FROM usim_space spc
   INNER JOIN usim_rel_mlv_dim rmd
      ON spc.usim_id_rmd = rmd.usim_id_rmd
   INNER JOIN usim_dimension dim
      ON rmd.usim_id_dim = dim.usim_id_dim
   INNER JOIN usim_multiverse mlv
      ON rmd.usim_id_mlv = mlv.usim_id_mlv
   INNER JOIN usim_position pos
      ON spc.usim_id_pos = pos.usim_id_pos
   INNER JOIN usim_node nod
      ON spc.usim_id_nod = nod.usim_id_nod

neu:CREATE OR REPLACE FORCE VIEW USIM_TEST.usim_spc_v AS
  SELECT rmd.usim_id_mlv
       , spc.usim_id_spc
       , spc.usim_id_rmd
       , spc.usim_id_pos
       , spc.usim_id_nod
       , spc.usim_process_spin
       , dim.usim_id_dim
       , dim.usim_n_dimension
       , rmd.usim_sign AS dim_sign
       , rmd.usim_n1_sign AS dim_n1_sign
       , pos.usim_coordinate
       , nod.usim_energy
       , mlv.usim_universe_status
       , mlv.usim_is_base_universe
       , CASE
           WHEN usim_spc.is_universe_base(spc.usim_id_spc) = 1
           THEN mlv.usim_energy_start_value
           ELSE NULL
         END                                      AS usim_energy_start_value
       , mlv.usim_ultimate_border
       , mlv.usim_planck_stable
       , mlv.usim_planck_length_unit
    FROM usim_space spc
   INNER JOIN usim_rel_mlv_dim rmd
      ON spc.usim_id_rmd = rmd.usim_id_rmd
   INNER JOIN usim_dimension dim
      ON rmd.usim_id_dim = dim.usim_id_dim
   INNER JOIN usim_multiverse mlv
      ON rmd.usim_id_mlv = mlv.usim_id_mlv
   INNER JOIN usim_position pos
      ON spc.usim_id_pos = pos.usim_id_pos
   INNER JOIN usim_node nod
      ON spc.usim_id_nod = nod.usim_id_nod
Warnung: View wurde mit Kompilierungsfehlern erstellt.
SQL> -- usim_space package
SQL> @@../PACKAGES/USIM_SPC.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_spc
  2  IS
  3    /**A low level package for actions on table usim_space and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9
 10    /**
 11    * Checks if usim_space has already data.
 12    * @return Returns 1 if data are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15      RETURN NUMBER
 16    ;
 17
 18    /**
 19    * Checks if usim_space has already data for a given space id.
 20    * @param p_usim_id_spc The relation id of universe/dimension/position/node.
 21    * @return Returns 1 if data are available, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 24      RETURN NUMBER
 25    ;
 26
 27    /**
 28    * Checks if usim_space has already data for given relation ids.
 29    * @param p_usim_id_rmd The relation id of universe/dimension.
 30    * @param p_usim_id_pos The id of the position.
 31    * @return Returns 1 if data are available, otherwise 0.
 32    */
 33    FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
 34                     , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
 35                     )
 36      RETURN NUMBER
 37    ;
 38
 39    /**
 40    * Checks if usim_space has already data for given relation ids.
 41    * @param p_usim_id_rmd The relation id of universe/dimension.
 42    * @param p_usim_id_pos The id of the position.
 43    * @param p_usim_id_nod The id of the node.
 44    * @return Returns 1 if data are available, otherwise 0.
 45    */
 46    FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
 47                     , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
 48                     , p_usim_id_nod IN usim_node.usim_id_nod%TYPE
 49                     )
 50      RETURN NUMBER
 51    ;
 52
 53    /**
 54    * Checks if usim_space has a entry for the base universe with dimension 0, position 0 and sign 0.
 55    * @return Returns 1 if base universe exists, otherwise 0.
 56    */
 57    FUNCTION has_base_universe
 58      RETURN NUMBER
 59    ;
 60
 61    /**
 62    * Checks if the space id is a universe base entry with dimension 0, position 0 and sign 0. Not necessarily the base universe.
 63    * @param p_usim_id_spc The space id.
 64    * @return Returns 1 if universe base entry exists, otherwise 0.
 65    */
 66    FUNCTION is_universe_base(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 67      RETURN NUMBER
 68    ;
 69
 70    /**
 71    * Returns the maximum available dimensions for a space id and the related universe in usim_space. Considers
 72    * all dimensions, not caring about the n1 sign.
 73    * @param p_usim_id_spc The space id.
 74    * @return Returns the maximum available dimensions for the related universe or -1 if no dimension available.
 75    */
 76    FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 77      RETURN usim_dimension.usim_n_dimension%TYPE
 78    ;
 79
 80    /**
 81    * Returns the current maximum available dimensions for a space id and the related universe in usim_space. Considers
 82    * only n1 dimension of the given id.
 83    * @param p_usim_id_spc The space id.
 84    * @return Returns the maximum available n=1 related dimensions for the related universe or NULL on errors.
 85    */
 86    FUNCTION get_cur_max_dim_n1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 87      RETURN usim_dimension.usim_n_dimension%TYPE
 88    ;
 89
 90    /**
 91    * Returns the current maximum absolute position coordinate for a space id and the related universe in usim_space. Considers
 92    * only the dimension axis of the given id.
 93    * @param p_usim_id_spc The space id.
 94    * @return Returns the maximum available absolute position coordinate (always positive) or NULL on errors.
 95    */
 96    FUNCTION get_cur_max_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 97      RETURN usim_position.usim_coordinate%TYPE
 98    ;
 99
100    /**
101    * Retrieves the universe/dimension id for a given space id if it exists in usim_space.
102    * @param p_usim_id_spc The space id.
103    * @return Returns usim_id_rmd if space id exists, otherwise NULL.
104    */
105    FUNCTION get_id_rmd(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
106      RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
107    ;
108
109    /**
110    * Retrieves the universe/dimension id for a given space id if it exists in usim_space.
111    * @param p_usim_id_spc The space id.
112    * @return Returns usim_id_rmd if space id exists, otherwise NULL.
113    */
114    FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
115      RETURN usim_position.usim_id_pos%TYPE
116    ;
117
118    /**
119    * Retrieves the universe id for a given space id if it exists in usim_space.
120    * @param p_usim_id_spc The space id.
121    * @return Returns usim_id_mlv if space id exists, otherwise NULL.
122    */
123    FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
124      RETURN usim_multiverse.usim_id_mlv%TYPE
125    ;
126
127    /**
128    * Retrieves the node id for a given space id if it exists in usim_space.
129    * @param p_usim_id_spc The space id.
130    * @return Returns usim_id_nod if space id exists, otherwise NULL.
131    */
132    FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
133      RETURN usim_node.usim_id_nod%TYPE
134    ;
135
136    /**
137    * Retrieves a space id for a given ids if it exists in usim_space.
138    * @param p_usim_id_rmd The universe/dimension relation id.
139    * @param p_usim_id_pos The position id.
140    * @return Returns usim_id_spc if it exists, otherwise NULL.
141    */
142    FUNCTION get_id_spc( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
143                       , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
144                       )
145      RETURN usim_space.usim_id_spc%TYPE
146    ;
147
148    /**
149    * Retrieves the space id for the base universe if it exists in usim_space.
150    * @return Returns usim_id_spc if base universe exists, otherwise NULL.
151    */
152    FUNCTION get_id_spc_base_universe
153      RETURN usim_space.usim_id_spc%TYPE
154    ;
155
156    /**
157    * Retrieves the dimension sign of a given space node.
158    * @param p_usim_id_spc The space id.
159    * @return The dimension sign of the space id or NULL, if space id does not exist.
160    */
161    FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
162      RETURN usim_rel_mlv_dim.usim_sign%TYPE
163    ;
164
165    /**
166    * Retrieves the dimension n=1 sign of a given space node.
167    * @param p_usim_id_spc The space id.
168    * @return The dimension n=1 sign of the space id, base universe nodes will return 0. NULL, if space id does not exist.
169    */
170    FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
171      RETURN usim_rel_mlv_dim.usim_sign%TYPE
172    ;
173
174    /**
175    * Retrieves the dimension for a given node.
176    * @param p_usim_id_spc The space id to get the dimension.
177    * @return Returns the dimension or -1 if node does not exist.
178    */
179    FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
180      RETURN usim_dimension.usim_n_dimension%TYPE
181    ;
182
183    /**
184    * Retrieves the coordinate for a given node.
185    * @param p_usim_id_spc The space id to get the dimension.
186    * @return Returns the coordinate or NULL if node does not exist.
187    */
188    FUNCTION get_coordinate(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
189      RETURN usim_position.usim_coordinate%TYPE
190    ;
191
192    /**
193    * Retrieves the process direction of a given space node.
194    * @param p_usim_id_spc The space id to get the process direction.
195    * @return Returns the process directions or NULL if space node does not exist.
196    */
197    FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
198      RETURN usim_space.usim_process_spin%TYPE
199    ;
200
201    /**
202    * Get basic details about a given space node.
203    * @param p_usim_id_spc The space id to get the details for.
204    * @param p_usim_id_rmd The associated dimension axis id.
205    * @param p_usim_id_pos The associated position id.
206    * @param p_usim_id_nod The associated node id.
207    * @param p_process_spin The current process spin of the space node.
208    * @return Returns 1 if data could be fetched or 0 on errors.
209    */
210    FUNCTION get_spc_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
211                            , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
212                            , p_usim_id_pos  OUT usim_position.usim_id_pos%TYPE
213                            , p_usim_id_nod  OUT usim_node.usim_id_nod%TYPE
214                            , p_process_spin OUT usim_space.usim_process_spin%TYPE
215                            )
216      RETURN NUMBER
217    ;
218
219    /**
220    * Get all details about a given space node.
221    * @param p_usim_id_spc The space id to get the details for.
222    * @param p_usim_id_rmd The associated dimension axis id.
223    * @param p_usim_id_pos The associated position id.
224    * @param p_usim_id_nod The associated node id.
225    * @param p_process_spin The current process spin of the space node.
226    * @param p_usim_id_mlv The associated universe id.
227    * @param p_n_dimension The associated dimension n.
228    * @param p_dim_sign The associated sign of the dimension axis.
229    * @param p_dim_n1_sign The associated n1 sign of the dimension axis.
230    * @param p_coordinate The associated coordinate.
231    * @param p_is_base The associated universe type.
232    * @param p_energy The associated node energy.
233    * @return Returns 1 if data could be fetched or 0 on errors.
234    */
235    FUNCTION get_spc_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
236                            , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
237                            , p_usim_id_pos  OUT usim_position.usim_id_pos%TYPE
238                            , p_usim_id_nod  OUT usim_node.usim_id_nod%TYPE
239                            , p_process_spin OUT usim_space.usim_process_spin%TYPE
240                            , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
241                            , p_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
242                            , p_dim_sign     OUT usim_rel_mlv_dim.usim_sign%TYPE
243                            , p_dim_n1_sign  OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
244                            , p_coordinate   OUT usim_position.usim_coordinate%TYPE
245                            , p_is_base      OUT usim_multiverse.usim_is_base_universe%TYPE
246                            , p_energy       OUT usim_node.usim_energy%TYPE
247                            )
248      RETURN NUMBER
249    ;
250
251    /**
252    * Inserts a new space node for the given ids in usim_space if it does not exist yet.
253    * @param p_usim_id_rmd The universe/dimension relation id.
254    * @param p_usim_id_pos The position id.
255    * @param p_usim_id_nod The node id.
256    * @param p_usim_process_spin The process spin (1, -1).
257    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
258    * @return Returns the new usim_id_spc id or NULL on errors.
259    */
260    FUNCTION insert_spc( p_usim_id_rmd       IN usim_rel_mlv_dim.usim_id_rmd%TYPE
261                       , p_usim_id_pos       IN usim_position.usim_id_pos%TYPE
262                       , p_usim_id_nod       IN usim_node.usim_id_nod%TYPE
263                       , p_usim_process_spin IN usim_space.usim_process_spin%TYPE
264                       , p_do_commit         IN BOOLEAN                           DEFAULT TRUE
265                       )
266      RETURN usim_space.usim_id_spc%TYPE
267    ;
268
269    /**
270    * Updates usim_process_spin by flipping the existing value (1 to -1 and vice versa)
271    * if the given space node is not in dimension 0 with position 0. Otherwise does nothing.
272    * @param p_usim_id_spc The space id to get the max dimension.
273    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
274    * @return Returns 1 if no errors or 0 if space id does not exist.
275    */
276    FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
277                              , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
278                              )
279      RETURN NUMBER
280    ;
281
282  END usim_spc;
283  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_spc
IS
  /**A low level package for actions on table usim_space and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_space has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_space has already data for a given space id.
  * @param p_usim_id_spc The relation id of universe/dimension/position/node.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_space has already data for given relation ids.
  * @param p_usim_id_rmd The relation id of universe/dimension.
  * @param p_usim_id_pos The id of the position.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                   , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                   )
    RETURN NUMBER
  ;

  /**
  * Checks if usim_space has already data for given relation ids.
  * @param p_usim_id_rmd The relation id of universe/dimension.
  * @param p_usim_id_pos The id of the position.
  * @param p_usim_id_nod The id of the node.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                   , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                   , p_usim_id_nod IN usim_node.usim_id_nod%TYPE
                   )
    RETURN NUMBER
  ;

  /**
  * Checks if usim_space has a entry for the base universe with dimension 0, position 0 and sign 0.
  * @return Returns 1 if base universe exists, otherwise 0.
  */
  FUNCTION has_base_universe
    RETURN NUMBER
  ;

  /**
  * Checks if the space id is a universe base entry with dimension 0, position 0 and sign 0. Not necessarily the base universe.
  * @param p_usim_id_spc The space id.
  * @return Returns 1 if universe base entry exists, otherwise 0.
  */
  FUNCTION is_universe_base(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Returns the maximum available dimensions for a space id and the related universe in usim_space. Considers
  * all dimensions, not caring about the n1 sign.
  * @param p_usim_id_spc The space id.
  * @return Returns the maximum available dimensions for the related universe or -1 if no dimension available.
  */
  FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Returns the current maximum available dimensions for a space id and the related universe in usim_space. Considers
  * only n1 dimension of the given id.
  * @param p_usim_id_spc The space id.
  * @return Returns the maximum available n=1 related dimensions for the related universe or NULL on errors.
  */
  FUNCTION get_cur_max_dim_n1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Returns the current maximum absolute position coordinate for a space id and the related universe in usim_space. Considers
  * only the dimension axis of the given id.
  * @param p_usim_id_spc The space id.
  * @return Returns the maximum available absolute position coordinate (always positive) or NULL on errors.
  */
  FUNCTION get_cur_max_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Retrieves the universe/dimension id for a given space id if it exists in usim_space.
  * @param p_usim_id_spc The space id.
  * @return Returns usim_id_rmd if space id exists, otherwise NULL.
  */
  FUNCTION get_id_rmd(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  ;

  /**
  * Retrieves the universe/dimension id for a given space id if it exists in usim_space.
  * @param p_usim_id_spc The space id.
  * @return Returns usim_id_rmd if space id exists, otherwise NULL.
  */
  FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Retrieves the universe id for a given space id if it exists in usim_space.
  * @param p_usim_id_spc The space id.
  * @return Returns usim_id_mlv if space id exists, otherwise NULL.
  */
  FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_multiverse.usim_id_mlv%TYPE
  ;

  /**
  * Retrieves the node id for a given space id if it exists in usim_space.
  * @param p_usim_id_spc The space id.
  * @return Returns usim_id_nod if space id exists, otherwise NULL.
  */
  FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_node.usim_id_nod%TYPE
  ;

  /**
  * Retrieves a space id for a given ids if it exists in usim_space.
  * @param p_usim_id_rmd The universe/dimension relation id.
  * @param p_usim_id_pos The position id.
  * @return Returns usim_id_spc if it exists, otherwise NULL.
  */
  FUNCTION get_id_spc( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                     , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                     )
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Retrieves the space id for the base universe if it exists in usim_space.
  * @return Returns usim_id_spc if base universe exists, otherwise NULL.
  */
  FUNCTION get_id_spc_base_universe
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Retrieves the dimension sign of a given space node.
  * @param p_usim_id_spc The space id.
  * @return The dimension sign of the space id or NULL, if space id does not exist.
  */
  FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  ;

  /**
  * Retrieves the dimension n=1 sign of a given space node.
  * @param p_usim_id_spc The space id.
  * @return The dimension n=1 sign of the space id, base universe nodes will return 0. NULL, if space id does not exist.
  */
  FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  ;

  /**
  * Retrieves the dimension for a given node.
  * @param p_usim_id_spc The space id to get the dimension.
  * @return Returns the dimension or -1 if node does not exist.
  */
  FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Retrieves the coordinate for a given node.
  * @param p_usim_id_spc The space id to get the dimension.
  * @return Returns the coordinate or NULL if node does not exist.
  */
  FUNCTION get_coordinate(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Retrieves the process direction of a given space node.
  * @param p_usim_id_spc The space id to get the process direction.
  * @return Returns the process directions or NULL if space node does not exist.
  */
  FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_process_spin%TYPE
  ;

  /**
  * Get basic details about a given space node.
  * @param p_usim_id_spc The space id to get the details for.
  * @param p_usim_id_rmd The associated dimension axis id.
  * @param p_usim_id_pos The associated position id.
  * @param p_usim_id_nod The associated node id.
  * @param p_process_spin The current process spin of the space node.
  * @return Returns 1 if data could be fetched or 0 on errors.
  */
  FUNCTION get_spc_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                          , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_pos  OUT usim_position.usim_id_pos%TYPE
                          , p_usim_id_nod  OUT usim_node.usim_id_nod%TYPE
                          , p_process_spin OUT usim_space.usim_process_spin%TYPE
                          )
    RETURN NUMBER
  ;

  /**
  * Get all details about a given space node.
  * @param p_usim_id_spc The space id to get the details for.
  * @param p_usim_id_rmd The associated dimension axis id.
  * @param p_usim_id_pos The associated position id.
  * @param p_usim_id_nod The associated node id.
  * @param p_process_spin The current process spin of the space node.
  * @param p_usim_id_mlv The associated universe id.
  * @param p_n_dimension The associated dimension n.
  * @param p_dim_sign The associated sign of the dimension axis.
  * @param p_dim_n1_sign The associated n1 sign of the dimension axis.
  * @param p_coordinate The associated coordinate.
  * @param p_is_base The associated universe type.
  * @param p_energy The associated node energy.
  * @return Returns 1 if data could be fetched or 0 on errors.
  */
  FUNCTION get_spc_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                          , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_pos  OUT usim_position.usim_id_pos%TYPE
                          , p_usim_id_nod  OUT usim_node.usim_id_nod%TYPE
                          , p_process_spin OUT usim_space.usim_process_spin%TYPE
                          , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
                          , p_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
                          , p_dim_sign     OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_dim_n1_sign  OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          , p_coordinate   OUT usim_position.usim_coordinate%TYPE
                          , p_is_base      OUT usim_multiverse.usim_is_base_universe%TYPE
                          , p_energy       OUT usim_node.usim_energy%TYPE
                          )
    RETURN NUMBER
  ;

  /**
  * Inserts a new space node for the given ids in usim_space if it does not exist yet.
  * @param p_usim_id_rmd The universe/dimension relation id.
  * @param p_usim_id_pos The position id.
  * @param p_usim_id_nod The node id.
  * @param p_usim_process_spin The process spin (1, -1).
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new usim_id_spc id or NULL on errors.
  */
  FUNCTION insert_spc( p_usim_id_rmd       IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                     , p_usim_id_pos       IN usim_position.usim_id_pos%TYPE
                     , p_usim_id_nod       IN usim_node.usim_id_nod%TYPE
                     , p_usim_process_spin IN usim_space.usim_process_spin%TYPE
                     , p_do_commit         IN BOOLEAN                           DEFAULT TRUE
                     )
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Updates usim_process_spin by flipping the existing value (1 to -1 and vice versa)
  * if the given space node is not in dimension 0 with position 0. Otherwise does nothing.
  * @param p_usim_id_spc The space id to get the max dimension.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if no errors or 0 if space id does not exist.
  */
  FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                            , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                            )
    RETURN NUMBER
  ;

END usim_spc;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_spc
IS
  /**A low level package for actions on table usim_space and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_space has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_space has already data for a given space id.
  * @param p_usim_id_spc The relation id of universe/dimension/position/node.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_space has already data for given relation ids.
  * @param p_usim_id_rmd The relation id of universe/dimension.
  * @param p_usim_id_pos The id of the position.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                   , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                   )
    RETURN NUMBER
  ;

  /**
  * Checks if usim_space has already data for given relation ids.
  * @param p_usim_id_rmd The relation id of universe/dimension.
  * @param p_usim_id_pos The id of the position.
  * @param p_usim_id_nod The id of the node.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                   , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                   , p_usim_id_nod IN usim_node.usim_id_nod%TYPE
                   )
    RETURN NUMBER
  ;

  /**
  * Checks if usim_space has a entry for the base universe with dimension 0, position 0 and sign 0.
  * @return Returns 1 if base universe exists, otherwise 0.
  */
  FUNCTION has_base_universe
    RETURN NUMBER
  ;

  /**
  * Checks if the space id is a universe base entry with dimension 0, position 0 and sign 0. Not necessarily the base universe.
  * @param p_usim_id_spc The space id.
  * @return Returns 1 if universe base entry exists, otherwise 0.
  */
  FUNCTION is_universe_base(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Returns the maximum available dimensions for a space id and the related universe in usim_space. Considers
  * all dimensions, not caring about the n1 sign.
  * @param p_usim_id_spc The space id.
  * @return Returns the maximum available dimensions for the related universe or -1 if no dimension available.
  */
  FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Returns the current maximum available dimensions for a space id and the related universe in usim_space. Considers
  * only n1 dimension of the given id.
  * @param p_usim_id_spc The space id.
  * @return Returns the maximum available n=1 related dimensions for the related universe or NULL on errors.
  */
  FUNCTION get_cur_max_dim_n1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Returns the current maximum absolute position coordinate for a space id and the related universe in usim_space. Considers
  * only the dimension axis of the given id.
  * @param p_usim_id_spc The space id.
  * @return Returns the maximum available absolute position coordinate (always positive) or NULL on errors.
  */
  FUNCTION get_cur_max_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Retrieves the universe/dimension id for a given space id if it exists in usim_space.
  * @param p_usim_id_spc The space id.
  * @return Returns usim_id_rmd if space id exists, otherwise NULL.
  */
  FUNCTION get_id_rmd(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  ;

  /**
  * Retrieves the universe/dimension id for a given space id if it exists in usim_space.
  * @param p_usim_id_spc The space id.
  * @return Returns usim_id_rmd if space id exists, otherwise NULL.
  */
  FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Retrieves the universe id for a given space id if it exists in usim_space.
  * @param p_usim_id_spc The space id.
  * @return Returns usim_id_mlv if space id exists, otherwise NULL.
  */
  FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_multiverse.usim_id_mlv%TYPE
  ;

  /**
  * Retrieves the node id for a given space id if it exists in usim_space.
  * @param p_usim_id_spc The space id.
  * @return Returns usim_id_nod if space id exists, otherwise NULL.
  */
  FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_node.usim_id_nod%TYPE
  ;

  /**
  * Retrieves a space id for a given ids if it exists in usim_space.
  * @param p_usim_id_rmd The universe/dimension relation id.
  * @param p_usim_id_pos The position id.
  * @return Returns usim_id_spc if it exists, otherwise NULL.
  */
  FUNCTION get_id_spc( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                     , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                     )
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Retrieves the space id for the base universe if it exists in usim_space.
  * @return Returns usim_id_spc if base universe exists, otherwise NULL.
  */
  FUNCTION get_id_spc_base_universe
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Retrieves the dimension sign of a given space node.
  * @param p_usim_id_spc The space id.
  * @return The dimension sign of the space id or NULL, if space id does not exist.
  */
  FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  ;

  /**
  * Retrieves the dimension n=1 sign of a given space node.
  * @param p_usim_id_spc The space id.
  * @return The dimension n=1 sign of the space id, base universe nodes will return 0. NULL, if space id does not exist.
  */
  FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  ;

  /**
  * Retrieves the dimension for a given node.
  * @param p_usim_id_spc The space id to get the dimension.
  * @return Returns the dimension or -1 if node does not exist.
  */
  FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Retrieves the coordinate for a given node.
  * @param p_usim_id_spc The space id to get the dimension.
  * @return Returns the coordinate or NULL if node does not exist.
  */
  FUNCTION get_coordinate(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Retrieves the process direction of a given space node.
  * @param p_usim_id_spc The space id to get the process direction.
  * @return Returns the process directions or NULL if space node does not exist.
  */
  FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_process_spin%TYPE
  ;

  /**
  * Get basic details about a given space node.
  * @param p_usim_id_spc The space id to get the details for.
  * @param p_usim_id_rmd The associated dimension axis id.
  * @param p_usim_id_pos The associated position id.
  * @param p_usim_id_nod The associated node id.
  * @param p_process_spin The current process spin of the space node.
  * @return Returns 1 if data could be fetched or 0 on errors.
  */
  FUNCTION get_spc_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                          , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_pos  OUT usim_position.usim_id_pos%TYPE
                          , p_usim_id_nod  OUT usim_node.usim_id_nod%TYPE
                          , p_process_spin OUT usim_space.usim_process_spin%TYPE
                          )
    RETURN NUMBER
  ;

  /**
  * Get all details about a given space node.
  * @param p_usim_id_spc The space id to get the details for.
  * @param p_usim_id_rmd The associated dimension axis id.
  * @param p_usim_id_pos The associated position id.
  * @param p_usim_id_nod The associated node id.
  * @param p_process_spin The current process spin of the space node.
  * @param p_usim_id_mlv The associated universe id.
  * @param p_n_dimension The associated dimension n.
  * @param p_dim_sign The associated sign of the dimension axis.
  * @param p_dim_n1_sign The associated n1 sign of the dimension axis.
  * @param p_coordinate The associated coordinate.
  * @param p_is_base The associated universe type.
  * @param p_energy The associated node energy.
  * @return Returns 1 if data could be fetched or 0 on errors.
  */
  FUNCTION get_spc_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                          , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_pos  OUT usim_position.usim_id_pos%TYPE
                          , p_usim_id_nod  OUT usim_node.usim_id_nod%TYPE
                          , p_process_spin OUT usim_space.usim_process_spin%TYPE
                          , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
                          , p_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
                          , p_dim_sign     OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_dim_n1_sign  OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          , p_coordinate   OUT usim_position.usim_coordinate%TYPE
                          , p_is_base      OUT usim_multiverse.usim_is_base_universe%TYPE
                          , p_energy       OUT usim_node.usim_energy%TYPE
                          )
    RETURN NUMBER
  ;

  /**
  * Inserts a new space node for the given ids in usim_space if it does not exist yet.
  * @param p_usim_id_rmd The universe/dimension relation id.
  * @param p_usim_id_pos The position id.
  * @param p_usim_id_nod The node id.
  * @param p_usim_process_spin The process spin (1, -1).
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new usim_id_spc id or NULL on errors.
  */
  FUNCTION insert_spc( p_usim_id_rmd       IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                     , p_usim_id_pos       IN usim_position.usim_id_pos%TYPE
                     , p_usim_id_nod       IN usim_node.usim_id_nod%TYPE
                     , p_usim_process_spin IN usim_space.usim_process_spin%TYPE
                     , p_do_commit         IN BOOLEAN                           DEFAULT TRUE
                     )
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Updates usim_process_spin by flipping the existing value (1 to -1 and vice versa)
  * if the given space node is not in dimension 0 with position 0. Otherwise does nothing.
  * @param p_usim_id_spc The space id to get the max dimension.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if no errors or 0 if space id does not exist.
  */
  FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                            , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                            )
    RETURN NUMBER
  ;

END usim_spc;

Package USIM_SPC kompiliert

SQL> @@../PACKAGES/USIM_SPC.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_spc
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_data
  5      RETURN NUMBER
  6    IS
  7      l_result NUMBER;
  8    BEGIN
  9      SELECT COUNT(*) INTO l_result FROM usim_space;
 10      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 11    END has_data
 12    ;
 13
 14    FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 15      RETURN NUMBER
 16    IS
 17      l_result NUMBER;
 18    BEGIN
 19      SELECT COUNT(*) INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
 20      RETURN l_result;
 21    END has_data
 22    ;
 23
 24    FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
 25                     , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
 26                     )
 27      RETURN NUMBER
 28    IS
 29      l_result NUMBER;
 30    BEGIN
 31      SELECT COUNT(*) INTO l_result FROM usim_spc_v WHERE usim_id_rmd = p_usim_id_rmd AND usim_id_pos = p_usim_id_pos;
 32      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 33    END has_data
 34    ;
 35
 36    FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
 37                     , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
 38                     , p_usim_id_nod IN usim_node.usim_id_nod%TYPE
 39                     )
 40      RETURN NUMBER
 41    IS
 42      l_result NUMBER;
 43    BEGIN
 44      SELECT COUNT(*) INTO l_result FROM usim_space WHERE usim_id_rmd = p_usim_id_rmd AND usim_id_pos = p_usim_id_pos AND usim_id_nod = p_usim_id_nod;
 45      RETURN l_result;
 46    END has_data
 47    ;
 48
 49    FUNCTION has_base_universe
 50      RETURN NUMBER
 51    IS
 52      l_result NUMBER;
 53    BEGIN
 54      SELECT COUNT(*) INTO l_result FROM usim_spc_v WHERE usim_is_base_universe = 1 AND usim_n_dimension = 0 AND usim_coordinate = 0;
 55      RETURN l_result;
 56    END has_base_universe
 57    ;
 58
 59    FUNCTION is_universe_base(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 60      RETURN NUMBER
 61    IS
 62      l_result NUMBER;
 63    BEGIN
 64      SELECT COUNT(*) INTO l_result FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc AND usim_n_dimension = 0 AND usim_coordinate = 0;
 65      RETURN l_result;
 66    END is_universe_base
 67    ;
 68
 69    FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 70      RETURN usim_dimension.usim_n_dimension%TYPE
 71    IS
 72      l_result      usim_dimension.usim_n_dimension%TYPE;
 73      l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
 74    BEGIN
 75      IF usim_spc.has_data(p_usim_id_spc) = 1
 76      THEN
 77        l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
 78        SELECT NVL(MAX(usim_n_dimension), -1)
 79          INTO l_result
 80          FROM usim_spc_v
 81         WHERE usim_id_mlv = l_usim_id_mlv
 82        ;
 83        RETURN l_result;
 84      ELSE
 85        usim_erl.log_error('usim_spc.get_cur_max_dimension', 'Used not existing id [' || p_usim_id_spc || '].');
 86        RETURN NULL;
 87      END IF;
 88    END get_cur_max_dimension
 89    ;
 90
 91    FUNCTION get_cur_max_dim_n1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 92      RETURN usim_dimension.usim_n_dimension%TYPE
 93    IS
 94      l_result      usim_dimension.usim_n_dimension%TYPE;
 95      l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
 96      l_n1_sign     usim_rel_mlv_dim.usim_n1_sign%TYPE;
 97    BEGIN
 98      IF usim_spc.has_data(p_usim_id_spc) = 1
 99      THEN
100        l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
101        l_n1_sign     := usim_spc.get_dim_n1_sign(p_usim_id_spc);
102        SELECT MAX(usim_n_dimension)
103          INTO l_result
104          FROM usim_spc_v
105         WHERE usim_id_mlv = l_usim_id_mlv
106           AND dim_n1_sign = l_n1_sign
107        ;
108        RETURN l_result;
109      ELSE
110        usim_erl.log_error('usim_spc.get_cur_max_dim_n1', 'Used not existing id [' || p_usim_id_spc || '].');
111        RETURN NULL;
112      END IF;
113    END get_cur_max_dim_n1
114    ;
115
116    FUNCTION get_cur_max_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
117      RETURN usim_position.usim_coordinate%TYPE
118    IS
119      l_usim_id_rmd usim_rel_mlv_dim.usim_id_rmd%TYPE;
120      l_max_pos     usim_position.usim_coordinate%TYPE;
121    BEGIN
122      IF usim_spc.has_data(p_usim_id_spc) = 1
123      THEN
124        l_usim_id_rmd := usim_spc.get_id_rmd(p_usim_id_spc);
125        SELECT MAX(ABS(usim_coordinate))
126          INTO l_max_pos
127          FROM usim_spc_v
128         WHERE usim_id_rmd = l_usim_id_rmd
129        ;
130        RETURN l_max_pos;
131      ELSE
132        usim_erl.log_error('usim_spc.get_cur_max_pos', 'Used not existing id [' || p_usim_id_spc || '].');
133        RETURN NULL;
134      END IF;
135    END get_cur_max_pos
136    ;
137
138    FUNCTION get_id_rmd(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
139      RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
140    IS
141      l_result usim_rel_mlv_dim.usim_id_rmd%TYPE;
142    BEGIN
143      IF usim_spc.has_data(p_usim_id_spc) = 1
144      THEN
145        SELECT usim_id_rmd INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
146        RETURN l_result;
147      ELSE
148        usim_erl.log_error('usim_spc.get_id_rmd', 'Used with not existing space id [' || p_usim_id_spc || '].');
149        RETURN NULL;
150      END IF;
151    END get_id_rmd
152    ;
153
154    FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
155      RETURN usim_position.usim_id_pos%TYPE
156    IS
157      l_result usim_position.usim_id_pos%TYPE;
158    BEGIN
159      IF usim_spc.has_data(p_usim_id_spc) = 1
160      THEN
161        SELECT usim_id_pos INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
162        RETURN l_result;
163      ELSE
164        usim_erl.log_error('usim_spc.get_id_pos', 'Used with not existing space id [' || p_usim_id_spc || '].');
165        RETURN NULL;
166      END IF;
167    END get_id_pos
168    ;
169
170    FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
171      RETURN usim_multiverse.usim_id_mlv%TYPE
172    IS
173      l_result usim_multiverse.usim_id_mlv%TYPE;
174    BEGIN
175      IF usim_spc.has_data(p_usim_id_spc) = 1
176      THEN
177        SELECT usim_id_mlv INTO l_result FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc;
178        RETURN l_result;
179      ELSE
180        usim_erl.log_error('usim_spc.get_id_mlv', 'Used with not existing space id [' || p_usim_id_spc || '].');
181        RETURN NULL;
182      END IF;
183    END get_id_mlv
184    ;
185
186    FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
187      RETURN usim_node.usim_id_nod%TYPE
188    IS
189      l_result usim_node.usim_id_nod%TYPE;
190    BEGIN
191      IF usim_spc.has_data(p_usim_id_spc) = 1
192      THEN
193        SELECT usim_id_nod INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
194        RETURN l_result;
195      ELSE
196        usim_erl.log_error('usim_spc.get_id_nod', 'Used with not existing space id [' || p_usim_id_spc || '].');
197        RETURN NULL;
198      END IF;
199    END get_id_nod
200    ;
201
202    FUNCTION get_id_spc( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
203                       , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
204                       )
205      RETURN usim_space.usim_id_spc%TYPE
206    IS
207      l_result usim_space.usim_id_spc%TYPE;
208    BEGIN
209      IF usim_spc.has_data(p_usim_id_rmd, p_usim_id_pos) = 1
210      THEN
211        SELECT usim_id_spc INTO l_result FROM usim_space WHERE usim_id_rmd = p_usim_id_rmd AND usim_id_pos = p_usim_id_pos;
212        RETURN l_result;
213      ELSE
214        usim_erl.log_error('usim_spc.get_id_spc', 'Used with not existing rmd id [' || p_usim_id_rmd || '] or pos id [' || p_usim_id_pos || '].');
215        RETURN NULL;
216      END IF;
217    END get_id_spc
218    ;
219
220    FUNCTION get_id_spc_base_universe
221      RETURN usim_space.usim_id_spc%TYPE
222    IS
223      l_result usim_space.usim_id_spc%TYPE;
224    BEGIN
225      IF usim_spc.has_base_universe = 1
226      THEN
227        SELECT usim_id_spc INTO l_result FROM usim_spc_v WHERE usim_is_base_universe = 1 AND usim_n_dimension = 0 AND usim_coordinate = 0;
228        RETURN l_result;
229      ELSE
230        usim_erl.log_error('usim_spc.get_id_spc_base_universe', 'Used with not existing base universe.');
231        RETURN NULL;
232      END IF;
233    END get_id_spc_base_universe
234    ;
235
236    FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
237      RETURN usim_rel_mlv_dim.usim_sign%TYPE
238    IS
239      l_result usim_rel_mlv_dim.usim_sign%TYPE;
240    BEGIN
241      IF usim_spc.has_data(p_usim_id_spc) = 1
242      THEN
243        SELECT dim_sign
244          INTO l_result
245          FROM usim_spc_v
246         WHERE usim_id_spc = p_usim_id_spc
247        ;
248        RETURN l_result;
249      ELSE
250        -- no space node available
251        usim_erl.log_error('usim_spc.get_dim_sign', 'Not existing space id [' || p_usim_id_spc || '].');
252        RETURN NULL;
253      END IF;
254    END get_dim_sign
255    ;
256
257    FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
258      RETURN usim_rel_mlv_dim.usim_sign%TYPE
259    IS
260      l_result usim_rel_mlv_dim.usim_sign%TYPE;
261    BEGIN
262      IF usim_spc.has_data(p_usim_id_spc) = 1
263      THEN
264        SELECT NVL(dim_n1_sign, 0)
265          INTO l_result
266          FROM usim_spc_v
267         WHERE usim_id_spc = p_usim_id_spc
268        ;
269        RETURN l_result;
270      ELSE
271        -- no space node available
272        usim_erl.log_error('usim_spc.get_dim_n1_sign', 'Not existing space id [' || p_usim_id_spc || '].');
273        RETURN NULL;
274      END IF;
275    END get_dim_n1_sign
276    ;
277
278    FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
279      RETURN usim_dimension.usim_n_dimension%TYPE
280    IS
281      l_result usim_dimension.usim_n_dimension%TYPE;
282    BEGIN
283      IF usim_spc.has_data(p_usim_id_spc) = 1
284      THEN
285        SELECT usim_n_dimension
286          INTO l_result
287          FROM usim_spc_v
288         WHERE usim_id_spc = p_usim_id_spc
289        ;
290        RETURN l_result;
291      ELSE
292        -- no space node available
293        usim_erl.log_error('usim_spc.get_dimension', 'Not existing space id [' || p_usim_id_spc || '].');
294        RETURN -1;
295      END IF;
296    END get_dimension
297    ;
298
299    FUNCTION get_coordinate(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
300      RETURN usim_position.usim_coordinate%TYPE
301    IS
302      l_result usim_position.usim_coordinate%TYPE;
303    BEGIN
304      IF usim_spc.has_data(p_usim_id_spc) = 1
305      THEN
306        SELECT usim_coordinate
307          INTO l_result
308          FROM usim_spc_v
309         WHERE usim_id_spc = p_usim_id_spc
310        ;
311        RETURN l_result;
312      ELSE
313        -- no space node available
314        usim_erl.log_error('usim_spc.get_coordinate', 'Not existing space id [' || p_usim_id_spc || '].');
315        RETURN NULL;
316      END IF;
317    END get_coordinate
318    ;
319
320    FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
321      RETURN usim_space.usim_process_spin%TYPE
322    IS
323      l_result usim_space.usim_process_spin%TYPE;
324    BEGIN
325      IF usim_spc.has_data(p_usim_id_spc) = 1
326      THEN
327        SELECT usim_process_spin
328          INTO l_result
329          FROM usim_space
330         WHERE usim_id_spc = p_usim_id_spc
331        ;
332        RETURN l_result;
333      ELSE
334        -- no space node available
335        usim_erl.log_error('usim_spc.get_process_spin', 'Not existing space id [' || p_usim_id_spc || '].');
336        RETURN NULL;
337      END IF;
338    END get_process_spin
339    ;
340
341    FUNCTION get_spc_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
342                            , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
343                            , p_usim_id_pos  OUT usim_position.usim_id_pos%TYPE
344                            , p_usim_id_nod  OUT usim_node.usim_id_nod%TYPE
345                            , p_process_spin OUT usim_space.usim_process_spin%TYPE
346                            )
347      RETURN NUMBER
348    IS
349    BEGIN
350      IF usim_spc.has_data(p_usim_id_spc) = 1
351      THEN
352        SELECT usim_id_rmd
353             , usim_id_pos
354             , usim_id_nod
355             , usim_process_spin
356          INTO p_usim_id_rmd
357             , p_usim_id_pos
358             , p_usim_id_nod
359             , p_process_spin
360          FROM usim_space
361         WHERE usim_id_spc = p_usim_id_spc
362        ;
363        RETURN 1;
364      ELSE
365        -- no space node available
366        usim_erl.log_error('usim_spc.get_spc_details', 'Not existing space id [' || p_usim_id_spc || '].');
367        RETURN 0;
368      END IF;
369    END get_spc_details
370    ;
371
372    FUNCTION get_spc_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
373                            , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
374                            , p_usim_id_pos  OUT usim_position.usim_id_pos%TYPE
375                            , p_usim_id_nod  OUT usim_node.usim_id_nod%TYPE
376                            , p_process_spin OUT usim_space.usim_process_spin%TYPE
377                            , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
378                            , p_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
379                            , p_dim_sign     OUT usim_rel_mlv_dim.usim_sign%TYPE
380                            , p_dim_n1_sign  OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
381                            , p_coordinate   OUT usim_position.usim_coordinate%TYPE
382                            , p_is_base      OUT usim_multiverse.usim_is_base_universe%TYPE
383                            , p_energy       OUT usim_node.usim_energy%TYPE
384                            )
385      RETURN NUMBER
386    IS
387    BEGIN
388      IF usim_spc.has_data(p_usim_id_spc) = 1
389      THEN
390        SELECT usim_id_rmd
391             , usim_id_pos
392             , usim_id_nod
393             , usim_process_spin
394             , usim_id_mlv
395             , usim_n_dimension
396             , dim_sign
397             , dim_n1_sign
398             , usim_coordinate
399             , usim_is_base_universe
400             , usim_energy
401          INTO p_usim_id_rmd
402             , p_usim_id_pos
403             , p_usim_id_nod
404             , p_process_spin
405             , p_usim_id_mlv
406             , p_n_dimension
407             , p_dim_sign
408             , p_dim_n1_sign
409             , p_coordinate
410             , p_is_base
411             , p_energy
412          FROM usim_spc_v
413         WHERE usim_id_spc = p_usim_id_spc
414        ;
415        RETURN 1;
416      ELSE
417        -- no space node available
418        usim_erl.log_error('usim_spc.get_spc_details', 'Not existing space id [' || p_usim_id_spc || '].');
419        RETURN 0;
420      END IF;
421    END get_spc_details
422    ;
423
424    FUNCTION insert_spc( p_usim_id_rmd       IN usim_rel_mlv_dim.usim_id_rmd%TYPE
425                       , p_usim_id_pos       IN usim_position.usim_id_pos%TYPE
426                       , p_usim_id_nod       IN usim_node.usim_id_nod%TYPE
427                       , p_usim_process_spin IN usim_space.usim_process_spin%TYPE
428                       , p_do_commit         IN BOOLEAN                           DEFAULT TRUE
429                       )
430      RETURN usim_space.usim_id_spc%TYPE
431    IS
432      l_result usim_space.usim_id_spc%TYPE;
433    BEGIN
434      IF     p_usim_id_rmd       IS NOT NULL
435         AND p_usim_id_pos       IS NOT NULL
436         AND p_usim_id_nod       IS NOT NULL
437         AND p_usim_process_spin IN (1, -1)
438      THEN
439        INSERT INTO usim_space
440          ( usim_id_rmd
441          , usim_id_pos
442          , usim_id_nod
443          , usim_process_spin
444          )
445          VALUES
446          ( p_usim_id_rmd
447          , p_usim_id_pos
448          , p_usim_id_nod
449          , p_usim_process_spin
450          )
451          RETURNING usim_id_spc INTO l_result
452        ;
453        IF p_do_commit
454        THEN
455          COMMIT;
456        END IF;
457        RETURN l_result;
458      ELSE
459        usim_erl.log_error('usim_spc.insert_spc', 'Used with invalid rmd id [' || p_usim_id_rmd || '], pos id [' || p_usim_id_pos || '], node id [' || p_usim_id_nod || '] or process spin [' || p_usim_process_spin || '].');
460        RETURN NULL;
461      END IF;
462    END insert_spc
463    ;
464
465    FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
466                              , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
467                              )
468      RETURN NUMBER
469    IS
470      l_spin usim_space.usim_process_spin%TYPE;
471    BEGIN
472      IF usim_spc.has_data(p_usim_id_spc) = 1
473      THEN
474        IF usim_spc.is_universe_base(p_usim_id_spc) = 0
475        THEN
476          l_spin := usim_spc.get_process_spin(p_usim_id_spc) * -1;
477          UPDATE usim_space
478             SET usim_process_spin = l_spin
479           WHERE usim_id_spc = p_usim_id_spc
480          ;
481          IF p_do_commit
482          THEN
483            COMMIT;
484          END IF;
485        END IF;
486        RETURN 1;
487      ELSE
488        -- no space node available
489        usim_erl.log_error('usim_spc.flip_process_spin', 'Not existing space id [' || p_usim_id_spc || '].');
490        RETURN 0;
491      END IF;
492
493    END flip_process_spin
494    ;
495
496  END usim_spc;
497  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_spc
IS
  -- see header for documentation
  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_space;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                   , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                   )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_v WHERE usim_id_rmd = p_usim_id_rmd AND usim_id_pos = p_usim_id_pos;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                   , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                   , p_usim_id_nod IN usim_node.usim_id_nod%TYPE
                   )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_space WHERE usim_id_rmd = p_usim_id_rmd AND usim_id_pos = p_usim_id_pos AND usim_id_nod = p_usim_id_nod;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_base_universe
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_v WHERE usim_is_base_universe = 1 AND usim_n_dimension = 0 AND usim_coordinate = 0;
    RETURN l_result;
  END has_base_universe
  ;

  FUNCTION is_universe_base(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc AND usim_n_dimension = 0 AND usim_coordinate = 0;
    RETURN l_result;
  END is_universe_base
  ;

  FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result      usim_dimension.usim_n_dimension%TYPE;
    l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
      SELECT NVL(MAX(usim_n_dimension), -1)
        INTO l_result
        FROM usim_spc_v
       WHERE usim_id_mlv = l_usim_id_mlv
      ;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_cur_max_dimension', 'Used not existing id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_cur_max_dimension
  ;

  FUNCTION get_cur_max_dim_n1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result      usim_dimension.usim_n_dimension%TYPE;
    l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
    l_n1_sign     usim_rel_mlv_dim.usim_n1_sign%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
      l_n1_sign     := usim_spc.get_dim_n1_sign(p_usim_id_spc);
      SELECT MAX(usim_n_dimension)
        INTO l_result
        FROM usim_spc_v
       WHERE usim_id_mlv = l_usim_id_mlv
         AND dim_n1_sign = l_n1_sign
      ;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_cur_max_dim_n1', 'Used not existing id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_cur_max_dim_n1
  ;

  FUNCTION get_cur_max_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_usim_id_rmd usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_max_pos     usim_position.usim_coordinate%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_usim_id_rmd := usim_spc.get_id_rmd(p_usim_id_spc);
      SELECT MAX(ABS(usim_coordinate))
        INTO l_max_pos
        FROM usim_spc_v
       WHERE usim_id_rmd = l_usim_id_rmd
      ;
      RETURN l_max_pos;
    ELSE
      usim_erl.log_error('usim_spc.get_cur_max_pos', 'Used not existing id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_cur_max_pos
  ;

  FUNCTION get_id_rmd(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_id_rmd%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_rmd INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_id_rmd', 'Used with not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_id_rmd
  ;

  FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_result usim_position.usim_id_pos%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_pos INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_id_pos', 'Used with not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_id_pos
  ;

  FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_multiverse.usim_id_mlv%TYPE
  IS
    l_result usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_mlv INTO l_result FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_id_mlv', 'Used with not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_id_mlv
  ;

  FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_node.usim_id_nod%TYPE
  IS
    l_result usim_node.usim_id_nod%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_nod INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_id_nod', 'Used with not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_id_nod
  ;

  FUNCTION get_id_spc( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                     , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                     )
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_rmd, p_usim_id_pos) = 1
    THEN
      SELECT usim_id_spc INTO l_result FROM usim_space WHERE usim_id_rmd = p_usim_id_rmd AND usim_id_pos = p_usim_id_pos;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_id_spc', 'Used with not existing rmd id [' || p_usim_id_rmd || '] or pos id [' || p_usim_id_pos || '].');
      RETURN NULL;
    END IF;
  END get_id_spc
  ;

  FUNCTION get_id_spc_base_universe
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    IF usim_spc.has_base_universe = 1
    THEN
      SELECT usim_id_spc INTO l_result FROM usim_spc_v WHERE usim_is_base_universe = 1 AND usim_n_dimension = 0 AND usim_coordinate = 0;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_id_spc_base_universe', 'Used with not existing base universe.');
      RETURN NULL;
    END IF;
  END get_id_spc_base_universe
  ;

  FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_sign%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT dim_sign
        INTO l_result
        FROM usim_spc_v
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN l_result;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_dim_sign', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_dim_sign
  ;

  FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_sign%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT NVL(dim_n1_sign, 0)
        INTO l_result
        FROM usim_spc_v
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN l_result;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_dim_n1_sign', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_dim_n1_sign
  ;

  FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result usim_dimension.usim_n_dimension%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_n_dimension
        INTO l_result
        FROM usim_spc_v
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN l_result;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_dimension', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN -1;
    END IF;
  END get_dimension
  ;

  FUNCTION get_coordinate(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_result usim_position.usim_coordinate%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_coordinate
        INTO l_result
        FROM usim_spc_v
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN l_result;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_coordinate', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_coordinate
  ;

  FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_process_spin%TYPE
  IS
    l_result usim_space.usim_process_spin%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_process_spin
        INTO l_result
        FROM usim_space
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN l_result;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_process_spin', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_process_spin
  ;

  FUNCTION get_spc_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                          , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_pos  OUT usim_position.usim_id_pos%TYPE
                          , p_usim_id_nod  OUT usim_node.usim_id_nod%TYPE
                          , p_process_spin OUT usim_space.usim_process_spin%TYPE
                          )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_rmd
           , usim_id_pos
           , usim_id_nod
           , usim_process_spin
        INTO p_usim_id_rmd
           , p_usim_id_pos
           , p_usim_id_nod
           , p_process_spin
        FROM usim_space
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN 1;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_spc_details', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN 0;
    END IF;
  END get_spc_details
  ;

  FUNCTION get_spc_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                          , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_pos  OUT usim_position.usim_id_pos%TYPE
                          , p_usim_id_nod  OUT usim_node.usim_id_nod%TYPE
                          , p_process_spin OUT usim_space.usim_process_spin%TYPE
                          , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
                          , p_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
                          , p_dim_sign     OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_dim_n1_sign  OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          , p_coordinate   OUT usim_position.usim_coordinate%TYPE
                          , p_is_base      OUT usim_multiverse.usim_is_base_universe%TYPE
                          , p_energy       OUT usim_node.usim_energy%TYPE
                          )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_rmd
           , usim_id_pos
           , usim_id_nod
           , usim_process_spin
           , usim_id_mlv
           , usim_n_dimension
           , dim_sign
           , dim_n1_sign
           , usim_coordinate
           , usim_is_base_universe
           , usim_energy
        INTO p_usim_id_rmd
           , p_usim_id_pos
           , p_usim_id_nod
           , p_process_spin
           , p_usim_id_mlv
           , p_n_dimension
           , p_dim_sign
           , p_dim_n1_sign
           , p_coordinate
           , p_is_base
           , p_energy
        FROM usim_spc_v
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN 1;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_spc_details', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN 0;
    END IF;
  END get_spc_details
  ;

  FUNCTION insert_spc( p_usim_id_rmd       IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                     , p_usim_id_pos       IN usim_position.usim_id_pos%TYPE
                     , p_usim_id_nod       IN usim_node.usim_id_nod%TYPE
                     , p_usim_process_spin IN usim_space.usim_process_spin%TYPE
                     , p_do_commit         IN BOOLEAN                           DEFAULT TRUE
                     )
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    IF     p_usim_id_rmd       IS NOT NULL
       AND p_usim_id_pos       IS NOT NULL
       AND p_usim_id_nod       IS NOT NULL
       AND p_usim_process_spin IN (1, -1)
    THEN
      INSERT INTO usim_space
        ( usim_id_rmd
        , usim_id_pos
        , usim_id_nod
        , usim_process_spin
        )
        VALUES
        ( p_usim_id_rmd
        , p_usim_id_pos
        , p_usim_id_nod
        , p_usim_process_spin
        )
        RETURNING usim_id_spc INTO l_result
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.insert_spc', 'Used with invalid rmd id [' || p_usim_id_rmd || '], pos id [' || p_usim_id_pos || '], node id [' || p_usim_id_nod || '] or process spin [' || p_usim_process_spin || '].');
      RETURN NULL;
    END IF;
  END insert_spc
  ;

  FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                            , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                            )
    RETURN NUMBER
  IS
    l_spin usim_space.usim_process_spin%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      IF usim_spc.is_universe_base(p_usim_id_spc) = 0
      THEN
        l_spin := usim_spc.get_process_spin(p_usim_id_spc) * -1;
        UPDATE usim_space
           SET usim_process_spin = l_spin
         WHERE usim_id_spc = p_usim_id_spc
        ;
        IF p_do_commit
        THEN
          COMMIT;
        END IF;
      END IF;
      RETURN 1;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.flip_process_spin', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN 0;
    END IF;

  END flip_process_spin
  ;

END usim_spc;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_spc
IS
  -- see header for documentation
  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_space;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                   , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                   )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_v WHERE usim_id_rmd = p_usim_id_rmd AND usim_id_pos = p_usim_id_pos;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                   , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                   , p_usim_id_nod IN usim_node.usim_id_nod%TYPE
                   )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_space WHERE usim_id_rmd = p_usim_id_rmd AND usim_id_pos = p_usim_id_pos AND usim_id_nod = p_usim_id_nod;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_base_universe
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_v WHERE usim_is_base_universe = 1 AND usim_n_dimension = 0 AND usim_coordinate = 0;
    RETURN l_result;
  END has_base_universe
  ;

  FUNCTION is_universe_base(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc AND usim_n_dimension = 0 AND usim_coordinate = 0;
    RETURN l_result;
  END is_universe_base
  ;

  FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result      usim_dimension.usim_n_dimension%TYPE;
    l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
      SELECT NVL(MAX(usim_n_dimension), -1)
        INTO l_result
        FROM usim_spc_v
       WHERE usim_id_mlv = l_usim_id_mlv
      ;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_cur_max_dimension', 'Used not existing id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_cur_max_dimension
  ;

  FUNCTION get_cur_max_dim_n1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result      usim_dimension.usim_n_dimension%TYPE;
    l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
    l_n1_sign     usim_rel_mlv_dim.usim_n1_sign%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
      l_n1_sign     := usim_spc.get_dim_n1_sign(p_usim_id_spc);
      SELECT MAX(usim_n_dimension)
        INTO l_result
        FROM usim_spc_v
       WHERE usim_id_mlv = l_usim_id_mlv
         AND dim_n1_sign = l_n1_sign
      ;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_cur_max_dim_n1', 'Used not existing id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_cur_max_dim_n1
  ;

  FUNCTION get_cur_max_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_usim_id_rmd usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_max_pos     usim_position.usim_coordinate%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_usim_id_rmd := usim_spc.get_id_rmd(p_usim_id_spc);
      SELECT MAX(ABS(usim_coordinate))
        INTO l_max_pos
        FROM usim_spc_v
       WHERE usim_id_rmd = l_usim_id_rmd
      ;
      RETURN l_max_pos;
    ELSE
      usim_erl.log_error('usim_spc.get_cur_max_pos', 'Used not existing id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_cur_max_pos
  ;

  FUNCTION get_id_rmd(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_id_rmd%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_rmd INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_id_rmd', 'Used with not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_id_rmd
  ;

  FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_result usim_position.usim_id_pos%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_pos INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_id_pos', 'Used with not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_id_pos
  ;

  FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_multiverse.usim_id_mlv%TYPE
  IS
    l_result usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_mlv INTO l_result FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_id_mlv', 'Used with not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_id_mlv
  ;

  FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_node.usim_id_nod%TYPE
  IS
    l_result usim_node.usim_id_nod%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_nod INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_id_nod', 'Used with not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_id_nod
  ;

  FUNCTION get_id_spc( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                     , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
                     )
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_rmd, p_usim_id_pos) = 1
    THEN
      SELECT usim_id_spc INTO l_result FROM usim_space WHERE usim_id_rmd = p_usim_id_rmd AND usim_id_pos = p_usim_id_pos;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_id_spc', 'Used with not existing rmd id [' || p_usim_id_rmd || '] or pos id [' || p_usim_id_pos || '].');
      RETURN NULL;
    END IF;
  END get_id_spc
  ;

  FUNCTION get_id_spc_base_universe
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    IF usim_spc.has_base_universe = 1
    THEN
      SELECT usim_id_spc INTO l_result FROM usim_spc_v WHERE usim_is_base_universe = 1 AND usim_n_dimension = 0 AND usim_coordinate = 0;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.get_id_spc_base_universe', 'Used with not existing base universe.');
      RETURN NULL;
    END IF;
  END get_id_spc_base_universe
  ;

  FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_sign%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT dim_sign
        INTO l_result
        FROM usim_spc_v
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN l_result;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_dim_sign', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_dim_sign
  ;

  FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_sign%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT NVL(dim_n1_sign, 0)
        INTO l_result
        FROM usim_spc_v
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN l_result;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_dim_n1_sign', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_dim_n1_sign
  ;

  FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result usim_dimension.usim_n_dimension%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_n_dimension
        INTO l_result
        FROM usim_spc_v
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN l_result;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_dimension', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN -1;
    END IF;
  END get_dimension
  ;

  FUNCTION get_coordinate(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_result usim_position.usim_coordinate%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_coordinate
        INTO l_result
        FROM usim_spc_v
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN l_result;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_coordinate', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_coordinate
  ;

  FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_process_spin%TYPE
  IS
    l_result usim_space.usim_process_spin%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_process_spin
        INTO l_result
        FROM usim_space
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN l_result;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_process_spin', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_process_spin
  ;

  FUNCTION get_spc_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                          , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_pos  OUT usim_position.usim_id_pos%TYPE
                          , p_usim_id_nod  OUT usim_node.usim_id_nod%TYPE
                          , p_process_spin OUT usim_space.usim_process_spin%TYPE
                          )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_rmd
           , usim_id_pos
           , usim_id_nod
           , usim_process_spin
        INTO p_usim_id_rmd
           , p_usim_id_pos
           , p_usim_id_nod
           , p_process_spin
        FROM usim_space
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN 1;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_spc_details', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN 0;
    END IF;
  END get_spc_details
  ;

  FUNCTION get_spc_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                          , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_pos  OUT usim_position.usim_id_pos%TYPE
                          , p_usim_id_nod  OUT usim_node.usim_id_nod%TYPE
                          , p_process_spin OUT usim_space.usim_process_spin%TYPE
                          , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
                          , p_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
                          , p_dim_sign     OUT usim_rel_mlv_dim.usim_sign%TYPE
                          , p_dim_n1_sign  OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                          , p_coordinate   OUT usim_position.usim_coordinate%TYPE
                          , p_is_base      OUT usim_multiverse.usim_is_base_universe%TYPE
                          , p_energy       OUT usim_node.usim_energy%TYPE
                          )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_rmd
           , usim_id_pos
           , usim_id_nod
           , usim_process_spin
           , usim_id_mlv
           , usim_n_dimension
           , dim_sign
           , dim_n1_sign
           , usim_coordinate
           , usim_is_base_universe
           , usim_energy
        INTO p_usim_id_rmd
           , p_usim_id_pos
           , p_usim_id_nod
           , p_process_spin
           , p_usim_id_mlv
           , p_n_dimension
           , p_dim_sign
           , p_dim_n1_sign
           , p_coordinate
           , p_is_base
           , p_energy
        FROM usim_spc_v
       WHERE usim_id_spc = p_usim_id_spc
      ;
      RETURN 1;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.get_spc_details', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN 0;
    END IF;
  END get_spc_details
  ;

  FUNCTION insert_spc( p_usim_id_rmd       IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                     , p_usim_id_pos       IN usim_position.usim_id_pos%TYPE
                     , p_usim_id_nod       IN usim_node.usim_id_nod%TYPE
                     , p_usim_process_spin IN usim_space.usim_process_spin%TYPE
                     , p_do_commit         IN BOOLEAN                           DEFAULT TRUE
                     )
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    IF     p_usim_id_rmd       IS NOT NULL
       AND p_usim_id_pos       IS NOT NULL
       AND p_usim_id_nod       IS NOT NULL
       AND p_usim_process_spin IN (1, -1)
    THEN
      INSERT INTO usim_space
        ( usim_id_rmd
        , usim_id_pos
        , usim_id_nod
        , usim_process_spin
        )
        VALUES
        ( p_usim_id_rmd
        , p_usim_id_pos
        , p_usim_id_nod
        , p_usim_process_spin
        )
        RETURNING usim_id_spc INTO l_result
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spc.insert_spc', 'Used with invalid rmd id [' || p_usim_id_rmd || '], pos id [' || p_usim_id_pos || '], node id [' || p_usim_id_nod || '] or process spin [' || p_usim_process_spin || '].');
      RETURN NULL;
    END IF;
  END insert_spc
  ;

  FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                            , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                            )
    RETURN NUMBER
  IS
    l_spin usim_space.usim_process_spin%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      IF usim_spc.is_universe_base(p_usim_id_spc) = 0
      THEN
        l_spin := usim_spc.get_process_spin(p_usim_id_spc) * -1;
        UPDATE usim_space
           SET usim_process_spin = l_spin
         WHERE usim_id_spc = p_usim_id_spc
        ;
        IF p_do_commit
        THEN
          COMMIT;
        END IF;
      END IF;
      RETURN 1;
    ELSE
      -- no space node available
      usim_erl.log_error('usim_spc.flip_process_spin', 'Not existing space id [' || p_usim_id_spc || '].');
      RETURN 0;
    END IF;

  END flip_process_spin
  ;

END usim_spc;

Package Body USIM_SPC kompiliert

SQL> -- USIM_SPC_CHILD (chi)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_SPC_CHILD_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPC_CHILD still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_CHILD'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_SPC_CHILD_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPC_CHILD still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_CHILD'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_SPC_CHILD_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPC_CHILD still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_CHILD'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../TABLES/USIM_SPC_CHILD_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_SPC_CHILD (chi)
SQL> CREATE TABLE &USIM_SCHEMA..usim_spc_child
  2    ( usim_id_spc        CHAR(55) NOT NULL ENABLE
  3    , usim_id_spc_child  CHAR(55) NOT NULL ENABLE
  4    )
  5  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_spc_child
  ( usim_id_spc        CHAR(55) NOT NULL ENABLE
  , usim_id_spc_child  CHAR(55) NOT NULL ENABLE
  )

neu:CREATE TABLE USIM_TEST.usim_spc_child
  ( usim_id_spc        CHAR(55) NOT NULL ENABLE
  , usim_id_spc_child  CHAR(55) NOT NULL ENABLE
  )

Table USIM_TEST.USIM_SPC_CHILD erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_spc_child IS 'Describes the parent-child relation between active nodes. Will use the alias chi.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_spc_child IS 'Describes the parent-child relation between active nodes. Will use the alias chi.'
neu:COMMENT ON TABLE USIM_TEST.usim_spc_child IS 'Describes the parent-child relation between active nodes. Will use the alias chi.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_child.usim_id_spc IS 'The parent id from usim_space.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_child.usim_id_spc IS 'The parent id from usim_space.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_child.usim_id_spc IS 'The parent id from usim_space.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_child.usim_id_spc_child IS 'The child id from usim_space.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_child.usim_id_spc_child IS 'The child id from usim_space.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_child.usim_id_spc_child IS 'The child id from usim_space.'

Comment erstellt.

SQL>
SQL> -- uk
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_child
  2    ADD CONSTRAINT usim_chi_uk
  3    UNIQUE (usim_id_spc, usim_id_spc_child)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_spc_child
  ADD CONSTRAINT usim_chi_uk
  UNIQUE (usim_id_spc, usim_id_spc_child)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_spc_child
  ADD CONSTRAINT usim_chi_uk
  UNIQUE (usim_id_spc, usim_id_spc_child)
  ENABLE

Table USIM_TEST.USIM_SPC_CHILD geändert.

SQL>
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_chi_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_spc_child
  3      FOR EACH ROW
  4      BEGIN
  5        IF :NEW.usim_id_spc = :NEW.usim_id_spc_child
  6        THEN
  7          RAISE_APPLICATION_ERROR( num => -20000
  8                                 , msg => 'Insert requirement not fulfilled. Parent and child cannot be equal.'
  9                                 )
 10          ;
 11        END IF;
 12      END;
 13  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_chi_ins_trg
  BEFORE INSERT ON &USIM_SCHEMA..usim_spc_child
    FOR EACH ROW
    BEGIN
      IF :NEW.usim_id_spc = :NEW.usim_id_spc_child
      THEN
        RAISE_APPLICATION_ERROR( num => -20000
                               , msg => 'Insert requirement not fulfilled. Parent and child cannot be equal.'
                               )
        ;
      END IF;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_chi_ins_trg
  BEFORE INSERT ON USIM_TEST.usim_spc_child
    FOR EACH ROW
    BEGIN
      IF :NEW.usim_id_spc = :NEW.usim_id_spc_child
      THEN
        RAISE_APPLICATION_ERROR( num => -20000
                               , msg => 'Insert requirement not fulfilled. Parent and child cannot be equal.'
                               )
        ;
      END IF;
    END;

Trigger USIM_CHI_INS_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_chi_ins_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_chi_ins_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_chi_ins_trg ENABLE

Trigger USIM_TEST.USIM_CHI_INS_TRG geändert.

SQL>
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_chi_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_spc_child
  3      FOR EACH ROW
  4      BEGIN
  5        RAISE_APPLICATION_ERROR( num => -20001
  6                               , msg => 'Update requirement not fulfilled. No update allowed.'
  7                               )
  8        ;
  9      END;
 10  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_chi_upd_trg
  BEFORE UPDATE ON &USIM_SCHEMA..usim_spc_child
    FOR EACH ROW
    BEGIN
      RAISE_APPLICATION_ERROR( num => -20001
                             , msg => 'Update requirement not fulfilled. No update allowed.'
                             )
      ;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_chi_upd_trg
  BEFORE UPDATE ON USIM_TEST.usim_spc_child
    FOR EACH ROW
    BEGIN
      RAISE_APPLICATION_ERROR( num => -20001
                             , msg => 'Update requirement not fulfilled. No update allowed.'
                             )
      ;
    END;

Trigger USIM_CHI_UPD_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_chi_upd_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_chi_upd_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_chi_upd_trg ENABLE

Trigger USIM_TEST.USIM_CHI_UPD_TRG geändert.

SQL> -- foreign keys
SQL> @@../FK/USIM_CHI_PARENT_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk parent-child relation between nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_child
  2    ADD CONSTRAINT usim_chi_parent_fk
  3    FOREIGN KEY (usim_id_spc) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_spc_child
  ADD CONSTRAINT usim_chi_parent_fk
  FOREIGN KEY (usim_id_spc) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_spc_child
  ADD CONSTRAINT usim_chi_parent_fk
  FOREIGN KEY (usim_id_spc) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_SPC_CHILD geändert.

SQL> @@../FK/USIM_CHI_CHILD_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk parent-child relation between nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_child
  2    ADD CONSTRAINT usim_chi_child_fk
  3    FOREIGN KEY (usim_id_spc_child) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_spc_child
  ADD CONSTRAINT usim_chi_child_fk
  FOREIGN KEY (usim_id_spc_child) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_spc_child
  ADD CONSTRAINT usim_chi_child_fk
  FOREIGN KEY (usim_id_spc_child) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_SPC_CHILD geändert.

SQL> -- views
SQL> @@../VIEW/USIM_CHI_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_CHI_V (chiv)
SQL> CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_chi_v AS
  2    SELECT r_parent.usim_n_dimension AS parent_dimension
  3         , r_parent.dim_sign AS parent_dim_sign
  4         , r_parent.dim_n1_sign AS parent_dim_n1_sign
  5         , r_child.usim_n_dimension AS child_dimension
  6         , r_child.dim_sign AS child_dim_sign
  7         , r_child.dim_n1_sign AS child_dim_n1_sign
  8         , r_parent.usim_coordinate AS parent_coordinate
  9         , r_child.usim_coordinate AS child_coordinate
 10         , chi.usim_id_spc
 11         , chi.usim_id_spc_child
 12         , r_parent.usim_id_rmd AS parent_id_rmd
 13         , r_child.usim_id_rmd AS child_id_rmd
 14         , r_parent.usim_id_mlv AS parent_id_mlv
 15         , r_child.usim_id_mlv AS child_id_mlv
 16      FROM usim_spc_child chi
 17      LEFT OUTER JOIN usim_spc_v r_parent
 18        ON chi.usim_id_spc = r_parent.usim_id_spc
 19      LEFT OUTER JOIN usim_spc_v r_child
 20        ON chi.usim_id_spc_child = r_child.usim_id_spc
 21  ;
alt:CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_chi_v AS
  SELECT r_parent.usim_n_dimension AS parent_dimension
       , r_parent.dim_sign AS parent_dim_sign
       , r_parent.dim_n1_sign AS parent_dim_n1_sign
       , r_child.usim_n_dimension AS child_dimension
       , r_child.dim_sign AS child_dim_sign
       , r_child.dim_n1_sign AS child_dim_n1_sign
       , r_parent.usim_coordinate AS parent_coordinate
       , r_child.usim_coordinate AS child_coordinate
       , chi.usim_id_spc
       , chi.usim_id_spc_child
       , r_parent.usim_id_rmd AS parent_id_rmd
       , r_child.usim_id_rmd AS child_id_rmd
       , r_parent.usim_id_mlv AS parent_id_mlv
       , r_child.usim_id_mlv AS child_id_mlv
    FROM usim_spc_child chi
    LEFT OUTER JOIN usim_spc_v r_parent
      ON chi.usim_id_spc = r_parent.usim_id_spc
    LEFT OUTER JOIN usim_spc_v r_child
      ON chi.usim_id_spc_child = r_child.usim_id_spc

neu:CREATE OR REPLACE FORCE VIEW USIM_TEST.usim_chi_v AS
  SELECT r_parent.usim_n_dimension AS parent_dimension
       , r_parent.dim_sign AS parent_dim_sign
       , r_parent.dim_n1_sign AS parent_dim_n1_sign
       , r_child.usim_n_dimension AS child_dimension
       , r_child.dim_sign AS child_dim_sign
       , r_child.dim_n1_sign AS child_dim_n1_sign
       , r_parent.usim_coordinate AS parent_coordinate
       , r_child.usim_coordinate AS child_coordinate
       , chi.usim_id_spc
       , chi.usim_id_spc_child
       , r_parent.usim_id_rmd AS parent_id_rmd
       , r_child.usim_id_rmd AS child_id_rmd
       , r_parent.usim_id_mlv AS parent_id_mlv
       , r_child.usim_id_mlv AS child_id_mlv
    FROM usim_spc_child chi
    LEFT OUTER JOIN usim_spc_v r_parent
      ON chi.usim_id_spc = r_parent.usim_id_spc
    LEFT OUTER JOIN usim_spc_v r_child
      ON chi.usim_id_spc_child = r_child.usim_id_spc

View USIM_TEST.USIM_CHI_V erstellt.

SQL> @@../VIEW/USIM_SPC_CHI_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_SPC_CHI_V (scv)
SQL> -- guarantees all space id in view with or without childs
SQL> CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spc_chi_v AS
  2    SELECT spcv.usim_n_dimension AS parent_dimension
  3         , spcv.dim_sign         AS parent_dim_sign
  4         , chiv.child_dimension
  5         , chiv.child_dim_sign
  6         , spcv.usim_coordinate  AS parent_coordinate
  7         , chiv.child_coordinate
  8         , spcv.usim_id_spc
  9         , chiv.usim_id_spc_child
 10         , spcv.usim_id_rmd
 11         , spcv.usim_id_pos
 12         , spcv.usim_id_mlv
 13         , spcv.usim_id_nod
 14         , spcv.usim_id_dim
 15         , chiv.child_id_rmd
 16      FROM usim_spc_v spcv
 17      LEFT OUTER JOIN usim_chi_v chiv
 18        ON spcv.usim_id_spc = chiv.usim_id_spc
 19  ;
alt:CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spc_chi_v AS
  SELECT spcv.usim_n_dimension AS parent_dimension
       , spcv.dim_sign         AS parent_dim_sign
       , chiv.child_dimension
       , chiv.child_dim_sign
       , spcv.usim_coordinate  AS parent_coordinate
       , chiv.child_coordinate
       , spcv.usim_id_spc
       , chiv.usim_id_spc_child
       , spcv.usim_id_rmd
       , spcv.usim_id_pos
       , spcv.usim_id_mlv
       , spcv.usim_id_nod
       , spcv.usim_id_dim
       , chiv.child_id_rmd
    FROM usim_spc_v spcv
    LEFT OUTER JOIN usim_chi_v chiv
      ON spcv.usim_id_spc = chiv.usim_id_spc

neu:CREATE OR REPLACE VIEW USIM_TEST.usim_spc_chi_v AS
  SELECT spcv.usim_n_dimension AS parent_dimension
       , spcv.dim_sign         AS parent_dim_sign
       , chiv.child_dimension
       , chiv.child_dim_sign
       , spcv.usim_coordinate  AS parent_coordinate
       , chiv.child_coordinate
       , spcv.usim_id_spc
       , chiv.usim_id_spc_child
       , spcv.usim_id_rmd
       , spcv.usim_id_pos
       , spcv.usim_id_mlv
       , spcv.usim_id_nod
       , spcv.usim_id_dim
       , chiv.child_id_rmd
    FROM usim_spc_v spcv
    LEFT OUTER JOIN usim_chi_v chiv
      ON spcv.usim_id_spc = chiv.usim_id_spc

View USIM_TEST.USIM_SPC_CHI_V erstellt.

SQL> -- usim_spc_child package
SQL> @@../PACKAGES/USIM_CHI.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_chi
  2  IS
  3    /**A package for actions on table usim_spc_child.*/
  4    /**A low level package for actions on table usim_spc_child and its associated
  5    * views. Views can be seen as interfaces and dependency. No other package dependencies
  6    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  7    * from constraints, triggers and foreign keys. Caller is responsible to handle
  8    * possible exceptions.
  9    */
 10
 11    /**
 12    * Checks if usim_spc_child has already data.
 13    * @return Returns 1 if data are available, otherwise 0.
 14    */
 15    FUNCTION has_data
 16      RETURN NUMBER
 17    ;
 18
 19    /**
 20    * Checks if usim_spc_child has data for parent or child.
 21    * @param p_usim_id_spc The parent id to check data for.
 22    * @return Returns 1 if data are available, otherwise 0.
 23    */
 24    FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 25      RETURN NUMBER
 26    ;
 27
 28    /**
 29    * Checks if usim_spc_child has data for given parent and child.
 30    * @param p_usim_id_spc The parent id to check data for.
 31    * @param p_usim_id_spc_child The child id to check data for.
 32    * @return Returns 1 if data are available, otherwise 0.
 33    */
 34    FUNCTION has_data( p_usim_id_spc       IN usim_space.usim_id_spc%TYPE
 35                     , p_usim_id_spc_child IN usim_space.usim_id_spc%TYPE
 36                     )
 37      RETURN NUMBER
 38    ;
 39
 40    /**
 41    * Checks if usim_spc_child has data for the given parent id.
 42    * @param p_usim_id_spc The parent id to check data for.
 43    * @return Returns 1 if data are available, otherwise 0.
 44    */
 45    FUNCTION has_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 46      RETURN NUMBER
 47    ;
 48
 49    /**
 50    * Checks if usim_spc_child has data for the given child id.
 51    * @param p_usim_id_spc The child id to check data for.
 52    * @return Returns 1 if data are available, otherwise 0.
 53    */
 54    FUNCTION has_child(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 55      RETURN NUMBER
 56    ;
 57
 58    /**
 59    * Checks if a given parent has the same universe as the child.
 60    * @param p_usim_id_spc The parent id to check data for.
 61    * @return Returns 1 if universe is equal for child and parent, otherwise 0.
 62    */
 63    FUNCTION has_child_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 64      RETURN NUMBER
 65    ;
 66
 67    /**
 68    * Checks if a given child has the same universe as the parent.
 69    * @param p_usim_id_spc The child id to check data for.
 70    * @return Returns 1 if universe is equal for child and parent, otherwise 0.
 71    */
 72    FUNCTION has_parent_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 73      RETURN NUMBER
 74    ;
 75
 76    /**
 77    * Checks if a given space node has a child in the next dimension.
 78    * @param p_usim_id_spc The space id to check data for.
 79    * @return Returns 1 if the node has at least one child in the next dimension, otherwise 0.
 80    */
 81    FUNCTION has_child_next_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 82      RETURN NUMBER
 83    ;
 84
 85    /**
 86    * Checks if a given space node has a child in the given dimension.
 87    * @param p_usim_id_spc The space id to check data for.
 88    * @param p_usim_n_dimension The dimension to check childs for.
 89    * @return Returns 1 if the node has at least one child in the given dimension, otherwise 0.
 90    */
 91    FUNCTION has_child_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
 92                             , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 93                             )
 94      RETURN NUMBER
 95    ;
 96
 97    /**
 98    * Checks if a given space node has a parent in the given dimension.
 99    * @param p_usim_id_spc The space id to check data for.
100    * @param p_usim_n_dimension The dimension to check parents for.
101    * @return Returns 1 if the node has at least one parent in the given dimension, otherwise 0.
102    */
103    FUNCTION has_parent_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
104                              , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
105                              )
106      RETURN NUMBER
107    ;
108
109    /**
110    * Checks if a given space node has a child in the current dimension.
111    * @param p_usim_id_spc The space id to check data for.
112    * @return Returns 1 if the node has a child in the current dimension, otherwise 0.
113    */
114    FUNCTION has_child_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
115      RETURN NUMBER
116    ;
117
118    /**
119    * Checks if a given space node has a parent in the current dimension.
120    * @param p_usim_id_spc The space id to check data for.
121    * @return Returns 1 if the node has a parent in the current dimension, otherwise 0.
122    */
123    FUNCTION has_parent_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
124      RETURN NUMBER
125    ;
126
127    /**
128    * Checks if a given space nodes have a relation. Type of relation is not considered, means not caring about
129    * whether one is child or parent.
130    * @param p_usim_id_spc The first space id to check data for.
131    * @param p_usim_id_spc_rel The second space id to check data for.
132    * @return Returns 1 if the nodes are related, otherwise 0.
133    */
134    FUNCTION has_relation( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
135                         , p_usim_id_spc_rel  IN usim_space.usim_id_spc%TYPE
136                         )
137      RETURN NUMBER
138    ;
139
140    /**
141    * Retrieves the amount of childs a given space id has in the universe the parent is in.
142    * @param p_usim_id_spc The space id to get the amount of childs.
143    * @return Returns the amount of childs found for the given space id in the related universe.
144    */
145    FUNCTION child_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
146      RETURN NUMBER
147    ;
148
149    /**
150    * Retrieves the amount of childs a given space id has in the universe the parent is in.
151    * @param p_usim_id_spc The space id to get the amount of childs.
152    * @return Returns the amount of childs found for the given space id regardless of related universe.
153    */
154    FUNCTION child_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
155      RETURN NUMBER
156    ;
157
158    /**
159    * Retrieves the amount of parents a given space id has in the universe the child is in.
160    * @param p_usim_id_spc The space id to get the amount of parents.
161    * @return Returns the amount of childs found for the given space id.
162    */
163    FUNCTION parent_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
164      RETURN NUMBER
165    ;
166
167    /**
168    * Retrieves the amount of parents a given space id has in the universe the child is in.
169    * @param p_usim_id_spc The space id to get the amount of parents.
170    * @return Returns the amount of childs found for the given space id.
171    */
172    FUNCTION parent_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
173      RETURN NUMBER
174    ;
175
176    /***
177    * Retrieve the child in the same dimension. Expected a from space node, which should always
178    * have only one child in the same dimension with the same sign.
179    * @param p_usim_id_spc The space id to get the child for.
180    * @return Returns the child space id or NULL if wrong space node used.
181    */
182    FUNCTION get_child_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
183      RETURN usim_space.usim_id_spc%TYPE
184    ;
185
186    /***
187    * Retrieve the child in the next dimension. Expects a space node, which should always
188    * have only one from child in the next dimension with given sign.
189    * @param p_usim_id_spc The space id to get the child for.
190    * @return Returns the child space id or NULL if wrong space node used.
191    */
192    FUNCTION get_child_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
193      RETURN usim_space.usim_id_spc%TYPE
194    ;
195
196    /***
197    * Retrieve the parent in the same dimension. Expected a to space node, which should always
198    * have only one parent in the same dimension with the same sign.
199    * @param p_usim_id_spc The space id to get the parent for.
200    * @return Returns the parent space id or NULL if wrong space node used.
201    */
202    FUNCTION get_parent_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
203      RETURN usim_space.usim_id_spc%TYPE
204    ;
205
206    /***
207    * Retrieve the maximum available dimension by childs and parents.
208    * @param p_usim_id_spc The space id to get the max child/parent dimensions for.
209    * @return Returns the highest dimension of childs/parents for the node.
210    */
211    FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
212      RETURN usim_dimension.usim_n_dimension%TYPE
213    ;
214
215    /**
216    * Get child and parent details for a given space node id.
217    * @param p_usim_id_spc The space id to get the details for.
218    * @return Returns 1 if data could be fetched or 0 on errors.
219    */
220    FUNCTION get_chi_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
221                            , p_parent_count OUT NUMBER
222                            , p_child_count  OUT NUMBER
223                            )
224      RETURN NUMBER
225    ;
226
227    /**
228    * Inserts a parent-child relation between nodes, if active nodes exist and are not equal. If relation
229    * exists, 1 is returned.
230    * @param p_usim_id_spc The parent id to insert.
231    * @param p_usim_id_spc_child The child id to insert.
232    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
233    * @return Returns 1 if insert was successful or 0 if constraints are not fulfilled.
234    */
235    FUNCTION insert_chi( p_usim_id_spc        IN usim_space.usim_id_spc%TYPE
236                       , p_usim_id_spc_child  IN usim_space.usim_id_spc%TYPE
237                       , p_do_commit          IN BOOLEAN                     DEFAULT TRUE
238                       )
239      RETURN NUMBER
240    ;
241
242  END usim_chi;
243  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_chi
IS
  /**A package for actions on table usim_spc_child.*/
  /**A low level package for actions on table usim_spc_child and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_spc_child has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_child has data for parent or child.
  * @param p_usim_id_spc The parent id to check data for.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_child has data for given parent and child.
  * @param p_usim_id_spc The parent id to check data for.
  * @param p_usim_id_spc_child The child id to check data for.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data( p_usim_id_spc       IN usim_space.usim_id_spc%TYPE
                   , p_usim_id_spc_child IN usim_space.usim_id_spc%TYPE
                   )
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_child has data for the given parent id.
  * @param p_usim_id_spc The parent id to check data for.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_child has data for the given child id.
  * @param p_usim_id_spc The child id to check data for.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_child(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given parent has the same universe as the child.
  * @param p_usim_id_spc The parent id to check data for.
  * @return Returns 1 if universe is equal for child and parent, otherwise 0.
  */
  FUNCTION has_child_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given child has the same universe as the parent.
  * @param p_usim_id_spc The child id to check data for.
  * @return Returns 1 if universe is equal for child and parent, otherwise 0.
  */
  FUNCTION has_parent_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given space node has a child in the next dimension.
  * @param p_usim_id_spc The space id to check data for.
  * @return Returns 1 if the node has at least one child in the next dimension, otherwise 0.
  */
  FUNCTION has_child_next_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given space node has a child in the given dimension.
  * @param p_usim_id_spc The space id to check data for.
  * @param p_usim_n_dimension The dimension to check childs for.
  * @return Returns 1 if the node has at least one child in the given dimension, otherwise 0.
  */
  FUNCTION has_child_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                           , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                           )
    RETURN NUMBER
  ;

  /**
  * Checks if a given space node has a parent in the given dimension.
  * @param p_usim_id_spc The space id to check data for.
  * @param p_usim_n_dimension The dimension to check parents for.
  * @return Returns 1 if the node has at least one parent in the given dimension, otherwise 0.
  */
  FUNCTION has_parent_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                            , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                            )
    RETURN NUMBER
  ;

  /**
  * Checks if a given space node has a child in the current dimension.
  * @param p_usim_id_spc The space id to check data for.
  * @return Returns 1 if the node has a child in the current dimension, otherwise 0.
  */
  FUNCTION has_child_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given space node has a parent in the current dimension.
  * @param p_usim_id_spc The space id to check data for.
  * @return Returns 1 if the node has a parent in the current dimension, otherwise 0.
  */
  FUNCTION has_parent_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given space nodes have a relation. Type of relation is not considered, means not caring about
  * whether one is child or parent.
  * @param p_usim_id_spc The first space id to check data for.
  * @param p_usim_id_spc_rel The second space id to check data for.
  * @return Returns 1 if the nodes are related, otherwise 0.
  */
  FUNCTION has_relation( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                       , p_usim_id_spc_rel  IN usim_space.usim_id_spc%TYPE
                       )
    RETURN NUMBER
  ;

  /**
  * Retrieves the amount of childs a given space id has in the universe the parent is in.
  * @param p_usim_id_spc The space id to get the amount of childs.
  * @return Returns the amount of childs found for the given space id in the related universe.
  */
  FUNCTION child_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the amount of childs a given space id has in the universe the parent is in.
  * @param p_usim_id_spc The space id to get the amount of childs.
  * @return Returns the amount of childs found for the given space id regardless of related universe.
  */
  FUNCTION child_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the amount of parents a given space id has in the universe the child is in.
  * @param p_usim_id_spc The space id to get the amount of parents.
  * @return Returns the amount of childs found for the given space id.
  */
  FUNCTION parent_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the amount of parents a given space id has in the universe the child is in.
  * @param p_usim_id_spc The space id to get the amount of parents.
  * @return Returns the amount of childs found for the given space id.
  */
  FUNCTION parent_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /***
  * Retrieve the child in the same dimension. Expected a from space node, which should always
  * have only one child in the same dimension with the same sign.
  * @param p_usim_id_spc The space id to get the child for.
  * @return Returns the child space id or NULL if wrong space node used.
  */
  FUNCTION get_child_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /***
  * Retrieve the child in the next dimension. Expects a space node, which should always
  * have only one from child in the next dimension with given sign.
  * @param p_usim_id_spc The space id to get the child for.
  * @return Returns the child space id or NULL if wrong space node used.
  */
  FUNCTION get_child_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /***
  * Retrieve the parent in the same dimension. Expected a to space node, which should always
  * have only one parent in the same dimension with the same sign.
  * @param p_usim_id_spc The space id to get the parent for.
  * @return Returns the parent space id or NULL if wrong space node used.
  */
  FUNCTION get_parent_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /***
  * Retrieve the maximum available dimension by childs and parents.
  * @param p_usim_id_spc The space id to get the max child/parent dimensions for.
  * @return Returns the highest dimension of childs/parents for the node.
  */
  FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Get child and parent details for a given space node id.
  * @param p_usim_id_spc The space id to get the details for.
  * @return Returns 1 if data could be fetched or 0 on errors.
  */
  FUNCTION get_chi_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                          , p_parent_count OUT NUMBER
                          , p_child_count  OUT NUMBER
                          )
    RETURN NUMBER
  ;

  /**
  * Inserts a parent-child relation between nodes, if active nodes exist and are not equal. If relation
  * exists, 1 is returned.
  * @param p_usim_id_spc The parent id to insert.
  * @param p_usim_id_spc_child The child id to insert.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if insert was successful or 0 if constraints are not fulfilled.
  */
  FUNCTION insert_chi( p_usim_id_spc        IN usim_space.usim_id_spc%TYPE
                     , p_usim_id_spc_child  IN usim_space.usim_id_spc%TYPE
                     , p_do_commit          IN BOOLEAN                     DEFAULT TRUE
                     )
    RETURN NUMBER
  ;

END usim_chi;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_chi
IS
  /**A package for actions on table usim_spc_child.*/
  /**A low level package for actions on table usim_spc_child and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_spc_child has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_child has data for parent or child.
  * @param p_usim_id_spc The parent id to check data for.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_child has data for given parent and child.
  * @param p_usim_id_spc The parent id to check data for.
  * @param p_usim_id_spc_child The child id to check data for.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data( p_usim_id_spc       IN usim_space.usim_id_spc%TYPE
                   , p_usim_id_spc_child IN usim_space.usim_id_spc%TYPE
                   )
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_child has data for the given parent id.
  * @param p_usim_id_spc The parent id to check data for.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_child has data for the given child id.
  * @param p_usim_id_spc The child id to check data for.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_child(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given parent has the same universe as the child.
  * @param p_usim_id_spc The parent id to check data for.
  * @return Returns 1 if universe is equal for child and parent, otherwise 0.
  */
  FUNCTION has_child_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given child has the same universe as the parent.
  * @param p_usim_id_spc The child id to check data for.
  * @return Returns 1 if universe is equal for child and parent, otherwise 0.
  */
  FUNCTION has_parent_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given space node has a child in the next dimension.
  * @param p_usim_id_spc The space id to check data for.
  * @return Returns 1 if the node has at least one child in the next dimension, otherwise 0.
  */
  FUNCTION has_child_next_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given space node has a child in the given dimension.
  * @param p_usim_id_spc The space id to check data for.
  * @param p_usim_n_dimension The dimension to check childs for.
  * @return Returns 1 if the node has at least one child in the given dimension, otherwise 0.
  */
  FUNCTION has_child_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                           , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                           )
    RETURN NUMBER
  ;

  /**
  * Checks if a given space node has a parent in the given dimension.
  * @param p_usim_id_spc The space id to check data for.
  * @param p_usim_n_dimension The dimension to check parents for.
  * @return Returns 1 if the node has at least one parent in the given dimension, otherwise 0.
  */
  FUNCTION has_parent_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                            , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                            )
    RETURN NUMBER
  ;

  /**
  * Checks if a given space node has a child in the current dimension.
  * @param p_usim_id_spc The space id to check data for.
  * @return Returns 1 if the node has a child in the current dimension, otherwise 0.
  */
  FUNCTION has_child_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given space node has a parent in the current dimension.
  * @param p_usim_id_spc The space id to check data for.
  * @return Returns 1 if the node has a parent in the current dimension, otherwise 0.
  */
  FUNCTION has_parent_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given space nodes have a relation. Type of relation is not considered, means not caring about
  * whether one is child or parent.
  * @param p_usim_id_spc The first space id to check data for.
  * @param p_usim_id_spc_rel The second space id to check data for.
  * @return Returns 1 if the nodes are related, otherwise 0.
  */
  FUNCTION has_relation( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                       , p_usim_id_spc_rel  IN usim_space.usim_id_spc%TYPE
                       )
    RETURN NUMBER
  ;

  /**
  * Retrieves the amount of childs a given space id has in the universe the parent is in.
  * @param p_usim_id_spc The space id to get the amount of childs.
  * @return Returns the amount of childs found for the given space id in the related universe.
  */
  FUNCTION child_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the amount of childs a given space id has in the universe the parent is in.
  * @param p_usim_id_spc The space id to get the amount of childs.
  * @return Returns the amount of childs found for the given space id regardless of related universe.
  */
  FUNCTION child_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the amount of parents a given space id has in the universe the child is in.
  * @param p_usim_id_spc The space id to get the amount of parents.
  * @return Returns the amount of childs found for the given space id.
  */
  FUNCTION parent_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the amount of parents a given space id has in the universe the child is in.
  * @param p_usim_id_spc The space id to get the amount of parents.
  * @return Returns the amount of childs found for the given space id.
  */
  FUNCTION parent_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /***
  * Retrieve the child in the same dimension. Expected a from space node, which should always
  * have only one child in the same dimension with the same sign.
  * @param p_usim_id_spc The space id to get the child for.
  * @return Returns the child space id or NULL if wrong space node used.
  */
  FUNCTION get_child_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /***
  * Retrieve the child in the next dimension. Expects a space node, which should always
  * have only one from child in the next dimension with given sign.
  * @param p_usim_id_spc The space id to get the child for.
  * @return Returns the child space id or NULL if wrong space node used.
  */
  FUNCTION get_child_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /***
  * Retrieve the parent in the same dimension. Expected a to space node, which should always
  * have only one parent in the same dimension with the same sign.
  * @param p_usim_id_spc The space id to get the parent for.
  * @return Returns the parent space id or NULL if wrong space node used.
  */
  FUNCTION get_parent_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /***
  * Retrieve the maximum available dimension by childs and parents.
  * @param p_usim_id_spc The space id to get the max child/parent dimensions for.
  * @return Returns the highest dimension of childs/parents for the node.
  */
  FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Get child and parent details for a given space node id.
  * @param p_usim_id_spc The space id to get the details for.
  * @return Returns 1 if data could be fetched or 0 on errors.
  */
  FUNCTION get_chi_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                          , p_parent_count OUT NUMBER
                          , p_child_count  OUT NUMBER
                          )
    RETURN NUMBER
  ;

  /**
  * Inserts a parent-child relation between nodes, if active nodes exist and are not equal. If relation
  * exists, 1 is returned.
  * @param p_usim_id_spc The parent id to insert.
  * @param p_usim_id_spc_child The child id to insert.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if insert was successful or 0 if constraints are not fulfilled.
  */
  FUNCTION insert_chi( p_usim_id_spc        IN usim_space.usim_id_spc%TYPE
                     , p_usim_id_spc_child  IN usim_space.usim_id_spc%TYPE
                     , p_do_commit          IN BOOLEAN                     DEFAULT TRUE
                     )
    RETURN NUMBER
  ;

END usim_chi;

Package USIM_CHI kompiliert

SQL> @@../PACKAGES/USIM_CHI.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_chi
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_data
  5      RETURN NUMBER
  6    IS
  7      l_result NUMBER;
  8    BEGIN
  9      SELECT COUNT(*) INTO l_result FROM usim_spc_child;
 10      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 11    END has_data
 12    ;
 13
 14    FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 15      RETURN NUMBER
 16    IS
 17      l_result NUMBER;
 18    BEGIN
 19      SELECT COUNT(*)
 20        INTO l_result
 21        FROM usim_spc_child
 22       WHERE usim_id_spc       = p_usim_id_spc
 23          OR usim_id_spc_child = p_usim_id_spc
 24      ;
 25      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 26    END has_data
 27    ;
 28
 29    FUNCTION has_data( p_usim_id_spc       IN usim_space.usim_id_spc%TYPE
 30                     , p_usim_id_spc_child IN usim_space.usim_id_spc%TYPE
 31                     )
 32      RETURN NUMBER
 33    IS
 34      l_result NUMBER;
 35    BEGIN
 36      SELECT COUNT(*)
 37        INTO l_result
 38        FROM usim_spc_child
 39       WHERE usim_id_spc       = p_usim_id_spc
 40         AND usim_id_spc_child = p_usim_id_spc_child
 41      ;
 42      RETURN l_result;
 43    END has_data
 44    ;
 45
 46    FUNCTION has_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 47      RETURN NUMBER
 48    IS
 49      l_result NUMBER;
 50    BEGIN
 51      SELECT COUNT(*) INTO l_result FROM usim_spc_child WHERE usim_id_spc_child = p_usim_id_spc;
 52      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 53    END has_parent
 54    ;
 55
 56    FUNCTION has_child(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 57      RETURN NUMBER
 58    IS
 59      l_result NUMBER;
 60    BEGIN
 61      SELECT COUNT(*) INTO l_result FROM usim_spc_child WHERE usim_id_spc = p_usim_id_spc;
 62      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 63    END has_child
 64    ;
 65
 66    FUNCTION has_child_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 67      RETURN NUMBER
 68    IS
 69      l_result NUMBER;
 70    BEGIN
 71      SELECT COUNT(*) INTO l_result
 72        FROM usim_spc_child chi
 73        LEFT OUTER JOIN usim_spc_v spc_parent
 74          ON chi.usim_id_spc = spc_parent.usim_id_spc
 75        LEFT OUTER JOIN usim_spc_v spc_child
 76          ON chi.usim_id_spc_child = spc_child.usim_id_spc
 77       WHERE chi.usim_id_spc        = p_usim_id_spc
 78         AND spc_parent.usim_id_mlv = spc_child.usim_id_mlv
 79      ;
 80      RETURN l_result;
 81    END has_child_same_universe
 82    ;
 83
 84    FUNCTION has_parent_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 85      RETURN NUMBER
 86    IS
 87      l_result NUMBER;
 88    BEGIN
 89      SELECT COUNT(*) INTO l_result
 90        FROM usim_spc_child chi
 91        LEFT OUTER JOIN usim_spc_v spc_parent
 92          ON chi.usim_id_spc = spc_parent.usim_id_spc
 93        LEFT OUTER JOIN usim_spc_v spc_child
 94          ON chi.usim_id_spc_child = spc_child.usim_id_spc
 95       WHERE chi.usim_id_spc_child  = p_usim_id_spc
 96         AND spc_parent.usim_id_mlv = spc_child.usim_id_mlv
 97      ;
 98      RETURN l_result;
 99    END has_parent_same_universe
100    ;
101
102    FUNCTION has_child_next_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
103      RETURN NUMBER
104    IS
105      l_result    NUMBER;
106    BEGIN
107      IF usim_chi.has_child(p_usim_id_spc) = 1
108      THEN
109        SELECT COUNT(*)
110          INTO l_result
111          FROM usim_chi_v
112         WHERE usim_id_spc            = p_usim_id_spc
113           AND (parent_dimension + 1) = child_dimension
114        ;
115        RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
116      ELSE
117        RETURN 0;
118      END IF;
119    END has_child_next_dim
120    ;
121
122    FUNCTION has_child_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
123                             , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
124                             )
125      RETURN NUMBER
126    IS
127      l_result NUMBER;
128    BEGIN
129      IF usim_chi.has_child(p_usim_id_spc) = 1
130      THEN
131        SELECT COUNT(*)
132          INTO l_result
133          FROM usim_chi_v
134         WHERE usim_id_spc     = p_usim_id_spc
135           AND child_dimension = p_usim_n_dimension
136        ;
137        RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
138      ELSE
139        RETURN 0;
140      END IF;
141    END has_child_at_dim
142    ;
143
144    FUNCTION has_parent_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
145                              , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
146                              )
147      RETURN NUMBER
148    IS
149      l_result NUMBER;
150    BEGIN
151      IF usim_chi.has_child(p_usim_id_spc) = 1
152      THEN
153        SELECT COUNT(*)
154          INTO l_result
155          FROM usim_chi_v
156         WHERE usim_id_spc_child = p_usim_id_spc
157           AND parent_dimension  = p_usim_n_dimension
158        ;
159        RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
160      ELSE
161        RETURN 0;
162      END IF;
163    END has_parent_at_dim
164    ;
165
166    FUNCTION has_child_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
167      RETURN NUMBER
168    IS
169      l_result    NUMBER;
170    BEGIN
171      IF usim_chi.has_child(p_usim_id_spc) = 1
172      THEN
173        SELECT COUNT(*)
174          INTO l_result
175          FROM usim_chi_v
176         WHERE usim_id_spc      = p_usim_id_spc
177           AND parent_id_rmd    = child_id_rmd
178        ;
179        RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
180      ELSE
181        RETURN 0;
182      END IF;
183    END has_child_same_dim
184    ;
185
186    FUNCTION has_parent_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
187      RETURN NUMBER
188    IS
189      l_result NUMBER;
190      l_id_rmd usim_rel_mlv_dim.usim_id_rmd%TYPE;
191    BEGIN
192      IF usim_chi.has_parent(p_usim_id_spc) = 1
193      THEN
194        SELECT COUNT(*)
195          INTO l_result
196          FROM usim_chi_v
197         WHERE usim_id_spc_child = p_usim_id_spc
198           AND parent_id_rmd     = child_id_rmd
199        ;
200        RETURN l_result;
201      ELSE
202        RETURN 0;
203      END IF;
204    END has_parent_same_dim
205    ;
206
207    FUNCTION has_relation( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
208                         , p_usim_id_spc_rel  IN usim_space.usim_id_spc%TYPE
209                         )
210      RETURN NUMBER
211    IS
212      l_result NUMBER;
213    BEGIN
214      SELECT COUNT(*)
215        INTO l_result
216        FROM usim_spc_child
217       WHERE (    usim_id_spc       = p_usim_id_spc
218              AND usim_id_spc_child = p_usim_id_spc_rel
219             )
220          OR (    usim_id_spc       = p_usim_id_spc_rel
221              AND usim_id_spc_child = p_usim_id_spc
222             )
223      ;
224      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
225    END has_relation
226    ;
227
228    FUNCTION child_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
229      RETURN NUMBER
230    IS
231      l_result NUMBER;
232    BEGIN
233        WITH src AS
234             (SELECT spc.usim_id_spc
235                   , rmd.usim_id_mlv
236                FROM usim_space spc
237               INNER JOIN usim_rel_mlv_dim rmd
238                  ON spc.usim_id_rmd = rmd.usim_id_rmd
239               WHERE spc.usim_id_spc = p_usim_id_spc
240             )
241           , childs AS
242             (SELECT chi.usim_id_spc
243                   , chi.usim_id_spc_child
244                   , rmd.usim_id_mlv AS usim_id_mlv_child
245                FROM usim_spc_child chi
246               INNER JOIN usim_space spc
247                  ON chi.usim_id_spc_child = spc.usim_id_spc
248               INNER JOIN usim_rel_mlv_dim rmd
249                  ON spc.usim_id_rmd = rmd.usim_id_rmd
250             )
251      SELECT COUNT(*)
252        INTO l_result
253        FROM childs
254       INNER JOIN src
255          ON childs.usim_id_spc       = src.usim_id_spc
256         AND childs.usim_id_mlv_child = src.usim_id_mlv
257      ;
258      RETURN l_result;
259    END child_count
260    ;
261
262    FUNCTION child_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
263      RETURN NUMBER
264    IS
265      l_result NUMBER;
266    BEGIN
267      SELECT COUNT(*)
268        INTO l_result
269        FROM usim_spc_child
270       WHERE usim_id_spc   = p_usim_id_spc
271      ;
272      RETURN l_result;
273    END child_count_all
274    ;
275
276    FUNCTION parent_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
277      RETURN NUMBER
278    IS
279      l_result NUMBER;
280    BEGIN
281        WITH src AS
282             (SELECT spc.usim_id_spc
283                   , rmd.usim_id_mlv
284                FROM usim_space spc
285               INNER JOIN usim_rel_mlv_dim rmd
286                  ON spc.usim_id_rmd = rmd.usim_id_rmd
287               WHERE spc.usim_id_spc = p_usim_id_spc
288             )
289           , parents AS
290             (SELECT chi.usim_id_spc
291                   , chi.usim_id_spc_child
292                   , rmd.usim_id_mlv AS usim_id_mlv_parent
293                FROM usim_spc_child chi
294               INNER JOIN usim_space spc
295                  ON chi.usim_id_spc = spc.usim_id_spc
296               INNER JOIN usim_rel_mlv_dim rmd
297                  ON spc.usim_id_rmd = rmd.usim_id_rmd
298             )
299      SELECT COUNT(*)
300        INTO l_result
301        FROM parents
302       INNER JOIN src
303          ON parents.usim_id_spc_child  = src.usim_id_spc
304         AND parents.usim_id_mlv_parent = src.usim_id_mlv
305      ;
306      RETURN l_result;
307    END parent_count
308    ;
309
310    FUNCTION parent_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
311      RETURN NUMBER
312    IS
313      l_result NUMBER;
314    BEGIN
315      SELECT COUNT(*)
316        INTO l_result
317        FROM usim_spc_child
318       WHERE usim_id_spc_child = p_usim_id_spc
319      ;
320      RETURN l_result;
321    END parent_count_all
322    ;
323
324    FUNCTION get_child_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
325      RETURN usim_space.usim_id_spc%TYPE
326    IS
327      l_result usim_space.usim_id_spc%TYPE;
328    BEGIN
329      IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
330      THEN
331        SELECT usim_id_spc_child
332          INTO l_result
333          FROM usim_chi_v
334         WHERE usim_id_spc      = p_usim_id_spc
335           AND parent_id_rmd    = child_id_rmd
336        ;
337        RETURN l_result;
338      ELSE
339        usim_erl.log_error('usim_chi.get_child_same_dimension', 'Used with space id [' || p_usim_id_spc || '] that has no child in the same dimension.');
340        RETURN NULL;
341      END IF;
342    END get_child_same_dimension
343    ;
344
345    FUNCTION get_child_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
346      RETURN usim_space.usim_id_spc%TYPE
347    IS
348      l_result usim_space.usim_id_spc%TYPE;
349    BEGIN
350      IF usim_chi.has_child_next_dim(p_usim_id_spc) = 1
351      THEN
352        SELECT usim_id_spc_child
353          INTO l_result
354          FROM usim_chi_v
355         WHERE usim_id_spc            = p_usim_id_spc
356           AND (parent_dimension + 1) = child_dimension
357        ;
358        RETURN l_result;
359      ELSE
360        usim_erl.log_error('usim_chi.get_child_same_dimension', 'Used with space id [' || p_usim_id_spc || '] that has no child in the next dimension.');
361        RETURN NULL;
362      END IF;
363    END get_child_next_dimension
364    ;
365
366    FUNCTION get_parent_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
367      RETURN usim_space.usim_id_spc%TYPE
368    IS
369      l_return usim_space.usim_id_spc%TYPE;
370    BEGIN
371      IF usim_chi.has_parent_same_dim(p_usim_id_spc) = 1
372      THEN
373        SELECT usim_id_spc
374          INTO l_return
375          FROM usim_chi_v
376         WHERE usim_id_spc_child = p_usim_id_spc
377           AND parent_id_rmd     = child_id_rmd
378        ;
379        RETURN l_return;
380      ELSE
381        usim_erl.log_error('usim_chi.get_parent_same_dimension', 'Used with space id [' || p_usim_id_spc || '] that has no parent in the same dimension.');
382        RETURN NULL;
383      END IF;
384    END get_parent_same_dimension
385    ;
386
387    FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
388      RETURN usim_dimension.usim_n_dimension%TYPE
389    IS
390      l_max_dim usim_dimension.usim_n_dimension%TYPE;
391      l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
392    BEGIN
393        SELECT dim_n1_sign INTO l_n1_sign FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc;
394        WITH maxdim AS
395             (SELECT MAX(child_dimension) AS max_dim
396                FROM usim_chi_v
397               WHERE usim_id_spc       = p_usim_id_spc
398                 AND child_dim_n1_sign = l_n1_sign
399               UNION ALL
400                     -- consider also possible parenting from higher dimensions
401              SELECT MAX(parent_dimension) AS max_dim
402                FROM usim_chi_v chip
403               WHERE usim_id_spc_child  = p_usim_id_spc
404                 AND parent_dim_n1_sign = l_n1_sign
405             )
406      SELECT NVL(MAX(max_dim), 0)
407        INTO l_max_dim
408        FROM maxdim
409      ;
410      RETURN l_max_dim;
411    END get_cur_max_dimension
412    ;
413
414    FUNCTION get_chi_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
415                            , p_parent_count OUT NUMBER
416                            , p_child_count  OUT NUMBER
417                            )
418      RETURN NUMBER
419    IS
420    BEGIN
421      IF usim_chi.has_data(p_usim_id_spc) = 1
422      THEN
423        SELECT COUNT(*) INTO p_parent_count FROM usim_spc_child WHERE usim_id_spc_child = p_usim_id_spc;
424        SELECT COUNT(*) INTO p_child_count FROM usim_spc_child WHERE usim_id_spc = p_usim_id_spc;
425        RETURN 1;
426      ELSE
427        p_parent_count := 0;
428        p_child_count  := 0;
429        RETURN 0;
430      END IF;
431    END get_chi_details
432    ;
433
434    FUNCTION insert_chi( p_usim_id_spc        IN usim_space.usim_id_spc%TYPE
435                       , p_usim_id_spc_child  IN usim_space.usim_id_spc%TYPE
436                       , p_do_commit          IN BOOLEAN                     DEFAULT TRUE
437                       )
438      RETURN NUMBER
439    IS
440    BEGIN
441      IF usim_chi.has_data(p_usim_id_spc, p_usim_id_spc_child) = 1
442      THEN
443        RETURN 1;
444      ELSIF p_usim_id_spc != p_usim_id_spc_child
445      THEN
446        INSERT INTO usim_spc_child (usim_id_spc, usim_id_spc_child) VALUES (p_usim_id_spc, p_usim_id_spc_child);
447          IF p_do_commit
448          THEN
449            COMMIT;
450          END IF;
451          RETURN 1;
452      ELSE
453        usim_erl.log_error('usim_chi.insert_chi', 'Used with equal ids parent [' || p_usim_id_spc || '] child [' || p_usim_id_spc_child || '].');
454        RETURN 0;
455      END IF;
456    END insert_chi
457    ;
458
459  END usim_chi;
460  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_chi
IS
  -- see header for documentation
  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_child;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spc_child
     WHERE usim_id_spc       = p_usim_id_spc
        OR usim_id_spc_child = p_usim_id_spc
    ;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data( p_usim_id_spc       IN usim_space.usim_id_spc%TYPE
                   , p_usim_id_spc_child IN usim_space.usim_id_spc%TYPE
                   )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spc_child
     WHERE usim_id_spc       = p_usim_id_spc
       AND usim_id_spc_child = p_usim_id_spc_child
    ;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_child WHERE usim_id_spc_child = p_usim_id_spc;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_parent
  ;

  FUNCTION has_child(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_child WHERE usim_id_spc = p_usim_id_spc;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_child
  ;

  FUNCTION has_child_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result
      FROM usim_spc_child chi
      LEFT OUTER JOIN usim_spc_v spc_parent
        ON chi.usim_id_spc = spc_parent.usim_id_spc
      LEFT OUTER JOIN usim_spc_v spc_child
        ON chi.usim_id_spc_child = spc_child.usim_id_spc
     WHERE chi.usim_id_spc        = p_usim_id_spc
       AND spc_parent.usim_id_mlv = spc_child.usim_id_mlv
    ;
    RETURN l_result;
  END has_child_same_universe
  ;

  FUNCTION has_parent_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result
      FROM usim_spc_child chi
      LEFT OUTER JOIN usim_spc_v spc_parent
        ON chi.usim_id_spc = spc_parent.usim_id_spc
      LEFT OUTER JOIN usim_spc_v spc_child
        ON chi.usim_id_spc_child = spc_child.usim_id_spc
     WHERE chi.usim_id_spc_child  = p_usim_id_spc
       AND spc_parent.usim_id_mlv = spc_child.usim_id_mlv
    ;
    RETURN l_result;
  END has_parent_same_universe
  ;

  FUNCTION has_child_next_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result    NUMBER;
  BEGIN
    IF usim_chi.has_child(p_usim_id_spc) = 1
    THEN
      SELECT COUNT(*)
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc            = p_usim_id_spc
         AND (parent_dimension + 1) = child_dimension
      ;
      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
    ELSE
      RETURN 0;
    END IF;
  END has_child_next_dim
  ;

  FUNCTION has_child_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                           , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                           )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_chi.has_child(p_usim_id_spc) = 1
    THEN
      SELECT COUNT(*)
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc     = p_usim_id_spc
         AND child_dimension = p_usim_n_dimension
      ;
      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
    ELSE
      RETURN 0;
    END IF;
  END has_child_at_dim
  ;

  FUNCTION has_parent_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                            , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                            )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_chi.has_child(p_usim_id_spc) = 1
    THEN
      SELECT COUNT(*)
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc_child = p_usim_id_spc
         AND parent_dimension  = p_usim_n_dimension
      ;
      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
    ELSE
      RETURN 0;
    END IF;
  END has_parent_at_dim
  ;

  FUNCTION has_child_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result    NUMBER;
  BEGIN
    IF usim_chi.has_child(p_usim_id_spc) = 1
    THEN
      SELECT COUNT(*)
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc      = p_usim_id_spc
         AND parent_id_rmd    = child_id_rmd
      ;
      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
    ELSE
      RETURN 0;
    END IF;
  END has_child_same_dim
  ;

  FUNCTION has_parent_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
    l_id_rmd usim_rel_mlv_dim.usim_id_rmd%TYPE;
  BEGIN
    IF usim_chi.has_parent(p_usim_id_spc) = 1
    THEN
      SELECT COUNT(*)
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc_child = p_usim_id_spc
         AND parent_id_rmd     = child_id_rmd
      ;
      RETURN l_result;
    ELSE
      RETURN 0;
    END IF;
  END has_parent_same_dim
  ;

  FUNCTION has_relation( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                       , p_usim_id_spc_rel  IN usim_space.usim_id_spc%TYPE
                       )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spc_child
     WHERE (    usim_id_spc       = p_usim_id_spc
            AND usim_id_spc_child = p_usim_id_spc_rel
           )
        OR (    usim_id_spc       = p_usim_id_spc_rel
            AND usim_id_spc_child = p_usim_id_spc
           )
    ;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_relation
  ;

  FUNCTION child_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
      WITH src AS
           (SELECT spc.usim_id_spc
                 , rmd.usim_id_mlv
              FROM usim_space spc
             INNER JOIN usim_rel_mlv_dim rmd
                ON spc.usim_id_rmd = rmd.usim_id_rmd
             WHERE spc.usim_id_spc = p_usim_id_spc
           )
         , childs AS
           (SELECT chi.usim_id_spc
                 , chi.usim_id_spc_child
                 , rmd.usim_id_mlv AS usim_id_mlv_child
              FROM usim_spc_child chi
             INNER JOIN usim_space spc
                ON chi.usim_id_spc_child = spc.usim_id_spc
             INNER JOIN usim_rel_mlv_dim rmd
                ON spc.usim_id_rmd = rmd.usim_id_rmd
           )
    SELECT COUNT(*)
      INTO l_result
      FROM childs
     INNER JOIN src
        ON childs.usim_id_spc       = src.usim_id_spc
       AND childs.usim_id_mlv_child = src.usim_id_mlv
    ;
    RETURN l_result;
  END child_count
  ;

  FUNCTION child_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spc_child
     WHERE usim_id_spc   = p_usim_id_spc
    ;
    RETURN l_result;
  END child_count_all
  ;

  FUNCTION parent_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
      WITH src AS
           (SELECT spc.usim_id_spc
                 , rmd.usim_id_mlv
              FROM usim_space spc
             INNER JOIN usim_rel_mlv_dim rmd
                ON spc.usim_id_rmd = rmd.usim_id_rmd
             WHERE spc.usim_id_spc = p_usim_id_spc
           )
         , parents AS
           (SELECT chi.usim_id_spc
                 , chi.usim_id_spc_child
                 , rmd.usim_id_mlv AS usim_id_mlv_parent
              FROM usim_spc_child chi
             INNER JOIN usim_space spc
                ON chi.usim_id_spc = spc.usim_id_spc
             INNER JOIN usim_rel_mlv_dim rmd
                ON spc.usim_id_rmd = rmd.usim_id_rmd
           )
    SELECT COUNT(*)
      INTO l_result
      FROM parents
     INNER JOIN src
        ON parents.usim_id_spc_child  = src.usim_id_spc
       AND parents.usim_id_mlv_parent = src.usim_id_mlv
    ;
    RETURN l_result;
  END parent_count
  ;

  FUNCTION parent_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spc_child
     WHERE usim_id_spc_child = p_usim_id_spc
    ;
    RETURN l_result;
  END parent_count_all
  ;

  FUNCTION get_child_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_spc_child
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc      = p_usim_id_spc
         AND parent_id_rmd    = child_id_rmd
      ;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_chi.get_child_same_dimension', 'Used with space id [' || p_usim_id_spc || '] that has no child in the same dimension.');
      RETURN NULL;
    END IF;
  END get_child_same_dimension
  ;

  FUNCTION get_child_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    IF usim_chi.has_child_next_dim(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_spc_child
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc            = p_usim_id_spc
         AND (parent_dimension + 1) = child_dimension
      ;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_chi.get_child_same_dimension', 'Used with space id [' || p_usim_id_spc || '] that has no child in the next dimension.');
      RETURN NULL;
    END IF;
  END get_child_next_dimension
  ;

  FUNCTION get_parent_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_return usim_space.usim_id_spc%TYPE;
  BEGIN
    IF usim_chi.has_parent_same_dim(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_spc
        INTO l_return
        FROM usim_chi_v
       WHERE usim_id_spc_child = p_usim_id_spc
         AND parent_id_rmd     = child_id_rmd
      ;
      RETURN l_return;
    ELSE
      usim_erl.log_error('usim_chi.get_parent_same_dimension', 'Used with space id [' || p_usim_id_spc || '] that has no parent in the same dimension.');
      RETURN NULL;
    END IF;
  END get_parent_same_dimension
  ;

  FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_max_dim usim_dimension.usim_n_dimension%TYPE;
    l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
  BEGIN
      SELECT dim_n1_sign INTO l_n1_sign FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc;
      WITH maxdim AS
           (SELECT MAX(child_dimension) AS max_dim
              FROM usim_chi_v
             WHERE usim_id_spc       = p_usim_id_spc
               AND child_dim_n1_sign = l_n1_sign
             UNION ALL
                   -- consider also possible parenting from higher dimensions
            SELECT MAX(parent_dimension) AS max_dim
              FROM usim_chi_v chip
             WHERE usim_id_spc_child  = p_usim_id_spc
               AND parent_dim_n1_sign = l_n1_sign
           )
    SELECT NVL(MAX(max_dim), 0)
      INTO l_max_dim
      FROM maxdim
    ;
    RETURN l_max_dim;
  END get_cur_max_dimension
  ;

  FUNCTION get_chi_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                          , p_parent_count OUT NUMBER
                          , p_child_count  OUT NUMBER
                          )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_chi.has_data(p_usim_id_spc) = 1
    THEN
      SELECT COUNT(*) INTO p_parent_count FROM usim_spc_child WHERE usim_id_spc_child = p_usim_id_spc;
      SELECT COUNT(*) INTO p_child_count FROM usim_spc_child WHERE usim_id_spc = p_usim_id_spc;
      RETURN 1;
    ELSE
      p_parent_count := 0;
      p_child_count  := 0;
      RETURN 0;
    END IF;
  END get_chi_details
  ;

  FUNCTION insert_chi( p_usim_id_spc        IN usim_space.usim_id_spc%TYPE
                     , p_usim_id_spc_child  IN usim_space.usim_id_spc%TYPE
                     , p_do_commit          IN BOOLEAN                     DEFAULT TRUE
                     )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_chi.has_data(p_usim_id_spc, p_usim_id_spc_child) = 1
    THEN
      RETURN 1;
    ELSIF p_usim_id_spc != p_usim_id_spc_child
    THEN
      INSERT INTO usim_spc_child (usim_id_spc, usim_id_spc_child) VALUES (p_usim_id_spc, p_usim_id_spc_child);
        IF p_do_commit
        THEN
          COMMIT;
        END IF;
        RETURN 1;
    ELSE
      usim_erl.log_error('usim_chi.insert_chi', 'Used with equal ids parent [' || p_usim_id_spc || '] child [' || p_usim_id_spc_child || '].');
      RETURN 0;
    END IF;
  END insert_chi
  ;

END usim_chi;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_chi
IS
  -- see header for documentation
  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_child;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spc_child
     WHERE usim_id_spc       = p_usim_id_spc
        OR usim_id_spc_child = p_usim_id_spc
    ;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data( p_usim_id_spc       IN usim_space.usim_id_spc%TYPE
                   , p_usim_id_spc_child IN usim_space.usim_id_spc%TYPE
                   )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spc_child
     WHERE usim_id_spc       = p_usim_id_spc
       AND usim_id_spc_child = p_usim_id_spc_child
    ;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_child WHERE usim_id_spc_child = p_usim_id_spc;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_parent
  ;

  FUNCTION has_child(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_child WHERE usim_id_spc = p_usim_id_spc;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_child
  ;

  FUNCTION has_child_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result
      FROM usim_spc_child chi
      LEFT OUTER JOIN usim_spc_v spc_parent
        ON chi.usim_id_spc = spc_parent.usim_id_spc
      LEFT OUTER JOIN usim_spc_v spc_child
        ON chi.usim_id_spc_child = spc_child.usim_id_spc
     WHERE chi.usim_id_spc        = p_usim_id_spc
       AND spc_parent.usim_id_mlv = spc_child.usim_id_mlv
    ;
    RETURN l_result;
  END has_child_same_universe
  ;

  FUNCTION has_parent_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result
      FROM usim_spc_child chi
      LEFT OUTER JOIN usim_spc_v spc_parent
        ON chi.usim_id_spc = spc_parent.usim_id_spc
      LEFT OUTER JOIN usim_spc_v spc_child
        ON chi.usim_id_spc_child = spc_child.usim_id_spc
     WHERE chi.usim_id_spc_child  = p_usim_id_spc
       AND spc_parent.usim_id_mlv = spc_child.usim_id_mlv
    ;
    RETURN l_result;
  END has_parent_same_universe
  ;

  FUNCTION has_child_next_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result    NUMBER;
  BEGIN
    IF usim_chi.has_child(p_usim_id_spc) = 1
    THEN
      SELECT COUNT(*)
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc            = p_usim_id_spc
         AND (parent_dimension + 1) = child_dimension
      ;
      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
    ELSE
      RETURN 0;
    END IF;
  END has_child_next_dim
  ;

  FUNCTION has_child_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                           , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                           )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_chi.has_child(p_usim_id_spc) = 1
    THEN
      SELECT COUNT(*)
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc     = p_usim_id_spc
         AND child_dimension = p_usim_n_dimension
      ;
      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
    ELSE
      RETURN 0;
    END IF;
  END has_child_at_dim
  ;

  FUNCTION has_parent_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                            , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                            )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_chi.has_child(p_usim_id_spc) = 1
    THEN
      SELECT COUNT(*)
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc_child = p_usim_id_spc
         AND parent_dimension  = p_usim_n_dimension
      ;
      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
    ELSE
      RETURN 0;
    END IF;
  END has_parent_at_dim
  ;

  FUNCTION has_child_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result    NUMBER;
  BEGIN
    IF usim_chi.has_child(p_usim_id_spc) = 1
    THEN
      SELECT COUNT(*)
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc      = p_usim_id_spc
         AND parent_id_rmd    = child_id_rmd
      ;
      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
    ELSE
      RETURN 0;
    END IF;
  END has_child_same_dim
  ;

  FUNCTION has_parent_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
    l_id_rmd usim_rel_mlv_dim.usim_id_rmd%TYPE;
  BEGIN
    IF usim_chi.has_parent(p_usim_id_spc) = 1
    THEN
      SELECT COUNT(*)
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc_child = p_usim_id_spc
         AND parent_id_rmd     = child_id_rmd
      ;
      RETURN l_result;
    ELSE
      RETURN 0;
    END IF;
  END has_parent_same_dim
  ;

  FUNCTION has_relation( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                       , p_usim_id_spc_rel  IN usim_space.usim_id_spc%TYPE
                       )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spc_child
     WHERE (    usim_id_spc       = p_usim_id_spc
            AND usim_id_spc_child = p_usim_id_spc_rel
           )
        OR (    usim_id_spc       = p_usim_id_spc_rel
            AND usim_id_spc_child = p_usim_id_spc
           )
    ;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_relation
  ;

  FUNCTION child_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
      WITH src AS
           (SELECT spc.usim_id_spc
                 , rmd.usim_id_mlv
              FROM usim_space spc
             INNER JOIN usim_rel_mlv_dim rmd
                ON spc.usim_id_rmd = rmd.usim_id_rmd
             WHERE spc.usim_id_spc = p_usim_id_spc
           )
         , childs AS
           (SELECT chi.usim_id_spc
                 , chi.usim_id_spc_child
                 , rmd.usim_id_mlv AS usim_id_mlv_child
              FROM usim_spc_child chi
             INNER JOIN usim_space spc
                ON chi.usim_id_spc_child = spc.usim_id_spc
             INNER JOIN usim_rel_mlv_dim rmd
                ON spc.usim_id_rmd = rmd.usim_id_rmd
           )
    SELECT COUNT(*)
      INTO l_result
      FROM childs
     INNER JOIN src
        ON childs.usim_id_spc       = src.usim_id_spc
       AND childs.usim_id_mlv_child = src.usim_id_mlv
    ;
    RETURN l_result;
  END child_count
  ;

  FUNCTION child_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spc_child
     WHERE usim_id_spc   = p_usim_id_spc
    ;
    RETURN l_result;
  END child_count_all
  ;

  FUNCTION parent_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
      WITH src AS
           (SELECT spc.usim_id_spc
                 , rmd.usim_id_mlv
              FROM usim_space spc
             INNER JOIN usim_rel_mlv_dim rmd
                ON spc.usim_id_rmd = rmd.usim_id_rmd
             WHERE spc.usim_id_spc = p_usim_id_spc
           )
         , parents AS
           (SELECT chi.usim_id_spc
                 , chi.usim_id_spc_child
                 , rmd.usim_id_mlv AS usim_id_mlv_parent
              FROM usim_spc_child chi
             INNER JOIN usim_space spc
                ON chi.usim_id_spc = spc.usim_id_spc
             INNER JOIN usim_rel_mlv_dim rmd
                ON spc.usim_id_rmd = rmd.usim_id_rmd
           )
    SELECT COUNT(*)
      INTO l_result
      FROM parents
     INNER JOIN src
        ON parents.usim_id_spc_child  = src.usim_id_spc
       AND parents.usim_id_mlv_parent = src.usim_id_mlv
    ;
    RETURN l_result;
  END parent_count
  ;

  FUNCTION parent_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spc_child
     WHERE usim_id_spc_child = p_usim_id_spc
    ;
    RETURN l_result;
  END parent_count_all
  ;

  FUNCTION get_child_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_spc_child
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc      = p_usim_id_spc
         AND parent_id_rmd    = child_id_rmd
      ;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_chi.get_child_same_dimension', 'Used with space id [' || p_usim_id_spc || '] that has no child in the same dimension.');
      RETURN NULL;
    END IF;
  END get_child_same_dimension
  ;

  FUNCTION get_child_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    IF usim_chi.has_child_next_dim(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_spc_child
        INTO l_result
        FROM usim_chi_v
       WHERE usim_id_spc            = p_usim_id_spc
         AND (parent_dimension + 1) = child_dimension
      ;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_chi.get_child_same_dimension', 'Used with space id [' || p_usim_id_spc || '] that has no child in the next dimension.');
      RETURN NULL;
    END IF;
  END get_child_next_dimension
  ;

  FUNCTION get_parent_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_return usim_space.usim_id_spc%TYPE;
  BEGIN
    IF usim_chi.has_parent_same_dim(p_usim_id_spc) = 1
    THEN
      SELECT usim_id_spc
        INTO l_return
        FROM usim_chi_v
       WHERE usim_id_spc_child = p_usim_id_spc
         AND parent_id_rmd     = child_id_rmd
      ;
      RETURN l_return;
    ELSE
      usim_erl.log_error('usim_chi.get_parent_same_dimension', 'Used with space id [' || p_usim_id_spc || '] that has no parent in the same dimension.');
      RETURN NULL;
    END IF;
  END get_parent_same_dimension
  ;

  FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_max_dim usim_dimension.usim_n_dimension%TYPE;
    l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
  BEGIN
      SELECT dim_n1_sign INTO l_n1_sign FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc;
      WITH maxdim AS
           (SELECT MAX(child_dimension) AS max_dim
              FROM usim_chi_v
             WHERE usim_id_spc       = p_usim_id_spc
               AND child_dim_n1_sign = l_n1_sign
             UNION ALL
                   -- consider also possible parenting from higher dimensions
            SELECT MAX(parent_dimension) AS max_dim
              FROM usim_chi_v chip
             WHERE usim_id_spc_child  = p_usim_id_spc
               AND parent_dim_n1_sign = l_n1_sign
           )
    SELECT NVL(MAX(max_dim), 0)
      INTO l_max_dim
      FROM maxdim
    ;
    RETURN l_max_dim;
  END get_cur_max_dimension
  ;

  FUNCTION get_chi_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                          , p_parent_count OUT NUMBER
                          , p_child_count  OUT NUMBER
                          )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_chi.has_data(p_usim_id_spc) = 1
    THEN
      SELECT COUNT(*) INTO p_parent_count FROM usim_spc_child WHERE usim_id_spc_child = p_usim_id_spc;
      SELECT COUNT(*) INTO p_child_count FROM usim_spc_child WHERE usim_id_spc = p_usim_id_spc;
      RETURN 1;
    ELSE
      p_parent_count := 0;
      p_child_count  := 0;
      RETURN 0;
    END IF;
  END get_chi_details
  ;

  FUNCTION insert_chi( p_usim_id_spc        IN usim_space.usim_id_spc%TYPE
                     , p_usim_id_spc_child  IN usim_space.usim_id_spc%TYPE
                     , p_do_commit          IN BOOLEAN                     DEFAULT TRUE
                     )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_chi.has_data(p_usim_id_spc, p_usim_id_spc_child) = 1
    THEN
      RETURN 1;
    ELSIF p_usim_id_spc != p_usim_id_spc_child
    THEN
      INSERT INTO usim_spc_child (usim_id_spc, usim_id_spc_child) VALUES (p_usim_id_spc, p_usim_id_spc_child);
        IF p_do_commit
        THEN
          COMMIT;
        END IF;
        RETURN 1;
    ELSE
      usim_erl.log_error('usim_chi.insert_chi', 'Used with equal ids parent [' || p_usim_id_spc || '] child [' || p_usim_id_spc_child || '].');
      RETURN 0;
    END IF;
  END insert_chi
  ;

END usim_chi;

Package Body USIM_CHI kompiliert

SQL> -- USIM_SPC_POS (spo)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_SPC_POS_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPC_POS still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_POS'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_SPC_POS_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPC_POS still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_POS'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_SPC_POS_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPC_POS still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_POS'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------
../TABLES/USIM_SPC_POS_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_SPC_POS (spo)
SQL> CREATE TABLE &USIM_SCHEMA..usim_spc_pos
  2    ( usim_id_spc  CHAR(55) NOT NULL ENABLE
  3    , usim_id_rmd  CHAR(55) NOT NULL ENABLE
  4    , usim_id_pos  CHAR(55) NOT NULL ENABLE
  5    )
  6  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_spc_pos
  ( usim_id_spc  CHAR(55) NOT NULL ENABLE
  , usim_id_rmd  CHAR(55) NOT NULL ENABLE
  , usim_id_pos  CHAR(55) NOT NULL ENABLE
  )

neu:CREATE TABLE USIM_TEST.usim_spc_pos
  ( usim_id_spc  CHAR(55) NOT NULL ENABLE
  , usim_id_rmd  CHAR(55) NOT NULL ENABLE
  , usim_id_pos  CHAR(55) NOT NULL ENABLE
  )

Table USIM_TEST.USIM_SPC_POS erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_spc_pos IS 'Describes the axis coordinate index for a given space node over all dimensions. Will use the alias spo.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_spc_pos IS 'Describes the axis coordinate index for a given space node over all dimensions. Will use the alias spo.'
neu:COMMENT ON TABLE USIM_TEST.usim_spc_pos IS 'Describes the axis coordinate index for a given space node over all dimensions. Will use the alias spo.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_pos.usim_id_spc IS 'The space node id from usim_space.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_pos.usim_id_spc IS 'The space node id from usim_space.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_pos.usim_id_spc IS 'The space node id from usim_space.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_pos.usim_id_rmd IS 'The dimension axis id relative to the universe defining the source position on this axis.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_pos.usim_id_rmd IS 'The dimension axis id relative to the universe defining the source position on this axis.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_pos.usim_id_rmd IS 'The dimension axis id relative to the universe defining the source position on this axis.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_pos.usim_id_pos IS 'The source position on the related dimension axis.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_pos.usim_id_pos IS 'The source position on the related dimension axis.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_pos.usim_id_pos IS 'The source position on the related dimension axis.'

Comment erstellt.

SQL>
SQL> -- uk
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_pos
  2    ADD CONSTRAINT usim_spo_uk
  3    UNIQUE (usim_id_spc, usim_id_rmd, usim_id_pos)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_spc_pos
  ADD CONSTRAINT usim_spo_uk
  UNIQUE (usim_id_spc, usim_id_rmd, usim_id_pos)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_spc_pos
  ADD CONSTRAINT usim_spo_uk
  UNIQUE (usim_id_spc, usim_id_rmd, usim_id_pos)
  ENABLE

Table USIM_TEST.USIM_SPC_POS geändert.

SQL>
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spo_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_spc_pos
  3      FOR EACH ROW
  4      BEGIN
  5        RAISE_APPLICATION_ERROR( num => -20001
  6                               , msg => 'Update requirement not fulfilled. No update allowed.'
  7                               )
  8        ;
  9      END;
 10  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spo_upd_trg
  BEFORE UPDATE ON &USIM_SCHEMA..usim_spc_pos
    FOR EACH ROW
    BEGIN
      RAISE_APPLICATION_ERROR( num => -20001
                             , msg => 'Update requirement not fulfilled. No update allowed.'
                             )
      ;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_spo_upd_trg
  BEFORE UPDATE ON USIM_TEST.usim_spc_pos
    FOR EACH ROW
    BEGIN
      RAISE_APPLICATION_ERROR( num => -20001
                             , msg => 'Update requirement not fulfilled. No update allowed.'
                             )
      ;
    END;

Trigger USIM_SPO_UPD_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_spo_upd_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_spo_upd_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_spo_upd_trg ENABLE

Trigger USIM_TEST.USIM_SPO_UPD_TRG geändert.

SQL> -- foreign keys
SQL> @@../FK/USIM_SPO_SPC_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk relation to nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_pos
  2    ADD CONSTRAINT usim_spo_spc_fk
  3    FOREIGN KEY (usim_id_spc) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_spc_pos
  ADD CONSTRAINT usim_spo_spc_fk
  FOREIGN KEY (usim_id_spc) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_spc_pos
  ADD CONSTRAINT usim_spo_spc_fk
  FOREIGN KEY (usim_id_spc) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_SPC_POS geändert.

SQL> @@../FK/USIM_SPO_RMD_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk base-mirror relation between nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_pos
  2    ADD CONSTRAINT usim_spo_rmd_fk
  3    FOREIGN KEY (usim_id_rmd) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_spc_pos
  ADD CONSTRAINT usim_spo_rmd_fk
  FOREIGN KEY (usim_id_rmd) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_spc_pos
  ADD CONSTRAINT usim_spo_rmd_fk
  FOREIGN KEY (usim_id_rmd) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_SPC_POS geändert.

SQL> @@../FK/USIM_SPO_POS_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk base-mirror relation between nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_pos
  2    ADD CONSTRAINT usim_spo_pos_fk
  3    FOREIGN KEY (usim_id_pos) REFERENCES usim_position (usim_id_pos) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_spc_pos
  ADD CONSTRAINT usim_spo_pos_fk
  FOREIGN KEY (usim_id_pos) REFERENCES usim_position (usim_id_pos) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_spc_pos
  ADD CONSTRAINT usim_spo_pos_fk
  FOREIGN KEY (usim_id_pos) REFERENCES usim_position (usim_id_pos) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_SPC_POS geändert.

SQL> -- views
SQL> @@../VIEW/USIM_SPO_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_SPO_V (spov)
SQL> CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_spo_v AS
  2    SELECT spo.usim_id_spc
  3         , spo.usim_id_rmd
  4         , spo.usim_id_pos
  5         , rmdv.usim_sign AS dim_sign
  6         , rmdv.usim_n1_sign AS dim_n1_sign
  7         , rmdv.usim_n_dimension
  8         , pos.usim_coordinate
  9         , rmdv.usim_id_mlv
 10      FROM usim_spc_pos spo
 11     INNER JOIN usim_rmd_v rmdv
 12        ON spo.usim_id_rmd = rmdv.usim_id_rmd
 13     INNER JOIN usim_position pos
 14        ON spo.usim_id_pos = pos.usim_id_pos
 15  ;
alt:CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_spo_v AS
  SELECT spo.usim_id_spc
       , spo.usim_id_rmd
       , spo.usim_id_pos
       , rmdv.usim_sign AS dim_sign
       , rmdv.usim_n1_sign AS dim_n1_sign
       , rmdv.usim_n_dimension
       , pos.usim_coordinate
       , rmdv.usim_id_mlv
    FROM usim_spc_pos spo
   INNER JOIN usim_rmd_v rmdv
      ON spo.usim_id_rmd = rmdv.usim_id_rmd
   INNER JOIN usim_position pos
      ON spo.usim_id_pos = pos.usim_id_pos

neu:CREATE OR REPLACE FORCE VIEW USIM_TEST.usim_spo_v AS
  SELECT spo.usim_id_spc
       , spo.usim_id_rmd
       , spo.usim_id_pos
       , rmdv.usim_sign AS dim_sign
       , rmdv.usim_n1_sign AS dim_n1_sign
       , rmdv.usim_n_dimension
       , pos.usim_coordinate
       , rmdv.usim_id_mlv
    FROM usim_spc_pos spo
   INNER JOIN usim_rmd_v rmdv
      ON spo.usim_id_rmd = rmdv.usim_id_rmd
   INNER JOIN usim_position pos
      ON spo.usim_id_pos = pos.usim_id_pos

View USIM_TEST.USIM_SPO_V erstellt.

SQL> -- usim_spc_pos package
SQL> @@../PACKAGES/USIM_SPO.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_spo
  2  IS
  3    /**A low level package for actions on table usim_spc_pos and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9
 10    /**
 11    * Checks if usim_spc_pos has already data.
 12    * @return Returns 1 if data are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15      RETURN NUMBER
 16    ;
 17
 18    /**
 19    * Checks if usim_spc_pos has already data for a given space node.
 20    * @param p_usim_id_spc The space id to check for data.
 21    * @return Returns 1 if data are available, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 24      RETURN NUMBER
 25    ;
 26
 27    /**
 28    * Checks if usim_spc_pos has a given dimension for the given space node.
 29    * @param p_usim_id_spc The space id to check for data.
 30    * @param p_usim_n_dimension The dimension of the space node to check for data.
 31    * @return Returns 1 if space node has given dimension, otherwise 0.
 32    */
 33    FUNCTION has_data( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
 34                     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 35                     )
 36      RETURN NUMBER
 37    ;
 38
 39    /**
 40    * Checks if for the given space id a maximum position on the dimension axis of the space
 41    * node exists, that may or may not be different to the given space id. Handles escape situation 4 where
 42    * dimension axis zero nodes can trigger new positions on their dimension axis.
 43    * @param p_usim_id_spc The space id to check for max position on its dimension axis.
 44    * @return Returns the count of maximum positions on the given dimension axis, any value not in 0,1 indicates an error in dimension symmetry.
 45    */
 46    FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 47      RETURN NUMBER
 48    ;
 49
 50    /**
 51    * Retrieves the x,y,z coordinates of a given space node, if it exists in USIM_SPC_POS.
 52    * @param p_usim_id_spc The space id to get the coordinates for.
 53    * @return Returns on success a comma separated string, format x,y,z, otherwise NULL.
 54    */
 55    FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 56      RETURN VARCHAR2
 57    ;
 58
 59    /**
 60    * Retrieves the coordinate of a given dimension and space node, if it exists in USIM_SPC_POS. The given dimension
 61    * may not be initialized yet and defaults to 0 if not available.
 62    * Relies on the fact, that table holds one position for one dimension, whatever axis the dimension has.
 63    * @param p_usim_id_spc The space id to get the coordinate for.
 64    * @param p_usim_n_dimension The dimension to get the coordinate for.
 65    * @return Returns on success the coordinate of the given dimension, otherwise NULL.
 66    */
 67    FUNCTION get_dim_coord( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
 68                          , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 69                          )
 70      RETURN usim_position.usim_coordinate%TYPE
 71    ;
 72
 73    /**
 74    * Retrieves the magnitude of a vector for the given dimension.
 75    * @param p_usim_id_spc The space id to get the magnitude for.
 76    * @param p_usim_n_dimension The dimension for the magnitude calculation.
 77    * @return Returns the magnitude of the vector associated to the given space id or NULL on errors.
 78    */
 79    FUNCTION get_magnitude( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
 80                          , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 81                          )
 82      RETURN NUMBER
 83    ;
 84
 85    /**
 86    * Builds a dimension coordinate index for a given space id, if the
 87    * index fits within VARCHAR2. Builds coordinate index like x,y,z but using
 88    * all supported dimension. Includes coordinate for dimension 0.
 89    * @param p_usim_id_spc The space id to build a dimension coordinate index.
 90    * @return Returns a coordinate string in the form of x,y,z with all dimensions, otherwise NULL.
 91    */
 92    FUNCTION get_coord_id(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 93      RETURN VARCHAR2
 94    ;
 95
 96    /**
 97    * Checks if the given node is a 0 coordinate on all dimension axis.
 98    * @param p_usim_id_spc The space id to check.
 99    * @return Returns 1 if is a zero position node, otherwise 0.
100    */
101    FUNCTION is_axis_zero_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
102      RETURN NUMBER
103    ;
104
105    /**
106    * Checks if the given node is a coordinate on a dimension axis, e.g. 1,0,0, 0,2,0.
107    * @param p_usim_id_spc The space id to check.
108    * @return Returns 1 if is an axis position node, otherwise 0.
109    */
110    FUNCTION is_axis_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
111      RETURN NUMBER
112    ;
113
114    /**
115    * Gets the space node with the maximum position on the given dimension axis. The dimension sign is
116    * used to identify the expected coordinate sign, the dimension n1 sign is used to limit the space
117    * which is divided into two subspaces by dimension 1. The dimension itself is used to identify the
118    * dimension axis, we want to get a new parent node from to extend the dimension and universe.
119    * Used with escape situation 4 where dimension axis zero nodes can trigger new positions on their dimension axis.
120    * @param p_usim_id_spc The space id ancestor node which may be itself the parent node or a 0 node on a dimension axis that can trigger new coordinates.
121    * @return The space node with the highest position on a dimension axis, sign and n1 sign of the given ancestor node, otherwise NULL on errors. Use has_axis_max_pos_parent to check before call.
122    */
123    FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
124      RETURN usim_space.usim_id_spc%TYPE
125    ;
126
127    /**
128    * Gets the space node with the position 0 on the given dimension axis.
129    * @param p_usim_id_spc The space id ancestor node which may be itself the parent node.
130    * @return The space node with the position 0 on a dimension axis, otherwise NULL on errors. Every dimension axis should have a zero entry.
131    */
132    FUNCTION get_axis_zero_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
133      RETURN usim_space.usim_id_spc%TYPE
134    ;
135
136    /**
137    * Inserts a coordinate and its dimension position and extends dimension position by
138    * parent, if no dimension entry exists yet. Does nothing if all dimension positions exist
139    * already. Dimensions with position 0 are ignored if not in dimension 0 which is the root of all.
140    * @param p_usim_id_spc The space id to insert a coordinate.
141    * @param p_usim_id_spc_parent The parent space id to check or extend coordinate.
142    * @return Returns 1 on success, otherwise 0 (also on exception which is logged).
143    */
144    FUNCTION insert_spc_pos( p_usim_id_spc        IN usim_space.usim_id_spc%TYPE
145                           , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
146                           , p_do_commit          IN BOOLEAN                     DEFAULT TRUE
147                           )
148      RETURN NUMBER
149    ;
150
151  END usim_spo;
152  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_spo
IS
  /**A low level package for actions on table usim_spc_pos and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_spc_pos has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_pos has already data for a given space node.
  * @param p_usim_id_spc The space id to check for data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_pos has a given dimension for the given space node.
  * @param p_usim_id_spc The space id to check for data.
  * @param p_usim_n_dimension The dimension of the space node to check for data.
  * @return Returns 1 if space node has given dimension, otherwise 0.
  */
  FUNCTION has_data( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                   , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                   )
    RETURN NUMBER
  ;

  /**
  * Checks if for the given space id a maximum position on the dimension axis of the space
  * node exists, that may or may not be different to the given space id. Handles escape situation 4 where
  * dimension axis zero nodes can trigger new positions on their dimension axis.
  * @param p_usim_id_spc The space id to check for max position on its dimension axis.
  * @return Returns the count of maximum positions on the given dimension axis, any value not in 0,1 indicates an error in dimension symmetry.
  */
  FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the x,y,z coordinates of a given space node, if it exists in USIM_SPC_POS.
  * @param p_usim_id_spc The space id to get the coordinates for.
  * @return Returns on success a comma separated string, format x,y,z, otherwise NULL.
  */
  FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  ;

  /**
  * Retrieves the coordinate of a given dimension and space node, if it exists in USIM_SPC_POS. The given dimension
  * may not be initialized yet and defaults to 0 if not available.
  * Relies on the fact, that table holds one position for one dimension, whatever axis the dimension has.
  * @param p_usim_id_spc The space id to get the coordinate for.
  * @param p_usim_n_dimension The dimension to get the coordinate for.
  * @return Returns on success the coordinate of the given dimension, otherwise NULL.
  */
  FUNCTION get_dim_coord( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Retrieves the magnitude of a vector for the given dimension.
  * @param p_usim_id_spc The space id to get the magnitude for.
  * @param p_usim_n_dimension The dimension for the magnitude calculation.
  * @return Returns the magnitude of the vector associated to the given space id or NULL on errors.
  */
  FUNCTION get_magnitude( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN NUMBER
  ;

  /**
  * Builds a dimension coordinate index for a given space id, if the
  * index fits within VARCHAR2. Builds coordinate index like x,y,z but using
  * all supported dimension. Includes coordinate for dimension 0.
  * @param p_usim_id_spc The space id to build a dimension coordinate index.
  * @return Returns a coordinate string in the form of x,y,z with all dimensions, otherwise NULL.
  */
  FUNCTION get_coord_id(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  ;

  /**
  * Checks if the given node is a 0 coordinate on all dimension axis.
  * @param p_usim_id_spc The space id to check.
  * @return Returns 1 if is a zero position node, otherwise 0.
  */
  FUNCTION is_axis_zero_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if the given node is a coordinate on a dimension axis, e.g. 1,0,0, 0,2,0.
  * @param p_usim_id_spc The space id to check.
  * @return Returns 1 if is an axis position node, otherwise 0.
  */
  FUNCTION is_axis_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the space node with the maximum position on the given dimension axis. The dimension sign is
  * used to identify the expected coordinate sign, the dimension n1 sign is used to limit the space
  * which is divided into two subspaces by dimension 1. The dimension itself is used to identify the
  * dimension axis, we want to get a new parent node from to extend the dimension and universe.
  * Used with escape situation 4 where dimension axis zero nodes can trigger new positions on their dimension axis.
  * @param p_usim_id_spc The space id ancestor node which may be itself the parent node or a 0 node on a dimension axis that can trigger new coordinates.
  * @return The space node with the highest position on a dimension axis, sign and n1 sign of the given ancestor node, otherwise NULL on errors. Use has_axis_max_pos_parent to check before call.
  */
  FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Gets the space node with the position 0 on the given dimension axis.
  * @param p_usim_id_spc The space id ancestor node which may be itself the parent node.
  * @return The space node with the position 0 on a dimension axis, otherwise NULL on errors. Every dimension axis should have a zero entry.
  */
  FUNCTION get_axis_zero_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Inserts a coordinate and its dimension position and extends dimension position by
  * parent, if no dimension entry exists yet. Does nothing if all dimension positions exist
  * already. Dimensions with position 0 are ignored if not in dimension 0 which is the root of all.
  * @param p_usim_id_spc The space id to insert a coordinate.
  * @param p_usim_id_spc_parent The parent space id to check or extend coordinate.
  * @return Returns 1 on success, otherwise 0 (also on exception which is logged).
  */
  FUNCTION insert_spc_pos( p_usim_id_spc        IN usim_space.usim_id_spc%TYPE
                         , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
                         , p_do_commit          IN BOOLEAN                     DEFAULT TRUE
                         )
    RETURN NUMBER
  ;

END usim_spo;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_spo
IS
  /**A low level package for actions on table usim_spc_pos and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_spc_pos has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_pos has already data for a given space node.
  * @param p_usim_id_spc The space id to check for data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_pos has a given dimension for the given space node.
  * @param p_usim_id_spc The space id to check for data.
  * @param p_usim_n_dimension The dimension of the space node to check for data.
  * @return Returns 1 if space node has given dimension, otherwise 0.
  */
  FUNCTION has_data( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                   , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                   )
    RETURN NUMBER
  ;

  /**
  * Checks if for the given space id a maximum position on the dimension axis of the space
  * node exists, that may or may not be different to the given space id. Handles escape situation 4 where
  * dimension axis zero nodes can trigger new positions on their dimension axis.
  * @param p_usim_id_spc The space id to check for max position on its dimension axis.
  * @return Returns the count of maximum positions on the given dimension axis, any value not in 0,1 indicates an error in dimension symmetry.
  */
  FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the x,y,z coordinates of a given space node, if it exists in USIM_SPC_POS.
  * @param p_usim_id_spc The space id to get the coordinates for.
  * @return Returns on success a comma separated string, format x,y,z, otherwise NULL.
  */
  FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  ;

  /**
  * Retrieves the coordinate of a given dimension and space node, if it exists in USIM_SPC_POS. The given dimension
  * may not be initialized yet and defaults to 0 if not available.
  * Relies on the fact, that table holds one position for one dimension, whatever axis the dimension has.
  * @param p_usim_id_spc The space id to get the coordinate for.
  * @param p_usim_n_dimension The dimension to get the coordinate for.
  * @return Returns on success the coordinate of the given dimension, otherwise NULL.
  */
  FUNCTION get_dim_coord( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Retrieves the magnitude of a vector for the given dimension.
  * @param p_usim_id_spc The space id to get the magnitude for.
  * @param p_usim_n_dimension The dimension for the magnitude calculation.
  * @return Returns the magnitude of the vector associated to the given space id or NULL on errors.
  */
  FUNCTION get_magnitude( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN NUMBER
  ;

  /**
  * Builds a dimension coordinate index for a given space id, if the
  * index fits within VARCHAR2. Builds coordinate index like x,y,z but using
  * all supported dimension. Includes coordinate for dimension 0.
  * @param p_usim_id_spc The space id to build a dimension coordinate index.
  * @return Returns a coordinate string in the form of x,y,z with all dimensions, otherwise NULL.
  */
  FUNCTION get_coord_id(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  ;

  /**
  * Checks if the given node is a 0 coordinate on all dimension axis.
  * @param p_usim_id_spc The space id to check.
  * @return Returns 1 if is a zero position node, otherwise 0.
  */
  FUNCTION is_axis_zero_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if the given node is a coordinate on a dimension axis, e.g. 1,0,0, 0,2,0.
  * @param p_usim_id_spc The space id to check.
  * @return Returns 1 if is an axis position node, otherwise 0.
  */
  FUNCTION is_axis_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the space node with the maximum position on the given dimension axis. The dimension sign is
  * used to identify the expected coordinate sign, the dimension n1 sign is used to limit the space
  * which is divided into two subspaces by dimension 1. The dimension itself is used to identify the
  * dimension axis, we want to get a new parent node from to extend the dimension and universe.
  * Used with escape situation 4 where dimension axis zero nodes can trigger new positions on their dimension axis.
  * @param p_usim_id_spc The space id ancestor node which may be itself the parent node or a 0 node on a dimension axis that can trigger new coordinates.
  * @return The space node with the highest position on a dimension axis, sign and n1 sign of the given ancestor node, otherwise NULL on errors. Use has_axis_max_pos_parent to check before call.
  */
  FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Gets the space node with the position 0 on the given dimension axis.
  * @param p_usim_id_spc The space id ancestor node which may be itself the parent node.
  * @return The space node with the position 0 on a dimension axis, otherwise NULL on errors. Every dimension axis should have a zero entry.
  */
  FUNCTION get_axis_zero_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Inserts a coordinate and its dimension position and extends dimension position by
  * parent, if no dimension entry exists yet. Does nothing if all dimension positions exist
  * already. Dimensions with position 0 are ignored if not in dimension 0 which is the root of all.
  * @param p_usim_id_spc The space id to insert a coordinate.
  * @param p_usim_id_spc_parent The parent space id to check or extend coordinate.
  * @return Returns 1 on success, otherwise 0 (also on exception which is logged).
  */
  FUNCTION insert_spc_pos( p_usim_id_spc        IN usim_space.usim_id_spc%TYPE
                         , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
                         , p_do_commit          IN BOOLEAN                     DEFAULT TRUE
                         )
    RETURN NUMBER
  ;

END usim_spo;

Package USIM_SPO kompiliert

SQL> @@../PACKAGES/USIM_SPO.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_spo
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_data
  5      RETURN NUMBER
  6    IS
  7      l_result NUMBER;
  8    BEGIN
  9      SELECT COUNT(*) INTO l_result FROM usim_spc_pos;
 10      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 11    END has_data
 12    ;
 13
 14    FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 15      RETURN NUMBER
 16    IS
 17      l_result NUMBER;
 18    BEGIN
 19      SELECT COUNT(*) INTO l_result FROM usim_spc_pos WHERE usim_id_spc = p_usim_id_spc;
 20      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 21    END has_data
 22    ;
 23
 24    FUNCTION has_data( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
 25                     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 26                     )
 27      RETURN NUMBER
 28    IS
 29      l_result NUMBER;
 30    BEGIN
 31      SELECT COUNT(*) INTO l_result FROM usim_spo_v WHERE usim_id_spc = p_usim_id_spc and usim_n_dimension = p_usim_n_dimension;
 32      RETURN l_result;
 33    END has_data
 34    ;
 35
 36    FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 37      RETURN NUMBER
 38    IS
 39      l_result            NUMBER;
 40    BEGIN
 41      -- fetch count
 42        WITH known AS
 43             (SELECT usim_id_spc
 44                   , usim_spo.is_axis_pos(usim_id_spc) AS is_axis
 45                   , usim_coordinate
 46                   , usim_id_rmd
 47                   , dim_sign
 48                FROM usim_spc_v
 49               WHERE usim_id_rmd = (SELECT usim_id_rmd FROM usim_space WHERE usim_id_spc = p_usim_id_spc)
 50             )
 51           , maxpos AS
 52             (SELECT CASE
 53                       WHEN dim_sign >= 0
 54                       THEN MAX(usim_coordinate)
 55                       ELSE MIN(usim_coordinate)
 56                     END                         AS parent_pos
 57                   , usim_id_rmd
 58                   , dim_sign
 59                FROM known
 60               WHERE is_axis = 1
 61               GROUP BY usim_id_rmd
 62                      , dim_sign
 63             )
 64      SELECT COUNT(*)
 65        INTO l_result
 66        FROM known
 67       INNER JOIN maxpos
 68          ON known.usim_coordinate  = maxpos.parent_pos
 69         AND known.usim_id_rmd      = maxpos.usim_id_rmd
 70         AND known.dim_sign         = maxpos.dim_sign
 71       WHERE known.is_axis = 1
 72      ;
 73      -- do not mimic count to 0 and 1 as any value > 1 is a dimension symmetry error
 74      RETURN l_result;
 75    END has_axis_max_pos_parent
 76    ;
 77
 78
 79    FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 80      RETURN VARCHAR2
 81    IS
 82      l_result VARCHAR2(32000);
 83    BEGIN
 84      IF usim_spo.has_data(p_usim_id_spc) = 1
 85      THEN
 86        l_result := '' || usim_spo.get_dim_coord(p_usim_id_spc, 1) || ',' || usim_spo.get_dim_coord(p_usim_id_spc, 2) || ',' || usim_spo.get_dim_coord(p_usim_id_spc, 3);
 87        RETURN TRIM(l_result);
 88      ELSE
 89        usim_erl.log_error('usim_spo.get_xyz', 'Used with space id [' || p_usim_id_spc || '] not in USIM_SPC_POS.');
 90        RETURN NULL;
 91      END IF;
 92    END get_xyz
 93    ;
 94
 95    FUNCTION get_dim_coord( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
 96                          , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 97                          )
 98      RETURN usim_position.usim_coordinate%TYPE
 99    IS
100      l_result usim_position.usim_coordinate%TYPE;
101    BEGIN
102      IF usim_spo.has_data(p_usim_id_spc) = 1
103      THEN
104          WITH dim AS
105               (SELECT p_usim_n_dimension AS usim_n_dimension FROM dual)
106             , coords AS
107               (SELECT usim_n_dimension
108                     , usim_coordinate
109                  FROM usim_spo_v
110                 WHERE usim_id_spc = p_usim_id_spc
111               )
112        SELECT NVL(usim_coordinate, 0)
113          INTO l_result
114          FROM dim
115          LEFT OUTER JOIN coords
116            ON dim.usim_n_dimension = coords.usim_n_dimension
117        ;
118        RETURN l_result;
119      ELSE
120        usim_erl.log_error('usim_spo.get_dim_coord', 'Used with space id [' || p_usim_id_spc || '] not in USIM_SPC_POS or not available dimension [' || p_usim_n_dimension || '].');
121        RETURN NULL;
122      END IF;
123    END get_dim_coord
124    ;
125
126    FUNCTION get_magnitude( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
127                          , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
128                          )
129      RETURN NUMBER
130    IS
131      l_sum    NUMBER;
132      l_result NUMBER;
133    BEGIN
134      IF usim_spc.has_data(p_usim_id_spc) = 0
135      THEN
136        usim_erl.log_error('usim_spo.get_magnitude', 'Used with not existing space id [' || p_usim_id_spc || ']');
137      END IF;
138      l_result := 0;
139      l_sum    := 0;
140      FOR l_idx IN 1..p_usim_n_dimension
141      LOOP
142        l_sum := l_sum + POWER(usim_spo.get_dim_coord(p_usim_id_spc, l_idx), 2);
143      END LOOP;
144      l_result := SQRT(l_sum);
145      RETURN l_result;
146    END get_magnitude
147    ;
148
149    FUNCTION get_coord_id(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
150      RETURN VARCHAR2
151    IS
152      l_coord_id VARCHAR2(32767);
153      l_max_dim  NUMBER;
154    BEGIN
155      IF usim_spo.has_data(p_usim_id_spc) = 1
156      THEN
157        l_max_dim  := usim_base.get_max_dimension;
158        l_coord_id := '';
159        FOR l_dim IN 0..l_max_dim
160        LOOP
161          -- check size before
162          IF LENGTH(l_coord_id) + LENGTH(',' || usim_spo.get_dim_coord(p_usim_id_spc, l_dim)) > 32767
163          THEN
164            usim_erl.log_error('usim_spo.get_coord_id', 'Too much dimensions to build coordinate id within system limits for space id [' || p_usim_id_spc || '].');
165            RETURN NULL;
166          END IF;
167          IF l_dim = 0
168          THEN
169            l_coord_id := l_coord_id || usim_spo.get_dim_coord(p_usim_id_spc, l_dim);
170          ELSE
171            l_coord_id := l_coord_id || ',' || usim_spo.get_dim_coord(p_usim_id_spc, l_dim);
172          END IF;
173        END LOOP;
174        RETURN l_coord_id;
175      ELSE
176        usim_erl.log_error('usim_spo.get_coord_id', 'Used with invalid space id [' || p_usim_id_spc || '].');
177        RETURN NULL;
178      END IF;
179    END get_coord_id
180    ;
181
182    FUNCTION is_axis_zero_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
183      RETURN NUMBER
184    IS
185      l_result NUMBER;
186    BEGIN
187      SELECT COUNT(*)
188        INTO l_result
189        FROM usim_spo_v
190       WHERE usim_id_spc      = p_usim_id_spc
191         AND usim_coordinate != 0
192      ;
193
194      RETURN (CASE WHEN l_result > 0 THEN 0 ELSE 1 END);
195    END is_axis_zero_pos
196    ;
197
198    FUNCTION is_axis_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
199      RETURN NUMBER
200    IS
201      l_result NUMBER;
202    BEGIN
203      -- zero axis is axis
204      IF usim_spo.is_axis_zero_pos(p_usim_id_spc) = 1
205      THEN
206        RETURN 1;
207      END IF;
208      -- get axis if not zero axis
209      SELECT COUNT(*)
210        INTO l_result
211        FROM usim_spo_v
212       WHERE usim_coordinate != 0
213         AND usim_id_spc      = p_usim_id_spc
214       GROUP BY usim_id_spc
215      ;
216      IF l_result = 1
217      THEN
218        RETURN 1;
219      ELSE
220        RETURN 0;
221      END IF;
222    END is_axis_pos
223    ;
224
225    FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
226      RETURN usim_space.usim_id_spc%TYPE
227    IS
228      l_result            usim_space.usim_id_spc%TYPE;
229    BEGIN
230      IF usim_spo.has_axis_max_pos_parent(p_usim_id_spc) = 1
231      THEN
232        -- fetch data
233          WITH known AS
234               (SELECT usim_id_spc
235                     , usim_spo.is_axis_pos(usim_id_spc) AS is_axis
236                     , usim_coordinate
237                     , usim_id_rmd
238                     , dim_sign
239                  FROM usim_spc_v
240                 WHERE usim_id_rmd = (SELECT usim_id_rmd FROM usim_space WHERE usim_id_spc = p_usim_id_spc)
241               )
242             , maxpos AS
243               (SELECT CASE
244                         WHEN dim_sign >= 0
245                         THEN MAX(usim_coordinate)
246                         ELSE MIN(usim_coordinate)
247                       END                         AS parent_pos
248                     , usim_id_rmd
249                     , dim_sign
250                  FROM known
251                 WHERE is_axis = 1
252                 GROUP BY usim_id_rmd
253                        , dim_sign
254               )
255        SELECT known.usim_id_spc
256          INTO l_result
257          FROM known
258         INNER JOIN maxpos
259            ON known.usim_coordinate  = maxpos.parent_pos
260           AND known.usim_id_rmd      = maxpos.usim_id_rmd
261           AND known.dim_sign         = maxpos.dim_sign
262         WHERE known.is_axis = 1
263        ;
264        RETURN l_result;
265      ELSE
266        RETURN NULL;
267      END IF;
268    END get_axis_max_pos_parent
269    ;
270
271    FUNCTION get_axis_zero_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
272      RETURN usim_space.usim_id_spc%TYPE
273    IS
274      l_result            usim_space.usim_id_spc%TYPE;
275    BEGIN
276      -- fetch data
277        WITH known AS
278             (SELECT usim_id_spc
279                   , usim_spo.is_axis_pos(usim_id_spc) AS is_axis
280                   , usim_coordinate
281                   , usim_id_rmd
282                   , dim_sign
283                FROM usim_spc_v
284               WHERE usim_id_rmd     = (SELECT usim_id_rmd FROM usim_space WHERE usim_id_spc = p_usim_id_spc)
285                 AND usim_coordinate = 0
286             )
287      SELECT known.usim_id_spc
288        INTO l_result
289        FROM known
290       WHERE known.is_axis = 1
291      ;
292      RETURN l_result;
293    END get_axis_zero_pos_parent
294    ;
295
296    FUNCTION insert_spc_pos( p_usim_id_spc        IN usim_space.usim_id_spc%TYPE
297                           , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
298                           , p_do_commit          IN BOOLEAN                     DEFAULT TRUE
299                           )
300      RETURN NUMBER
301    IS
302      l_dim     usim_dimension.usim_n_dimension%TYPE;
303      l_id_mlv  usim_multiverse.usim_id_mlv%TYPE;
304
305      CURSOR cur_dims( cp_usim_id_spc        IN usim_space.usim_id_spc%TYPE
306                     , cp_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
307                     , cp_usim_id_mlv        IN usim_multiverse.usim_id_mlv%TYPE
308                     )
309      IS
310          WITH org_dim AS
311               (SELECT /*+MATERIALIZE */
312                       usim_n_dimension
313                  FROM usim_spo_v
314                 WHERE usim_id_spc = cp_usim_id_spc
315                       -- consider only the universe of the given new space id
316                   AND usim_id_mlv = cp_usim_id_mlv
317               )
318        SELECT usim_id_rmd
319             , usim_id_pos
320          FROM usim_spo_v
321               -- parent might be in a different universe, so no positions are added from other universes
322         WHERE usim_id_spc           = cp_usim_id_spc_parent
323           AND usim_id_mlv           = cp_usim_id_mlv
324           AND usim_n_dimension NOT IN (SELECT usim_n_dimension FROM org_dim)
325  -- not sure if to exclude 0 coordinates and dimensions
326  --         AND (   usim_coordinate  != 0
327  --              OR usim_n_dimension  = 0
328  --             )
329      ;
330    BEGIN
331      IF usim_spo.has_data(p_usim_id_spc) = 0
332      THEN
333        -- insert the new space id
334        INSERT INTO usim_spc_pos
335          ( usim_id_spc
336          , usim_id_rmd
337          , usim_id_pos
338          )
339          SELECT usim_id_spc
340               , usim_id_rmd
341               , usim_id_pos
342            FROM usim_space
343           WHERE usim_id_spc = p_usim_id_spc
344        ;
345      END IF;
346      -- check parent
347      IF usim_spo.has_data(p_usim_id_spc_parent) = 1
348      THEN
349        l_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
350        -- only lower dimension not present and position > 0, missing dimensions means 0 position in this dimension
351        FOR rec IN cur_dims(p_usim_id_spc, p_usim_id_spc_parent, l_id_mlv)
352        LOOP
353          INSERT INTO usim_spc_pos
354            ( usim_id_spc
355            , usim_id_rmd
356            , usim_id_pos
357            )
358            VALUES
359            ( p_usim_id_spc
360            , rec.usim_id_rmd
361            , rec.usim_id_pos
362            )
363          ;
364        END LOOP;
365      ELSE
366        -- if parent is NULL and dimension is 0, everything okay, only one entry otherwise error
367        IF p_usim_id_spc_parent IS NOT NULL
368        THEN
369          SELECT usim_n_dimension INTO l_dim FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc;
370          IF l_dim != 0
371          THEN
372            ROLLBACK;
373            usim_erl.log_error('usim_spo.insert_spc_pos', 'Used with invalid parent space id [' || p_usim_id_spc_parent || '] or wrong dimension > 0.');
374            RETURN 0;
375          END IF;
376        END IF;
377      END IF;
378      -- everything done, do commit if needed
379      IF p_do_commit
380      THEN
381        COMMIT;
382      END IF;
383      RETURN 1;
384    END insert_spc_pos
385    ;
386
387  END usim_spo;
388  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_spo
IS
  -- see header for documentation
  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_pos;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_pos WHERE usim_id_spc = p_usim_id_spc;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                   , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                   )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spo_v WHERE usim_id_spc = p_usim_id_spc and usim_n_dimension = p_usim_n_dimension;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result            NUMBER;
  BEGIN
    -- fetch count
      WITH known AS
           (SELECT usim_id_spc
                 , usim_spo.is_axis_pos(usim_id_spc) AS is_axis
                 , usim_coordinate
                 , usim_id_rmd
                 , dim_sign
              FROM usim_spc_v
             WHERE usim_id_rmd = (SELECT usim_id_rmd FROM usim_space WHERE usim_id_spc = p_usim_id_spc)
           )
         , maxpos AS
           (SELECT CASE
                     WHEN dim_sign >= 0
                     THEN MAX(usim_coordinate)
                     ELSE MIN(usim_coordinate)
                   END                         AS parent_pos
                 , usim_id_rmd
                 , dim_sign
              FROM known
             WHERE is_axis = 1
             GROUP BY usim_id_rmd
                    , dim_sign
           )
    SELECT COUNT(*)
      INTO l_result
      FROM known
     INNER JOIN maxpos
        ON known.usim_coordinate  = maxpos.parent_pos
       AND known.usim_id_rmd      = maxpos.usim_id_rmd
       AND known.dim_sign         = maxpos.dim_sign
     WHERE known.is_axis = 1
    ;
    -- do not mimic count to 0 and 1 as any value > 1 is a dimension symmetry error
    RETURN l_result;
  END has_axis_max_pos_parent
  ;


  FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  IS
    l_result VARCHAR2(32000);
  BEGIN
    IF usim_spo.has_data(p_usim_id_spc) = 1
    THEN
      l_result := '' || usim_spo.get_dim_coord(p_usim_id_spc, 1) || ',' || usim_spo.get_dim_coord(p_usim_id_spc, 2) || ',' || usim_spo.get_dim_coord(p_usim_id_spc, 3);
      RETURN TRIM(l_result);
    ELSE
      usim_erl.log_error('usim_spo.get_xyz', 'Used with space id [' || p_usim_id_spc || '] not in USIM_SPC_POS.');
      RETURN NULL;
    END IF;
  END get_xyz
  ;

  FUNCTION get_dim_coord( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_result usim_position.usim_coordinate%TYPE;
  BEGIN
    IF usim_spo.has_data(p_usim_id_spc) = 1
    THEN
        WITH dim AS
             (SELECT p_usim_n_dimension AS usim_n_dimension FROM dual)
           , coords AS
             (SELECT usim_n_dimension
                   , usim_coordinate
                FROM usim_spo_v
               WHERE usim_id_spc = p_usim_id_spc
             )
      SELECT NVL(usim_coordinate, 0)
        INTO l_result
        FROM dim
        LEFT OUTER JOIN coords
          ON dim.usim_n_dimension = coords.usim_n_dimension
      ;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spo.get_dim_coord', 'Used with space id [' || p_usim_id_spc || '] not in USIM_SPC_POS or not available dimension [' || p_usim_n_dimension || '].');
      RETURN NULL;
    END IF;
  END get_dim_coord
  ;

  FUNCTION get_magnitude( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN NUMBER
  IS
    l_sum    NUMBER;
    l_result NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 0
    THEN
      usim_erl.log_error('usim_spo.get_magnitude', 'Used with not existing space id [' || p_usim_id_spc || ']');
    END IF;
    l_result := 0;
    l_sum    := 0;
    FOR l_idx IN 1..p_usim_n_dimension
    LOOP
      l_sum := l_sum + POWER(usim_spo.get_dim_coord(p_usim_id_spc, l_idx), 2);
    END LOOP;
    l_result := SQRT(l_sum);
    RETURN l_result;
  END get_magnitude
  ;

  FUNCTION get_coord_id(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  IS
    l_coord_id VARCHAR2(32767);
    l_max_dim  NUMBER;
  BEGIN
    IF usim_spo.has_data(p_usim_id_spc) = 1
    THEN
      l_max_dim  := usim_base.get_max_dimension;
      l_coord_id := '';
      FOR l_dim IN 0..l_max_dim
      LOOP
        -- check size before
        IF LENGTH(l_coord_id) + LENGTH(',' || usim_spo.get_dim_coord(p_usim_id_spc, l_dim)) > 32767
        THEN
          usim_erl.log_error('usim_spo.get_coord_id', 'Too much dimensions to build coordinate id within system limits for space id [' || p_usim_id_spc || '].');
          RETURN NULL;
        END IF;
        IF l_dim = 0
        THEN
          l_coord_id := l_coord_id || usim_spo.get_dim_coord(p_usim_id_spc, l_dim);
        ELSE
          l_coord_id := l_coord_id || ',' || usim_spo.get_dim_coord(p_usim_id_spc, l_dim);
        END IF;
      END LOOP;
      RETURN l_coord_id;
    ELSE
      usim_erl.log_error('usim_spo.get_coord_id', 'Used with invalid space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_coord_id
  ;

  FUNCTION is_axis_zero_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spo_v
     WHERE usim_id_spc      = p_usim_id_spc
       AND usim_coordinate != 0
    ;

    RETURN (CASE WHEN l_result > 0 THEN 0 ELSE 1 END);
  END is_axis_zero_pos
  ;

  FUNCTION is_axis_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    -- zero axis is axis
    IF usim_spo.is_axis_zero_pos(p_usim_id_spc) = 1
    THEN
      RETURN 1;
    END IF;
    -- get axis if not zero axis
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spo_v
     WHERE usim_coordinate != 0
       AND usim_id_spc      = p_usim_id_spc
     GROUP BY usim_id_spc
    ;
    IF l_result = 1
    THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  END is_axis_pos
  ;

  FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result            usim_space.usim_id_spc%TYPE;
  BEGIN
    IF usim_spo.has_axis_max_pos_parent(p_usim_id_spc) = 1
    THEN
      -- fetch data
        WITH known AS
             (SELECT usim_id_spc
                   , usim_spo.is_axis_pos(usim_id_spc) AS is_axis
                   , usim_coordinate
                   , usim_id_rmd
                   , dim_sign
                FROM usim_spc_v
               WHERE usim_id_rmd = (SELECT usim_id_rmd FROM usim_space WHERE usim_id_spc = p_usim_id_spc)
             )
           , maxpos AS
             (SELECT CASE
                       WHEN dim_sign >= 0
                       THEN MAX(usim_coordinate)
                       ELSE MIN(usim_coordinate)
                     END                         AS parent_pos
                   , usim_id_rmd
                   , dim_sign
                FROM known
               WHERE is_axis = 1
               GROUP BY usim_id_rmd
                      , dim_sign
             )
      SELECT known.usim_id_spc
        INTO l_result
        FROM known
       INNER JOIN maxpos
          ON known.usim_coordinate  = maxpos.parent_pos
         AND known.usim_id_rmd      = maxpos.usim_id_rmd
         AND known.dim_sign         = maxpos.dim_sign
       WHERE known.is_axis = 1
      ;
      RETURN l_result;
    ELSE
      RETURN NULL;
    END IF;
  END get_axis_max_pos_parent
  ;

  FUNCTION get_axis_zero_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result            usim_space.usim_id_spc%TYPE;
  BEGIN
    -- fetch data
      WITH known AS
           (SELECT usim_id_spc
                 , usim_spo.is_axis_pos(usim_id_spc) AS is_axis
                 , usim_coordinate
                 , usim_id_rmd
                 , dim_sign
              FROM usim_spc_v
             WHERE usim_id_rmd     = (SELECT usim_id_rmd FROM usim_space WHERE usim_id_spc = p_usim_id_spc)
               AND usim_coordinate = 0
           )
    SELECT known.usim_id_spc
      INTO l_result
      FROM known
     WHERE known.is_axis = 1
    ;
    RETURN l_result;
  END get_axis_zero_pos_parent
  ;

  FUNCTION insert_spc_pos( p_usim_id_spc        IN usim_space.usim_id_spc%TYPE
                         , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
                         , p_do_commit          IN BOOLEAN                     DEFAULT TRUE
                         )
    RETURN NUMBER
  IS
    l_dim     usim_dimension.usim_n_dimension%TYPE;
    l_id_mlv  usim_multiverse.usim_id_mlv%TYPE;

    CURSOR cur_dims( cp_usim_id_spc        IN usim_space.usim_id_spc%TYPE
                   , cp_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
                   , cp_usim_id_mlv        IN usim_multiverse.usim_id_mlv%TYPE
                   )
    IS
        WITH org_dim AS
             (SELECT /*+MATERIALIZE */
                     usim_n_dimension
                FROM usim_spo_v
               WHERE usim_id_spc = cp_usim_id_spc
                     -- consider only the universe of the given new space id
                 AND usim_id_mlv = cp_usim_id_mlv
             )
      SELECT usim_id_rmd
           , usim_id_pos
        FROM usim_spo_v
             -- parent might be in a different universe, so no positions are added from other universes
       WHERE usim_id_spc           = cp_usim_id_spc_parent
         AND usim_id_mlv           = cp_usim_id_mlv
         AND usim_n_dimension NOT IN (SELECT usim_n_dimension FROM org_dim)
-- not sure if to exclude 0 coordinates and dimensions
--         AND (   usim_coordinate  != 0
--              OR usim_n_dimension  = 0
--             )
    ;
  BEGIN
    IF usim_spo.has_data(p_usim_id_spc) = 0
    THEN
      -- insert the new space id
      INSERT INTO usim_spc_pos
        ( usim_id_spc
        , usim_id_rmd
        , usim_id_pos
        )
        SELECT usim_id_spc
             , usim_id_rmd
             , usim_id_pos
          FROM usim_space
         WHERE usim_id_spc = p_usim_id_spc
      ;
    END IF;
    -- check parent
    IF usim_spo.has_data(p_usim_id_spc_parent) = 1
    THEN
      l_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
      -- only lower dimension not present and position > 0, missing dimensions means 0 position in this dimension
      FOR rec IN cur_dims(p_usim_id_spc, p_usim_id_spc_parent, l_id_mlv)
      LOOP
        INSERT INTO usim_spc_pos
          ( usim_id_spc
          , usim_id_rmd
          , usim_id_pos
          )
          VALUES
          ( p_usim_id_spc
          , rec.usim_id_rmd
          , rec.usim_id_pos
          )
        ;
      END LOOP;
    ELSE
      -- if parent is NULL and dimension is 0, everything okay, only one entry otherwise error
      IF p_usim_id_spc_parent IS NOT NULL
      THEN
        SELECT usim_n_dimension INTO l_dim FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc;
        IF l_dim != 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_spo.insert_spc_pos', 'Used with invalid parent space id [' || p_usim_id_spc_parent || '] or wrong dimension > 0.');
          RETURN 0;
        END IF;
      END IF;
    END IF;
    -- everything done, do commit if needed
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN 1;
  END insert_spc_pos
  ;

END usim_spo;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_spo
IS
  -- see header for documentation
  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_pos;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_pos WHERE usim_id_spc = p_usim_id_spc;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                   , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                   )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spo_v WHERE usim_id_spc = p_usim_id_spc and usim_n_dimension = p_usim_n_dimension;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result            NUMBER;
  BEGIN
    -- fetch count
      WITH known AS
           (SELECT usim_id_spc
                 , usim_spo.is_axis_pos(usim_id_spc) AS is_axis
                 , usim_coordinate
                 , usim_id_rmd
                 , dim_sign
              FROM usim_spc_v
             WHERE usim_id_rmd = (SELECT usim_id_rmd FROM usim_space WHERE usim_id_spc = p_usim_id_spc)
           )
         , maxpos AS
           (SELECT CASE
                     WHEN dim_sign >= 0
                     THEN MAX(usim_coordinate)
                     ELSE MIN(usim_coordinate)
                   END                         AS parent_pos
                 , usim_id_rmd
                 , dim_sign
              FROM known
             WHERE is_axis = 1
             GROUP BY usim_id_rmd
                    , dim_sign
           )
    SELECT COUNT(*)
      INTO l_result
      FROM known
     INNER JOIN maxpos
        ON known.usim_coordinate  = maxpos.parent_pos
       AND known.usim_id_rmd      = maxpos.usim_id_rmd
       AND known.dim_sign         = maxpos.dim_sign
     WHERE known.is_axis = 1
    ;
    -- do not mimic count to 0 and 1 as any value > 1 is a dimension symmetry error
    RETURN l_result;
  END has_axis_max_pos_parent
  ;


  FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  IS
    l_result VARCHAR2(32000);
  BEGIN
    IF usim_spo.has_data(p_usim_id_spc) = 1
    THEN
      l_result := '' || usim_spo.get_dim_coord(p_usim_id_spc, 1) || ',' || usim_spo.get_dim_coord(p_usim_id_spc, 2) || ',' || usim_spo.get_dim_coord(p_usim_id_spc, 3);
      RETURN TRIM(l_result);
    ELSE
      usim_erl.log_error('usim_spo.get_xyz', 'Used with space id [' || p_usim_id_spc || '] not in USIM_SPC_POS.');
      RETURN NULL;
    END IF;
  END get_xyz
  ;

  FUNCTION get_dim_coord( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_result usim_position.usim_coordinate%TYPE;
  BEGIN
    IF usim_spo.has_data(p_usim_id_spc) = 1
    THEN
        WITH dim AS
             (SELECT p_usim_n_dimension AS usim_n_dimension FROM dual)
           , coords AS
             (SELECT usim_n_dimension
                   , usim_coordinate
                FROM usim_spo_v
               WHERE usim_id_spc = p_usim_id_spc
             )
      SELECT NVL(usim_coordinate, 0)
        INTO l_result
        FROM dim
        LEFT OUTER JOIN coords
          ON dim.usim_n_dimension = coords.usim_n_dimension
      ;
      RETURN l_result;
    ELSE
      usim_erl.log_error('usim_spo.get_dim_coord', 'Used with space id [' || p_usim_id_spc || '] not in USIM_SPC_POS or not available dimension [' || p_usim_n_dimension || '].');
      RETURN NULL;
    END IF;
  END get_dim_coord
  ;

  FUNCTION get_magnitude( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN NUMBER
  IS
    l_sum    NUMBER;
    l_result NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 0
    THEN
      usim_erl.log_error('usim_spo.get_magnitude', 'Used with not existing space id [' || p_usim_id_spc || ']');
    END IF;
    l_result := 0;
    l_sum    := 0;
    FOR l_idx IN 1..p_usim_n_dimension
    LOOP
      l_sum := l_sum + POWER(usim_spo.get_dim_coord(p_usim_id_spc, l_idx), 2);
    END LOOP;
    l_result := SQRT(l_sum);
    RETURN l_result;
  END get_magnitude
  ;

  FUNCTION get_coord_id(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  IS
    l_coord_id VARCHAR2(32767);
    l_max_dim  NUMBER;
  BEGIN
    IF usim_spo.has_data(p_usim_id_spc) = 1
    THEN
      l_max_dim  := usim_base.get_max_dimension;
      l_coord_id := '';
      FOR l_dim IN 0..l_max_dim
      LOOP
        -- check size before
        IF LENGTH(l_coord_id) + LENGTH(',' || usim_spo.get_dim_coord(p_usim_id_spc, l_dim)) > 32767
        THEN
          usim_erl.log_error('usim_spo.get_coord_id', 'Too much dimensions to build coordinate id within system limits for space id [' || p_usim_id_spc || '].');
          RETURN NULL;
        END IF;
        IF l_dim = 0
        THEN
          l_coord_id := l_coord_id || usim_spo.get_dim_coord(p_usim_id_spc, l_dim);
        ELSE
          l_coord_id := l_coord_id || ',' || usim_spo.get_dim_coord(p_usim_id_spc, l_dim);
        END IF;
      END LOOP;
      RETURN l_coord_id;
    ELSE
      usim_erl.log_error('usim_spo.get_coord_id', 'Used with invalid space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  END get_coord_id
  ;

  FUNCTION is_axis_zero_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spo_v
     WHERE usim_id_spc      = p_usim_id_spc
       AND usim_coordinate != 0
    ;

    RETURN (CASE WHEN l_result > 0 THEN 0 ELSE 1 END);
  END is_axis_zero_pos
  ;

  FUNCTION is_axis_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    -- zero axis is axis
    IF usim_spo.is_axis_zero_pos(p_usim_id_spc) = 1
    THEN
      RETURN 1;
    END IF;
    -- get axis if not zero axis
    SELECT COUNT(*)
      INTO l_result
      FROM usim_spo_v
     WHERE usim_coordinate != 0
       AND usim_id_spc      = p_usim_id_spc
     GROUP BY usim_id_spc
    ;
    IF l_result = 1
    THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  END is_axis_pos
  ;

  FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result            usim_space.usim_id_spc%TYPE;
  BEGIN
    IF usim_spo.has_axis_max_pos_parent(p_usim_id_spc) = 1
    THEN
      -- fetch data
        WITH known AS
             (SELECT usim_id_spc
                   , usim_spo.is_axis_pos(usim_id_spc) AS is_axis
                   , usim_coordinate
                   , usim_id_rmd
                   , dim_sign
                FROM usim_spc_v
               WHERE usim_id_rmd = (SELECT usim_id_rmd FROM usim_space WHERE usim_id_spc = p_usim_id_spc)
             )
           , maxpos AS
             (SELECT CASE
                       WHEN dim_sign >= 0
                       THEN MAX(usim_coordinate)
                       ELSE MIN(usim_coordinate)
                     END                         AS parent_pos
                   , usim_id_rmd
                   , dim_sign
                FROM known
               WHERE is_axis = 1
               GROUP BY usim_id_rmd
                      , dim_sign
             )
      SELECT known.usim_id_spc
        INTO l_result
        FROM known
       INNER JOIN maxpos
          ON known.usim_coordinate  = maxpos.parent_pos
         AND known.usim_id_rmd      = maxpos.usim_id_rmd
         AND known.dim_sign         = maxpos.dim_sign
       WHERE known.is_axis = 1
      ;
      RETURN l_result;
    ELSE
      RETURN NULL;
    END IF;
  END get_axis_max_pos_parent
  ;

  FUNCTION get_axis_zero_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result            usim_space.usim_id_spc%TYPE;
  BEGIN
    -- fetch data
      WITH known AS
           (SELECT usim_id_spc
                 , usim_spo.is_axis_pos(usim_id_spc) AS is_axis
                 , usim_coordinate
                 , usim_id_rmd
                 , dim_sign
              FROM usim_spc_v
             WHERE usim_id_rmd     = (SELECT usim_id_rmd FROM usim_space WHERE usim_id_spc = p_usim_id_spc)
               AND usim_coordinate = 0
           )
    SELECT known.usim_id_spc
      INTO l_result
      FROM known
     WHERE known.is_axis = 1
    ;
    RETURN l_result;
  END get_axis_zero_pos_parent
  ;

  FUNCTION insert_spc_pos( p_usim_id_spc        IN usim_space.usim_id_spc%TYPE
                         , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
                         , p_do_commit          IN BOOLEAN                     DEFAULT TRUE
                         )
    RETURN NUMBER
  IS
    l_dim     usim_dimension.usim_n_dimension%TYPE;
    l_id_mlv  usim_multiverse.usim_id_mlv%TYPE;

    CURSOR cur_dims( cp_usim_id_spc        IN usim_space.usim_id_spc%TYPE
                   , cp_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
                   , cp_usim_id_mlv        IN usim_multiverse.usim_id_mlv%TYPE
                   )
    IS
        WITH org_dim AS
             (SELECT /*+MATERIALIZE */
                     usim_n_dimension
                FROM usim_spo_v
               WHERE usim_id_spc = cp_usim_id_spc
                     -- consider only the universe of the given new space id
                 AND usim_id_mlv = cp_usim_id_mlv
             )
      SELECT usim_id_rmd
           , usim_id_pos
        FROM usim_spo_v
             -- parent might be in a different universe, so no positions are added from other universes
       WHERE usim_id_spc           = cp_usim_id_spc_parent
         AND usim_id_mlv           = cp_usim_id_mlv
         AND usim_n_dimension NOT IN (SELECT usim_n_dimension FROM org_dim)
-- not sure if to exclude 0 coordinates and dimensions
--         AND (   usim_coordinate  != 0
--              OR usim_n_dimension  = 0
--             )
    ;
  BEGIN
    IF usim_spo.has_data(p_usim_id_spc) = 0
    THEN
      -- insert the new space id
      INSERT INTO usim_spc_pos
        ( usim_id_spc
        , usim_id_rmd
        , usim_id_pos
        )
        SELECT usim_id_spc
             , usim_id_rmd
             , usim_id_pos
          FROM usim_space
         WHERE usim_id_spc = p_usim_id_spc
      ;
    END IF;
    -- check parent
    IF usim_spo.has_data(p_usim_id_spc_parent) = 1
    THEN
      l_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
      -- only lower dimension not present and position > 0, missing dimensions means 0 position in this dimension
      FOR rec IN cur_dims(p_usim_id_spc, p_usim_id_spc_parent, l_id_mlv)
      LOOP
        INSERT INTO usim_spc_pos
          ( usim_id_spc
          , usim_id_rmd
          , usim_id_pos
          )
          VALUES
          ( p_usim_id_spc
          , rec.usim_id_rmd
          , rec.usim_id_pos
          )
        ;
      END LOOP;
    ELSE
      -- if parent is NULL and dimension is 0, everything okay, only one entry otherwise error
      IF p_usim_id_spc_parent IS NOT NULL
      THEN
        SELECT usim_n_dimension INTO l_dim FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc;
        IF l_dim != 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_spo.insert_spc_pos', 'Used with invalid parent space id [' || p_usim_id_spc_parent || '] or wrong dimension > 0.');
          RETURN 0;
        END IF;
      END IF;
    END IF;
    -- everything done, do commit if needed
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN 1;
  END insert_spc_pos
  ;

END usim_spo;

Package Body USIM_SPO kompiliert

SQL> -- package depend view
SQL> @@../VIEW/USIM_SPO_XYZ_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_SPO_XYZ_V (xyzv)
SQL> CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spo_xyz_v AS
  2    SELECT usim_id_spc
  3         , usim_process_spin
  4         , usim_spo.get_dim_coord(usim_id_spc, 1) AS x_coord
  5         , usim_spo.get_dim_coord(usim_id_spc, 2) AS y_coord
  6         , usim_spo.get_dim_coord(usim_id_spc, 3) AS z_coord
  7         , usim_spo.get_xyz(usim_id_spc) AS xyz_coord
  8         , usim_n_dimension
  9         , dim_sign
 10         , dim_n1_sign
 11         , usim_id_mlv
 12         , usim_energy
 13      FROM usim_spc_v
 14  ;
alt:CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spo_xyz_v AS
  SELECT usim_id_spc
       , usim_process_spin
       , usim_spo.get_dim_coord(usim_id_spc, 1) AS x_coord
       , usim_spo.get_dim_coord(usim_id_spc, 2) AS y_coord
       , usim_spo.get_dim_coord(usim_id_spc, 3) AS z_coord
       , usim_spo.get_xyz(usim_id_spc) AS xyz_coord
       , usim_n_dimension
       , dim_sign
       , dim_n1_sign
       , usim_id_mlv
       , usim_energy
    FROM usim_spc_v

neu:CREATE OR REPLACE VIEW USIM_TEST.usim_spo_xyz_v AS
  SELECT usim_id_spc
       , usim_process_spin
       , usim_spo.get_dim_coord(usim_id_spc, 1) AS x_coord
       , usim_spo.get_dim_coord(usim_id_spc, 2) AS y_coord
       , usim_spo.get_dim_coord(usim_id_spc, 3) AS z_coord
       , usim_spo.get_xyz(usim_id_spc) AS xyz_coord
       , usim_n_dimension
       , dim_sign
       , dim_n1_sign
       , usim_id_mlv
       , usim_energy
    FROM usim_spc_v

View USIM_TEST.USIM_SPO_XYZ_V erstellt.

SQL> @@../VIEW/USIM_SPO_BASE3D_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_SPO_BASE3D_V (spb3d)
SQL> CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spo_base3d_v AS
  2      WITH base AS
  3           (SELECT /*+ MATERIALIZE */
  4                   usim_spo.get_xyz(chi.usim_id_spc)          AS src_xyz
  5                 , usim_spo.get_xyz(chi.usim_id_spc_child)    AS tgt_xyz
  6                 , usim_spo.get_magnitude(chi.usim_id_spc, 3) AS src_mag
  7                 , src.usim_n_dimension                       AS src_dim
  8                 , tgt.usim_n_dimension                       AS tgt_dim
  9                 , src.dim_sign                               AS src_dim_sign
 10                 , tgt.dim_sign                               AS tgt_dim_sign
 11                 , src.usim_id_mlv                            AS src_id_mlv
 12              FROM usim_spc_child chi
 13              LEFT OUTER JOIN usim_spc_v src
 14                ON chi.usim_id_spc = src.usim_id_spc
 15              LEFT OUTER JOIN usim_spc_v tgt
 16                ON chi.usim_id_spc_child = tgt.usim_id_spc
 17             WHERE src.usim_n_dimension <= 3
 18               AND tgt.usim_n_dimension <= 3
 19               AND src.usim_id_mlv       = tgt.usim_id_mlv -- no inter universe connects
 20           )
 21         , grp_prep AS
 22           (SELECT src_xyz
 23                 , tgt_xyz
 24                 , src_mag
 25                 , CASE
 26                     WHEN src_xyz = '0,0,0'
 27                      AND src_xyz = tgt_xyz
 28                     THEN 0
 29                     ELSE src_dim
 30                   END                        AS src_dim
 31                 , CASE
 32                     WHEN src_xyz = '0,0,0'
 33                      AND src_xyz = tgt_xyz
 34                     THEN 1
 35                     ELSE tgt_dim
 36                   END                        AS tgt_dim
 37                 , CASE
 38                     WHEN src_xyz = '0,0,0'
 39                      AND src_xyz = tgt_xyz
 40                     THEN 0
 41                     ELSE src_dim_sign
 42                   END                        AS src_dim_sign
 43                 , CASE
 44                     WHEN src_xyz = '0,0,0'
 45                      AND src_xyz = tgt_xyz
 46                     THEN 0
 47                     ELSE tgt_dim_sign
 48                   END                        AS tgt_dim_sign
 49                 , src_id_mlv
 50              FROM base
 51           )
 52    SELECT src_xyz
 53         , tgt_xyz
 54         , src_mag
 55         , src_dim
 56         , tgt_dim
 57         , src_dim_sign
 58         , tgt_dim_sign
 59         , src_id_mlv     AS usim_id_mlv
 60      FROM grp_prep
 61     GROUP BY src_id_mlv
 62            , src_xyz
 63            , tgt_xyz
 64            , src_mag
 65            , src_dim
 66            , tgt_dim
 67            , src_dim_sign
 68            , tgt_dim_sign
 69     ORDER BY src_id_mlv
 70            , src_mag
 71            , src_dim
 72            , tgt_dim
 73            , src_dim_sign DESC
 74            , tgt_dim_sign DESC
 75            , src_xyz
 76            , tgt_xyz
 77  ;
alt:CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spo_base3d_v AS
    WITH base AS
         (SELECT /*+ MATERIALIZE */
                 usim_spo.get_xyz(chi.usim_id_spc)          AS src_xyz
               , usim_spo.get_xyz(chi.usim_id_spc_child)    AS tgt_xyz
               , usim_spo.get_magnitude(chi.usim_id_spc, 3) AS src_mag
               , src.usim_n_dimension                       AS src_dim
               , tgt.usim_n_dimension                       AS tgt_dim
               , src.dim_sign                               AS src_dim_sign
               , tgt.dim_sign                               AS tgt_dim_sign
               , src.usim_id_mlv                            AS src_id_mlv
            FROM usim_spc_child chi
            LEFT OUTER JOIN usim_spc_v src
              ON chi.usim_id_spc = src.usim_id_spc
            LEFT OUTER JOIN usim_spc_v tgt
              ON chi.usim_id_spc_child = tgt.usim_id_spc
           WHERE src.usim_n_dimension <= 3
             AND tgt.usim_n_dimension <= 3
             AND src.usim_id_mlv       = tgt.usim_id_mlv -- no inter universe connects
         )
       , grp_prep AS
         (SELECT src_xyz
               , tgt_xyz
               , src_mag
               , CASE
                   WHEN src_xyz = '0,0,0'
                    AND src_xyz = tgt_xyz
                   THEN 0
                   ELSE src_dim
                 END                        AS src_dim
               , CASE
                   WHEN src_xyz = '0,0,0'
                    AND src_xyz = tgt_xyz
                   THEN 1
                   ELSE tgt_dim
                 END                        AS tgt_dim
               , CASE
                   WHEN src_xyz = '0,0,0'
                    AND src_xyz = tgt_xyz
                   THEN 0
                   ELSE src_dim_sign
                 END                        AS src_dim_sign
               , CASE
                   WHEN src_xyz = '0,0,0'
                    AND src_xyz = tgt_xyz
                   THEN 0
                   ELSE tgt_dim_sign
                 END                        AS tgt_dim_sign
               , src_id_mlv
            FROM base
         )
  SELECT src_xyz
       , tgt_xyz
       , src_mag
       , src_dim
       , tgt_dim
       , src_dim_sign
       , tgt_dim_sign
       , src_id_mlv     AS usim_id_mlv
    FROM grp_prep
   GROUP BY src_id_mlv
          , src_xyz
          , tgt_xyz
          , src_mag
          , src_dim
          , tgt_dim
          , src_dim_sign
          , tgt_dim_sign
   ORDER BY src_id_mlv
          , src_mag
          , src_dim
          , tgt_dim
          , src_dim_sign DESC
          , tgt_dim_sign DESC
          , src_xyz
          , tgt_xyz

neu:CREATE OR REPLACE VIEW USIM_TEST.usim_spo_base3d_v AS
    WITH base AS
         (SELECT /*+ MATERIALIZE */
                 usim_spo.get_xyz(chi.usim_id_spc)          AS src_xyz
               , usim_spo.get_xyz(chi.usim_id_spc_child)    AS tgt_xyz
               , usim_spo.get_magnitude(chi.usim_id_spc, 3) AS src_mag
               , src.usim_n_dimension                       AS src_dim
               , tgt.usim_n_dimension                       AS tgt_dim
               , src.dim_sign                               AS src_dim_sign
               , tgt.dim_sign                               AS tgt_dim_sign
               , src.usim_id_mlv                            AS src_id_mlv
            FROM usim_spc_child chi
            LEFT OUTER JOIN usim_spc_v src
              ON chi.usim_id_spc = src.usim_id_spc
            LEFT OUTER JOIN usim_spc_v tgt
              ON chi.usim_id_spc_child = tgt.usim_id_spc
           WHERE src.usim_n_dimension <= 3
             AND tgt.usim_n_dimension <= 3
             AND src.usim_id_mlv       = tgt.usim_id_mlv -- no inter universe connects
         )
       , grp_prep AS
         (SELECT src_xyz
               , tgt_xyz
               , src_mag
               , CASE
                   WHEN src_xyz = '0,0,0'
                    AND src_xyz = tgt_xyz
                   THEN 0
                   ELSE src_dim
                 END                        AS src_dim
               , CASE
                   WHEN src_xyz = '0,0,0'
                    AND src_xyz = tgt_xyz
                   THEN 1
                   ELSE tgt_dim
                 END                        AS tgt_dim
               , CASE
                   WHEN src_xyz = '0,0,0'
                    AND src_xyz = tgt_xyz
                   THEN 0
                   ELSE src_dim_sign
                 END                        AS src_dim_sign
               , CASE
                   WHEN src_xyz = '0,0,0'
                    AND src_xyz = tgt_xyz
                   THEN 0
                   ELSE tgt_dim_sign
                 END                        AS tgt_dim_sign
               , src_id_mlv
            FROM base
         )
  SELECT src_xyz
       , tgt_xyz
       , src_mag
       , src_dim
       , tgt_dim
       , src_dim_sign
       , tgt_dim_sign
       , src_id_mlv     AS usim_id_mlv
    FROM grp_prep
   GROUP BY src_id_mlv
          , src_xyz
          , tgt_xyz
          , src_mag
          , src_dim
          , tgt_dim
          , src_dim_sign
          , tgt_dim_sign
   ORDER BY src_id_mlv
          , src_mag
          , src_dim
          , tgt_dim
          , src_dim_sign DESC
          , tgt_dim_sign DESC
          , src_xyz
          , tgt_xyz

View USIM_TEST.USIM_SPO_BASE3D_V erstellt.

SQL> @@../VIEW/USIM_SPO_ZERO3D_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_SPO_ZERO3D_V (spz3d)
SQL> CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spo_zero3d_v AS
  2      WITH base AS
  3           (SELECT /*+ MATERIALIZE */
  4                   usim_spo.get_xyz(chi.usim_id_spc)          AS src_xyz
  5                 , usim_spo.get_xyz(chi.usim_id_spc_child)    AS tgt_xyz
  6                 , usim_spo.get_magnitude(chi.usim_id_spc, 3) AS src_mag
  7                 , src.usim_n_dimension                       AS src_dim
  8                 , tgt.usim_n_dimension                       AS tgt_dim
  9                 , src.dim_sign                               AS src_dim_sign
 10                 , tgt.dim_sign                               AS tgt_dim_sign
 11                 , src.dim_n1_sign                            AS src_n1_sign
 12                 , tgt.dim_n1_sign                            AS tgt_n1_sign
 13                 , src.usim_id_mlv                            AS src_id_mlv
 14              FROM usim_spc_child chi
 15              LEFT OUTER JOIN usim_spc_v src
 16                ON chi.usim_id_spc = src.usim_id_spc
 17              LEFT OUTER JOIN usim_spc_v tgt
 18                ON chi.usim_id_spc_child = tgt.usim_id_spc
 19             WHERE src.usim_n_dimension <= 3
 20               AND tgt.usim_n_dimension <= 3
 21               AND src.usim_id_mlv       = tgt.usim_id_mlv -- no inter universe connects
 22           )
 23    SELECT src_xyz
 24         , tgt_xyz
 25         , src_mag
 26         , src_dim
 27         , tgt_dim
 28         , src_dim_sign
 29         , tgt_dim_sign
 30         , src_n1_sign
 31         , tgt_n1_sign
 32         , src_id_mlv     AS usim_id_mlv
 33      FROM base
 34     GROUP BY src_id_mlv
 35            , src_xyz
 36            , tgt_xyz
 37            , src_mag
 38            , src_dim
 39            , tgt_dim
 40            , src_dim_sign
 41            , tgt_dim_sign
 42            , src_n1_sign
 43            , tgt_n1_sign
 44     ORDER BY src_id_mlv
 45            , src_mag
 46            , src_dim
 47            , tgt_dim
 48            , src_dim_sign DESC
 49            , tgt_dim_sign DESC
 50            , src_n1_sign DESC
 51            , tgt_n1_sign DESC
 52            , src_xyz
 53            , tgt_xyz
 54  ;
alt:CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spo_zero3d_v AS
    WITH base AS
         (SELECT /*+ MATERIALIZE */
                 usim_spo.get_xyz(chi.usim_id_spc)          AS src_xyz
               , usim_spo.get_xyz(chi.usim_id_spc_child)    AS tgt_xyz
               , usim_spo.get_magnitude(chi.usim_id_spc, 3) AS src_mag
               , src.usim_n_dimension                       AS src_dim
               , tgt.usim_n_dimension                       AS tgt_dim
               , src.dim_sign                               AS src_dim_sign
               , tgt.dim_sign                               AS tgt_dim_sign
               , src.dim_n1_sign                            AS src_n1_sign
               , tgt.dim_n1_sign                            AS tgt_n1_sign
               , src.usim_id_mlv                            AS src_id_mlv
            FROM usim_spc_child chi
            LEFT OUTER JOIN usim_spc_v src
              ON chi.usim_id_spc = src.usim_id_spc
            LEFT OUTER JOIN usim_spc_v tgt
              ON chi.usim_id_spc_child = tgt.usim_id_spc
           WHERE src.usim_n_dimension <= 3
             AND tgt.usim_n_dimension <= 3
             AND src.usim_id_mlv       = tgt.usim_id_mlv -- no inter universe connects
         )
  SELECT src_xyz
       , tgt_xyz
       , src_mag
       , src_dim
       , tgt_dim
       , src_dim_sign
       , tgt_dim_sign
       , src_n1_sign
       , tgt_n1_sign
       , src_id_mlv     AS usim_id_mlv
    FROM base
   GROUP BY src_id_mlv
          , src_xyz
          , tgt_xyz
          , src_mag
          , src_dim
          , tgt_dim
          , src_dim_sign
          , tgt_dim_sign
          , src_n1_sign
          , tgt_n1_sign
   ORDER BY src_id_mlv
          , src_mag
          , src_dim
          , tgt_dim
          , src_dim_sign DESC
          , tgt_dim_sign DESC
          , src_n1_sign DESC
          , tgt_n1_sign DESC
          , src_xyz
          , tgt_xyz

neu:CREATE OR REPLACE VIEW USIM_TEST.usim_spo_zero3d_v AS
    WITH base AS
         (SELECT /*+ MATERIALIZE */
                 usim_spo.get_xyz(chi.usim_id_spc)          AS src_xyz
               , usim_spo.get_xyz(chi.usim_id_spc_child)    AS tgt_xyz
               , usim_spo.get_magnitude(chi.usim_id_spc, 3) AS src_mag
               , src.usim_n_dimension                       AS src_dim
               , tgt.usim_n_dimension                       AS tgt_dim
               , src.dim_sign                               AS src_dim_sign
               , tgt.dim_sign                               AS tgt_dim_sign
               , src.dim_n1_sign                            AS src_n1_sign
               , tgt.dim_n1_sign                            AS tgt_n1_sign
               , src.usim_id_mlv                            AS src_id_mlv
            FROM usim_spc_child chi
            LEFT OUTER JOIN usim_spc_v src
              ON chi.usim_id_spc = src.usim_id_spc
            LEFT OUTER JOIN usim_spc_v tgt
              ON chi.usim_id_spc_child = tgt.usim_id_spc
           WHERE src.usim_n_dimension <= 3
             AND tgt.usim_n_dimension <= 3
             AND src.usim_id_mlv       = tgt.usim_id_mlv -- no inter universe connects
         )
  SELECT src_xyz
       , tgt_xyz
       , src_mag
       , src_dim
       , tgt_dim
       , src_dim_sign
       , tgt_dim_sign
       , src_n1_sign
       , tgt_n1_sign
       , src_id_mlv     AS usim_id_mlv
    FROM base
   GROUP BY src_id_mlv
          , src_xyz
          , tgt_xyz
          , src_mag
          , src_dim
          , tgt_dim
          , src_dim_sign
          , tgt_dim_sign
          , src_n1_sign
          , tgt_n1_sign
   ORDER BY src_id_mlv
          , src_mag
          , src_dim
          , tgt_dim
          , src_dim_sign DESC
          , tgt_dim_sign DESC
          , src_n1_sign DESC
          , tgt_n1_sign DESC
          , src_xyz
          , tgt_xyz

View USIM_TEST.USIM_SPO_ZERO3D_V erstellt.

SQL> -- USIM_SPC_PROCESS (SPR)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_SPC_PROCESS_TBL.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPC_PROCESS still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_PROCESS'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_SPC_PROCESS_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPC_PROCESS still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_PROCESS'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_SPC_PROCESS_TBL.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPC_PROCESS still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_SPC_PROCESS'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------------
../TABLES/USIM_SPC_PROCESS_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_SPC_PROCESS (SPR)
SQL> CREATE TABLE &USIM_SCHEMA..usim_spc_process
  2    ( usim_id_spr        CHAR(55)                     NOT NULL ENABLE
  3    , usim_planck_aeon   CHAR(55)                     NOT NULL ENABLE
  4    , usim_planck_time   NUMBER                       NOT NULL ENABLE
  5    , usim_id_spc_source CHAR(55)                     NOT NULL ENABLE
  6    , usim_id_spc_target CHAR(55)                     NOT NULL ENABLE
  7    , usim_real_time     DATE         DEFAULT SYSDATE NOT NULL ENABLE
  8    , is_processed       NUMBER(1, 0) DEFAULT 0       NOT NULL ENABLE
  9    , usim_energy_source NUMBER
 10    , usim_energy_target NUMBER
 11    , usim_energy_output NUMBER
 12    )
 13    PARTITION BY RANGE (usim_real_time)
 14      INTERVAL (NUMTODSINTERVAL(1, 'DAY'))
 15      (PARTITION p_first VALUES LESS THAN (TO_DATE('01.01.2023', 'DD.MM.YYYY')))
 16  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_spc_process
  ( usim_id_spr        CHAR(55)                     NOT NULL ENABLE
  , usim_planck_aeon   CHAR(55)                     NOT NULL ENABLE
  , usim_planck_time   NUMBER                       NOT NULL ENABLE
  , usim_id_spc_source CHAR(55)                     NOT NULL ENABLE
  , usim_id_spc_target CHAR(55)                     NOT NULL ENABLE
  , usim_real_time     DATE         DEFAULT SYSDATE NOT NULL ENABLE
  , is_processed       NUMBER(1, 0) DEFAULT 0       NOT NULL ENABLE
  , usim_energy_source NUMBER
  , usim_energy_target NUMBER
  , usim_energy_output NUMBER
  )
  PARTITION BY RANGE (usim_real_time)
    INTERVAL (NUMTODSINTERVAL(1, 'DAY'))
    (PARTITION p_first VALUES LESS THAN (TO_DATE('01.01.2023', 'DD.MM.YYYY')))

neu:CREATE TABLE USIM_TEST.usim_spc_process
  ( usim_id_spr        CHAR(55)                     NOT NULL ENABLE
  , usim_planck_aeon   CHAR(55)                     NOT NULL ENABLE
  , usim_planck_time   NUMBER                       NOT NULL ENABLE
  , usim_id_spc_source CHAR(55)                     NOT NULL ENABLE
  , usim_id_spc_target CHAR(55)                     NOT NULL ENABLE
  , usim_real_time     DATE         DEFAULT SYSDATE NOT NULL ENABLE
  , is_processed       NUMBER(1, 0) DEFAULT 0       NOT NULL ENABLE
  , usim_energy_source NUMBER
  , usim_energy_target NUMBER
  , usim_energy_output NUMBER
  )
  PARTITION BY RANGE (usim_real_time)
    INTERVAL (NUMTODSINTERVAL(1, 'DAY'))
    (PARTITION p_first VALUES LESS THAN (TO_DATE('01.01.2023', 'DD.MM.YYYY')))

Table USIM_TEST.USIM_SPC_PROCESS erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_spc_process IS 'Holds the log of all space activity. Will use the alias spr.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_spc_process IS 'Holds the log of all space activity. Will use the alias spr.'
neu:COMMENT ON TABLE USIM_TEST.usim_spc_process IS 'Holds the log of all space activity. Will use the alias spr.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_id_spr IS 'The unique id of a process step. Will be set on insert.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_id_spr IS 'The unique id of a process step. Will be set on insert.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_id_spr IS 'The unique id of a process step. Will be set on insert.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_planck_aeon IS 'The current planck aeon of the energy output. Only insert allowed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_planck_aeon IS 'The current planck aeon of the energy output. Only insert allowed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_planck_aeon IS 'The current planck aeon of the energy output. Only insert allowed.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_planck_time IS 'The current planck time relative to the planck aeon of the energy output. Only insert allowed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_planck_time IS 'The current planck time relative to the planck aeon of the energy output. Only insert allowed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_planck_time IS 'The current planck time relative to the planck aeon of the energy output. Only insert allowed.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_id_spc_source IS 'The space node id of the energy source, which will output energy to the target. Only insert allowed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_id_spc_source IS 'The space node id of the energy source, which will output energy to the target. Only insert allowed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_id_spc_source IS 'The space node id of the energy source, which will output energy to the target. Only insert allowed.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_id_spc_target IS 'The space node id of the target, which will receive the energy output from the source. Only insert allowed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_id_spc_target IS 'The space node id of the target, which will receive the energy output from the source. Only insert allowed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_id_spc_target IS 'The space node id of the target, which will receive the energy output from the source. Only insert allowed.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_real_time IS 'The real date time of the simulation. Automatically set.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_real_time IS 'The real date time of the simulation. Automatically set.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_real_time IS 'The real date time of the simulation. Automatically set.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.is_processed IS 'The indicator for processed outputs. On creation 0, after output applied 1, if universe of target not valid 2. Only updates allowed. Any update sets this to 1 (processed).';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.is_processed IS 'The indicator for processed outputs. On creation 0, after output applied 1, if universe of target not valid 2. Only updates allowed. Any update sets this to 1 (processed).'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_process.is_processed IS 'The indicator for processed outputs. On creation 0, after output applied 1, if universe of target not valid 2. Only updates allowed. Any update sets this to 1 (processed).'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_energy_source IS 'The energy of the source, which was the base of the calculated output before processing. Only insert allowed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_energy_source IS 'The energy of the source, which was the base of the calculated output before processing. Only insert allowed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_energy_source IS 'The energy of the source, which was the base of the calculated output before processing. Only insert allowed.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_energy_target IS 'The energy of the target before processing. Only insert allowed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_energy_target IS 'The energy of the target before processing. Only insert allowed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_energy_target IS 'The energy of the target before processing. Only insert allowed.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_energy_output IS 'The output energy of the source that has to be applied to the target. Only insert allowed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_energy_output IS 'The output energy of the source that has to be applied to the target. Only insert allowed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_energy_output IS 'The output energy of the source that has to be applied to the target. Only insert allowed.'

Comment erstellt.

SQL>
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_process
  2    ADD CONSTRAINT usim_spr_pk
  3    PRIMARY KEY (usim_id_spr)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_spc_process
  ADD CONSTRAINT usim_spr_pk
  PRIMARY KEY (usim_id_spr)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_spc_process
  ADD CONSTRAINT usim_spr_pk
  PRIMARY KEY (usim_id_spr)
  ENABLE

Table USIM_TEST.USIM_SPC_PROCESS geändert.

SQL> -- indexes
SQL> CREATE INDEX &USIM_SCHEMA..usim_spr_src_idx
  2      ON &USIM_SCHEMA..usim_spc_process
  3         ( usim_planck_aeon
  4         , usim_planck_time
  5         , usim_id_spc_source
  6         )
  7  ;
alt:CREATE INDEX &USIM_SCHEMA..usim_spr_src_idx
    ON &USIM_SCHEMA..usim_spc_process
       ( usim_planck_aeon
       , usim_planck_time
       , usim_id_spc_source
       )

neu:CREATE INDEX USIM_TEST.usim_spr_src_idx
    ON USIM_TEST.usim_spc_process
       ( usim_planck_aeon
       , usim_planck_time
       , usim_id_spc_source
       )

Index USIM_TEST.USIM_SPR_SRC_IDX erstellt.

SQL>
SQL> CREATE INDEX &USIM_SCHEMA..usim_spr_tgt_idx
  2      ON &USIM_SCHEMA..usim_spc_process
  3         ( usim_planck_aeon
  4         , usim_planck_time
  5         , usim_id_spc_target
  6         )
  7  ;
alt:CREATE INDEX &USIM_SCHEMA..usim_spr_tgt_idx
    ON &USIM_SCHEMA..usim_spc_process
       ( usim_planck_aeon
       , usim_planck_time
       , usim_id_spc_target
       )

neu:CREATE INDEX USIM_TEST.usim_spr_tgt_idx
    ON USIM_TEST.usim_spc_process
       ( usim_planck_aeon
       , usim_planck_time
       , usim_id_spc_target
       )

Index USIM_TEST.USIM_SPR_TGT_IDX erstellt.

SQL> -- constraints
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_process
  2    ADD CONSTRAINT usim_processed_chk
  3    CHECK (is_processed IN (0, 1, 2))
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_spc_process
  ADD CONSTRAINT usim_processed_chk
  CHECK (is_processed IN (0, 1, 2))
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_spc_process
  ADD CONSTRAINT usim_processed_chk
  CHECK (is_processed IN (0, 1, 2))
  ENABLE

Table USIM_TEST.USIM_SPC_PROCESS geändert.

SQL>
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spr_ins_trg
  2    -- set insert values that can not be changed on insert
  3    BEFORE INSERT ON &USIM_SCHEMA..usim_spc_process
  4      FOR EACH ROW
  5      BEGIN
  6        -- ignore input on pk, is_processed and real time
  7        :NEW.usim_id_spr := usim_static.get_big_pk(usim_spr_id_seq.NEXTVAL);
  8        :NEW.is_processed   := 0;
  9        :NEW.usim_real_time := SYSDATE;
 10      END;
 11  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spr_ins_trg
  -- set insert values that can not be changed on insert
  BEFORE INSERT ON &USIM_SCHEMA..usim_spc_process
    FOR EACH ROW
    BEGIN
      -- ignore input on pk, is_processed and real time
      :NEW.usim_id_spr := usim_static.get_big_pk(usim_spr_id_seq.NEXTVAL);
      :NEW.is_processed   := 0;
      :NEW.usim_real_time := SYSDATE;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_spr_ins_trg
  -- set insert values that can not be changed on insert
  BEFORE INSERT ON USIM_TEST.usim_spc_process
    FOR EACH ROW
    BEGIN
      -- ignore input on pk, is_processed and real time
      :NEW.usim_id_spr := usim_static.get_big_pk(usim_spr_id_seq.NEXTVAL);
      :NEW.is_processed   := 0;
      :NEW.usim_real_time := SYSDATE;
    END;

Trigger USIM_SPR_INS_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_spr_ins_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_spr_ins_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_spr_ins_trg ENABLE

Trigger USIM_TEST.USIM_SPR_INS_TRG geändert.

SQL>  -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spr_upd_trg
  2    -- set insert values that can not be changed on insert
  3    BEFORE UPDATE ON &USIM_SCHEMA..usim_spc_process
  4      FOR EACH ROW
  5      BEGIN
  6        IF :NEW.usim_id_spr != :OLD.usim_id_spr
  7        THEN
  8          :NEW.usim_id_spr := :OLD.usim_id_spr;
  9        END IF;
 10        IF :NEW.usim_planck_aeon != :OLD.usim_planck_aeon
 11        THEN
 12          :NEW.usim_planck_aeon := :OLD.usim_planck_aeon;
 13        END IF;
 14        IF :NEW.usim_planck_time != :OLD.usim_planck_time
 15        THEN
 16          :NEW.usim_planck_time := :OLD.usim_planck_time;
 17        END IF;
 18        IF :NEW.usim_id_spc_source != :OLD.usim_id_spc_source
 19        THEN
 20          :NEW.usim_id_spc_source := :OLD.usim_id_spc_source;
 21        END IF;
 22        IF :NEW.usim_id_spc_target != :OLD.usim_id_spc_target
 23        THEN
 24          :NEW.usim_id_spc_target := :OLD.usim_id_spc_target;
 25        END IF;
 26        IF :NEW.usim_real_time != :OLD.usim_real_time
 27        THEN
 28          :NEW.usim_real_time := :OLD.usim_real_time;
 29        END IF;
 30        IF :NEW.usim_energy_source != :OLD.usim_energy_source
 31        THEN
 32          :NEW.usim_energy_source := :OLD.usim_energy_source;
 33        END IF;
 34        IF :NEW.usim_energy_target != :OLD.usim_energy_target
 35        THEN
 36          :NEW.usim_energy_target := :OLD.usim_energy_target;
 37        END IF;
 38        IF :NEW.usim_energy_output != :OLD.usim_energy_output
 39        THEN
 40          :NEW.usim_energy_output := :OLD.usim_energy_output;
 41        END IF;
 42      END;
 43  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spr_upd_trg
  -- set insert values that can not be changed on insert
  BEFORE UPDATE ON &USIM_SCHEMA..usim_spc_process
    FOR EACH ROW
    BEGIN
      IF :NEW.usim_id_spr != :OLD.usim_id_spr
      THEN
        :NEW.usim_id_spr := :OLD.usim_id_spr;
      END IF;
      IF :NEW.usim_planck_aeon != :OLD.usim_planck_aeon
      THEN
        :NEW.usim_planck_aeon := :OLD.usim_planck_aeon;
      END IF;
      IF :NEW.usim_planck_time != :OLD.usim_planck_time
      THEN
        :NEW.usim_planck_time := :OLD.usim_planck_time;
      END IF;
      IF :NEW.usim_id_spc_source != :OLD.usim_id_spc_source
      THEN
        :NEW.usim_id_spc_source := :OLD.usim_id_spc_source;
      END IF;
      IF :NEW.usim_id_spc_target != :OLD.usim_id_spc_target
      THEN
        :NEW.usim_id_spc_target := :OLD.usim_id_spc_target;
      END IF;
      IF :NEW.usim_real_time != :OLD.usim_real_time
      THEN
        :NEW.usim_real_time := :OLD.usim_real_time;
      END IF;
      IF :NEW.usim_energy_source != :OLD.usim_energy_source
      THEN
        :NEW.usim_energy_source := :OLD.usim_energy_source;
      END IF;
      IF :NEW.usim_energy_target != :OLD.usim_energy_target
      THEN
        :NEW.usim_energy_target := :OLD.usim_energy_target;
      END IF;
      IF :NEW.usim_energy_output != :OLD.usim_energy_output
      THEN
        :NEW.usim_energy_output := :OLD.usim_energy_output;
      END IF;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_spr_upd_trg
  -- set insert values that can not be changed on insert
  BEFORE UPDATE ON USIM_TEST.usim_spc_process
    FOR EACH ROW
    BEGIN
      IF :NEW.usim_id_spr != :OLD.usim_id_spr
      THEN
        :NEW.usim_id_spr := :OLD.usim_id_spr;
      END IF;
      IF :NEW.usim_planck_aeon != :OLD.usim_planck_aeon
      THEN
        :NEW.usim_planck_aeon := :OLD.usim_planck_aeon;
      END IF;
      IF :NEW.usim_planck_time != :OLD.usim_planck_time
      THEN
        :NEW.usim_planck_time := :OLD.usim_planck_time;
      END IF;
      IF :NEW.usim_id_spc_source != :OLD.usim_id_spc_source
      THEN
        :NEW.usim_id_spc_source := :OLD.usim_id_spc_source;
      END IF;
      IF :NEW.usim_id_spc_target != :OLD.usim_id_spc_target
      THEN
        :NEW.usim_id_spc_target := :OLD.usim_id_spc_target;
      END IF;
      IF :NEW.usim_real_time != :OLD.usim_real_time
      THEN
        :NEW.usim_real_time := :OLD.usim_real_time;
      END IF;
      IF :NEW.usim_energy_source != :OLD.usim_energy_source
      THEN
        :NEW.usim_energy_source := :OLD.usim_energy_source;
      END IF;
      IF :NEW.usim_energy_target != :OLD.usim_energy_target
      THEN
        :NEW.usim_energy_target := :OLD.usim_energy_target;
      END IF;
      IF :NEW.usim_energy_output != :OLD.usim_energy_output
      THEN
        :NEW.usim_energy_output := :OLD.usim_energy_output;
      END IF;
    END;

Trigger USIM_SPR_UPD_TRG kompiliert

SQL>  ALTER TRIGGER &USIM_SCHEMA..usim_spr_upd_trg ENABLE;
alt: ALTER TRIGGER &USIM_SCHEMA..usim_spr_upd_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_spr_upd_trg ENABLE

Trigger USIM_TEST.USIM_SPR_UPD_TRG geändert.

SQL> -- foreign keys
SQL> @@../FK/USIM_SPR_SRC_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk relation to nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_process
  2    ADD CONSTRAINT usim_spr_src_fk
  3    FOREIGN KEY (usim_id_spc_source) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_spc_process
  ADD CONSTRAINT usim_spr_src_fk
  FOREIGN KEY (usim_id_spc_source) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_spc_process
  ADD CONSTRAINT usim_spr_src_fk
  FOREIGN KEY (usim_id_spc_source) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_SPC_PROCESS geändert.

SQL> @@../FK/USIM_SPR_TGT_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- fk relation to nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_process
  2    ADD CONSTRAINT usim_spr_tgt_fk
  3    FOREIGN KEY (usim_id_spc_target) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_spc_process
  ADD CONSTRAINT usim_spr_tgt_fk
  FOREIGN KEY (usim_id_spc_target) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_spc_process
  ADD CONSTRAINT usim_spr_tgt_fk
  FOREIGN KEY (usim_id_spc_target) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  ENABLE

Table USIM_TEST.USIM_SPC_PROCESS geändert.

SQL> -- views
SQL> @@../VIEW/USIM_SPR_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spr_v AS
  2    SELECT spr.is_processed
  3         , xyzv_src.xyz_coord         AS src_xyz -- temporary, must have all dimensions
  4         , xyzv_src.usim_process_spin AS src_spin
  5         , xyzv_src.usim_n_dimension  AS src_dim
  6         , xyzv_src.dim_sign          AS src_dim_sign
  7         , xyzv_src.dim_n1_sign       AS src_dim_n1_sign
  8         , xyzv_tgt.xyz_coord         AS tgt_xyz
  9         , xyzv_tgt.usim_process_spin AS tgt_spin
 10         , xyzv_tgt.usim_n_dimension  AS tgt_dim
 11         , xyzv_tgt.dim_sign          AS tgt_dim_sign
 12         , xyzv_tgt.dim_n1_sign       AS tgt_dim_n1_sign
 13         , spr.usim_energy_source
 14         , spr.usim_energy_output
 15         , spr.usim_energy_target
 16         , spr.usim_id_spc_source
 17         , spr.usim_id_spc_target
 18         , xyzv_src.usim_id_mlv       AS src_id_mlv
 19         , xyzv_tgt.usim_id_mlv       AS tgt_id_mlv
 20         , spr.usim_planck_aeon
 21         , spr.usim_planck_time
 22         , spr.usim_real_time
 23      FROM usim_spc_process spr
 24      LEFT OUTER JOIN usim_spo_xyz_v xyzv_src
 25        ON spr.usim_id_spc_source = xyzv_src.usim_id_spc
 26      LEFT OUTER JOIN usim_spo_xyz_v xyzv_tgt
 27        ON spr.usim_id_spc_target = xyzv_tgt.usim_id_spc
 28           -- provide basic process order as ROWID can only be accessed from here
 29     ORDER BY spr.usim_planck_aeon
 30            , spr.usim_planck_time
 31            , spr.usim_real_time
 32              -- use ROWID order for processes to fast for real time and planck time
 33            , spr.ROWID ASC
 34  ;
alt:CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spr_v AS
  SELECT spr.is_processed
       , xyzv_src.xyz_coord         AS src_xyz -- temporary, must have all dimensions
       , xyzv_src.usim_process_spin AS src_spin
       , xyzv_src.usim_n_dimension  AS src_dim
       , xyzv_src.dim_sign          AS src_dim_sign
       , xyzv_src.dim_n1_sign       AS src_dim_n1_sign
       , xyzv_tgt.xyz_coord         AS tgt_xyz
       , xyzv_tgt.usim_process_spin AS tgt_spin
       , xyzv_tgt.usim_n_dimension  AS tgt_dim
       , xyzv_tgt.dim_sign          AS tgt_dim_sign
       , xyzv_tgt.dim_n1_sign       AS tgt_dim_n1_sign
       , spr.usim_energy_source
       , spr.usim_energy_output
       , spr.usim_energy_target
       , spr.usim_id_spc_source
       , spr.usim_id_spc_target
       , xyzv_src.usim_id_mlv       AS src_id_mlv
       , xyzv_tgt.usim_id_mlv       AS tgt_id_mlv
       , spr.usim_planck_aeon
       , spr.usim_planck_time
       , spr.usim_real_time
    FROM usim_spc_process spr
    LEFT OUTER JOIN usim_spo_xyz_v xyzv_src
      ON spr.usim_id_spc_source = xyzv_src.usim_id_spc
    LEFT OUTER JOIN usim_spo_xyz_v xyzv_tgt
      ON spr.usim_id_spc_target = xyzv_tgt.usim_id_spc
         -- provide basic process order as ROWID can only be accessed from here
   ORDER BY spr.usim_planck_aeon
          , spr.usim_planck_time
          , spr.usim_real_time
            -- use ROWID order for processes to fast for real time and planck time
          , spr.ROWID ASC

neu:CREATE OR REPLACE VIEW USIM_TEST.usim_spr_v AS
  SELECT spr.is_processed
       , xyzv_src.xyz_coord         AS src_xyz -- temporary, must have all dimensions
       , xyzv_src.usim_process_spin AS src_spin
       , xyzv_src.usim_n_dimension  AS src_dim
       , xyzv_src.dim_sign          AS src_dim_sign
       , xyzv_src.dim_n1_sign       AS src_dim_n1_sign
       , xyzv_tgt.xyz_coord         AS tgt_xyz
       , xyzv_tgt.usim_process_spin AS tgt_spin
       , xyzv_tgt.usim_n_dimension  AS tgt_dim
       , xyzv_tgt.dim_sign          AS tgt_dim_sign
       , xyzv_tgt.dim_n1_sign       AS tgt_dim_n1_sign
       , spr.usim_energy_source
       , spr.usim_energy_output
       , spr.usim_energy_target
       , spr.usim_id_spc_source
       , spr.usim_id_spc_target
       , xyzv_src.usim_id_mlv       AS src_id_mlv
       , xyzv_tgt.usim_id_mlv       AS tgt_id_mlv
       , spr.usim_planck_aeon
       , spr.usim_planck_time
       , spr.usim_real_time
    FROM usim_spc_process spr
    LEFT OUTER JOIN usim_spo_xyz_v xyzv_src
      ON spr.usim_id_spc_source = xyzv_src.usim_id_spc
    LEFT OUTER JOIN usim_spo_xyz_v xyzv_tgt
      ON spr.usim_id_spc_target = xyzv_tgt.usim_id_spc
         -- provide basic process order as ROWID can only be accessed from here
   ORDER BY spr.usim_planck_aeon
          , spr.usim_planck_time
          , spr.usim_real_time
            -- use ROWID order for processes to fast for real time and planck time
          , spr.ROWID ASC

View USIM_TEST.USIM_SPR_V erstellt.

SQL> -- usim_spc_process package
SQL> @@../PACKAGES/USIM_SPR.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_spr
  2  IS
  3    /**A low level package for actions on table usim_spc_process and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_BASE and USIM_SPC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9
 10    /**
 11    * Checks if usim_spc_process has already data.
 12    * @return Returns 1 if data are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15      RETURN NUMBER
 16    ;
 17
 18    /**
 19    * Checks if usim_spc_process has already data for a given process id.
 20    * @param p_usim_id_spr The process id to check.
 21    * @return Returns 1 if data are available for this id, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
 24      RETURN NUMBER
 25    ;
 26
 27    /**
 28    * Checks if usim_spc_process has unprocessed data.
 29    * @return Returns 1 if unprocessed data are available, otherwise 0.
 30    */
 31    FUNCTION has_unprocessed
 32      RETURN NUMBER
 33    ;
 34
 35    /**
 36    * Checks if the current unprocessed queue is valid. All unprocessed records must have the current
 37    * planck aeon and time and if the table is not empty, there must be at least 2 process records.
 38    * Count of process records must be a multitude of 2. An empty table will also return 1.
 39    * @return Returns 1 if queue is ready to be processed, otherwise error code: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
 40    */
 41    FUNCTION is_queue_valid
 42      RETURN NUMBER
 43    ;
 44
 45    /**
 46    * Fetches the current planck aeon and time if the queue is valid. Will not operate on empty tables.
 47    * @param p_usim_planck_aeon The planck aeon for the current unprocessed records.
 48    * @param p_usim_planck_time The planck time for the current unprocessed records.
 49    * @return Returns 1 if planck data could be fetched, otherwise error code from USIM_SPR.IS_QUEUE_VALID: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
 50    */
 51    FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
 52                                   , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
 53                                   )
 54      RETURN NUMBER
 55    ;
 56
 57    /**
 58    * Inserts a new process record with status IS_PROCESSED = 0 and current real time, planck aeon
 59    * and planck tick.
 60    * @param p_usim_id_spc_source The space id of the process that emits energy. Must exist.
 61    * @param p_usim_id_spc_target The space id of the process that receives energy. Must exist.
 62    * @param p_usim_energy_source The energy of the source before processing. NULL not allowed.
 63    * @param p_usim_energy_target The energy of the target before processing.
 64    * @param p_usim_energy_output The energy output of the source before processing. NULL not allowed.
 65    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 66    * @return Returns the new unique process id or NULL on errors. May throw exceptions on number inserts causing overflows.
 67    */
 68    FUNCTION insert_spr( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
 69                       , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
 70                       , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
 71                       , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
 72                       , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
 73                       , p_do_commit          IN BOOLEAN                                  DEFAULT TRUE
 74                       )
 75      RETURN usim_spc_process.usim_id_spr%TYPE
 76    ;
 77
 78    /**
 79    * Sets the given process step to processed.
 80    * @param p_usim_id_spr The process id of the process that should be set to processed. Must exist.
 81    * @param p_process_state The process state to set. 1=processed, 2=universe not active, not processed. Default is 1.
 82    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 83    * @return Returns 1 if processed state could be set otherwise 0.
 84    */
 85    FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
 86                          , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
 87                          , p_do_commit     IN BOOLEAN                            DEFAULT TRUE
 88                          )
 89      RETURN NUMBER
 90    ;
 91
 92  END usim_spr;
 93  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_spr
IS
  /**A low level package for actions on table usim_spc_process and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_BASE and USIM_SPC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_spc_process has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_process has already data for a given process id.
  * @param p_usim_id_spr The process id to check.
  * @return Returns 1 if data are available for this id, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_process has unprocessed data.
  * @return Returns 1 if unprocessed data are available, otherwise 0.
  */
  FUNCTION has_unprocessed
    RETURN NUMBER
  ;

  /**
  * Checks if the current unprocessed queue is valid. All unprocessed records must have the current
  * planck aeon and time and if the table is not empty, there must be at least 2 process records.
  * Count of process records must be a multitude of 2. An empty table will also return 1.
  * @return Returns 1 if queue is ready to be processed, otherwise error code: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
  */
  FUNCTION is_queue_valid
    RETURN NUMBER
  ;

  /**
  * Fetches the current planck aeon and time if the queue is valid. Will not operate on empty tables.
  * @param p_usim_planck_aeon The planck aeon for the current unprocessed records.
  * @param p_usim_planck_time The planck time for the current unprocessed records.
  * @return Returns 1 if planck data could be fetched, otherwise error code from USIM_SPR.IS_QUEUE_VALID: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
  */
  FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
                                 , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
                                 )
    RETURN NUMBER
  ;

  /**
  * Inserts a new process record with status IS_PROCESSED = 0 and current real time, planck aeon
  * and planck tick.
  * @param p_usim_id_spc_source The space id of the process that emits energy. Must exist.
  * @param p_usim_id_spc_target The space id of the process that receives energy. Must exist.
  * @param p_usim_energy_source The energy of the source before processing. NULL not allowed.
  * @param p_usim_energy_target The energy of the target before processing.
  * @param p_usim_energy_output The energy output of the source before processing. NULL not allowed.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new unique process id or NULL on errors. May throw exceptions on number inserts causing overflows.
  */
  FUNCTION insert_spr( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
                     , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
                     , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
                     , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
                     , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
                     , p_do_commit          IN BOOLEAN                                  DEFAULT TRUE
                     )
    RETURN usim_spc_process.usim_id_spr%TYPE
  ;

  /**
  * Sets the given process step to processed.
  * @param p_usim_id_spr The process id of the process that should be set to processed. Must exist.
  * @param p_process_state The process state to set. 1=processed, 2=universe not active, not processed. Default is 1.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if processed state could be set otherwise 0.
  */
  FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
                        , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
                        , p_do_commit     IN BOOLEAN                            DEFAULT TRUE
                        )
    RETURN NUMBER
  ;

END usim_spr;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_spr
IS
  /**A low level package for actions on table usim_spc_process and its associated
  * views. Views can be seen as interfaces and dependency. No other package dependencies
  * apart from USIM_BASE and USIM_SPC. ATTENTION Package may throw exceptions
  * from constraints, triggers and foreign keys. Caller is responsible to handle
  * possible exceptions.
  */

  /**
  * Checks if usim_spc_process has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_process has already data for a given process id.
  * @param p_usim_id_spr The process id to check.
  * @return Returns 1 if data are available for this id, otherwise 0.
  */
  FUNCTION has_data(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_process has unprocessed data.
  * @return Returns 1 if unprocessed data are available, otherwise 0.
  */
  FUNCTION has_unprocessed
    RETURN NUMBER
  ;

  /**
  * Checks if the current unprocessed queue is valid. All unprocessed records must have the current
  * planck aeon and time and if the table is not empty, there must be at least 2 process records.
  * Count of process records must be a multitude of 2. An empty table will also return 1.
  * @return Returns 1 if queue is ready to be processed, otherwise error code: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
  */
  FUNCTION is_queue_valid
    RETURN NUMBER
  ;

  /**
  * Fetches the current planck aeon and time if the queue is valid. Will not operate on empty tables.
  * @param p_usim_planck_aeon The planck aeon for the current unprocessed records.
  * @param p_usim_planck_time The planck time for the current unprocessed records.
  * @return Returns 1 if planck data could be fetched, otherwise error code from USIM_SPR.IS_QUEUE_VALID: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
  */
  FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
                                 , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
                                 )
    RETURN NUMBER
  ;

  /**
  * Inserts a new process record with status IS_PROCESSED = 0 and current real time, planck aeon
  * and planck tick.
  * @param p_usim_id_spc_source The space id of the process that emits energy. Must exist.
  * @param p_usim_id_spc_target The space id of the process that receives energy. Must exist.
  * @param p_usim_energy_source The energy of the source before processing. NULL not allowed.
  * @param p_usim_energy_target The energy of the target before processing.
  * @param p_usim_energy_output The energy output of the source before processing. NULL not allowed.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new unique process id or NULL on errors. May throw exceptions on number inserts causing overflows.
  */
  FUNCTION insert_spr( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
                     , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
                     , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
                     , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
                     , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
                     , p_do_commit          IN BOOLEAN                                  DEFAULT TRUE
                     )
    RETURN usim_spc_process.usim_id_spr%TYPE
  ;

  /**
  * Sets the given process step to processed.
  * @param p_usim_id_spr The process id of the process that should be set to processed. Must exist.
  * @param p_process_state The process state to set. 1=processed, 2=universe not active, not processed. Default is 1.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if processed state could be set otherwise 0.
  */
  FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
                        , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
                        , p_do_commit     IN BOOLEAN                            DEFAULT TRUE
                        )
    RETURN NUMBER
  ;

END usim_spr;

Package USIM_SPR kompiliert

SQL> @@../PACKAGES/USIM_SPR.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_spr
  2  IS
  3    -- see header for documentation
  4
  5    FUNCTION has_data
  6      RETURN NUMBER
  7    IS
  8      l_result NUMBER;
  9    BEGIN
 10      SELECT COUNT(*) INTO l_result FROM usim_spc_process;
 11      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 12    END has_data
 13    ;
 14
 15    FUNCTION has_data(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
 16      RETURN NUMBER
 17    IS
 18      l_result NUMBER;
 19    BEGIN
 20      SELECT COUNT(*) INTO l_result FROM usim_spc_process WHERE usim_id_spr = p_usim_id_spr;
 21      RETURN l_result;
 22    END has_data
 23    ;
 24
 25    FUNCTION has_unprocessed
 26      RETURN NUMBER
 27    IS
 28      l_result NUMBER;
 29    BEGIN
 30      SELECT COUNT(*) INTO l_result FROM usim_spc_process WHERE is_processed = 0;
 31      RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 32    END has_unprocessed
 33    ;
 34
 35    FUNCTION is_queue_valid
 36      RETURN NUMBER
 37    IS
 38      l_count       NUMBER;
 39      l_planck_aeon usim_spc_process.usim_planck_aeon%TYPE;
 40      l_planck_time usim_spc_process.usim_planck_time%TYPE;
 41    BEGIN
 42      IF usim_spr.has_data = 0
 43      THEN
 44        RETURN 1;
 45      ELSE
 46        IF usim_spr.has_unprocessed = 0
 47        THEN
 48          RETURN 0;
 49        END IF;
 50        SELECT COUNT(*) INTO l_count FROM (SELECT usim_planck_aeon, usim_planck_time FROM usim_spc_process WHERE is_processed = 0 GROUP BY usim_planck_aeon, usim_planck_time);
 51        IF l_count != 1
 52        THEN
 53          RETURN -1;
 54        END IF;
 55        SELECT COUNT(*) INTO l_count FROM usim_spc_process WHERE is_processed = 0;
 56        IF MOD(l_count, 2) != 0
 57        THEN
 58          RETURN -2;
 59        END IF;
 60        SELECT usim_planck_aeon, usim_planck_time INTO l_planck_aeon, l_planck_time FROM usim_spc_process WHERE is_processed = 0 GROUP BY usim_planck_aeon, usim_planck_time;
 61        IF    usim_base.get_planck_aeon_seq_current != l_planck_aeon
 62           OR usim_base.get_planck_time_current     != l_planck_time
 63        THEN
 64          RETURN -1;
 65        END IF;
 66        -- all checks passed
 67        RETURN 1;
 68      END IF;
 69    END is_queue_valid
 70    ;
 71
 72    FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
 73                                   , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
 74                                   )
 75      RETURN NUMBER
 76    IS
 77      l_return NUMBER;
 78    BEGIN
 79      -- can't process not existing data
 80      IF usim_spr.has_data = 0
 81      THEN
 82        RETURN 0;
 83      END IF;
 84      l_return := usim_spr.is_queue_valid;
 85      IF l_return = 1
 86      THEN
 87        SELECT usim_planck_aeon, usim_planck_time INTO p_usim_planck_aeon, p_usim_planck_time FROM usim_spc_process WHERE is_processed = 0 GROUP BY usim_planck_aeon, usim_planck_time;
 88      END IF;
 89      RETURN l_return;
 90    END get_unprocessed_planck
 91    ;
 92
 93    FUNCTION insert_spr( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
 94                       , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
 95                       , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
 96                       , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
 97                       , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
 98                       , p_do_commit          IN BOOLEAN                                  DEFAULT TRUE
 99                       )
100      RETURN usim_spc_process.usim_id_spr%TYPE
101    IS
102      l_result usim_spc_process.usim_id_spr%TYPE;
103    BEGIN
104      -- check parameters
105      IF     usim_spc.has_data(p_usim_id_spc_source) = 1
106         AND usim_spc.has_data(p_usim_id_spc_target) = 1
107         AND p_usim_energy_source                   IS NOT NULL
108         AND p_usim_energy_output                   IS NOT NULL
109      THEN
110        INSERT INTO usim_spc_process
111          ( usim_planck_aeon
112          , usim_planck_time
113          , usim_id_spc_source
114          , usim_id_spc_target
115          , usim_energy_source
116          , usim_energy_target
117          , usim_energy_output
118          )
119          VALUES
120          ( usim_base.get_planck_aeon_seq_current
121          , usim_base.get_planck_time_current
122          , p_usim_id_spc_source
123          , p_usim_id_spc_target
124          , p_usim_energy_source
125          , p_usim_energy_target
126          , p_usim_energy_output
127          )
128          RETURNING usim_id_spr INTO l_result
129        ;
130        IF p_do_commit
131        THEN
132          COMMIT;
133        END IF;
134        RETURN l_result;
135      ELSE
136        -- constraints not fulfilled
137        usim_erl.log_error('usim_spr.insert_spr', 'Constraints not fulfilled for process insert of source id [' || p_usim_id_spc_source || '], target id [' || p_usim_id_spc_target || '], source energy [' || p_usim_energy_source || '] and output energy [' || p_usim_energy_output || '].');
138        RETURN NULL;
139      END IF;
140    END insert_spr
141    ;
142
143    FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
144                          , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
145                          , p_do_commit     IN BOOLEAN                            DEFAULT TRUE
146                          )
147      RETURN NUMBER
148    IS
149      l_target_id usim_space.usim_id_spc%TYPE;
150    BEGIN
151      IF     usim_spr.has_data(p_usim_id_spr) = 1
152         AND p_process_state                 IN (1, 2)
153      THEN
154        UPDATE usim_spc_process
155           SET is_processed = p_process_state
156         WHERE usim_id_spr = p_usim_id_spr
157        ;
158        IF p_do_commit
159        THEN
160          COMMIT;
161        END IF;
162        RETURN 1;
163      ELSE
164        usim_erl.log_error('usim_spr.set_processed', 'Used with invalid process id [' || p_usim_id_spr || '] or process state [' || p_process_state || '].');
165        RETURN 0;
166      END IF;
167    END set_processed
168    ;
169
170  END usim_spr;
171  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_spr
IS
  -- see header for documentation

  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_process;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_process WHERE usim_id_spr = p_usim_id_spr;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_unprocessed
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_process WHERE is_processed = 0;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_unprocessed
  ;

  FUNCTION is_queue_valid
    RETURN NUMBER
  IS
    l_count       NUMBER;
    l_planck_aeon usim_spc_process.usim_planck_aeon%TYPE;
    l_planck_time usim_spc_process.usim_planck_time%TYPE;
  BEGIN
    IF usim_spr.has_data = 0
    THEN
      RETURN 1;
    ELSE
      IF usim_spr.has_unprocessed = 0
      THEN
        RETURN 0;
      END IF;
      SELECT COUNT(*) INTO l_count FROM (SELECT usim_planck_aeon, usim_planck_time FROM usim_spc_process WHERE is_processed = 0 GROUP BY usim_planck_aeon, usim_planck_time);
      IF l_count != 1
      THEN
        RETURN -1;
      END IF;
      SELECT COUNT(*) INTO l_count FROM usim_spc_process WHERE is_processed = 0;
      IF MOD(l_count, 2) != 0
      THEN
        RETURN -2;
      END IF;
      SELECT usim_planck_aeon, usim_planck_time INTO l_planck_aeon, l_planck_time FROM usim_spc_process WHERE is_processed = 0 GROUP BY usim_planck_aeon, usim_planck_time;
      IF    usim_base.get_planck_aeon_seq_current != l_planck_aeon
         OR usim_base.get_planck_time_current     != l_planck_time
      THEN
        RETURN -1;
      END IF;
      -- all checks passed
      RETURN 1;
    END IF;
  END is_queue_valid
  ;

  FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
                                 , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
                                 )
    RETURN NUMBER
  IS
    l_return NUMBER;
  BEGIN
    -- can't process not existing data
    IF usim_spr.has_data = 0
    THEN
      RETURN 0;
    END IF;
    l_return := usim_spr.is_queue_valid;
    IF l_return = 1
    THEN
      SELECT usim_planck_aeon, usim_planck_time INTO p_usim_planck_aeon, p_usim_planck_time FROM usim_spc_process WHERE is_processed = 0 GROUP BY usim_planck_aeon, usim_planck_time;
    END IF;
    RETURN l_return;
  END get_unprocessed_planck
  ;

  FUNCTION insert_spr( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
                     , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
                     , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
                     , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
                     , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
                     , p_do_commit          IN BOOLEAN                                  DEFAULT TRUE
                     )
    RETURN usim_spc_process.usim_id_spr%TYPE
  IS
    l_result usim_spc_process.usim_id_spr%TYPE;
  BEGIN
    -- check parameters
    IF     usim_spc.has_data(p_usim_id_spc_source) = 1
       AND usim_spc.has_data(p_usim_id_spc_target) = 1
       AND p_usim_energy_source                   IS NOT NULL
       AND p_usim_energy_output                   IS NOT NULL
    THEN
      INSERT INTO usim_spc_process
        ( usim_planck_aeon
        , usim_planck_time
        , usim_id_spc_source
        , usim_id_spc_target
        , usim_energy_source
        , usim_energy_target
        , usim_energy_output
        )
        VALUES
        ( usim_base.get_planck_aeon_seq_current
        , usim_base.get_planck_time_current
        , p_usim_id_spc_source
        , p_usim_id_spc_target
        , p_usim_energy_source
        , p_usim_energy_target
        , p_usim_energy_output
        )
        RETURNING usim_id_spr INTO l_result
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN l_result;
    ELSE
      -- constraints not fulfilled
      usim_erl.log_error('usim_spr.insert_spr', 'Constraints not fulfilled for process insert of source id [' || p_usim_id_spc_source || '], target id [' || p_usim_id_spc_target || '], source energy [' || p_usim_energy_source || '] and output energy [' || p_usim_energy_output || '].');
      RETURN NULL;
    END IF;
  END insert_spr
  ;

  FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
                        , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
                        , p_do_commit     IN BOOLEAN                            DEFAULT TRUE
                        )
    RETURN NUMBER
  IS
    l_target_id usim_space.usim_id_spc%TYPE;
  BEGIN
    IF     usim_spr.has_data(p_usim_id_spr) = 1
       AND p_process_state                 IN (1, 2)
    THEN
      UPDATE usim_spc_process
         SET is_processed = p_process_state
       WHERE usim_id_spr = p_usim_id_spr
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_spr.set_processed', 'Used with invalid process id [' || p_usim_id_spr || '] or process state [' || p_process_state || '].');
      RETURN 0;
    END IF;
  END set_processed
  ;

END usim_spr;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_spr
IS
  -- see header for documentation

  FUNCTION has_data
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_process;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_data
  ;

  FUNCTION has_data(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_process WHERE usim_id_spr = p_usim_id_spr;
    RETURN l_result;
  END has_data
  ;

  FUNCTION has_unprocessed
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    SELECT COUNT(*) INTO l_result FROM usim_spc_process WHERE is_processed = 0;
    RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
  END has_unprocessed
  ;

  FUNCTION is_queue_valid
    RETURN NUMBER
  IS
    l_count       NUMBER;
    l_planck_aeon usim_spc_process.usim_planck_aeon%TYPE;
    l_planck_time usim_spc_process.usim_planck_time%TYPE;
  BEGIN
    IF usim_spr.has_data = 0
    THEN
      RETURN 1;
    ELSE
      IF usim_spr.has_unprocessed = 0
      THEN
        RETURN 0;
      END IF;
      SELECT COUNT(*) INTO l_count FROM (SELECT usim_planck_aeon, usim_planck_time FROM usim_spc_process WHERE is_processed = 0 GROUP BY usim_planck_aeon, usim_planck_time);
      IF l_count != 1
      THEN
        RETURN -1;
      END IF;
      SELECT COUNT(*) INTO l_count FROM usim_spc_process WHERE is_processed = 0;
      IF MOD(l_count, 2) != 0
      THEN
        RETURN -2;
      END IF;
      SELECT usim_planck_aeon, usim_planck_time INTO l_planck_aeon, l_planck_time FROM usim_spc_process WHERE is_processed = 0 GROUP BY usim_planck_aeon, usim_planck_time;
      IF    usim_base.get_planck_aeon_seq_current != l_planck_aeon
         OR usim_base.get_planck_time_current     != l_planck_time
      THEN
        RETURN -1;
      END IF;
      -- all checks passed
      RETURN 1;
    END IF;
  END is_queue_valid
  ;

  FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
                                 , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
                                 )
    RETURN NUMBER
  IS
    l_return NUMBER;
  BEGIN
    -- can't process not existing data
    IF usim_spr.has_data = 0
    THEN
      RETURN 0;
    END IF;
    l_return := usim_spr.is_queue_valid;
    IF l_return = 1
    THEN
      SELECT usim_planck_aeon, usim_planck_time INTO p_usim_planck_aeon, p_usim_planck_time FROM usim_spc_process WHERE is_processed = 0 GROUP BY usim_planck_aeon, usim_planck_time;
    END IF;
    RETURN l_return;
  END get_unprocessed_planck
  ;

  FUNCTION insert_spr( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
                     , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
                     , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
                     , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
                     , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
                     , p_do_commit          IN BOOLEAN                                  DEFAULT TRUE
                     )
    RETURN usim_spc_process.usim_id_spr%TYPE
  IS
    l_result usim_spc_process.usim_id_spr%TYPE;
  BEGIN
    -- check parameters
    IF     usim_spc.has_data(p_usim_id_spc_source) = 1
       AND usim_spc.has_data(p_usim_id_spc_target) = 1
       AND p_usim_energy_source                   IS NOT NULL
       AND p_usim_energy_output                   IS NOT NULL
    THEN
      INSERT INTO usim_spc_process
        ( usim_planck_aeon
        , usim_planck_time
        , usim_id_spc_source
        , usim_id_spc_target
        , usim_energy_source
        , usim_energy_target
        , usim_energy_output
        )
        VALUES
        ( usim_base.get_planck_aeon_seq_current
        , usim_base.get_planck_time_current
        , p_usim_id_spc_source
        , p_usim_id_spc_target
        , p_usim_energy_source
        , p_usim_energy_target
        , p_usim_energy_output
        )
        RETURNING usim_id_spr INTO l_result
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN l_result;
    ELSE
      -- constraints not fulfilled
      usim_erl.log_error('usim_spr.insert_spr', 'Constraints not fulfilled for process insert of source id [' || p_usim_id_spc_source || '], target id [' || p_usim_id_spc_target || '], source energy [' || p_usim_energy_source || '] and output energy [' || p_usim_energy_output || '].');
      RETURN NULL;
    END IF;
  END insert_spr
  ;

  FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
                        , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
                        , p_do_commit     IN BOOLEAN                            DEFAULT TRUE
                        )
    RETURN NUMBER
  IS
    l_target_id usim_space.usim_id_spc%TYPE;
  BEGIN
    IF     usim_spr.has_data(p_usim_id_spr) = 1
       AND p_process_state                 IN (1, 2)
    THEN
      UPDATE usim_spc_process
         SET is_processed = p_process_state
       WHERE usim_id_spr = p_usim_id_spr
      ;
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_spr.set_processed', 'Used with invalid process id [' || p_usim_id_spr || '] or process state [' || p_process_state || '].');
      RETURN 0;
    END IF;
  END set_processed
  ;

END usim_spr;

Package Body USIM_SPR kompiliert

SQL> --== relation tables end ==--
SQL>
SQL> --== other views start ==--
SQL> @@../VIEW/USIM_MLV_STATE_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_MLV_STATE_V (mlsv)
SQL> CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_mlv_state_v AS
  2      WITH det AS
  3           (SELECT usim_id_mlv
  4                 , dim_n1_sign
  5                 , SUM(NVL(usim_energy, 0)) AS energy
  6              FROM usim_spc_v
  7             GROUP BY usim_id_mlv
  8                    , dim_n1_sign
  9           )
 10         , tot AS
 11           (SELECT usim_id_mlv
 12                 , SUM(NVL(usim_energy, 0)) AS energy
 13              FROM usim_spc_v
 14             GROUP BY usim_id_mlv
 15           )
 16         , ovr AS
 17           (SELECT mlv.usim_id_mlv
 18                 , usim_static.get_multiverse_status(mlv.usim_universe_status) AS current_status
 19                 , mlv.usim_is_base_universe
 20                 , tot.energy AS energy_total
 21                 , det_base.energy AS energy_base
 22                 , det_pos.energy AS energy_positive
 23                 , det_neg.energy AS energy_negative
 24                 , mlv.usim_universe_status
 25                 , usim_spr.has_data AS has_process_data
 26                 , usim_spr.has_unprocessed AS has_unprocessed
 27              FROM usim_multiverse mlv
 28              LEFT OUTER JOIN det det_neg
 29                ON mlv.usim_id_mlv = det_neg.usim_id_mlv
 30               AND det_neg.dim_n1_sign = -1
 31              LEFT OUTER JOIN det det_pos
 32                ON mlv.usim_id_mlv = det_pos.usim_id_mlv
 33               AND det_pos.dim_n1_sign = 1
 34              LEFT OUTER JOIN det det_base
 35                ON mlv.usim_id_mlv = det_base.usim_id_mlv
 36               AND det_base.dim_n1_sign IS NULL
 37              LEFT OUTER JOIN tot
 38                ON mlv.usim_id_mlv = tot.usim_id_mlv
 39           )
 40    SELECT usim_id_mlv
 41         , usim_base.get_planck_aeon_seq_current  AS planck_aeon
 42         , usim_base.get_planck_time_current      AS planck_time
 43         , current_status                         AS status_txt
 44         , CASE usim_universe_status
 45             WHEN usim_static.get_multiverse_active
 46             THEN CASE
 47                    WHEN has_process_data = 1
 48                     AND energy_base      = 0
 49                    THEN 1
 50                    ELSE 0
 51                  END
 52             WHEN usim_static.get_multiverse_crashed
 53             THEN CASE
 54                    WHEN has_process_data = 1
 55                     AND has_unprocessed  = 0
 56                    THEN 1
 57                    WHEN has_process_data  = 1
 58                     AND has_unprocessed   = 1
 59                     AND energy_base      != 0
 60                    THEN 1
 61                    ELSE 0
 62                  END
 63             WHEN usim_static.get_multiverse_dead
 64             THEN CASE
 65                    WHEN has_process_data = 1
 66                     AND energy_base      = 0
 67                     AND energy_total     = 0
 68                     AND energy_positive  = 0
 69                     AND energy_negative  = 0
 70                    THEN 1
 71                    ELSE 0
 72                  END
 73             WHEN usim_static.get_multiverse_inactive
 74             THEN CASE
 75                    WHEN has_process_data = 0
 76                    THEN 1
 77                    ELSE 0
 78                  END
 79             ELSE -1
 80           END                                    AS status_valid
 81         , CASE
 82             WHEN has_process_data    = 1
 83              AND NVL(energy_base, 0) = 0
 84             THEN usim_static.get_multiverse_active
 85             WHEN has_process_data = 1
 86              AND has_unprocessed  = 0
 87             THEN usim_static.get_multiverse_crashed
 88             WHEN has_process_data = 1
 89              AND has_unprocessed  = 1
 90              AND energy_base     != 0
 91             THEN usim_static.get_multiverse_crashed
 92             WHEN energy_base      = 0
 93              AND energy_total     = 0
 94              AND energy_positive  = 0
 95              AND energy_negative  = 0
 96             THEN usim_static.get_multiverse_dead
 97             WHEN has_process_data = 0
 98             THEN usim_static.get_multiverse_inactive
 99             ELSE NULL
100           END                                    AS status_calculated
101         , usim_universe_status                   AS status_current
102         , usim_is_base_universe
103         , energy_base
104         , energy_total AS energy_total_calc
105         , energy_positive
106         , energy_negative
107         , has_process_data
108         , has_unprocessed
109      FROM ovr
110  ;
alt:CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_mlv_state_v AS
    WITH det AS
         (SELECT usim_id_mlv
               , dim_n1_sign
               , SUM(NVL(usim_energy, 0)) AS energy
            FROM usim_spc_v
           GROUP BY usim_id_mlv
                  , dim_n1_sign
         )
       , tot AS
         (SELECT usim_id_mlv
               , SUM(NVL(usim_energy, 0)) AS energy
            FROM usim_spc_v
           GROUP BY usim_id_mlv
         )
       , ovr AS
         (SELECT mlv.usim_id_mlv
               , usim_static.get_multiverse_status(mlv.usim_universe_status) AS current_status
               , mlv.usim_is_base_universe
               , tot.energy AS energy_total
               , det_base.energy AS energy_base
               , det_pos.energy AS energy_positive
               , det_neg.energy AS energy_negative
               , mlv.usim_universe_status
               , usim_spr.has_data AS has_process_data
               , usim_spr.has_unprocessed AS has_unprocessed
            FROM usim_multiverse mlv
            LEFT OUTER JOIN det det_neg
              ON mlv.usim_id_mlv = det_neg.usim_id_mlv
             AND det_neg.dim_n1_sign = -1
            LEFT OUTER JOIN det det_pos
              ON mlv.usim_id_mlv = det_pos.usim_id_mlv
             AND det_pos.dim_n1_sign = 1
            LEFT OUTER JOIN det det_base
              ON mlv.usim_id_mlv = det_base.usim_id_mlv
             AND det_base.dim_n1_sign IS NULL
            LEFT OUTER JOIN tot
              ON mlv.usim_id_mlv = tot.usim_id_mlv
         )
  SELECT usim_id_mlv
       , usim_base.get_planck_aeon_seq_current  AS planck_aeon
       , usim_base.get_planck_time_current      AS planck_time
       , current_status                         AS status_txt
       , CASE usim_universe_status
           WHEN usim_static.get_multiverse_active
           THEN CASE
                  WHEN has_process_data = 1
                   AND energy_base      = 0
                  THEN 1
                  ELSE 0
                END
           WHEN usim_static.get_multiverse_crashed
           THEN CASE
                  WHEN has_process_data = 1
                   AND has_unprocessed  = 0
                  THEN 1
                  WHEN has_process_data  = 1
                   AND has_unprocessed   = 1
                   AND energy_base      != 0
                  THEN 1
                  ELSE 0
                END
           WHEN usim_static.get_multiverse_dead
           THEN CASE
                  WHEN has_process_data = 1
                   AND energy_base      = 0
                   AND energy_total     = 0
                   AND energy_positive  = 0
                   AND energy_negative  = 0
                  THEN 1
                  ELSE 0
                END
           WHEN usim_static.get_multiverse_inactive
           THEN CASE
                  WHEN has_process_data = 0
                  THEN 1
                  ELSE 0
                END
           ELSE -1
         END                                    AS status_valid
       , CASE
           WHEN has_process_data    = 1
            AND NVL(energy_base, 0) = 0
           THEN usim_static.get_multiverse_active
           WHEN has_process_data = 1
            AND has_unprocessed  = 0
           THEN usim_static.get_multiverse_crashed
           WHEN has_process_data = 1
            AND has_unprocessed  = 1
            AND energy_base     != 0
           THEN usim_static.get_multiverse_crashed
           WHEN energy_base      = 0
            AND energy_total     = 0
            AND energy_positive  = 0
            AND energy_negative  = 0
           THEN usim_static.get_multiverse_dead
           WHEN has_process_data = 0
           THEN usim_static.get_multiverse_inactive
           ELSE NULL
         END                                    AS status_calculated
       , usim_universe_status                   AS status_current
       , usim_is_base_universe
       , energy_base
       , energy_total AS energy_total_calc
       , energy_positive
       , energy_negative
       , has_process_data
       , has_unprocessed
    FROM ovr

neu:CREATE OR REPLACE VIEW USIM_TEST.usim_mlv_state_v AS
    WITH det AS
         (SELECT usim_id_mlv
               , dim_n1_sign
               , SUM(NVL(usim_energy, 0)) AS energy
            FROM usim_spc_v
           GROUP BY usim_id_mlv
                  , dim_n1_sign
         )
       , tot AS
         (SELECT usim_id_mlv
               , SUM(NVL(usim_energy, 0)) AS energy
            FROM usim_spc_v
           GROUP BY usim_id_mlv
         )
       , ovr AS
         (SELECT mlv.usim_id_mlv
               , usim_static.get_multiverse_status(mlv.usim_universe_status) AS current_status
               , mlv.usim_is_base_universe
               , tot.energy AS energy_total
               , det_base.energy AS energy_base
               , det_pos.energy AS energy_positive
               , det_neg.energy AS energy_negative
               , mlv.usim_universe_status
               , usim_spr.has_data AS has_process_data
               , usim_spr.has_unprocessed AS has_unprocessed
            FROM usim_multiverse mlv
            LEFT OUTER JOIN det det_neg
              ON mlv.usim_id_mlv = det_neg.usim_id_mlv
             AND det_neg.dim_n1_sign = -1
            LEFT OUTER JOIN det det_pos
              ON mlv.usim_id_mlv = det_pos.usim_id_mlv
             AND det_pos.dim_n1_sign = 1
            LEFT OUTER JOIN det det_base
              ON mlv.usim_id_mlv = det_base.usim_id_mlv
             AND det_base.dim_n1_sign IS NULL
            LEFT OUTER JOIN tot
              ON mlv.usim_id_mlv = tot.usim_id_mlv
         )
  SELECT usim_id_mlv
       , usim_base.get_planck_aeon_seq_current  AS planck_aeon
       , usim_base.get_planck_time_current      AS planck_time
       , current_status                         AS status_txt
       , CASE usim_universe_status
           WHEN usim_static.get_multiverse_active
           THEN CASE
                  WHEN has_process_data = 1
                   AND energy_base      = 0
                  THEN 1
                  ELSE 0
                END
           WHEN usim_static.get_multiverse_crashed
           THEN CASE
                  WHEN has_process_data = 1
                   AND has_unprocessed  = 0
                  THEN 1
                  WHEN has_process_data  = 1
                   AND has_unprocessed   = 1
                   AND energy_base      != 0
                  THEN 1
                  ELSE 0
                END
           WHEN usim_static.get_multiverse_dead
           THEN CASE
                  WHEN has_process_data = 1
                   AND energy_base      = 0
                   AND energy_total     = 0
                   AND energy_positive  = 0
                   AND energy_negative  = 0
                  THEN 1
                  ELSE 0
                END
           WHEN usim_static.get_multiverse_inactive
           THEN CASE
                  WHEN has_process_data = 0
                  THEN 1
                  ELSE 0
                END
           ELSE -1
         END                                    AS status_valid
       , CASE
           WHEN has_process_data    = 1
            AND NVL(energy_base, 0) = 0
           THEN usim_static.get_multiverse_active
           WHEN has_process_data = 1
            AND has_unprocessed  = 0
           THEN usim_static.get_multiverse_crashed
           WHEN has_process_data = 1
            AND has_unprocessed  = 1
            AND energy_base     != 0
           THEN usim_static.get_multiverse_crashed
           WHEN energy_base      = 0
            AND energy_total     = 0
            AND energy_positive  = 0
            AND energy_negative  = 0
           THEN usim_static.get_multiverse_dead
           WHEN has_process_data = 0
           THEN usim_static.get_multiverse_inactive
           ELSE NULL
         END                                    AS status_calculated
       , usim_universe_status                   AS status_current
       , usim_is_base_universe
       , energy_base
       , energy_total AS energy_total_calc
       , energy_positive
       , energy_negative
       , has_process_data
       , has_unprocessed
    FROM ovr

View USIM_TEST.USIM_MLV_STATE_V erstellt.

SQL>
SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.status_valid IS 'Determines if the current database status is valid. 1 = valid 0 = invalid, -1 = no valid calculation rule found for a related universe';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.status_valid IS 'Determines if the current database status is valid. 1 = valid 0 = invalid, -1 = no valid calculation rule found for a related universe'
neu:COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.status_valid IS 'Determines if the current database status is valid. 1 = valid 0 = invalid, -1 = no valid calculation rule found for a related universe'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.status_calculated IS 'Calculates the database status by current energy and process data for a related universe, NULL means invalid no rules found to determine state';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.status_calculated IS 'Calculates the database status by current energy and process data for a related universe, NULL means invalid no rules found to determine state'
neu:COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.status_calculated IS 'Calculates the database status by current energy and process data for a related universe, NULL means invalid no rules found to determine state'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_total_calc IS 'The total summed up energy of the related universe, may differ slightly from 0 for missing SUM exactness on high decimals';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_total_calc IS 'The total summed up energy of the related universe, may differ slightly from 0 for missing SUM exactness on high decimals'
neu:COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.energy_total_calc IS 'The total summed up energy of the related universe, may differ slightly from 0 for missing SUM exactness on high decimals'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_positive IS 'The energy sum for all dimension axis with n1 sign = +1';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_positive IS 'The energy sum for all dimension axis with n1 sign = +1'
neu:COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.energy_positive IS 'The energy sum for all dimension axis with n1 sign = +1'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_negative IS 'The energy sum for all dimension axis with n1 sign = -1';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_negative IS 'The energy sum for all dimension axis with n1 sign = -1'
neu:COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.energy_negative IS 'The energy sum for all dimension axis with n1 sign = -1'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_base IS 'The energy sum for the base universe node with n1 sign = NULL';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_base IS 'The energy sum for the base universe node with n1 sign = NULL'
neu:COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.energy_base IS 'The energy sum for the base universe node with n1 sign = NULL'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.has_process_data IS 'Determines if process data are available. Without process data or no unprocessed data, the universe is inactive';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.has_process_data IS 'Determines if process data are available. Without process data or no unprocessed data, the universe is inactive'
neu:COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.has_process_data IS 'Determines if process data are available. Without process data or no unprocessed data, the universe is inactive'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.has_unprocessed IS 'Determines if there are unprocessed data. An active universe should always have some unprocessed data';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.has_unprocessed IS 'Determines if there are unprocessed data. An active universe should always have some unprocessed data'
neu:COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.has_unprocessed IS 'Determines if there are unprocessed data. An active universe should always have some unprocessed data'

Comment erstellt.

SQL> --== other views end ==--
SQL>
SQL> --== interface package start ==--
SQL> @@../PACKAGES/USIM_DBIF.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_dbif
  2  IS
  3    /**This package is used as an database interface package, handling
  4    * exceptions from low level packages for the existing tables and
  5    * applying universe rules on package usage. It has dependencies to
  6    * all low level packages. Packages on a higher level should only
  7    * use usim_dbif for accessing objects.</br>
  8    * Will try to handle exceptions if possible. Severe application or
  9    * database errors will set all universes to crashed and raise the
 10    * exception found. All errors get logged as far as the database basically
 11    * still works.
 12    */
 13
 14    /**
 15    * Sets all multiverses to crashed. This is for application errors like
 16    * exceptions that invalidate the whole model.
 17    * Uses an anonymous transaction to be able to write in any case.
 18    */
 19    PROCEDURE set_crashed;
 20
 21    /**
 22    * Wrapper for usim_mlv.update_state. Updates state by USIM_MLV_STATE_V valid and calculated state.
 23    * If state does not match (STATUS_VALID = 0) the calculated state is set. If state is valid, do nothing.
 24    * @param p_usim_id_mlv The id of the universe, that should update its state.
 25    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 26    * @return Returns the updated state or NULL on errors.
 27    */
 28    FUNCTION set_universe_state( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
 29                               , p_do_commit   IN BOOLEAN                          DEFAULT TRUE
 30                               )
 31      RETURN usim_multiverse.usim_universe_status%TYPE
 32    ;
 33
 34    /**
 35    * Determines the state of the universe, the given space node is in and updates the state to the calculated state
 36    * of USIM_MLV_STATE_V if current state is not valid.
 37    * @param p_usim_id_spc The space id of a node in a universe that should update its state.
 38    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 39    * @return Returns the current state of the universe or NULL on errors.
 40    */
 41    FUNCTION set_universe_state_spc( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
 42                                   , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
 43                                   )
 44      RETURN usim_multiverse.usim_universe_status%TYPE
 45    ;
 46
 47    /**
 48    * Sets the seed universe active ignoring any current state. Used for placing start node and activate the seed universe for the
 49    * first run. Afterwards the universe state should be determined after running a process queue.
 50    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 51    * @return Returns the activated state of the universe or NULL on errors.
 52    */
 53    FUNCTION set_seed_active(p_do_commit IN BOOLEAN DEFAULT TRUE)
 54      RETURN usim_multiverse.usim_universe_status%TYPE
 55    ;
 56
 57    /**
 58    * Wrapper for usim_base.init_basedata.
 59    * Initializes the base data with the attributes that have to be set on insert if no base data
 60    * exist, otherwise do nothing. As this procedure mimics the constraints, adjusting the constraints needs package adjustment.
 61    * @param p_max_dimension The maximum dimensions possible for this multiverse.
 62    * @param p_usim_abs_max_number The absolute maximum number available for this multiverse.
 63    * @param p_usim_overflow_node_seed Defines the overflow behaviour, default 0 means standard overflow behaviour. If set to 1, all new nodes are created with the universe seed at coordinate 0 as the parent.
 64    * @return Returns 1 if base data init was successful, 0 on errors.
 65    */
 66    FUNCTION init_basedata( p_max_dimension            IN NUMBER DEFAULT 42
 67                          , p_usim_abs_max_number      IN NUMBER DEFAULT 99999999999999999999999999999999999999
 68                          , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
 69                          )
 70      RETURN NUMBER
 71    ;
 72
 73    /**
 74    * Initialize the dimensions supported by the multiverse defined by usim_max_dimension in base_data.
 75    * Does nothing if base data do not exist. Wrapper for usim_dim.init_dimensions.
 76    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 77    * @return Returns 1 if base data exist and init was successful, 0 if base data do not exist and -1 on errors.
 78    */
 79    FUNCTION init_dimensions(p_do_commit IN BOOLEAN DEFAULT TRUE)
 80      RETURN NUMBER
 81    ;
 82
 83    /**
 84    * Initialize the positions supported by the multiverse defined by usim_abs_max_number in base_data.
 85    * Does nothing if base data do not exist. Wrapper for usim_pos.init_positions.
 86    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 87    * @return Returns 1 if base data exist and init was successful, 0 if base data do not exist and -1 on errors.
 88    */
 89    FUNCTION init_positions(p_do_commit IN BOOLEAN DEFAULT TRUE)
 90      RETURN NUMBER
 91    ;
 92
 93    /**
 94    * Checks if base data have been initialized.
 95    * @return Returns 1 if base data are available, otherwise 0.
 96    */
 97    FUNCTION has_basedata
 98      RETURN NUMBER
 99    ;
100
101    /**
102    * Checks if usim_space has already data.
103    * @return Returns 1 if data are available, otherwise 0.
104    */
105    FUNCTION has_data_spc
106      RETURN NUMBER
107    ;
108
109    /**
110    * Checks if usim_space has already data for a given space id.
111    * @param p_usim_id_spc The relation id of universe/dimension/position/node.
112    * @return Returns 1 if data are available, otherwise 0.
113    */
114    FUNCTION has_data_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
115      RETURN NUMBER
116    ;
117
118    /**
119    * Checks if usim_spc_process has already data.
120    * @return Returns 1 if data are available, otherwise 0.
121    */
122    FUNCTION has_data_spr
123      RETURN NUMBER
124    ;
125
126    /**
127    * Checks if usim_spc_process has already data for a given process id.
128    * @param p_usim_id_spr The process id to check.
129    * @return Returns 1 if data are available for this id, otherwise 0.
130    */
131    FUNCTION has_data_spr(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
132      RETURN NUMBER
133    ;
134
135    /**
136    * Wrapper for usim_spr.has_unprocessed.
137    * Checks if usim_spc_process has unprocessed data.
138    * @return Returns 1 if unprocessed data are available, otherwise 0.
139    */
140    FUNCTION has_unprocessed
141      RETURN NUMBER
142    ;
143
144    /**
145    * Checks if usim_multiverse has data.
146    * @return Returns 1 if data exists, otherwise 0.
147    */
148    FUNCTION has_data_mlv
149      RETURN NUMBER
150    ;
151
152    /**
153    * Checks if a given usim_multiverse id exists.
154    * @param p_usim_id_mlv The id of the universe to check.
155    * @return Returns 1 if universe exists, otherwise 0.
156    */
157    FUNCTION has_data_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
158      RETURN NUMBER
159    ;
160
161    /**
162    * Wrapper for usim_spo.has_axis_max_pos_parent.
163    * Checks if for the given space id a maximum position on the dimension axis of the space
164    * node exists, that may or may not be different to the given space id. Handles escape situation 4 where
165    * dimension axis zero nodes can trigger new positions on their dimension axis.
166    * @param p_usim_id_spc The space id to check for max position on its dimension axis.
167    * @return Returns 1 for maximum dimension position found, 0 for not found and -1 for errors in dimension symmetry.
168    */
169    FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
170      RETURN NUMBER
171    ;
172
173    /**
174    * Checks if a given space node has free between axis positions, if node has not reached max childs possible.
175    * @param p_usim_id_spc The space id to check for free between position on available dimension axis.
176    * @return Returns 1 if between positions are available or 0 for no between positions available.
177    */
178    FUNCTION has_free_between(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
179      RETURN NUMBER
180    ;
181
182    /**
183    * Checks if the universe seed is active.
184    * @return Returns 1 if universe seed is active, otherwise 0.
185    */
186    FUNCTION is_seed_active
187      RETURN NUMBER
188    ;
189
190    /**
191    * Checks if the universe is active the given space node is in.
192    * @param p_usim_id_spc The id of the space node to check universe state.
193    * @return Returns 1 if universe is active, otherwise 0 for dead, crashed or inactive.
194    */
195    FUNCTION is_universe_active(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
196      RETURN NUMBER
197    ;
198
199    /**
200    * Checks if the given space node is a base universe, not necessarily the base universe seed. Must have position 0
201    * at dimension 0. Parents are not considered.
202    * @param p_usim_id_spc The id of the space node to check universe base state.
203    * @return Returns 1 if universe is a base type universe otherwise 0.
204    */
205    FUNCTION is_universe_base_type(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
206      RETURN NUMBER
207    ;
208
209    /**
210    * Checks if a given position is in overflow. Depends on init_positions. Overflow is simply detected
211    * by a position that does not exist.
212    * @param p_usim_coordinate The coordinate to check against overflow.
213    * @return Returns 1 if given position coordinate is counted as overflow otherwise 0.
214    */
215    FUNCTION is_overflow_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
216      RETURN NUMBER
217    ;
218
219    /**
220    * Checks if a given universe is in position overflow. Depends on base data. Overflow is detected by highest
221    * available space coordinates for every sign and compared against the maximum possible number.
222    * @param p_usim_id_mlv The universe id to check against position overflow.
223    * @return Returns 1 if given universe is counted as position overflow otherwise 0.
224    */
225    FUNCTION is_overflow_pos_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
226      RETURN NUMBER
227    ;
228
229    /**
230    * Checks if a given universe is in dimension overflow. Depends on base data. Overflow is detected by highest
231    * available rmd dimension for every n1 sign and compared against the maximum possible dimensions. It will check
232    * only dimension overflow on axis level, not considering nodes inbetween connected to other dimensions.
233    * @param p_usim_id_mlv The universe id to check against dimension overflow.
234    * @return Returns TRUE if given universe is counted as dimension overflow otherwise FALSE.
235    */
236    FUNCTION is_overflow_dim_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
237      RETURN NUMBER
238    ;
239
240    /**
241    * Checks if the universe for a given space id is in dimension overflow. Depends on base data. Overflow is detected by highest
242    * available space dimension for every n1 sign and compared against the maximum possible dimension.It will check
243    * only dimension overflow on axis level, not considering nodes inbetween connected to other dimensions.
244    * @param p_usim_id_spc The space id to check the universe it belongs against dimension overflow.
245    * @return Returns 1 if the universe for the given space id is counted as dimension overflow otherwise 0.
246    */
247    FUNCTION is_overflow_dim_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
248      RETURN NUMBER
249    ;
250
251    /**
252    * Checks if the universe for a given space id is in position overflow. Means that for this specific space
253    * id no position is free. Positions itself may not be in overflow. It will check only position overflow
254    * on axis level, not considering nodes inbetween connected to other dimensions.
255    * @param p_usim_id_spc The space id to check the universe it belongs against position overflow.
256    * @return Returns 1 if the universe for the given space id is counted as position overflow otherwise 0.
257    */
258    FUNCTION is_overflow_pos_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
259      RETURN NUMBER
260    ;
261
262    /**
263    * Checks if a given energy is in overflow. Depends on base data. Overflow is detected
264    * by checking the given value against the maximum number supported.
265    * @param p_energy The energy value to check against overflow.
266    * @return Returns 1 if energy is counted as overflow otherwise 0 (also if no base data exist).
267    */
268    FUNCTION is_overflow_energy(p_energy IN NUMBER)
269      RETURN NUMBER
270    ;
271
272    /**
273    * Checks if an addition of  given energies would produce an overflow. Depends on base data. Overflow is detected
274    * by checking the given value against the maximum number supported.
275    * @param p_energy The energy value to check against overflow.
276    * @return Returns 1 if energy is counted as overflow otherwise 0.
277    */
278    FUNCTION is_overflow_energy_add( p_energy IN NUMBER
279                                   , p_add    IN NUMBER
280                                   )
281      RETURN NUMBER
282    ;
283
284    /**
285    * Wrapper for usim_spc.get_id_spc_base_universe.
286    * Checks if a given space node id is the base universe seed at dimension 0 and position 0.
287    * @param p_usim_id_spc The space node id to check.
288    * @return Returns 1 space node is base universe seed otherwise 0.
289    */
290    FUNCTION is_base_universe_seed(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
291      RETURN NUMBER
292    ;
293
294    /**
295    * Wrapper for usim_spr.is_queue_valid.
296    * Checks if the current unprocessed queue is valid. All unprocessed records must have the current
297    * planck aeon and time and if the table is not empty, there must be at least 2 process records.
298    * Count of process records must be a multitude of 2. An empty table will also return 1.
299    * @return Returns 1 if queue is ready to be processed, otherwise error code: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
300    */
301    FUNCTION is_queue_valid
302      RETURN NUMBER
303    ;
304
305    /**
306    * Checks if a given space id is extendable with a new position. Space node must either be a zero position axis node or
307    * a node that has no child it its dimension to match.
308    * @param p_usim_id_spc The space node id to check.
309    * @return Returns 1 if node has no child in its dimension, 2 if node is a zero position axis node else 0.
310    */
311    FUNCTION is_pos_extendable(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
312      RETURN NUMBER
313    ;
314
315    /**
316    * Checks if a given space id is extendable with a new dimension.
317    * @param p_usim_id_spc The space node id to check.
318    * @param p_use_parent The parent space node id to use for dimension extend. NULL on return 0.
319    * @param p_next_dim The next available dimension to create. NULL on return 0.
320    * @return Returns 1 if node has no child in free dimension, 2 if new dimension on zero axis should be build else error 0.
321    */
322    FUNCTION is_dim_extendable( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
323                              , p_use_parent  OUT usim_space.usim_id_spc%TYPE
324                              , p_next_dim    OUT usim_dimension.usim_n_dimension%TYPE
325                              )
326      RETURN NUMBER
327    ;
328
329    /**
330    * Get the child count of a given space node either in related universe or in all
331    * universes.
332    * @param p_usim_id_spc The space node id to check.
333    * @param p_ignore_mlv Defines if childs are only counted within universe of the space node (0) or childs are counted regardless of the universe they are in.
334    * @return Returns amount of childs for the given space node and universe mode or NULL on errors.
335    */
336    FUNCTION child_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
337                        , p_ignore_mlv  IN NUMBER                      DEFAULT 0
338                        )
339      RETURN NUMBER
340    ;
341
342    /**
343    * Get the parent count of a given space node either in related universe or in all
344    * universes.
345    * @param p_usim_id_spc The space node id to check.
346    * @param p_ignore_mlv Defines if parents are only counted within universe of the space node (0) or parents are counted regardless of the universe they are in.
347    * @return Returns amount of parents for the given space node and universe mode or NULL on errors.
348    */
349    FUNCTION parent_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
350                         , p_ignore_mlv  IN NUMBER                      DEFAULT 0
351                         )
352      RETURN NUMBER
353    ;
354
355    /**
356    * Wrapper for usim_mlv.insert_universe.
357    * Inserts a new universe with the given values. Does check if a base universe already exists. USIM_UNIVERSE_STATUS is automatically set
358    * to inactive on insert. USIM_IS_BASE_UNIVERSE is determined by existance of data. If no base universe exist, the universe gets the base universe, otherwise
359    * the universe will be a sub-universe of the existing base universe.
360    * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used or default if NULL or 0.
361    * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value or default if NULL or 0.
362    * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value or default if NULL or 0.
363    * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value or default if NULL or 0.
364    * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct.
365    * @param p_usim_ultimate_border The ultimate border rule for this universe. 1 is ultimate border reached, no childs left, 0 is any border at dimensions axis even with childs left.
366    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
367    * @return The new universe big id or NULL if insert failed.
368    */
369    FUNCTION create_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
370                            , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
371                            , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
372                            , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
373                            , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
374                            , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
375                            , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
376                            )
377      RETURN usim_multiverse.usim_id_mlv%TYPE
378    ;
379
380    /**
381    * Creates a negative and a positive dim axis in usim_rel_mlv_dim if dimension > 0. Dimension 0 has only one
382    * axis, in this case positive and negative dimension axis are equal. Wrapper for usim_rmd.insert_rmd.
383    * @param p_usim_id_mlv The id of the universe, to add a dimension axis. The universe must exist.
384    * @param p_usim_n_dimension The dimension n to create an dimension axis with signs for. Must be >= 0, integer and must exist.
385    * @param p_usim_id_rmd_parent The rmd id of the parent axis at n = 1 if dimension > 1 otherwise NULL.
386    * @param p_usim_id_rmd_pos The dimension axis for the given dimension with sign 1 if dimension > 0. Otherwise equal to p_usim_id_rmd_neg.
387    * @param p_usim_id_rmd_neg The dimension axis for the given dimension with sign -1 if dimension > 0. Otherwise equal to p_usim_id_rmd_pos.
388    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
389    * @return Returns 1 if dimension axis could be created or retrieved, 0 on errors.
390    */
391    FUNCTION create_dim_axis( p_usim_id_mlv        IN  usim_multiverse.usim_id_mlv%TYPE
392                            , p_usim_n_dimension   IN  usim_dimension.usim_n_dimension%TYPE
393                            , p_usim_id_rmd_parent IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
394                            , p_usim_id_rmd_pos    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
395                            , p_usim_id_rmd_neg    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
396                            , p_do_commit          IN  BOOLEAN                              DEFAULT TRUE
397                            )
398      RETURN NUMBER
399    ;
400
401    /**
402    * Wrapper for usim_spc.insert_spc.
403    * Inserts a new space node for the given ids in usim_space. Updates childs
404    * and space position. Node is created for the space node.
405    * @param p_usim_id_rmd The universe/dimension relation id.
406    * @param p_usim_id_pos The position id.
407    * @param p_usim_parents An array of position parent ids for this space node. EMPTY only allowed if universe of rmd is base universe and no entry at dimension 0, position 0, sign 0, n1 sign NULL does not exist.
408    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
409    * @return Returns the new usim_id_spc id or NULL on errors.
410    */
411    FUNCTION create_space_node( p_usim_id_rmd  IN usim_rel_mlv_dim.usim_id_rmd%TYPE
412                              , p_usim_id_pos  IN usim_position.usim_id_pos%TYPE
413                              , p_usim_parents IN usim_static.usim_ids_type
414                              , p_do_commit    IN BOOLEAN                           DEFAULT TRUE
415                              )
416      RETURN usim_space.usim_id_spc%TYPE
417    ;
418
419    /**
420    * Wrapper for usim_spr.insert_spr.
421    * Inserts a new process record with status IS_PROCESSED = 0 and current real time, planck aeon
422    * and planck tick.
423    * @param p_usim_id_spc_source The space id of the process that emits energy. Must exist.
424    * @param p_usim_id_spc_target The space id of the process that receives energy. Must exist.
425    * @param p_usim_energy_source The energy of the source before processing. NULL not allowed.
426    * @param p_usim_energy_target The energy of the target before processing.
427    * @param p_usim_energy_output The energy output of the source before processing. NULL not allowed.
428    * @return Returns the process id, otherwise NULL if constraints are not fulfilled.
429    */
430    FUNCTION create_process( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
431                           , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
432                           , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
433                           , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
434                           , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
435                           , p_do_commit          IN BOOLEAN                                  DEFAULT TRUE
436                           )
437      RETURN usim_spc_process.usim_id_spr%TYPE
438    ;
439
440    /**
441    * Checks border situation for a given space node and flips, depending on the border rule,
442    * the process spin to the correct direction.
443    * @param p_usim_id_spc The space node to check. Mandatory.
444    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
445    * @return Return 1 if all was successfully processed otherwise 0.
446    */
447    FUNCTION check_border( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
448                         , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
449                         )
450      RETURN NUMBER
451    ;
452
453    /**
454    * Wrapper for usim_spc.flip_process_spin.
455    * Updates usim_process_spin by flipping the existing value (1 to -1 and vice versa)
456    * if the given space node is not in dimension 0 with position 0. Otherwise does nothing.
457    * @param p_usim_id_spc The space id to flip process spin.
458    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
459    * @return Returns 1 if no errors or 0 if space id does not exist.
460    */
461    FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
462                              , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
463                              )
464      RETURN NUMBER
465    ;
466
467    /**
468    * Wrapper for usim_spr.set_processed.
469    * Sets the given process step to processed.
470    * @param p_usim_id_spr The process id of the process that should be set to processed. Must exist.
471    * @param p_process_state The process state to set. 1=processed, 2=universe not active, not processed. Default is 1.
472    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
473    * @return Returns 1 if processed state could be set otherwise 0.
474    */
475    FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
476                          , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
477                          , p_do_commit     IN BOOLEAN                            DEFAULT TRUE
478                          )
479      RETURN NUMBER
480    ;
481
482    /**
483    * Wrapper for usim_pos.get_id_pos.
484    * Retrieve the position id for a given coordinate.
485    * @param p_usim_coordinate The coordinate to get the position id for.
486    * @return Returns the usim_id_pos for the given coordinate or NULL on errors.
487    */
488    FUNCTION get_id_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
489      RETURN usim_position.usim_id_pos%TYPE
490    ;
491
492    /**
493    * Wrapper for usim_spc.get_id_pos.
494    * Retrieve the position id for a given coordinate.
495    * @param p_usim_id_spc The space id to get the position id for.
496    * @return Returns the usim_id_pos for the given coordinate or NULL on errors.
497    */
498    FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
499      RETURN usim_position.usim_id_pos%TYPE
500    ;
501
502    /**
503    * Wrapper for usim_spc.get_id_nod.
504    * Retrieves the node id for a given space id if it exists in usim_space.
505    * @param p_usim_id_spc The space id.
506    * @return Returns usim_id_nod if space id exists, otherwise NULL.
507    */
508    FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
509      RETURN usim_node.usim_id_nod%TYPE
510    ;
511
512    /**
513    * Wrapper for usim_spc.get_id_mlv.
514    * Retrieves the universe id for a given space id if it exists in usim_space.
515    * @param p_usim_id_spc The space id.
516    * @return Returns usim_id_mlv if space id exists, otherwise NULL.
517    */
518    FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
519      RETURN usim_multiverse.usim_id_mlv%TYPE
520    ;
521
522    /**
523    * Wrapper for usim_spc.get_id_spc_base_universe.
524    * Retrieve the space id of the universe base seed at position 0 and dimension 0 without any parents.
525    * @return Returns the usim_id_spc if a base universe seed exists or NULL.
526    */
527    FUNCTION get_id_spc_base_universe
528      RETURN usim_space.usim_id_spc%TYPE
529    ;
530
531    /**
532    * Retrieve details about the space id for creation new dimensions.
533    * @param p_usim_id_spc The space id to get data for.
534    * @param p_usim_id_mlv The universe id of the space node.
535    * @param p_usim_id_rmd The dimension axis id of the space node.
536    * @param p_usim_sign The dimension sign of the space node.
537    * @param p_usim_n1_sign The dimension n1 sign of the space node.
538    * @return Returns 1 if data exist for space id or 0 if space id does not exist.
539    */
540    FUNCTION get_spc_dim_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
541                                , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
542                                , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
543                                , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
544                                , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
545                                )
546      RETURN NUMBER
547    ;
548
549    /**
550    * Retrieves the current absolute maximum number allowed.
551    * @return The current value from column usim_abs_max_number or NULL if base data are not initialized.
552    */
553    FUNCTION get_abs_max_number
554      RETURN NUMBER
555    ;
556
557    /**
558    * Retrieves the coordinate of a given dimension and space node, if it exists in USIM_SPC_POS. The given dimension
559    * may not be initialized yet and defaults to 0 if not available.
560    * Relies on the fact, that table holds one position for one dimension, whatever axis the dimension has.
561    * @param p_usim_id_spc The space id to get the coordinate for.
562    * @param p_usim_n_dimension The dimension to get the coordinate for.
563    * @return Returns on success the coordinate of the given dimension, otherwise NULL.
564    */
565    FUNCTION get_dim_coord( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
566                          , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
567                          )
568      RETURN usim_position.usim_coordinate%TYPE
569    ;
570
571    /**
572    * Retrieves the dimension for a given node.
573    * @param p_usim_id_spc The space id to get the dimension.
574    * @return Returns the dimension or -1 if node does not exist.
575    */
576    FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
577      RETURN usim_dimension.usim_n_dimension%TYPE
578    ;
579
580    /**
581    * Retrieves the dimension sign of a given space node.
582    * @param p_usim_id_spc The space id.
583    * @return The dimension sign of the space id or NULL, if space id does not exist.
584    */
585    FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
586      RETURN usim_rel_mlv_dim.usim_sign%TYPE
587    ;
588
589    /**
590    * Retrieves the dimension n=1 sign of a given space node.
591    * @param p_usim_id_spc The space id.
592    * @return The dimension n1 sign of the space id, 0 for base universe nodes or NULL, if space id does not exist.
593    */
594    FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
595      RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
596    ;
597
598    /**
599    * Wrapper for usim_spo.get_xyz.
600    * Retrieves the x,y,z coordinates of a given space node, if it exists in USIM_SPC_POS.
601    * @param p_usim_id_spc The space id to get the coordinates for.
602    * @return Returns on success a comma separated string, format x,y,z, otherwise NULL.
603    */
604    FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
605      RETURN VARCHAR2
606    ;
607
608    /**
609    * Wrapper for usim_spo.get_magnitude.
610    * Retrieves the magnitude of a vector for the given dimension.
611    * @param p_usim_id_spc The space id to get the magnitude for.
612    * @param p_usim_n_dimension The dimension for the magnitude calculation.
613    * @return Returns the magnitude of the vector associated to the given space id or NULL on errors.
614    */
615    FUNCTION get_magnitude( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
616                          , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
617                          )
618      RETURN NUMBER
619    ;
620
621    /**
622    * Wrapper for usim_spc.get_process_spin.
623    * Retrieves the process direction of a given space node.
624    * @param p_usim_id_spc The space id to get the process direction.
625    * @return Returns the process directions or NULL if space node does not exist.
626    */
627    FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
628      RETURN usim_space.usim_process_spin%TYPE
629    ;
630
631    /**
632    * Retrieves the text expression of the universe state of the given space node.
633    * @param p_usim_id_spc The space id to get the universe state description for.
634    * @return Returns ACTIVE, INACTIVE, CRASHED, DEAD or UNKNOWN if universe does not exist.
635    */
636    FUNCTION get_universe_state_desc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
637      RETURN VARCHAR2
638    ;
639
640    /**
641    * Wrapper for usim_base.get_planck_time_current
642    * Retrieves the current planck time tick.
643    * @return The current value from column usim_planck_time_seq_curr or NULL if not initialized.
644    */
645    FUNCTION get_planck_time_current
646      RETURN NUMBER
647    ;
648
649    /**
650    * Wrapper for usim_base.get_planck_aeon_seq_current.
651    * Retrieves the current planck aeon sequence big id.
652    * @return The current value from column usim_planck_aeon_seq_curr or usim_static.usim_not_available if not initialized.
653    */
654    FUNCTION get_planck_aeon_seq_current
655      RETURN VARCHAR2
656    ;
657
658    /**
659    * Wrapper for usim_base.get_planck_time_next.
660    * Retrieves the next planck time tick. Will update current and last planck time as well as planck
661    * aeon if planck time sequence will cycle. If planck aeon is not set, it will be initialized.
662    * @return The next planck time tick number or NULL if not initialized/sequence does not exist.
663    */
664    FUNCTION get_planck_time_next
665      RETURN NUMBER
666    ;
667
668    /**
669    * Wrapper for usim_spr.get_unprocessed_planck.
670    * Fetches the current planck aeon and time if the queue is valid. Will not operate on empty tables.
671    * @param p_usim_planck_aeon The planck aeon for the current unprocessed records.
672    * @param p_usim_planck_time The planck time for the current unprocessed records.
673    * @return Returns 1 if planck data could be fetched, otherwise error code from USIM_SPR.IS_QUEUE_VALID: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
674    */
675    FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
676                                   , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
677                                   )
678      RETURN NUMBER
679    ;
680
681    /**
682    * Wrapper for usim_spo.get_axis_max_pos_parent.
683    * Gets the space node with the maximum position on the given dimension axis. The dimension sign is
684    * used to identify the expected coordinate sign, the dimension n1 sign is used to limit the space
685    * which is divided into two subspaces by dimension 1. The dimension itself is used to identify the
686    * dimension axis, we want to get a new parent node from to extend the dimension and universe.
687    * Used with escape situation 4 where dimension axis zero nodes can trigger new positions on their dimension axis.
688    * @param p_usim_id_spc The space id ancestor node which may be itself the parent node or a 0 node on a dimension axis that can trigger new coordinates.
689    * @return The space node with the highest position on a dimension axis, sign and n1 sign of the given ancestor node, otherwise NULL on errors. Use has_axis_max_pos_parent to check before call.
690    */
691    FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
692      RETURN usim_space.usim_id_spc%TYPE
693    ;
694
695    /**
696    * Gets the current maximum position on the related dimension 1 axis for a given space node.
697    * @param p_usim_id_spc The space id node to get the max dimension 1 position.
698    * @return The maximum coordinate on dimension axis 1 or NULL on errors.
699    */
700    FUNCTION get_axis_max_pos_dim1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
701      RETURN usim_position.usim_coordinate%TYPE
702    ;
703
704    /**
705    * Retrieve the the next position and axis for a given space id.
706    * @param p_usim_id_spc The space id ancestor node which may be itself the parent node or a 0 node on a dimension axis that can trigger new coordinates.
707    * @return Return 1 if the operation was successful otherwise 0.
708    */
709    FUNCTION get_next_pos_on_axis( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
710                                 , p_usim_id_pos OUT usim_position.usim_id_pos%TYPE
711                                 , p_usim_id_rmd OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
712                                 )
713      RETURN NUMBER
714    ;
715
716    /**
717    * Gets the overflow rating for a given space id. Overflow rating:</br>
718    * 0 if universe has overflow in position and dimension.</br>
719    * 1 if no overflow at all.</br>
720    * 2 if overflow in position.</br>
721    * 3 if overflow in dimension.</br>
722    * @param p_usim_id_spc The child id to check data for.
723    * @return Returns overflow rating as defined.
724    */
725    FUNCTION overflow_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
726      RETURN NUMBER
727    ;
728
729    /**
730    * Gets the dimension axis rating for a given space id and the possible maximum number of childs. Maximum childs are calculated for the next
731    * possible dimension, if dimension is not already maximum to enable extension. Max n is n+1 where n+1 < max n else maximum possible dimensions. Dimension rating:</br>
732    * -1 error retrieving axis rating.</br>
733    * 0 center axis at dimension n = 0, with position 0 in dimension 0. 2 special childs possible with opposite output energy sign.</br>
734    * 1 center axis at dimension n = 1, with position 0 in dimension n and sign (-/+1). (max n - n) x 2 + 1 childs possible</br>
735    * 2 center axis at dimension n > 1, with position 0 in dimension n and sign (-/+1). 2 childs possible</br>
736    * 3 node is pure dimension axis coordinate, all other dimension coordinates are 0 apart from current dimension. (max n - n) + 1 possible childs</br>
737    * 4 node is in the middle of somewhere. max n possible childs</br>
738    * @param p_usim_id_spc The child id to check data for.
739    * @param p_max_childs The maximum childs possible as calculated for dimension axis type.
740    * @return Returns dimension rating as defined.
741    */
742    FUNCTION dimension_rating( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
743                             , p_max_childs  OUT NUMBER
744                             )
745      RETURN NUMBER
746    ;
747
748    /**
749    * Gets the dimension axis rating for a given space id. Dimension rating:</br>
750    * -1 error retrieving axis rating.</br>
751    * 0 center axis at dimension n = 0, with position 0 in dimension 0. 2 special childs possible with opposite output energy sign.</br>
752    * 1 center axis at dimension n = 1, with position 0 in dimension n and sign (-/+1). (max n - n) x 2 + 1 childs possible</br>
753    * 2 center axis at dimension n > 1, with position 0 in dimension n and sign (-/+1). 2 childs possible</br>
754    * 3 node is pure dimension axis coordinate, all other dimension coordinates are 0 apart from current dimension. (max n - n) + 1 possible childs</br>
755    * 4 node is in the middle of somewhere. max n possible childs</br>
756    * @param p_usim_id_spc The child id to check data for.
757    * @return Returns dimension rating as defined.
758    */
759    FUNCTION dimension_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
760      RETURN NUMBER
761    ;
762
763    /***
764    * Returns the maximum possible childs a given space node can have calculated by the identified dimension axis type.
765    * Just a wrapper for dimension_rating.
766    * @param p_usim_id_spc The child id to check data for.
767    * @return Returns the maximum possible childs for the given space node or < 0 on errors.
768    */
769    FUNCTION max_childs(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
770      RETURN NUMBER
771    ;
772
773    /**
774    * Classifies a space parent node in means of options for connects to new space nodes. Considers only existing dimensions
775    * and position. Does not consider situations of escape and extend. Will set universe to crashed on severe errors.</br>
776    * Classifications:</br>
777    * -2 node not allowed, e.g. from type parent with ancestor in dimension 1 and position != 0.</br>
778    * -1 node data model corrupt, e.g. id is NULL or amount of childs not in sync with model.</br>
779    * 0 node is fully connected, no further childs or connects are possible.</br>
780    * 1 node is ready to get connected, further childs or connects are possible to dimensions and positions.</br>
781    * 2 node is ready to get connected, further childs or connects are possible only to dimensions.</br>
782    * 3 node is ready to get connected, further childs or connects are possible only to positions.</br>
783    * 4 node is ready to get connected, only new positions on dimension axis possible.</br>
784    * @param p_usim_id_spc The parent space id to classify.
785    * @return Returns the classification of the parent space node.
786    */
787    FUNCTION classify_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
788      RETURN NUMBER
789    ;
790
791    /**
792    * Classifies a space node in means of options to escape the universe or extend the existing universe dimensions and
793    * positions within the limits, so new connections are possible.</br>
794    * Classifications:</br>
795    * -1 error.</br>
796    * 0 node can only escape to another universe.</br>
797    * 1 node can extend dimensions and positions to escape.</br>
798    * 2 node can only extend dimensions to escape. Includes between positions to higher dimensions.</br>
799    * 3 node can only extend positions to escape.</br>
800    * 4 node can only delegate new dim axis to axis zero position on dimension 1.</br>
801    * 5 node can only delegate new position on axis to axis zero position on current dimension.</br>
802    * 6 node can only delegate new position on dimension axis 1 related to the space node.</br>
803    * 7 node can only delegate new between position on current and next free higher dimension to axis zero position on current dimension.</br>
804    * @param p_usim_id_spc The space id to classify.
805    * @return Returns the classification of the space node for escapes.
806    */
807    FUNCTION classify_escape(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
808      RETURN NUMBER
809    ;
810
811    /**
812    * Retrieves the dimensional gravitational constant for a given space node and its dimension.
813    * A wrapper for usim_maths.calc_dim_G.
814    * @param p_usim_id_spc The space node to get G for. Mandatory.
815    * @param p_node_G The dimensional gravitational constant for the space node as OUT parameter.
816    * @return Returns 1 if G could be calculated, 0 if an overflow happened or -1 on not supported errors or missing space id.
817    */
818    FUNCTION get_dim_G( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
819                      , p_node_G      OUT NUMBER
820                      )
821      RETURN NUMBER
822    ;
823
824    /**
825    * Retrieves the outer radius for a given space node. Radius r is the distance from one node to another node.
826    * @param p_usim_id_spc The space node to get G for. Mandatory.
827    * @param p_outer_planck_r The outer planck radius, the distance between space nodes, as OUT parameter.
828    * @return Returns 1 if radius could be calculated, 0 if an overflow happened or -1 on not supported errors or missing space id.
829    */
830    FUNCTION get_outer_planck_r( p_usim_id_spc    IN  usim_space.usim_id_spc%TYPE
831                               , p_outer_planck_r OUT NUMBER
832                               )
833      RETURN NUMBER
834    ;
835
836    /**
837    * Retrieves the energy as acceleration to add to the target node.
838    * A wrapper for usim_maths.calc_planck_a2.
839    * @param p_energy The energy of the source space node that accelerates its energy to the position of the target space node.
840    * @param p_radius The outer distance between neighbor space nodes.
841    * @param p_G The dimensional gravitational constant G for the source space node and its dimension.
842    * @param p_target_energy The energy to add to the target energy as OUT parameter.
843    * @return Returns 1 if target energy could be calculated, 0 on overflow or -1 on not supported errors or missing space id.
844    */
845    FUNCTION get_acceleration( p_energy         IN  NUMBER
846                             , p_radius         IN  NUMBER
847                             , p_G              IN  NUMBER
848                             , p_target_energy  OUT NUMBER
849                             )
850      RETURN NUMBER
851    ;
852
853  END usim_dbif;
854  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_dbif
IS
  /**This package is used as an database interface package, handling
  * exceptions from low level packages for the existing tables and
  * applying universe rules on package usage. It has dependencies to
  * all low level packages. Packages on a higher level should only
  * use usim_dbif for accessing objects.</br>
  * Will try to handle exceptions if possible. Severe application or
  * database errors will set all universes to crashed and raise the
  * exception found. All errors get logged as far as the database basically
  * still works.
  */

  /**
  * Sets all multiverses to crashed. This is for application errors like
  * exceptions that invalidate the whole model.
  * Uses an anonymous transaction to be able to write in any case.
  */
  PROCEDURE set_crashed;

  /**
  * Wrapper for usim_mlv.update_state. Updates state by USIM_MLV_STATE_V valid and calculated state.
  * If state does not match (STATUS_VALID = 0) the calculated state is set. If state is valid, do nothing.
  * @param p_usim_id_mlv The id of the universe, that should update its state.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the updated state or NULL on errors.
  */
  FUNCTION set_universe_state( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
                             , p_do_commit   IN BOOLEAN                          DEFAULT TRUE
                             )
    RETURN usim_multiverse.usim_universe_status%TYPE
  ;

  /**
  * Determines the state of the universe, the given space node is in and updates the state to the calculated state
  * of USIM_MLV_STATE_V if current state is not valid.
  * @param p_usim_id_spc The space id of a node in a universe that should update its state.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the current state of the universe or NULL on errors.
  */
  FUNCTION set_universe_state_spc( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                                 , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                                 )
    RETURN usim_multiverse.usim_universe_status%TYPE
  ;

  /**
  * Sets the seed universe active ignoring any current state. Used for placing start node and activate the seed universe for the
  * first run. Afterwards the universe state should be determined after running a process queue.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the activated state of the universe or NULL on errors.
  */
  FUNCTION set_seed_active(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN usim_multiverse.usim_universe_status%TYPE
  ;

  /**
  * Wrapper for usim_base.init_basedata.
  * Initializes the base data with the attributes that have to be set on insert if no base data
  * exist, otherwise do nothing. As this procedure mimics the constraints, adjusting the constraints needs package adjustment.
  * @param p_max_dimension The maximum dimensions possible for this multiverse.
  * @param p_usim_abs_max_number The absolute maximum number available for this multiverse.
  * @param p_usim_overflow_node_seed Defines the overflow behaviour, default 0 means standard overflow behaviour. If set to 1, all new nodes are created with the universe seed at coordinate 0 as the parent.
  * @return Returns 1 if base data init was successful, 0 on errors.
  */
  FUNCTION init_basedata( p_max_dimension            IN NUMBER DEFAULT 42
                        , p_usim_abs_max_number      IN NUMBER DEFAULT 99999999999999999999999999999999999999
                        , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
                        )
    RETURN NUMBER
  ;

  /**
  * Initialize the dimensions supported by the multiverse defined by usim_max_dimension in base_data.
  * Does nothing if base data do not exist. Wrapper for usim_dim.init_dimensions.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if base data exist and init was successful, 0 if base data do not exist and -1 on errors.
  */
  FUNCTION init_dimensions(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  ;

  /**
  * Initialize the positions supported by the multiverse defined by usim_abs_max_number in base_data.
  * Does nothing if base data do not exist. Wrapper for usim_pos.init_positions.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if base data exist and init was successful, 0 if base data do not exist and -1 on errors.
  */
  FUNCTION init_positions(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  ;

  /**
  * Checks if base data have been initialized.
  * @return Returns 1 if base data are available, otherwise 0.
  */
  FUNCTION has_basedata
    RETURN NUMBER
  ;

  /**
  * Checks if usim_space has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data_spc
    RETURN NUMBER
  ;

  /**
  * Checks if usim_space has already data for a given space id.
  * @param p_usim_id_spc The relation id of universe/dimension/position/node.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_process has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data_spr
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_process has already data for a given process id.
  * @param p_usim_id_spr The process id to check.
  * @return Returns 1 if data are available for this id, otherwise 0.
  */
  FUNCTION has_data_spr(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spr.has_unprocessed.
  * Checks if usim_spc_process has unprocessed data.
  * @return Returns 1 if unprocessed data are available, otherwise 0.
  */
  FUNCTION has_unprocessed
    RETURN NUMBER
  ;

  /**
  * Checks if usim_multiverse has data.
  * @return Returns 1 if data exists, otherwise 0.
  */
  FUNCTION has_data_mlv
    RETURN NUMBER
  ;

  /**
  * Checks if a given usim_multiverse id exists.
  * @param p_usim_id_mlv The id of the universe to check.
  * @return Returns 1 if universe exists, otherwise 0.
  */
  FUNCTION has_data_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spo.has_axis_max_pos_parent.
  * Checks if for the given space id a maximum position on the dimension axis of the space
  * node exists, that may or may not be different to the given space id. Handles escape situation 4 where
  * dimension axis zero nodes can trigger new positions on their dimension axis.
  * @param p_usim_id_spc The space id to check for max position on its dimension axis.
  * @return Returns 1 for maximum dimension position found, 0 for not found and -1 for errors in dimension symmetry.
  */
  FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given space node has free between axis positions, if node has not reached max childs possible.
  * @param p_usim_id_spc The space id to check for free between position on available dimension axis.
  * @return Returns 1 if between positions are available or 0 for no between positions available.
  */
  FUNCTION has_free_between(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if the universe seed is active.
  * @return Returns 1 if universe seed is active, otherwise 0.
  */
  FUNCTION is_seed_active
    RETURN NUMBER
  ;

  /**
  * Checks if the universe is active the given space node is in.
  * @param p_usim_id_spc The id of the space node to check universe state.
  * @return Returns 1 if universe is active, otherwise 0 for dead, crashed or inactive.
  */
  FUNCTION is_universe_active(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if the given space node is a base universe, not necessarily the base universe seed. Must have position 0
  * at dimension 0. Parents are not considered.
  * @param p_usim_id_spc The id of the space node to check universe base state.
  * @return Returns 1 if universe is a base type universe otherwise 0.
  */
  FUNCTION is_universe_base_type(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given position is in overflow. Depends on init_positions. Overflow is simply detected
  * by a position that does not exist.
  * @param p_usim_coordinate The coordinate to check against overflow.
  * @return Returns 1 if given position coordinate is counted as overflow otherwise 0.
  */
  FUNCTION is_overflow_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given universe is in position overflow. Depends on base data. Overflow is detected by highest
  * available space coordinates for every sign and compared against the maximum possible number.
  * @param p_usim_id_mlv The universe id to check against position overflow.
  * @return Returns 1 if given universe is counted as position overflow otherwise 0.
  */
  FUNCTION is_overflow_pos_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given universe is in dimension overflow. Depends on base data. Overflow is detected by highest
  * available rmd dimension for every n1 sign and compared against the maximum possible dimensions. It will check
  * only dimension overflow on axis level, not considering nodes inbetween connected to other dimensions.
  * @param p_usim_id_mlv The universe id to check against dimension overflow.
  * @return Returns TRUE if given universe is counted as dimension overflow otherwise FALSE.
  */
  FUNCTION is_overflow_dim_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if the universe for a given space id is in dimension overflow. Depends on base data. Overflow is detected by highest
  * available space dimension for every n1 sign and compared against the maximum possible dimension.It will check
  * only dimension overflow on axis level, not considering nodes inbetween connected to other dimensions.
  * @param p_usim_id_spc The space id to check the universe it belongs against dimension overflow.
  * @return Returns 1 if the universe for the given space id is counted as dimension overflow otherwise 0.
  */
  FUNCTION is_overflow_dim_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if the universe for a given space id is in position overflow. Means that for this specific space
  * id no position is free. Positions itself may not be in overflow. It will check only position overflow
  * on axis level, not considering nodes inbetween connected to other dimensions.
  * @param p_usim_id_spc The space id to check the universe it belongs against position overflow.
  * @return Returns 1 if the universe for the given space id is counted as position overflow otherwise 0.
  */
  FUNCTION is_overflow_pos_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given energy is in overflow. Depends on base data. Overflow is detected
  * by checking the given value against the maximum number supported.
  * @param p_energy The energy value to check against overflow.
  * @return Returns 1 if energy is counted as overflow otherwise 0 (also if no base data exist).
  */
  FUNCTION is_overflow_energy(p_energy IN NUMBER)
    RETURN NUMBER
  ;

  /**
  * Checks if an addition of  given energies would produce an overflow. Depends on base data. Overflow is detected
  * by checking the given value against the maximum number supported.
  * @param p_energy The energy value to check against overflow.
  * @return Returns 1 if energy is counted as overflow otherwise 0.
  */
  FUNCTION is_overflow_energy_add( p_energy IN NUMBER
                                 , p_add    IN NUMBER
                                 )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spc.get_id_spc_base_universe.
  * Checks if a given space node id is the base universe seed at dimension 0 and position 0.
  * @param p_usim_id_spc The space node id to check.
  * @return Returns 1 space node is base universe seed otherwise 0.
  */
  FUNCTION is_base_universe_seed(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spr.is_queue_valid.
  * Checks if the current unprocessed queue is valid. All unprocessed records must have the current
  * planck aeon and time and if the table is not empty, there must be at least 2 process records.
  * Count of process records must be a multitude of 2. An empty table will also return 1.
  * @return Returns 1 if queue is ready to be processed, otherwise error code: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
  */
  FUNCTION is_queue_valid
    RETURN NUMBER
  ;

  /**
  * Checks if a given space id is extendable with a new position. Space node must either be a zero position axis node or
  * a node that has no child it its dimension to match.
  * @param p_usim_id_spc The space node id to check.
  * @return Returns 1 if node has no child in its dimension, 2 if node is a zero position axis node else 0.
  */
  FUNCTION is_pos_extendable(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given space id is extendable with a new dimension.
  * @param p_usim_id_spc The space node id to check.
  * @param p_use_parent The parent space node id to use for dimension extend. NULL on return 0.
  * @param p_next_dim The next available dimension to create. NULL on return 0.
  * @return Returns 1 if node has no child in free dimension, 2 if new dimension on zero axis should be build else error 0.
  */
  FUNCTION is_dim_extendable( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                            , p_use_parent  OUT usim_space.usim_id_spc%TYPE
                            , p_next_dim    OUT usim_dimension.usim_n_dimension%TYPE
                            )
    RETURN NUMBER
  ;

  /**
  * Get the child count of a given space node either in related universe or in all
  * universes.
  * @param p_usim_id_spc The space node id to check.
  * @param p_ignore_mlv Defines if childs are only counted within universe of the space node (0) or childs are counted regardless of the universe they are in.
  * @return Returns amount of childs for the given space node and universe mode or NULL on errors.
  */
  FUNCTION child_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                      , p_ignore_mlv  IN NUMBER                      DEFAULT 0
                      )
    RETURN NUMBER
  ;

  /**
  * Get the parent count of a given space node either in related universe or in all
  * universes.
  * @param p_usim_id_spc The space node id to check.
  * @param p_ignore_mlv Defines if parents are only counted within universe of the space node (0) or parents are counted regardless of the universe they are in.
  * @return Returns amount of parents for the given space node and universe mode or NULL on errors.
  */
  FUNCTION parent_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                       , p_ignore_mlv  IN NUMBER                      DEFAULT 0
                       )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_mlv.insert_universe.
  * Inserts a new universe with the given values. Does check if a base universe already exists. USIM_UNIVERSE_STATUS is automatically set
  * to inactive on insert. USIM_IS_BASE_UNIVERSE is determined by existance of data. If no base universe exist, the universe gets the base universe, otherwise
  * the universe will be a sub-universe of the existing base universe.
  * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used or default if NULL or 0.
  * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value or default if NULL or 0.
  * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value or default if NULL or 0.
  * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value or default if NULL or 0.
  * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct.
  * @param p_usim_ultimate_border The ultimate border rule for this universe. 1 is ultimate border reached, no childs left, 0 is any border at dimensions axis even with childs left.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return The new universe big id or NULL if insert failed.
  */
  FUNCTION create_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                          , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                          , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                          , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                          , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                          )
    RETURN usim_multiverse.usim_id_mlv%TYPE
  ;

  /**
  * Creates a negative and a positive dim axis in usim_rel_mlv_dim if dimension > 0. Dimension 0 has only one
  * axis, in this case positive and negative dimension axis are equal. Wrapper for usim_rmd.insert_rmd.
  * @param p_usim_id_mlv The id of the universe, to add a dimension axis. The universe must exist.
  * @param p_usim_n_dimension The dimension n to create an dimension axis with signs for. Must be >= 0, integer and must exist.
  * @param p_usim_id_rmd_parent The rmd id of the parent axis at n = 1 if dimension > 1 otherwise NULL.
  * @param p_usim_id_rmd_pos The dimension axis for the given dimension with sign 1 if dimension > 0. Otherwise equal to p_usim_id_rmd_neg.
  * @param p_usim_id_rmd_neg The dimension axis for the given dimension with sign -1 if dimension > 0. Otherwise equal to p_usim_id_rmd_pos.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if dimension axis could be created or retrieved, 0 on errors.
  */
  FUNCTION create_dim_axis( p_usim_id_mlv        IN  usim_multiverse.usim_id_mlv%TYPE
                          , p_usim_n_dimension   IN  usim_dimension.usim_n_dimension%TYPE
                          , p_usim_id_rmd_parent IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_rmd_pos    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_rmd_neg    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_do_commit          IN  BOOLEAN                              DEFAULT TRUE
                          )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spc.insert_spc.
  * Inserts a new space node for the given ids in usim_space. Updates childs
  * and space position. Node is created for the space node.
  * @param p_usim_id_rmd The universe/dimension relation id.
  * @param p_usim_id_pos The position id.
  * @param p_usim_parents An array of position parent ids for this space node. EMPTY only allowed if universe of rmd is base universe and no entry at dimension 0, position 0, sign 0, n1 sign NULL does not exist.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new usim_id_spc id or NULL on errors.
  */
  FUNCTION create_space_node( p_usim_id_rmd  IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                            , p_usim_id_pos  IN usim_position.usim_id_pos%TYPE
                            , p_usim_parents IN usim_static.usim_ids_type
                            , p_do_commit    IN BOOLEAN                           DEFAULT TRUE
                            )
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Wrapper for usim_spr.insert_spr.
  * Inserts a new process record with status IS_PROCESSED = 0 and current real time, planck aeon
  * and planck tick.
  * @param p_usim_id_spc_source The space id of the process that emits energy. Must exist.
  * @param p_usim_id_spc_target The space id of the process that receives energy. Must exist.
  * @param p_usim_energy_source The energy of the source before processing. NULL not allowed.
  * @param p_usim_energy_target The energy of the target before processing.
  * @param p_usim_energy_output The energy output of the source before processing. NULL not allowed.
  * @return Returns the process id, otherwise NULL if constraints are not fulfilled.
  */
  FUNCTION create_process( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
                         , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
                         , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
                         , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
                         , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
                         , p_do_commit          IN BOOLEAN                                  DEFAULT TRUE
                         )
    RETURN usim_spc_process.usim_id_spr%TYPE
  ;

  /**
  * Checks border situation for a given space node and flips, depending on the border rule,
  * the process spin to the correct direction.
  * @param p_usim_id_spc The space node to check. Mandatory.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Return 1 if all was successfully processed otherwise 0.
  */
  FUNCTION check_border( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                       , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                       )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spc.flip_process_spin.
  * Updates usim_process_spin by flipping the existing value (1 to -1 and vice versa)
  * if the given space node is not in dimension 0 with position 0. Otherwise does nothing.
  * @param p_usim_id_spc The space id to flip process spin.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if no errors or 0 if space id does not exist.
  */
  FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                            , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                            )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spr.set_processed.
  * Sets the given process step to processed.
  * @param p_usim_id_spr The process id of the process that should be set to processed. Must exist.
  * @param p_process_state The process state to set. 1=processed, 2=universe not active, not processed. Default is 1.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if processed state could be set otherwise 0.
  */
  FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
                        , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
                        , p_do_commit     IN BOOLEAN                            DEFAULT TRUE
                        )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_pos.get_id_pos.
  * Retrieve the position id for a given coordinate.
  * @param p_usim_coordinate The coordinate to get the position id for.
  * @return Returns the usim_id_pos for the given coordinate or NULL on errors.
  */
  FUNCTION get_id_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Wrapper for usim_spc.get_id_pos.
  * Retrieve the position id for a given coordinate.
  * @param p_usim_id_spc The space id to get the position id for.
  * @return Returns the usim_id_pos for the given coordinate or NULL on errors.
  */
  FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Wrapper for usim_spc.get_id_nod.
  * Retrieves the node id for a given space id if it exists in usim_space.
  * @param p_usim_id_spc The space id.
  * @return Returns usim_id_nod if space id exists, otherwise NULL.
  */
  FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_node.usim_id_nod%TYPE
  ;

  /**
  * Wrapper for usim_spc.get_id_mlv.
  * Retrieves the universe id for a given space id if it exists in usim_space.
  * @param p_usim_id_spc The space id.
  * @return Returns usim_id_mlv if space id exists, otherwise NULL.
  */
  FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_multiverse.usim_id_mlv%TYPE
  ;

  /**
  * Wrapper for usim_spc.get_id_spc_base_universe.
  * Retrieve the space id of the universe base seed at position 0 and dimension 0 without any parents.
  * @return Returns the usim_id_spc if a base universe seed exists or NULL.
  */
  FUNCTION get_id_spc_base_universe
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Retrieve details about the space id for creation new dimensions.
  * @param p_usim_id_spc The space id to get data for.
  * @param p_usim_id_mlv The universe id of the space node.
  * @param p_usim_id_rmd The dimension axis id of the space node.
  * @param p_usim_sign The dimension sign of the space node.
  * @param p_usim_n1_sign The dimension n1 sign of the space node.
  * @return Returns 1 if data exist for space id or 0 if space id does not exist.
  */
  FUNCTION get_spc_dim_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                              , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
                              , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                              , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
                              , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                              )
    RETURN NUMBER
  ;

  /**
  * Retrieves the current absolute maximum number allowed.
  * @return The current value from column usim_abs_max_number or NULL if base data are not initialized.
  */
  FUNCTION get_abs_max_number
    RETURN NUMBER
  ;

  /**
  * Retrieves the coordinate of a given dimension and space node, if it exists in USIM_SPC_POS. The given dimension
  * may not be initialized yet and defaults to 0 if not available.
  * Relies on the fact, that table holds one position for one dimension, whatever axis the dimension has.
  * @param p_usim_id_spc The space id to get the coordinate for.
  * @param p_usim_n_dimension The dimension to get the coordinate for.
  * @return Returns on success the coordinate of the given dimension, otherwise NULL.
  */
  FUNCTION get_dim_coord( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Retrieves the dimension for a given node.
  * @param p_usim_id_spc The space id to get the dimension.
  * @return Returns the dimension or -1 if node does not exist.
  */
  FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Retrieves the dimension sign of a given space node.
  * @param p_usim_id_spc The space id.
  * @return The dimension sign of the space id or NULL, if space id does not exist.
  */
  FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  ;

  /**
  * Retrieves the dimension n=1 sign of a given space node.
  * @param p_usim_id_spc The space id.
  * @return The dimension n1 sign of the space id, 0 for base universe nodes or NULL, if space id does not exist.
  */
  FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
  ;

  /**
  * Wrapper for usim_spo.get_xyz.
  * Retrieves the x,y,z coordinates of a given space node, if it exists in USIM_SPC_POS.
  * @param p_usim_id_spc The space id to get the coordinates for.
  * @return Returns on success a comma separated string, format x,y,z, otherwise NULL.
  */
  FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  ;

  /**
  * Wrapper for usim_spo.get_magnitude.
  * Retrieves the magnitude of a vector for the given dimension.
  * @param p_usim_id_spc The space id to get the magnitude for.
  * @param p_usim_n_dimension The dimension for the magnitude calculation.
  * @return Returns the magnitude of the vector associated to the given space id or NULL on errors.
  */
  FUNCTION get_magnitude( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spc.get_process_spin.
  * Retrieves the process direction of a given space node.
  * @param p_usim_id_spc The space id to get the process direction.
  * @return Returns the process directions or NULL if space node does not exist.
  */
  FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_process_spin%TYPE
  ;

  /**
  * Retrieves the text expression of the universe state of the given space node.
  * @param p_usim_id_spc The space id to get the universe state description for.
  * @return Returns ACTIVE, INACTIVE, CRASHED, DEAD or UNKNOWN if universe does not exist.
  */
  FUNCTION get_universe_state_desc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  ;

  /**
  * Wrapper for usim_base.get_planck_time_current
  * Retrieves the current planck time tick.
  * @return The current value from column usim_planck_time_seq_curr or NULL if not initialized.
  */
  FUNCTION get_planck_time_current
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_base.get_planck_aeon_seq_current.
  * Retrieves the current planck aeon sequence big id.
  * @return The current value from column usim_planck_aeon_seq_curr or usim_static.usim_not_available if not initialized.
  */
  FUNCTION get_planck_aeon_seq_current
    RETURN VARCHAR2
  ;

  /**
  * Wrapper for usim_base.get_planck_time_next.
  * Retrieves the next planck time tick. Will update current and last planck time as well as planck
  * aeon if planck time sequence will cycle. If planck aeon is not set, it will be initialized.
  * @return The next planck time tick number or NULL if not initialized/sequence does not exist.
  */
  FUNCTION get_planck_time_next
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spr.get_unprocessed_planck.
  * Fetches the current planck aeon and time if the queue is valid. Will not operate on empty tables.
  * @param p_usim_planck_aeon The planck aeon for the current unprocessed records.
  * @param p_usim_planck_time The planck time for the current unprocessed records.
  * @return Returns 1 if planck data could be fetched, otherwise error code from USIM_SPR.IS_QUEUE_VALID: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
  */
  FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
                                 , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
                                 )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spo.get_axis_max_pos_parent.
  * Gets the space node with the maximum position on the given dimension axis. The dimension sign is
  * used to identify the expected coordinate sign, the dimension n1 sign is used to limit the space
  * which is divided into two subspaces by dimension 1. The dimension itself is used to identify the
  * dimension axis, we want to get a new parent node from to extend the dimension and universe.
  * Used with escape situation 4 where dimension axis zero nodes can trigger new positions on their dimension axis.
  * @param p_usim_id_spc The space id ancestor node which may be itself the parent node or a 0 node on a dimension axis that can trigger new coordinates.
  * @return The space node with the highest position on a dimension axis, sign and n1 sign of the given ancestor node, otherwise NULL on errors. Use has_axis_max_pos_parent to check before call.
  */
  FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Gets the current maximum position on the related dimension 1 axis for a given space node.
  * @param p_usim_id_spc The space id node to get the max dimension 1 position.
  * @return The maximum coordinate on dimension axis 1 or NULL on errors.
  */
  FUNCTION get_axis_max_pos_dim1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Retrieve the the next position and axis for a given space id.
  * @param p_usim_id_spc The space id ancestor node which may be itself the parent node or a 0 node on a dimension axis that can trigger new coordinates.
  * @return Return 1 if the operation was successful otherwise 0.
  */
  FUNCTION get_next_pos_on_axis( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                               , p_usim_id_pos OUT usim_position.usim_id_pos%TYPE
                               , p_usim_id_rmd OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                               )
    RETURN NUMBER
  ;

  /**
  * Gets the overflow rating for a given space id. Overflow rating:</br>
  * 0 if universe has overflow in position and dimension.</br>
  * 1 if no overflow at all.</br>
  * 2 if overflow in position.</br>
  * 3 if overflow in dimension.</br>
  * @param p_usim_id_spc The child id to check data for.
  * @return Returns overflow rating as defined.
  */
  FUNCTION overflow_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the dimension axis rating for a given space id and the possible maximum number of childs. Maximum childs are calculated for the next
  * possible dimension, if dimension is not already maximum to enable extension. Max n is n+1 where n+1 < max n else maximum possible dimensions. Dimension rating:</br>
  * -1 error retrieving axis rating.</br>
  * 0 center axis at dimension n = 0, with position 0 in dimension 0. 2 special childs possible with opposite output energy sign.</br>
  * 1 center axis at dimension n = 1, with position 0 in dimension n and sign (-/+1). (max n - n) x 2 + 1 childs possible</br>
  * 2 center axis at dimension n > 1, with position 0 in dimension n and sign (-/+1). 2 childs possible</br>
  * 3 node is pure dimension axis coordinate, all other dimension coordinates are 0 apart from current dimension. (max n - n) + 1 possible childs</br>
  * 4 node is in the middle of somewhere. max n possible childs</br>
  * @param p_usim_id_spc The child id to check data for.
  * @param p_max_childs The maximum childs possible as calculated for dimension axis type.
  * @return Returns dimension rating as defined.
  */
  FUNCTION dimension_rating( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                           , p_max_childs  OUT NUMBER
                           )
    RETURN NUMBER
  ;

  /**
  * Gets the dimension axis rating for a given space id. Dimension rating:</br>
  * -1 error retrieving axis rating.</br>
  * 0 center axis at dimension n = 0, with position 0 in dimension 0. 2 special childs possible with opposite output energy sign.</br>
  * 1 center axis at dimension n = 1, with position 0 in dimension n and sign (-/+1). (max n - n) x 2 + 1 childs possible</br>
  * 2 center axis at dimension n > 1, with position 0 in dimension n and sign (-/+1). 2 childs possible</br>
  * 3 node is pure dimension axis coordinate, all other dimension coordinates are 0 apart from current dimension. (max n - n) + 1 possible childs</br>
  * 4 node is in the middle of somewhere. max n possible childs</br>
  * @param p_usim_id_spc The child id to check data for.
  * @return Returns dimension rating as defined.
  */
  FUNCTION dimension_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /***
  * Returns the maximum possible childs a given space node can have calculated by the identified dimension axis type.
  * Just a wrapper for dimension_rating.
  * @param p_usim_id_spc The child id to check data for.
  * @return Returns the maximum possible childs for the given space node or < 0 on errors.
  */
  FUNCTION max_childs(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Classifies a space parent node in means of options for connects to new space nodes. Considers only existing dimensions
  * and position. Does not consider situations of escape and extend. Will set universe to crashed on severe errors.</br>
  * Classifications:</br>
  * -2 node not allowed, e.g. from type parent with ancestor in dimension 1 and position != 0.</br>
  * -1 node data model corrupt, e.g. id is NULL or amount of childs not in sync with model.</br>
  * 0 node is fully connected, no further childs or connects are possible.</br>
  * 1 node is ready to get connected, further childs or connects are possible to dimensions and positions.</br>
  * 2 node is ready to get connected, further childs or connects are possible only to dimensions.</br>
  * 3 node is ready to get connected, further childs or connects are possible only to positions.</br>
  * 4 node is ready to get connected, only new positions on dimension axis possible.</br>
  * @param p_usim_id_spc The parent space id to classify.
  * @return Returns the classification of the parent space node.
  */
  FUNCTION classify_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Classifies a space node in means of options to escape the universe or extend the existing universe dimensions and
  * positions within the limits, so new connections are possible.</br>
  * Classifications:</br>
  * -1 error.</br>
  * 0 node can only escape to another universe.</br>
  * 1 node can extend dimensions and positions to escape.</br>
  * 2 node can only extend dimensions to escape. Includes between positions to higher dimensions.</br>
  * 3 node can only extend positions to escape.</br>
  * 4 node can only delegate new dim axis to axis zero position on dimension 1.</br>
  * 5 node can only delegate new position on axis to axis zero position on current dimension.</br>
  * 6 node can only delegate new position on dimension axis 1 related to the space node.</br>
  * 7 node can only delegate new between position on current and next free higher dimension to axis zero position on current dimension.</br>
  * @param p_usim_id_spc The space id to classify.
  * @return Returns the classification of the space node for escapes.
  */
  FUNCTION classify_escape(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the dimensional gravitational constant for a given space node and its dimension.
  * A wrapper for usim_maths.calc_dim_G.
  * @param p_usim_id_spc The space node to get G for. Mandatory.
  * @param p_node_G The dimensional gravitational constant for the space node as OUT parameter.
  * @return Returns 1 if G could be calculated, 0 if an overflow happened or -1 on not supported errors or missing space id.
  */
  FUNCTION get_dim_G( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                    , p_node_G      OUT NUMBER
                    )
    RETURN NUMBER
  ;

  /**
  * Retrieves the outer radius for a given space node. Radius r is the distance from one node to another node.
  * @param p_usim_id_spc The space node to get G for. Mandatory.
  * @param p_outer_planck_r The outer planck radius, the distance between space nodes, as OUT parameter.
  * @return Returns 1 if radius could be calculated, 0 if an overflow happened or -1 on not supported errors or missing space id.
  */
  FUNCTION get_outer_planck_r( p_usim_id_spc    IN  usim_space.usim_id_spc%TYPE
                             , p_outer_planck_r OUT NUMBER
                             )
    RETURN NUMBER
  ;

  /**
  * Retrieves the energy as acceleration to add to the target node.
  * A wrapper for usim_maths.calc_planck_a2.
  * @param p_energy The energy of the source space node that accelerates its energy to the position of the target space node.
  * @param p_radius The outer distance between neighbor space nodes.
  * @param p_G The dimensional gravitational constant G for the source space node and its dimension.
  * @param p_target_energy The energy to add to the target energy as OUT parameter.
  * @return Returns 1 if target energy could be calculated, 0 on overflow or -1 on not supported errors or missing space id.
  */
  FUNCTION get_acceleration( p_energy         IN  NUMBER
                           , p_radius         IN  NUMBER
                           , p_G              IN  NUMBER
                           , p_target_energy  OUT NUMBER
                           )
    RETURN NUMBER
  ;

END usim_dbif;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_dbif
IS
  /**This package is used as an database interface package, handling
  * exceptions from low level packages for the existing tables and
  * applying universe rules on package usage. It has dependencies to
  * all low level packages. Packages on a higher level should only
  * use usim_dbif for accessing objects.</br>
  * Will try to handle exceptions if possible. Severe application or
  * database errors will set all universes to crashed and raise the
  * exception found. All errors get logged as far as the database basically
  * still works.
  */

  /**
  * Sets all multiverses to crashed. This is for application errors like
  * exceptions that invalidate the whole model.
  * Uses an anonymous transaction to be able to write in any case.
  */
  PROCEDURE set_crashed;

  /**
  * Wrapper for usim_mlv.update_state. Updates state by USIM_MLV_STATE_V valid and calculated state.
  * If state does not match (STATUS_VALID = 0) the calculated state is set. If state is valid, do nothing.
  * @param p_usim_id_mlv The id of the universe, that should update its state.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the updated state or NULL on errors.
  */
  FUNCTION set_universe_state( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
                             , p_do_commit   IN BOOLEAN                          DEFAULT TRUE
                             )
    RETURN usim_multiverse.usim_universe_status%TYPE
  ;

  /**
  * Determines the state of the universe, the given space node is in and updates the state to the calculated state
  * of USIM_MLV_STATE_V if current state is not valid.
  * @param p_usim_id_spc The space id of a node in a universe that should update its state.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the current state of the universe or NULL on errors.
  */
  FUNCTION set_universe_state_spc( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                                 , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                                 )
    RETURN usim_multiverse.usim_universe_status%TYPE
  ;

  /**
  * Sets the seed universe active ignoring any current state. Used for placing start node and activate the seed universe for the
  * first run. Afterwards the universe state should be determined after running a process queue.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the activated state of the universe or NULL on errors.
  */
  FUNCTION set_seed_active(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN usim_multiverse.usim_universe_status%TYPE
  ;

  /**
  * Wrapper for usim_base.init_basedata.
  * Initializes the base data with the attributes that have to be set on insert if no base data
  * exist, otherwise do nothing. As this procedure mimics the constraints, adjusting the constraints needs package adjustment.
  * @param p_max_dimension The maximum dimensions possible for this multiverse.
  * @param p_usim_abs_max_number The absolute maximum number available for this multiverse.
  * @param p_usim_overflow_node_seed Defines the overflow behaviour, default 0 means standard overflow behaviour. If set to 1, all new nodes are created with the universe seed at coordinate 0 as the parent.
  * @return Returns 1 if base data init was successful, 0 on errors.
  */
  FUNCTION init_basedata( p_max_dimension            IN NUMBER DEFAULT 42
                        , p_usim_abs_max_number      IN NUMBER DEFAULT 99999999999999999999999999999999999999
                        , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
                        )
    RETURN NUMBER
  ;

  /**
  * Initialize the dimensions supported by the multiverse defined by usim_max_dimension in base_data.
  * Does nothing if base data do not exist. Wrapper for usim_dim.init_dimensions.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if base data exist and init was successful, 0 if base data do not exist and -1 on errors.
  */
  FUNCTION init_dimensions(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  ;

  /**
  * Initialize the positions supported by the multiverse defined by usim_abs_max_number in base_data.
  * Does nothing if base data do not exist. Wrapper for usim_pos.init_positions.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if base data exist and init was successful, 0 if base data do not exist and -1 on errors.
  */
  FUNCTION init_positions(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  ;

  /**
  * Checks if base data have been initialized.
  * @return Returns 1 if base data are available, otherwise 0.
  */
  FUNCTION has_basedata
    RETURN NUMBER
  ;

  /**
  * Checks if usim_space has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data_spc
    RETURN NUMBER
  ;

  /**
  * Checks if usim_space has already data for a given space id.
  * @param p_usim_id_spc The relation id of universe/dimension/position/node.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_process has already data.
  * @return Returns 1 if data are available, otherwise 0.
  */
  FUNCTION has_data_spr
    RETURN NUMBER
  ;

  /**
  * Checks if usim_spc_process has already data for a given process id.
  * @param p_usim_id_spr The process id to check.
  * @return Returns 1 if data are available for this id, otherwise 0.
  */
  FUNCTION has_data_spr(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spr.has_unprocessed.
  * Checks if usim_spc_process has unprocessed data.
  * @return Returns 1 if unprocessed data are available, otherwise 0.
  */
  FUNCTION has_unprocessed
    RETURN NUMBER
  ;

  /**
  * Checks if usim_multiverse has data.
  * @return Returns 1 if data exists, otherwise 0.
  */
  FUNCTION has_data_mlv
    RETURN NUMBER
  ;

  /**
  * Checks if a given usim_multiverse id exists.
  * @param p_usim_id_mlv The id of the universe to check.
  * @return Returns 1 if universe exists, otherwise 0.
  */
  FUNCTION has_data_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spo.has_axis_max_pos_parent.
  * Checks if for the given space id a maximum position on the dimension axis of the space
  * node exists, that may or may not be different to the given space id. Handles escape situation 4 where
  * dimension axis zero nodes can trigger new positions on their dimension axis.
  * @param p_usim_id_spc The space id to check for max position on its dimension axis.
  * @return Returns 1 for maximum dimension position found, 0 for not found and -1 for errors in dimension symmetry.
  */
  FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given space node has free between axis positions, if node has not reached max childs possible.
  * @param p_usim_id_spc The space id to check for free between position on available dimension axis.
  * @return Returns 1 if between positions are available or 0 for no between positions available.
  */
  FUNCTION has_free_between(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if the universe seed is active.
  * @return Returns 1 if universe seed is active, otherwise 0.
  */
  FUNCTION is_seed_active
    RETURN NUMBER
  ;

  /**
  * Checks if the universe is active the given space node is in.
  * @param p_usim_id_spc The id of the space node to check universe state.
  * @return Returns 1 if universe is active, otherwise 0 for dead, crashed or inactive.
  */
  FUNCTION is_universe_active(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if the given space node is a base universe, not necessarily the base universe seed. Must have position 0
  * at dimension 0. Parents are not considered.
  * @param p_usim_id_spc The id of the space node to check universe base state.
  * @return Returns 1 if universe is a base type universe otherwise 0.
  */
  FUNCTION is_universe_base_type(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given position is in overflow. Depends on init_positions. Overflow is simply detected
  * by a position that does not exist.
  * @param p_usim_coordinate The coordinate to check against overflow.
  * @return Returns 1 if given position coordinate is counted as overflow otherwise 0.
  */
  FUNCTION is_overflow_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given universe is in position overflow. Depends on base data. Overflow is detected by highest
  * available space coordinates for every sign and compared against the maximum possible number.
  * @param p_usim_id_mlv The universe id to check against position overflow.
  * @return Returns 1 if given universe is counted as position overflow otherwise 0.
  */
  FUNCTION is_overflow_pos_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given universe is in dimension overflow. Depends on base data. Overflow is detected by highest
  * available rmd dimension for every n1 sign and compared against the maximum possible dimensions. It will check
  * only dimension overflow on axis level, not considering nodes inbetween connected to other dimensions.
  * @param p_usim_id_mlv The universe id to check against dimension overflow.
  * @return Returns TRUE if given universe is counted as dimension overflow otherwise FALSE.
  */
  FUNCTION is_overflow_dim_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if the universe for a given space id is in dimension overflow. Depends on base data. Overflow is detected by highest
  * available space dimension for every n1 sign and compared against the maximum possible dimension.It will check
  * only dimension overflow on axis level, not considering nodes inbetween connected to other dimensions.
  * @param p_usim_id_spc The space id to check the universe it belongs against dimension overflow.
  * @return Returns 1 if the universe for the given space id is counted as dimension overflow otherwise 0.
  */
  FUNCTION is_overflow_dim_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if the universe for a given space id is in position overflow. Means that for this specific space
  * id no position is free. Positions itself may not be in overflow. It will check only position overflow
  * on axis level, not considering nodes inbetween connected to other dimensions.
  * @param p_usim_id_spc The space id to check the universe it belongs against position overflow.
  * @return Returns 1 if the universe for the given space id is counted as position overflow otherwise 0.
  */
  FUNCTION is_overflow_pos_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given energy is in overflow. Depends on base data. Overflow is detected
  * by checking the given value against the maximum number supported.
  * @param p_energy The energy value to check against overflow.
  * @return Returns 1 if energy is counted as overflow otherwise 0 (also if no base data exist).
  */
  FUNCTION is_overflow_energy(p_energy IN NUMBER)
    RETURN NUMBER
  ;

  /**
  * Checks if an addition of  given energies would produce an overflow. Depends on base data. Overflow is detected
  * by checking the given value against the maximum number supported.
  * @param p_energy The energy value to check against overflow.
  * @return Returns 1 if energy is counted as overflow otherwise 0.
  */
  FUNCTION is_overflow_energy_add( p_energy IN NUMBER
                                 , p_add    IN NUMBER
                                 )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spc.get_id_spc_base_universe.
  * Checks if a given space node id is the base universe seed at dimension 0 and position 0.
  * @param p_usim_id_spc The space node id to check.
  * @return Returns 1 space node is base universe seed otherwise 0.
  */
  FUNCTION is_base_universe_seed(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spr.is_queue_valid.
  * Checks if the current unprocessed queue is valid. All unprocessed records must have the current
  * planck aeon and time and if the table is not empty, there must be at least 2 process records.
  * Count of process records must be a multitude of 2. An empty table will also return 1.
  * @return Returns 1 if queue is ready to be processed, otherwise error code: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
  */
  FUNCTION is_queue_valid
    RETURN NUMBER
  ;

  /**
  * Checks if a given space id is extendable with a new position. Space node must either be a zero position axis node or
  * a node that has no child it its dimension to match.
  * @param p_usim_id_spc The space node id to check.
  * @return Returns 1 if node has no child in its dimension, 2 if node is a zero position axis node else 0.
  */
  FUNCTION is_pos_extendable(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Checks if a given space id is extendable with a new dimension.
  * @param p_usim_id_spc The space node id to check.
  * @param p_use_parent The parent space node id to use for dimension extend. NULL on return 0.
  * @param p_next_dim The next available dimension to create. NULL on return 0.
  * @return Returns 1 if node has no child in free dimension, 2 if new dimension on zero axis should be build else error 0.
  */
  FUNCTION is_dim_extendable( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                            , p_use_parent  OUT usim_space.usim_id_spc%TYPE
                            , p_next_dim    OUT usim_dimension.usim_n_dimension%TYPE
                            )
    RETURN NUMBER
  ;

  /**
  * Get the child count of a given space node either in related universe or in all
  * universes.
  * @param p_usim_id_spc The space node id to check.
  * @param p_ignore_mlv Defines if childs are only counted within universe of the space node (0) or childs are counted regardless of the universe they are in.
  * @return Returns amount of childs for the given space node and universe mode or NULL on errors.
  */
  FUNCTION child_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                      , p_ignore_mlv  IN NUMBER                      DEFAULT 0
                      )
    RETURN NUMBER
  ;

  /**
  * Get the parent count of a given space node either in related universe or in all
  * universes.
  * @param p_usim_id_spc The space node id to check.
  * @param p_ignore_mlv Defines if parents are only counted within universe of the space node (0) or parents are counted regardless of the universe they are in.
  * @return Returns amount of parents for the given space node and universe mode or NULL on errors.
  */
  FUNCTION parent_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                       , p_ignore_mlv  IN NUMBER                      DEFAULT 0
                       )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_mlv.insert_universe.
  * Inserts a new universe with the given values. Does check if a base universe already exists. USIM_UNIVERSE_STATUS is automatically set
  * to inactive on insert. USIM_IS_BASE_UNIVERSE is determined by existance of data. If no base universe exist, the universe gets the base universe, otherwise
  * the universe will be a sub-universe of the existing base universe.
  * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used or default if NULL or 0.
  * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value or default if NULL or 0.
  * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value or default if NULL or 0.
  * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value or default if NULL or 0.
  * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct.
  * @param p_usim_ultimate_border The ultimate border rule for this universe. 1 is ultimate border reached, no childs left, 0 is any border at dimensions axis even with childs left.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return The new universe big id or NULL if insert failed.
  */
  FUNCTION create_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                          , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                          , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                          , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                          , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                          )
    RETURN usim_multiverse.usim_id_mlv%TYPE
  ;

  /**
  * Creates a negative and a positive dim axis in usim_rel_mlv_dim if dimension > 0. Dimension 0 has only one
  * axis, in this case positive and negative dimension axis are equal. Wrapper for usim_rmd.insert_rmd.
  * @param p_usim_id_mlv The id of the universe, to add a dimension axis. The universe must exist.
  * @param p_usim_n_dimension The dimension n to create an dimension axis with signs for. Must be >= 0, integer and must exist.
  * @param p_usim_id_rmd_parent The rmd id of the parent axis at n = 1 if dimension > 1 otherwise NULL.
  * @param p_usim_id_rmd_pos The dimension axis for the given dimension with sign 1 if dimension > 0. Otherwise equal to p_usim_id_rmd_neg.
  * @param p_usim_id_rmd_neg The dimension axis for the given dimension with sign -1 if dimension > 0. Otherwise equal to p_usim_id_rmd_pos.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if dimension axis could be created or retrieved, 0 on errors.
  */
  FUNCTION create_dim_axis( p_usim_id_mlv        IN  usim_multiverse.usim_id_mlv%TYPE
                          , p_usim_n_dimension   IN  usim_dimension.usim_n_dimension%TYPE
                          , p_usim_id_rmd_parent IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_rmd_pos    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_rmd_neg    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_do_commit          IN  BOOLEAN                              DEFAULT TRUE
                          )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spc.insert_spc.
  * Inserts a new space node for the given ids in usim_space. Updates childs
  * and space position. Node is created for the space node.
  * @param p_usim_id_rmd The universe/dimension relation id.
  * @param p_usim_id_pos The position id.
  * @param p_usim_parents An array of position parent ids for this space node. EMPTY only allowed if universe of rmd is base universe and no entry at dimension 0, position 0, sign 0, n1 sign NULL does not exist.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns the new usim_id_spc id or NULL on errors.
  */
  FUNCTION create_space_node( p_usim_id_rmd  IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                            , p_usim_id_pos  IN usim_position.usim_id_pos%TYPE
                            , p_usim_parents IN usim_static.usim_ids_type
                            , p_do_commit    IN BOOLEAN                           DEFAULT TRUE
                            )
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Wrapper for usim_spr.insert_spr.
  * Inserts a new process record with status IS_PROCESSED = 0 and current real time, planck aeon
  * and planck tick.
  * @param p_usim_id_spc_source The space id of the process that emits energy. Must exist.
  * @param p_usim_id_spc_target The space id of the process that receives energy. Must exist.
  * @param p_usim_energy_source The energy of the source before processing. NULL not allowed.
  * @param p_usim_energy_target The energy of the target before processing.
  * @param p_usim_energy_output The energy output of the source before processing. NULL not allowed.
  * @return Returns the process id, otherwise NULL if constraints are not fulfilled.
  */
  FUNCTION create_process( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
                         , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
                         , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
                         , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
                         , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
                         , p_do_commit          IN BOOLEAN                                  DEFAULT TRUE
                         )
    RETURN usim_spc_process.usim_id_spr%TYPE
  ;

  /**
  * Checks border situation for a given space node and flips, depending on the border rule,
  * the process spin to the correct direction.
  * @param p_usim_id_spc The space node to check. Mandatory.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Return 1 if all was successfully processed otherwise 0.
  */
  FUNCTION check_border( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                       , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                       )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spc.flip_process_spin.
  * Updates usim_process_spin by flipping the existing value (1 to -1 and vice versa)
  * if the given space node is not in dimension 0 with position 0. Otherwise does nothing.
  * @param p_usim_id_spc The space id to flip process spin.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if no errors or 0 if space id does not exist.
  */
  FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                            , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                            )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spr.set_processed.
  * Sets the given process step to processed.
  * @param p_usim_id_spr The process id of the process that should be set to processed. Must exist.
  * @param p_process_state The process state to set. 1=processed, 2=universe not active, not processed. Default is 1.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if processed state could be set otherwise 0.
  */
  FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
                        , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
                        , p_do_commit     IN BOOLEAN                            DEFAULT TRUE
                        )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_pos.get_id_pos.
  * Retrieve the position id for a given coordinate.
  * @param p_usim_coordinate The coordinate to get the position id for.
  * @return Returns the usim_id_pos for the given coordinate or NULL on errors.
  */
  FUNCTION get_id_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Wrapper for usim_spc.get_id_pos.
  * Retrieve the position id for a given coordinate.
  * @param p_usim_id_spc The space id to get the position id for.
  * @return Returns the usim_id_pos for the given coordinate or NULL on errors.
  */
  FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  ;

  /**
  * Wrapper for usim_spc.get_id_nod.
  * Retrieves the node id for a given space id if it exists in usim_space.
  * @param p_usim_id_spc The space id.
  * @return Returns usim_id_nod if space id exists, otherwise NULL.
  */
  FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_node.usim_id_nod%TYPE
  ;

  /**
  * Wrapper for usim_spc.get_id_mlv.
  * Retrieves the universe id for a given space id if it exists in usim_space.
  * @param p_usim_id_spc The space id.
  * @return Returns usim_id_mlv if space id exists, otherwise NULL.
  */
  FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_multiverse.usim_id_mlv%TYPE
  ;

  /**
  * Wrapper for usim_spc.get_id_spc_base_universe.
  * Retrieve the space id of the universe base seed at position 0 and dimension 0 without any parents.
  * @return Returns the usim_id_spc if a base universe seed exists or NULL.
  */
  FUNCTION get_id_spc_base_universe
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Retrieve details about the space id for creation new dimensions.
  * @param p_usim_id_spc The space id to get data for.
  * @param p_usim_id_mlv The universe id of the space node.
  * @param p_usim_id_rmd The dimension axis id of the space node.
  * @param p_usim_sign The dimension sign of the space node.
  * @param p_usim_n1_sign The dimension n1 sign of the space node.
  * @return Returns 1 if data exist for space id or 0 if space id does not exist.
  */
  FUNCTION get_spc_dim_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                              , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
                              , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                              , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
                              , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                              )
    RETURN NUMBER
  ;

  /**
  * Retrieves the current absolute maximum number allowed.
  * @return The current value from column usim_abs_max_number or NULL if base data are not initialized.
  */
  FUNCTION get_abs_max_number
    RETURN NUMBER
  ;

  /**
  * Retrieves the coordinate of a given dimension and space node, if it exists in USIM_SPC_POS. The given dimension
  * may not be initialized yet and defaults to 0 if not available.
  * Relies on the fact, that table holds one position for one dimension, whatever axis the dimension has.
  * @param p_usim_id_spc The space id to get the coordinate for.
  * @param p_usim_n_dimension The dimension to get the coordinate for.
  * @return Returns on success the coordinate of the given dimension, otherwise NULL.
  */
  FUNCTION get_dim_coord( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Retrieves the dimension for a given node.
  * @param p_usim_id_spc The space id to get the dimension.
  * @return Returns the dimension or -1 if node does not exist.
  */
  FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  ;

  /**
  * Retrieves the dimension sign of a given space node.
  * @param p_usim_id_spc The space id.
  * @return The dimension sign of the space id or NULL, if space id does not exist.
  */
  FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  ;

  /**
  * Retrieves the dimension n=1 sign of a given space node.
  * @param p_usim_id_spc The space id.
  * @return The dimension n1 sign of the space id, 0 for base universe nodes or NULL, if space id does not exist.
  */
  FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
  ;

  /**
  * Wrapper for usim_spo.get_xyz.
  * Retrieves the x,y,z coordinates of a given space node, if it exists in USIM_SPC_POS.
  * @param p_usim_id_spc The space id to get the coordinates for.
  * @return Returns on success a comma separated string, format x,y,z, otherwise NULL.
  */
  FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  ;

  /**
  * Wrapper for usim_spo.get_magnitude.
  * Retrieves the magnitude of a vector for the given dimension.
  * @param p_usim_id_spc The space id to get the magnitude for.
  * @param p_usim_n_dimension The dimension for the magnitude calculation.
  * @return Returns the magnitude of the vector associated to the given space id or NULL on errors.
  */
  FUNCTION get_magnitude( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spc.get_process_spin.
  * Retrieves the process direction of a given space node.
  * @param p_usim_id_spc The space id to get the process direction.
  * @return Returns the process directions or NULL if space node does not exist.
  */
  FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_process_spin%TYPE
  ;

  /**
  * Retrieves the text expression of the universe state of the given space node.
  * @param p_usim_id_spc The space id to get the universe state description for.
  * @return Returns ACTIVE, INACTIVE, CRASHED, DEAD or UNKNOWN if universe does not exist.
  */
  FUNCTION get_universe_state_desc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  ;

  /**
  * Wrapper for usim_base.get_planck_time_current
  * Retrieves the current planck time tick.
  * @return The current value from column usim_planck_time_seq_curr or NULL if not initialized.
  */
  FUNCTION get_planck_time_current
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_base.get_planck_aeon_seq_current.
  * Retrieves the current planck aeon sequence big id.
  * @return The current value from column usim_planck_aeon_seq_curr or usim_static.usim_not_available if not initialized.
  */
  FUNCTION get_planck_aeon_seq_current
    RETURN VARCHAR2
  ;

  /**
  * Wrapper for usim_base.get_planck_time_next.
  * Retrieves the next planck time tick. Will update current and last planck time as well as planck
  * aeon if planck time sequence will cycle. If planck aeon is not set, it will be initialized.
  * @return The next planck time tick number or NULL if not initialized/sequence does not exist.
  */
  FUNCTION get_planck_time_next
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spr.get_unprocessed_planck.
  * Fetches the current planck aeon and time if the queue is valid. Will not operate on empty tables.
  * @param p_usim_planck_aeon The planck aeon for the current unprocessed records.
  * @param p_usim_planck_time The planck time for the current unprocessed records.
  * @return Returns 1 if planck data could be fetched, otherwise error code from USIM_SPR.IS_QUEUE_VALID: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
  */
  FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
                                 , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
                                 )
    RETURN NUMBER
  ;

  /**
  * Wrapper for usim_spo.get_axis_max_pos_parent.
  * Gets the space node with the maximum position on the given dimension axis. The dimension sign is
  * used to identify the expected coordinate sign, the dimension n1 sign is used to limit the space
  * which is divided into two subspaces by dimension 1. The dimension itself is used to identify the
  * dimension axis, we want to get a new parent node from to extend the dimension and universe.
  * Used with escape situation 4 where dimension axis zero nodes can trigger new positions on their dimension axis.
  * @param p_usim_id_spc The space id ancestor node which may be itself the parent node or a 0 node on a dimension axis that can trigger new coordinates.
  * @return The space node with the highest position on a dimension axis, sign and n1 sign of the given ancestor node, otherwise NULL on errors. Use has_axis_max_pos_parent to check before call.
  */
  FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * Gets the current maximum position on the related dimension 1 axis for a given space node.
  * @param p_usim_id_spc The space id node to get the max dimension 1 position.
  * @return The maximum coordinate on dimension axis 1 or NULL on errors.
  */
  FUNCTION get_axis_max_pos_dim1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  ;

  /**
  * Retrieve the the next position and axis for a given space id.
  * @param p_usim_id_spc The space id ancestor node which may be itself the parent node or a 0 node on a dimension axis that can trigger new coordinates.
  * @return Return 1 if the operation was successful otherwise 0.
  */
  FUNCTION get_next_pos_on_axis( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                               , p_usim_id_pos OUT usim_position.usim_id_pos%TYPE
                               , p_usim_id_rmd OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                               )
    RETURN NUMBER
  ;

  /**
  * Gets the overflow rating for a given space id. Overflow rating:</br>
  * 0 if universe has overflow in position and dimension.</br>
  * 1 if no overflow at all.</br>
  * 2 if overflow in position.</br>
  * 3 if overflow in dimension.</br>
  * @param p_usim_id_spc The child id to check data for.
  * @return Returns overflow rating as defined.
  */
  FUNCTION overflow_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Gets the dimension axis rating for a given space id and the possible maximum number of childs. Maximum childs are calculated for the next
  * possible dimension, if dimension is not already maximum to enable extension. Max n is n+1 where n+1 < max n else maximum possible dimensions. Dimension rating:</br>
  * -1 error retrieving axis rating.</br>
  * 0 center axis at dimension n = 0, with position 0 in dimension 0. 2 special childs possible with opposite output energy sign.</br>
  * 1 center axis at dimension n = 1, with position 0 in dimension n and sign (-/+1). (max n - n) x 2 + 1 childs possible</br>
  * 2 center axis at dimension n > 1, with position 0 in dimension n and sign (-/+1). 2 childs possible</br>
  * 3 node is pure dimension axis coordinate, all other dimension coordinates are 0 apart from current dimension. (max n - n) + 1 possible childs</br>
  * 4 node is in the middle of somewhere. max n possible childs</br>
  * @param p_usim_id_spc The child id to check data for.
  * @param p_max_childs The maximum childs possible as calculated for dimension axis type.
  * @return Returns dimension rating as defined.
  */
  FUNCTION dimension_rating( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                           , p_max_childs  OUT NUMBER
                           )
    RETURN NUMBER
  ;

  /**
  * Gets the dimension axis rating for a given space id. Dimension rating:</br>
  * -1 error retrieving axis rating.</br>
  * 0 center axis at dimension n = 0, with position 0 in dimension 0. 2 special childs possible with opposite output energy sign.</br>
  * 1 center axis at dimension n = 1, with position 0 in dimension n and sign (-/+1). (max n - n) x 2 + 1 childs possible</br>
  * 2 center axis at dimension n > 1, with position 0 in dimension n and sign (-/+1). 2 childs possible</br>
  * 3 node is pure dimension axis coordinate, all other dimension coordinates are 0 apart from current dimension. (max n - n) + 1 possible childs</br>
  * 4 node is in the middle of somewhere. max n possible childs</br>
  * @param p_usim_id_spc The child id to check data for.
  * @return Returns dimension rating as defined.
  */
  FUNCTION dimension_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /***
  * Returns the maximum possible childs a given space node can have calculated by the identified dimension axis type.
  * Just a wrapper for dimension_rating.
  * @param p_usim_id_spc The child id to check data for.
  * @return Returns the maximum possible childs for the given space node or < 0 on errors.
  */
  FUNCTION max_childs(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Classifies a space parent node in means of options for connects to new space nodes. Considers only existing dimensions
  * and position. Does not consider situations of escape and extend. Will set universe to crashed on severe errors.</br>
  * Classifications:</br>
  * -2 node not allowed, e.g. from type parent with ancestor in dimension 1 and position != 0.</br>
  * -1 node data model corrupt, e.g. id is NULL or amount of childs not in sync with model.</br>
  * 0 node is fully connected, no further childs or connects are possible.</br>
  * 1 node is ready to get connected, further childs or connects are possible to dimensions and positions.</br>
  * 2 node is ready to get connected, further childs or connects are possible only to dimensions.</br>
  * 3 node is ready to get connected, further childs or connects are possible only to positions.</br>
  * 4 node is ready to get connected, only new positions on dimension axis possible.</br>
  * @param p_usim_id_spc The parent space id to classify.
  * @return Returns the classification of the parent space node.
  */
  FUNCTION classify_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Classifies a space node in means of options to escape the universe or extend the existing universe dimensions and
  * positions within the limits, so new connections are possible.</br>
  * Classifications:</br>
  * -1 error.</br>
  * 0 node can only escape to another universe.</br>
  * 1 node can extend dimensions and positions to escape.</br>
  * 2 node can only extend dimensions to escape. Includes between positions to higher dimensions.</br>
  * 3 node can only extend positions to escape.</br>
  * 4 node can only delegate new dim axis to axis zero position on dimension 1.</br>
  * 5 node can only delegate new position on axis to axis zero position on current dimension.</br>
  * 6 node can only delegate new position on dimension axis 1 related to the space node.</br>
  * 7 node can only delegate new between position on current and next free higher dimension to axis zero position on current dimension.</br>
  * @param p_usim_id_spc The space id to classify.
  * @return Returns the classification of the space node for escapes.
  */
  FUNCTION classify_escape(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the dimensional gravitational constant for a given space node and its dimension.
  * A wrapper for usim_maths.calc_dim_G.
  * @param p_usim_id_spc The space node to get G for. Mandatory.
  * @param p_node_G The dimensional gravitational constant for the space node as OUT parameter.
  * @return Returns 1 if G could be calculated, 0 if an overflow happened or -1 on not supported errors or missing space id.
  */
  FUNCTION get_dim_G( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                    , p_node_G      OUT NUMBER
                    )
    RETURN NUMBER
  ;

  /**
  * Retrieves the outer radius for a given space node. Radius r is the distance from one node to another node.
  * @param p_usim_id_spc The space node to get G for. Mandatory.
  * @param p_outer_planck_r The outer planck radius, the distance between space nodes, as OUT parameter.
  * @return Returns 1 if radius could be calculated, 0 if an overflow happened or -1 on not supported errors or missing space id.
  */
  FUNCTION get_outer_planck_r( p_usim_id_spc    IN  usim_space.usim_id_spc%TYPE
                             , p_outer_planck_r OUT NUMBER
                             )
    RETURN NUMBER
  ;

  /**
  * Retrieves the energy as acceleration to add to the target node.
  * A wrapper for usim_maths.calc_planck_a2.
  * @param p_energy The energy of the source space node that accelerates its energy to the position of the target space node.
  * @param p_radius The outer distance between neighbor space nodes.
  * @param p_G The dimensional gravitational constant G for the source space node and its dimension.
  * @param p_target_energy The energy to add to the target energy as OUT parameter.
  * @return Returns 1 if target energy could be calculated, 0 on overflow or -1 on not supported errors or missing space id.
  */
  FUNCTION get_acceleration( p_energy         IN  NUMBER
                           , p_radius         IN  NUMBER
                           , p_G              IN  NUMBER
                           , p_target_energy  OUT NUMBER
                           )
    RETURN NUMBER
  ;

END usim_dbif;

Package USIM_DBIF kompiliert

SQL> @@../PACKAGES/USIM_DBIF.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_dbif
  2  IS
  3    -- see header for documentation
  4
  5    PROCEDURE set_crashed
  6    IS
  7      PRAGMA AUTONOMOUS_TRANSACTION;
  8    BEGIN
  9      UPDATE usim_multiverse
 10         SET usim_universe_status = usim_static.usim_multiverse_status_crashed
 11      ;
 12      COMMIT;
 13    EXCEPTION
 14      WHEN OTHERS THEN
 15        ROLLBACK;
 16        -- write error might still work
 17        usim_erl.log_error('usim_dbif.set_crashed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
 18        -- try to set all to crashed
 19        usim_dbif.set_crashed;
 20        -- raise in any case
 21        RAISE;
 22    END set_crashed
 23    ;
 24
 25    FUNCTION set_universe_state( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
 26                               , p_do_commit   IN BOOLEAN                          DEFAULT TRUE
 27                               )
 28      RETURN usim_multiverse.usim_universe_status%TYPE
 29    IS
 30      l_return            NUMBER;
 31      l_status_valid      NUMBER;
 32      l_status_calculated usim_multiverse.usim_universe_status%TYPE;
 33    BEGIN
 34      -- check parameter
 35      IF usim_mlv.has_data(p_usim_id_mlv) = 1
 36      THEN
 37        -- check state and correct it if mismatch
 38        SELECT status_valid, status_calculated INTO l_status_valid, l_status_calculated FROM usim_mlv_state_v WHERE usim_id_mlv = p_usim_id_mlv;
 39        IF l_status_calculated != usim_static.usim_multiverse_status_active
 40        THEN
 41          -- we have an error in the universe
 42          usim_erl.log_error('usim_dbif.set_universe_state', 'Current invalid status not running for mlv id [' || p_usim_id_mlv || '] is [' || l_status_valid || '] calculated [' || l_status_calculated || '].');
 43          IF l_status_valid != 1
 44          THEN
 45            l_return := usim_mlv.update_state(p_usim_id_mlv, l_status_calculated, FALSE);
 46            IF l_return IS NULL
 47            THEN
 48              ROLLBACK;
 49              usim_erl.log_error('usim_dbif.set_universe_state', 'Could not update state for mlv id [' || p_usim_id_mlv || '].');
 50            END IF;
 51            RETURN l_return;
 52          ELSE
 53            RETURN l_status_calculated;
 54          END IF;
 55        ELSE
 56          -- update state, if current state not valid
 57          IF l_status_valid != 1
 58          THEN
 59            l_return := usim_mlv.update_state(p_usim_id_mlv, l_status_calculated, FALSE);
 60            IF l_return IS NULL
 61            THEN
 62              ROLLBACK;
 63              usim_erl.log_error('usim_dbif.set_universe_state', 'Could not update state for mlv id [' || p_usim_id_mlv || '].');
 64            END IF;
 65            RETURN l_return;
 66          ELSE
 67            RETURN l_status_calculated;
 68          END IF;
 69        END IF;
 70      ELSE
 71        usim_erl.log_error('usim_dbif.set_universe_state', 'Invalid parameter mlv id [' || p_usim_id_mlv || '].');
 72        RETURN NULL;
 73      END IF;
 74    EXCEPTION
 75      WHEN OTHERS THEN
 76        -- write error might still work
 77        usim_erl.log_error('usim_dbif.set_universe_state', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
 78        -- try to set all to crashed
 79        usim_dbif.set_crashed;
 80        -- raise in any case
 81        RAISE;
 82    END set_universe_state
 83    ;
 84
 85    FUNCTION set_universe_state_spc( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
 86                                   , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
 87                                   )
 88      RETURN usim_multiverse.usim_universe_status%TYPE
 89    IS
 90      l_usim_id_mlv       usim_multiverse.usim_id_mlv%TYPE;
 91      l_status_calculated usim_multiverse.usim_universe_status%TYPE;
 92      l_return            NUMBER;
 93      l_status_valid      NUMBER;
 94    BEGIN
 95      IF usim_spc.has_data(p_usim_id_spc) = 1
 96      THEN
 97        l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
 98        IF l_usim_id_mlv IS NULL
 99        THEN
100          usim_erl.log_error('usim_dbif.set_universe_state_spc', 'No valid universe found for space id [' || p_usim_id_spc || '].');
101          RETURN NULL;
102        END IF;
103        -- check state and correct it if mismatch
104        SELECT status_valid, status_calculated INTO l_status_valid, l_status_calculated FROM usim_mlv_state_v WHERE usim_id_mlv = l_usim_id_mlv;
105        -- do only something, is status is not valid
106        IF l_status_valid = 0
107        THEN
108          l_return := usim_mlv.update_state(l_usim_id_mlv, l_status_calculated, FALSE);
109          IF l_return IS NULL
110          THEN
111            ROLLBACK;
112            usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Could not update state for mlv id [' || l_usim_id_mlv || '].');
113          ELSE
114            IF p_do_commit
115            THEN
116              COMMIT;
117            END IF;
118          END IF;
119          RETURN l_return;
120        ELSIF l_status_valid = -1
121        THEN
122          usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Invalid calculation state for mlv id [' || l_usim_id_mlv || '].');
123          RETURN NULL;
124        ELSE
125          RETURN l_status_calculated;
126        END IF;
127      ELSE
128        usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Invalid parameter space id [' || p_usim_id_spc || '].');
129        RETURN NULL;
130      END IF;
131    EXCEPTION
132      WHEN OTHERS THEN
133        -- write error might still work
134        usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
135        -- try to set all to crashed
136        usim_dbif.set_crashed;
137        -- raise in any case
138        RAISE;
139    END set_universe_state_spc
140    ;
141
142    FUNCTION set_seed_active(p_do_commit IN BOOLEAN DEFAULT TRUE)
143      RETURN usim_multiverse.usim_universe_status%TYPE
144    IS
145      l_return      usim_multiverse.usim_universe_status%TYPE;
146      l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
147    BEGIN
148      IF usim_mlv.has_base = 1
149      THEN
150        SELECT usim_id_mlv INTO l_usim_id_mlv FROM usim_multiverse WHERE usim_is_base_universe = 1;
151        l_return := usim_mlv.update_state(l_usim_id_mlv, usim_static.usim_multiverse_status_active, FALSE);
152        IF l_return != usim_static.usim_multiverse_status_active
153        THEN
154          ROLLBACK;
155          usim_erl.log_error('usim_dbif.set_seed_active', 'Could not update state to active on universe seed id [' || l_usim_id_mlv || '] getting status [' || l_return || '].');
156          RETURN NULL;
157        ELSE
158          IF p_do_commit
159          THEN
160            COMMIT;
161          END IF;
162          RETURN l_return;
163        END IF;
164      ELSE
165        usim_erl.log_error('usim_dbif.set_seed_active', 'No base universe found.');
166        RETURN NULL;
167      END IF;
168    EXCEPTION
169      WHEN OTHERS THEN
170        ROLLBACK;
171        -- write error might still work
172        usim_erl.log_error('usim_dbif.set_seed_active', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
173        -- try to set all to crashed
174        usim_dbif.set_crashed;
175        -- raise in any case
176        RAISE;
177    END set_seed_active
178    ;
179
180    FUNCTION init_basedata( p_max_dimension            IN NUMBER DEFAULT 42
181                          , p_usim_abs_max_number      IN NUMBER DEFAULT 99999999999999999999999999999999999999
182                          , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
183                          )
184      RETURN NUMBER
185    IS
186      l_result NUMBER;
187    BEGIN
188      IF usim_base.has_basedata = 0
189      THEN
190        usim_base.init_basedata(p_max_dimension, p_usim_abs_max_number, p_usim_overflow_node_seed);
191      END IF;
192      IF usim_base.has_basedata = 0
193      THEN
194        usim_erl.log_error('usim_dbif.init_basedata', 'Could not initialize base data for max dim [' || p_max_dimension || '] max num [' || p_usim_abs_max_number || '] and overflow seed [' || p_usim_overflow_node_seed || '].');
195      END IF;
196      l_result := usim_base.has_basedata;
197      RETURN l_result;
198    EXCEPTION
199      WHEN OTHERS THEN
200        -- write error might still work
201        usim_erl.log_error('usim_dbif.init_basedata', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
202        -- try to set all to crashed
203        usim_dbif.set_crashed;
204        -- raise in any case
205        RAISE;
206    END init_basedata
207    ;
208
209    FUNCTION init_dimensions(p_do_commit IN BOOLEAN DEFAULT TRUE)
210      RETURN NUMBER
211    IS
212      l_max_dim usim_dimension.usim_n_dimension%TYPE;
213      l_return  NUMBER;
214    BEGIN
215      IF usim_base.has_basedata = 1
216      THEN
217        l_max_dim := usim_base.get_max_dimension;
218        l_return  := usim_dim.init_dimensions(l_max_dim, FALSE);
219        IF l_return != 1
220        THEN
221          ROLLBACK;
222          usim_erl.log_error('usim_dbif.init_dimensions', 'Could not init dimensions up to max [' || l_max_dim || '].');
223          RETURN -1;
224        ELSE
225          IF p_do_commit
226          THEN
227            COMMIT;
228           END IF;
229        END IF;
230        RETURN l_return;
231      ELSE
232        RETURN 0;
233      END IF;
234    EXCEPTION
235      WHEN OTHERS THEN
236        -- write error might still work
237        usim_erl.log_error('usim_dbif.init_dimensions', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
238        -- try to set all to crashed
239        usim_dbif.set_crashed;
240        -- raise in any case
241        RAISE;
242    END init_dimensions
243    ;
244
245    FUNCTION has_basedata
246      RETURN NUMBER
247    IS
248      l_result NUMBER;
249    BEGIN
250      l_result := usim_base.has_basedata;
251      RETURN l_result;
252    EXCEPTION
253      WHEN OTHERS THEN
254        ROLLBACK;
255        -- write error might still work
256        usim_erl.log_error('usim_dbif.has_basedata', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
257        -- try to set all to crashed
258        usim_dbif.set_crashed;
259        -- raise in any case
260        RAISE;
261    END has_basedata
262    ;
263
264    FUNCTION has_data_spc
265      RETURN NUMBER
266    IS
267      l_result NUMBER;
268    BEGIN
269      l_result := usim_spc.has_data;
270      RETURN l_result;
271    EXCEPTION
272      WHEN OTHERS THEN
273        ROLLBACK;
274        -- write error might still work
275        usim_erl.log_error('usim_dbif.has_data_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
276        -- try to set all to crashed
277        usim_dbif.set_crashed;
278        -- raise in any case
279        RAISE;
280    END has_data_spc
281    ;
282
283    FUNCTION has_data_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
284      RETURN NUMBER
285    IS
286      l_result NUMBER;
287    BEGIN
288      l_result := usim_spc.has_data(p_usim_id_spc);
289      RETURN l_result;
290    EXCEPTION
291      WHEN OTHERS THEN
292        ROLLBACK;
293        -- write error might still work
294        usim_erl.log_error('usim_dbif.has_data_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
295        -- try to set all to crashed
296        usim_dbif.set_crashed;
297        -- raise in any case
298        RAISE;
299    END has_data_spc
300    ;
301
302    FUNCTION has_data_spr
303      RETURN NUMBER
304    IS
305      l_result NUMBER;
306    BEGIN
307      l_result := usim_spr.has_data;
308      RETURN l_result;
309    EXCEPTION
310      WHEN OTHERS THEN
311        -- write error might still work
312        usim_erl.log_error('usim_dbif.has_data_spr', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
313        -- try to set all to crashed
314        usim_dbif.set_crashed;
315        -- raise in any case
316        RAISE;
317    END has_data_spr
318    ;
319
320    FUNCTION has_data_spr(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
321      RETURN NUMBER
322    IS
323      l_result NUMBER;
324    BEGIN
325      l_result := usim_spr.has_data(p_usim_id_spr);
326      RETURN l_result;
327    EXCEPTION
328      WHEN OTHERS THEN
329        -- write error might still work
330        usim_erl.log_error('usim_dbif.has_data_spr', 'Unexpected error for id [' || p_usim_id_spr || '], SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
331        -- try to set all to crashed
332        usim_dbif.set_crashed;
333        -- raise in any case
334        RAISE;
335    END has_data_spr
336    ;
337
338    FUNCTION has_unprocessed
339      RETURN NUMBER
340    IS
341      l_result NUMBER;
342    BEGIN
343      l_result := usim_spr.has_unprocessed;
344      RETURN l_result;
345    EXCEPTION
346      WHEN OTHERS THEN
347        -- write error might still work
348        usim_erl.log_error('usim_dbif.has_unprocessed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
349        -- try to set all to crashed
350        usim_dbif.set_crashed;
351        -- raise in any case
352        RAISE;
353    END has_unprocessed
354    ;
355
356    FUNCTION has_data_mlv
357      RETURN NUMBER
358    IS
359      l_result NUMBER;
360    BEGIN
361      l_result := usim_mlv.has_data;
362      RETURN l_result;
363    EXCEPTION
364      WHEN OTHERS THEN
365        -- write error might still work
366        usim_erl.log_error('usim_dbif.has_data_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
367        -- try to set all to crashed
368        usim_dbif.set_crashed;
369        -- raise in any case
370        RAISE;
371    END has_data_mlv
372    ;
373
374    FUNCTION has_data_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
375      RETURN NUMBER
376    IS
377      l_result NUMBER;
378    BEGIN
379      l_result := usim_mlv.has_data(p_usim_id_mlv);
380      RETURN l_result;
381    EXCEPTION
382      WHEN OTHERS THEN
383        -- write error might still work
384        usim_erl.log_error('usim_dbif.has_data_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
385        -- try to set all to crashed
386        usim_dbif.set_crashed;
387        -- raise in any case
388        RAISE;
389    END has_data_mlv
390    ;
391
392    FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
393      RETURN NUMBER
394    IS
395      l_result NUMBER;
396    BEGIN
397      l_result := usim_spo.has_axis_max_pos_parent(p_usim_id_spc);
398      IF l_result > 1
399      THEN
400        usim_erl.log_error('usim_dbif.has_axis_max_pos_parent', 'Error dimension symmetry, more than one maximum position on dimension axis found for space node [' || p_usim_id_spc || '].');
401        usim_dbif.set_crashed;
402        RETURN -1;
403      ELSE
404        RETURN l_result;
405      END IF;
406    EXCEPTION
407      WHEN OTHERS THEN
408        -- write error might still work
409        usim_erl.log_error('usim_dbif.has_axis_max_pos_parent', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
410        -- try to set all to crashed
411        usim_dbif.set_crashed;
412        -- raise in any case
413        RAISE;
414    END has_axis_max_pos_parent
415    ;
416
417    FUNCTION has_free_between(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
418      RETURN NUMBER
419    IS
420    BEGIN
421      -- if not related to all dimensions, relying on dimensions are built and assigned in order
422      IF usim_chi.get_cur_max_dimension(p_usim_id_spc) < usim_spc.get_cur_max_dim_n1(p_usim_id_spc)
423      THEN
424        RETURN 1;
425      ELSE
426        RETURN 0;
427      END IF;
428    EXCEPTION
429      WHEN OTHERS THEN
430        -- write error might still work
431        usim_erl.log_error('usim_dbif.has_free_between', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
432        -- try to set all to crashed
433        usim_dbif.set_crashed;
434        -- raise in any case
435        RAISE;
436    END has_free_between
437    ;
438
439    FUNCTION is_seed_active
440      RETURN NUMBER
441    IS
442      l_status_calculated NUMBER;
443      l_planck_aeon       usim_static.usim_id;
444      l_planck_time       NUMBER;
445      l_energy_total      NUMBER;
446      l_energy_positive   NUMBER;
447      l_energy_negative   NUMBER;
448      l_has_process_data  NUMBER;
449      l_has_unprocessed   NUMBER;
450    BEGIN
451      IF usim_mlv.has_base = 1
452      THEN
453        SELECT status_calculated INTO l_status_calculated FROM usim_mlv_state_v WHERE usim_is_base_universe = 1;
454        IF l_status_calculated = usim_static.usim_multiverse_status_active
455        THEN
456          RETURN 1;
457        ELSE
458          SELECT planck_aeon
459               , planck_time
460               , energy_base
461               , energy_positive
462               , energy_negative
463               , has_process_data
464               , has_unprocessed
465            INTO l_planck_aeon
466               , l_planck_time
467               , l_energy_total
468               , l_energy_positive
469               , l_energy_negative
470               , l_has_process_data
471               , l_has_unprocessed
472            FROM usim_mlv_state_v
473           WHERE usim_is_base_universe = 1
474          ;
475          usim_erl.log_error('usim_dbif.is_seed_active', 'Seed not active at planck aeon [' || l_planck_aeon || '], time [' || l_planck_time || '], total e [' || l_energy_total || '], e+ [' || l_energy_positive || '], e- [' || l_energy_negative || '], process data [' || l_has_process_data || '], unprocessed [' || l_has_unprocessed || '].');
476          RETURN 0;
477        END IF;
478      ELSE
479        usim_erl.log_error('usim_dbif.is_seed_active', 'No base universe found.');
480        RETURN 0;
481      END IF;
482    EXCEPTION
483      WHEN OTHERS THEN
484        -- write error might still work
485        usim_erl.log_error('usim_dbif.is_seed_active', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
486        -- try to set all to crashed
487        usim_dbif.set_crashed;
488        -- raise in any case
489        RAISE;
490    END is_seed_active
491    ;
492
493    FUNCTION is_universe_active(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
494      RETURN NUMBER
495    IS
496      l_mlv_id    usim_multiverse.usim_id_mlv%TYPE;
497      l_state     usim_multiverse.usim_universe_status%TYPE;
498    BEGIN
499      -- get universe
500      l_mlv_id := usim_spc.get_id_mlv(p_usim_id_spc);
501      IF l_mlv_id IS NULL
502      THEN
503        RETURN 0;
504      END IF;
505      l_state  := usim_mlv.get_state(l_mlv_id);
506      IF l_state = usim_static.usim_multiverse_status_active
507      THEN
508        RETURN 1;
509      ELSE
510        RETURN 0;
511      END IF;
512    EXCEPTION
513      WHEN OTHERS THEN
514        -- write error might still work
515        usim_erl.log_error('usim_dbif.is_universe_active', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
516        -- try to set all to crashed
517        usim_dbif.set_crashed;
518        -- raise in any case
519        RAISE;
520    END is_universe_active
521    ;
522
523    FUNCTION is_universe_base_type(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
524      RETURN NUMBER
525    IS
526      l_return NUMBER;
527    BEGIN
528      l_return := usim_spc.is_universe_base(p_usim_id_spc);
529      RETURN l_return;
530    EXCEPTION
531      WHEN OTHERS THEN
532        -- write error might still work
533        usim_erl.log_error('usim_dbif.is_universe_base', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
534        -- try to set all to crashed
535        usim_dbif.set_crashed;
536        -- raise in any case
537        RAISE;
538    END is_universe_base_type
539    ;
540
541    FUNCTION init_positions(p_do_commit IN BOOLEAN DEFAULT TRUE)
542      RETURN NUMBER
543    IS
544      l_max_pos usim_position.usim_coordinate%TYPE;
545      l_return  NUMBER;
546    BEGIN
547      IF usim_base.has_basedata = 1
548      THEN
549        l_max_pos := usim_base.get_abs_max_number;
550        l_return  := usim_pos.init_positions(l_max_pos, FALSE);
551        IF l_return != 1
552        THEN
553          ROLLBACK;
554          usim_erl.log_error('usim_dbif.init_positions', 'Could not init positions up to max [' || l_max_pos || '].');
555          RETURN -1;
556        ELSE
557          IF p_do_commit
558          THEN
559            COMMIT;
560          END IF;
561        END IF;
562        RETURN l_return;
563      ELSE
564        RETURN 0;
565      END IF;
566    EXCEPTION
567      WHEN OTHERS THEN
568        ROLLBACK;
569        -- write error might still work
570        usim_erl.log_error('usim_dbif.init_positions', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
571        -- try to set all to crashed
572        usim_dbif.set_crashed;
573        -- raise in any case
574        RAISE;
575    END init_positions
576    ;
577
578    FUNCTION is_overflow_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
579      RETURN NUMBER
580    IS
581    BEGIN
582      IF usim_pos.has_data = 0
583      THEN
584        -- no data
585        RETURN 0;
586      END IF;
587      IF usim_pos.has_data(p_usim_coordinate) = 1
588      THEN
589        RETURN 0;
590      ELSE
591        RETURN 1;
592      END IF;
593    EXCEPTION
594      WHEN OTHERS THEN
595        -- write error might still work
596        usim_erl.log_error('usim_dbif.is_overflow_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
597        -- try to set all to crashed
598        usim_dbif.set_crashed;
599        -- raise in any case
600        RAISE;
601    END is_overflow_pos
602    ;
603
604    FUNCTION is_overflow_pos_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
605      RETURN NUMBER
606    IS
607      l_max_pos1 usim_position.usim_coordinate%TYPE;
608      l_max_neg1 usim_position.usim_coordinate%TYPE;
609      l_max_pos2 usim_position.usim_coordinate%TYPE;
610      l_max_neg2 usim_position.usim_coordinate%TYPE;
611      l_max      NUMBER;
612    BEGIN
613      IF usim_mlv.has_data(p_usim_id_mlv) = 1
614      THEN
615        -- universe does not exist
616        RETURN 0;
617      END IF;
618      IF usim_base.has_basedata = 1
619      THEN
620        SELECT MAX(usim_n_dimension) INTO l_max_pos1 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = 1 AND usim_coordinate >= 0;
621        SELECT MIN(usim_n_dimension) INTO l_max_neg1 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = 1 AND usim_coordinate <= 0;
622        SELECT MAX(usim_n_dimension) INTO l_max_pos2 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = -1 AND usim_coordinate >= 0;
623        SELECT MIN(usim_n_dimension) INTO l_max_neg2 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = -1 AND usim_coordinate <= 0;
624        l_max := usim_base.get_abs_max_number;
625        IF     l_max_pos1      >= l_max
626           AND ABS(l_max_neg1) >= l_max
627           AND l_max_pos2      >= l_max
628           AND ABS(l_max_neg2) >= l_max
629        THEN
630          RETURN 1;
631        ELSE
632          RETURN 0;
633        END IF;
634      ELSE
635        -- can't check
636        RETURN 0;
637      END IF;
638    EXCEPTION
639      WHEN OTHERS THEN
640        -- write error might still work
641        usim_erl.log_error('usim_dbif.is_overflow_pos_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
642        -- try to set all to crashed
643        usim_dbif.set_crashed;
644        -- raise in any case
645        RAISE;
646    END is_overflow_pos_mlv
647    ;
648
649    FUNCTION is_overflow_dim_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
650      RETURN NUMBER
651    IS
652      l_max_dim_pos usim_dimension.usim_n_dimension%TYPE;
653      l_max_dim_neg usim_dimension.usim_n_dimension%TYPE;
654      l_max         NUMBER;
655    BEGIN
656      IF usim_mlv.has_data(p_usim_id_mlv) = 1
657      THEN
658        -- universe does not exist
659        RETURN 0;
660      END IF;
661      IF usim_base.has_basedata = 1
662      THEN
663        SELECT MAX(usim_n_dimension) INTO l_max_dim_pos FROM usim_rmd_v WHERE usim_id_mlv = p_usim_id_mlv AND usim_n1_sign = 1;
664        SELECT MAX(usim_n_dimension) INTO l_max_dim_neg FROM usim_rmd_v WHERE usim_id_mlv = p_usim_id_mlv AND usim_n1_sign = -1;
665        l_max := usim_base.get_max_dimension;
666        IF     l_max_dim_neg >= l_max
667           AND l_max_dim_pos >= l_max
668        THEN
669          RETURN 1;
670        ELSE
671          RETURN 0;
672        END IF;
673      ELSE
674        -- can't check
675        RETURN 0;
676      END IF;
677    EXCEPTION
678      WHEN OTHERS THEN
679        -- write error might still work
680        usim_erl.log_error('usim_dbif.is_overflow_dim_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
681        -- try to set all to crashed
682        usim_dbif.set_crashed;
683        -- raise in any case
684        RAISE;
685    END is_overflow_dim_mlv
686    ;
687
688    FUNCTION is_overflow_dim_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
689      RETURN NUMBER
690    IS
691      l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
692      l_max_dim     NUMBER;
693    BEGIN
694      IF usim_spc.has_data(p_usim_id_spc) = 1
695      THEN
696        l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
697        IF l_usim_id_mlv IS NULL
698        THEN
699          -- no overflow for not existing mlv
700          RETURN 0;
701        END IF;
702        -- check if is base at dimension 0 and has two childs = overflow
703        IF     usim_spc.is_universe_base(p_usim_id_spc) = 1
704           AND usim_chi.child_count(p_usim_id_spc)      = 2
705        THEN
706          RETURN 1;
707        ELSIF usim_spc.is_universe_base(p_usim_id_spc) = 1
708        THEN
709          RETURN 0;
710        ELSE
711          -- check if is not base and childs have all dimensions = overflow
712          SELECT MAX(usim_n_dimension)
713            INTO l_max_dim
714            FROM usim_spo_v
715           WHERE usim_id_spc = p_usim_id_spc
716             AND usim_id_mlv = l_usim_id_mlv
717          ;
718          IF l_max_dim >= usim_base.get_max_dimension
719          THEN
720            RETURN 1;
721          ELSE
722            RETURN 0;
723          END IF;
724        END IF;
725      ELSE
726        -- no overflow for not existing space id
727        RETURN 0;
728      END IF;
729    EXCEPTION
730      WHEN OTHERS THEN
731        -- write error might still work
732        usim_erl.log_error('usim_dbif.is_overflow_dim_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
733        -- try to set all to crashed
734        usim_dbif.set_crashed;
735        -- raise in any case
736        RAISE;
737    END is_overflow_dim_spc
738    ;
739
740    FUNCTION is_overflow_pos_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
741      RETURN NUMBER
742    IS
743    BEGIN
744      IF usim_spc.has_data(p_usim_id_spc) = 1
745      THEN
746        -- no position free on base
747        IF usim_spc.is_universe_base(p_usim_id_spc) = 1
748        THEN
749          -- base node has no position free
750          RETURN 1;
751        END IF;
752        -- if child in same dimension we are in overflow
753        IF     usim_chi.has_child_same_dim(p_usim_id_spc) = 1
754               -- if node is on position 0 on all axis, the node can trigger position extension, so it should not be a zero axis position
755           AND usim_spo.is_axis_zero_pos(p_usim_id_spc)   = 0
756        THEN
757          RETURN 1;
758        ELSE
759          RETURN 0;
760        END IF;
761      ELSE
762        -- no overflow if space id does not exist
763        RETURN 0;
764      END IF;
765    EXCEPTION
766      WHEN OTHERS THEN
767        -- write error might still work
768        usim_erl.log_error('usim_dbif.is_overflow_dim_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
769        -- try to set all to crashed
770        usim_dbif.set_crashed;
771        -- raise in any case
772        RAISE;
773    END is_overflow_pos_spc
774    ;
775
776    FUNCTION is_overflow_energy(p_energy IN NUMBER)
777      RETURN NUMBER
778    IS
779      l_result NUMBER;
780    BEGIN
781      IF usim_base.has_basedata = 1
782      THEN
783        l_result := usim_base.num_has_overflow(p_energy);
784        IF l_result = 1
785        THEN
786          RETURN 1;
787        ELSE
788          RETURN 0;
789        END IF;
790      ELSE
791        -- we can't check
792        RETURN 0;
793      END IF;
794    EXCEPTION
795      WHEN OTHERS THEN
796        IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
797        THEN
798          -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
799          -- -1487: packed decimal number too large
800          usim_erl.log_error('usim_dbif.is_overflow_energy', 'Numerical error on energy overflow check for [' || SQLCODE || '] error message: ' || SQLERRM);
801          RETURN 1;
802        ELSE
803          -- write error might still work
804          usim_erl.log_error('usim_dbif.is_overflow_energy', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
805          -- try to set all to crashed
806          usim_dbif.set_crashed;
807          -- raise in any case
808          RAISE;
809        END IF;
810    END is_overflow_energy
811    ;
812
813    FUNCTION is_overflow_energy_add( p_energy IN NUMBER
814                                   , p_add    IN NUMBER
815                                   )
816      RETURN NUMBER
817    IS
818      l_result NUMBER;
819    BEGIN
820      IF usim_base.has_basedata = 1
821      THEN
822        -- check against base
823        l_result := usim_base.num_add_has_overflow(p_energy, p_add);
824        RETURN l_result;
825      ELSE
826        -- check against system, if fails with numerical exception we have overflow state
827        l_result := p_energy + p_add;
828        RETURN 0;
829      END IF;
830    EXCEPTION
831      WHEN OTHERS THEN
832        IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
833        THEN
834          -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
835          -- -1487: packed decimal number too large
836          usim_erl.log_error('usim_dbif.is_overflow_energy_add', 'Numerical error on add energy overflow check [' || SQLCODE || '] error message: ' || SQLERRM);
837          RETURN 1;
838        ELSE
839          -- write error might still work
840          usim_erl.log_error('usim_dbif.is_overflow_energy_add', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
841          -- try to set all to crashed
842          usim_dbif.set_crashed;
843          -- raise in any case
844          RAISE;
845        END IF;
846    END is_overflow_energy_add
847    ;
848
849    FUNCTION is_base_universe_seed(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
850      RETURN NUMBER
851    IS
852    BEGIN
853      IF usim_spc.get_id_spc_base_universe = p_usim_id_spc
854      THEN
855        RETURN 1;
856      ELSE
857        IF usim_spc.has_base_universe = 0
858        THEN
859          usim_erl.log_error('usim_dbif.is_base_universe_seed', 'Used function without a base universe seed currently available.');
860        END IF;
861        RETURN 0;
862      END IF;
863    EXCEPTION
864      WHEN OTHERS THEN
865        -- write error might still work
866        usim_erl.log_error('usim_dbif.is_base_universe_seed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
867        -- try to set all to crashed
868        usim_dbif.set_crashed;
869        -- raise in any case
870        RAISE;
871    END is_base_universe_seed
872    ;
873
874    FUNCTION is_queue_valid
875      RETURN NUMBER
876    IS
877      l_return NUMBER;
878    BEGIN
879      l_return := usim_spr.is_queue_valid;
880      RETURN l_return;
881    EXCEPTION
882      WHEN OTHERS THEN
883        -- write error might still work
884        usim_erl.log_error('usim_dbif.is_queue_valid', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
885        -- try to set all to crashed
886        usim_dbif.set_crashed;
887        -- raise in any case
888        RAISE;
889    END is_queue_valid
890    ;
891
892    FUNCTION is_pos_extendable(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
893      RETURN NUMBER
894    IS
895    BEGIN
896      IF usim_chi.has_child_same_dim(p_usim_id_spc) = 0
897      THEN
898        RETURN 1;
899      END IF;
900      IF usim_spo.is_axis_zero_pos(p_usim_id_spc) = 1
901      THEN
902        RETURN 2;
903      END IF;
904      -- no check passed
905      usim_erl.log_error('usim_dbif.is_pos_extendable', 'Given space node id [' || p_usim_id_spc || '] is not extendable on position.');
906      RETURN 0;
907    EXCEPTION
908      WHEN OTHERS THEN
909        -- write error might still work
910        usim_erl.log_error('usim_dbif.is_pos_extendable', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
911        -- try to set all to crashed
912        usim_dbif.set_crashed;
913        -- raise in any case
914        RAISE;
915    END is_pos_extendable
916    ;
917
918    FUNCTION is_dim_extendable( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
919                              , p_use_parent  OUT usim_space.usim_id_spc%TYPE
920                              , p_next_dim    OUT usim_dimension.usim_n_dimension%TYPE
921                              )
922      RETURN NUMBER
923    IS
924      l_max_cur_dim NUMBER;
925      l_max_chi_dim NUMBER;
926      l_max_dim     NUMBER;
927    BEGIN
928      l_max_cur_dim := usim_spc.get_cur_max_dim_n1(p_usim_id_spc);
929      l_max_chi_dim := usim_chi.get_cur_max_dimension(p_usim_id_spc);
930      l_max_dim     := usim_base.get_max_dimension;
931      IF usim_spo.is_axis_zero_pos(p_usim_id_spc) = 1
932      THEN
933        IF l_max_chi_dim < l_max_dim
934        THEN
935          p_use_parent := p_usim_id_spc;
936          p_next_dim   := l_max_chi_dim + 1;
937          RETURN 2;
938        ELSE
939          -- no dimension left
940          p_use_parent := NULL;
941          p_next_dim   := NULL;
942          RETURN 0;
943        END IF;
944      END IF;
945      IF l_max_chi_dim < l_max_cur_dim
946      THEN
947        -- free available dimensions
948        p_use_parent := p_usim_id_spc;
949        p_next_dim   := l_max_chi_dim + 1;
950        RETURN 1;
951      ELSIF l_max_chi_dim < l_max_dim
952      THEN
953        -- free dimension, but dimension has to be build
954        p_use_parent := usim_spo.get_axis_zero_pos_parent(p_usim_id_spc);
955        p_next_dim   := l_max_chi_dim + 1;
956        RETURN 2;
957      ELSE
958        p_use_parent := NULL;
959        p_next_dim   := NULL;
960        RETURN 0;
961      END IF;
962    EXCEPTION
963      WHEN OTHERS THEN
964        -- write error might still work
965        usim_erl.log_error('usim_dbif.is_dim_extendable', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
966        -- try to set all to crashed
967        usim_dbif.set_crashed;
968        -- raise in any case
969        RAISE;
970    END is_dim_extendable
971    ;
972
973    FUNCTION child_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
974                        , p_ignore_mlv  IN NUMBER                      DEFAULT 0
975                        )
976      RETURN NUMBER
977    IS
978      l_result NUMBER;
979    BEGIN
980      IF p_ignore_mlv = 0
981      THEN
982        l_result := usim_chi.child_count(p_usim_id_spc);
983      ELSE
984        l_result := usim_chi.child_count_all(p_usim_id_spc);
985      END IF;
986      RETURN l_result;
987    EXCEPTION
988      WHEN OTHERS THEN
989        -- write error might still work
990        usim_erl.log_error('usim_dbif.child_count', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
991        -- try to set all to crashed
992        usim_dbif.set_crashed;
993        -- raise in any case
994        RAISE;
995    END child_count
996    ;
997
998    FUNCTION parent_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
999                         , p_ignore_mlv  IN NUMBER                      DEFAULT 0
1000                         )
1001      RETURN NUMBER
1002    IS
1003      l_result NUMBER;
1004    BEGIN
1005      IF p_ignore_mlv = 0
1006      THEN
1007        l_result := usim_chi.parent_count(p_usim_id_spc);
1008      ELSE
1009        l_result := usim_chi.parent_count_all(p_usim_id_spc);
1010      END IF;
1011      RETURN l_result;
1012    EXCEPTION
1013      WHEN OTHERS THEN
1014        -- write error might still work
1015        usim_erl.log_error('usim_dbif.parent_count', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1016        -- try to set all to crashed
1017        usim_dbif.set_crashed;
1018        -- raise in any case
1019        RAISE;
1020    END parent_count
1021    ;
1022
1023    FUNCTION create_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
1024                            , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
1025                            , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
1026                            , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
1027                            , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
1028                            , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
1029                            , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
1030                            )
1031      RETURN usim_multiverse.usim_id_mlv%TYPE
1032    IS
1033      l_result usim_multiverse.usim_id_mlv%TYPE;
1034    BEGIN
1035      IF usim_mlv.has_data     = 1
1036         AND usim_mlv.has_base = 0
1037      THEN
1038        -- wrong state
1039        usim_erl.log_error('usim_dbif.create_universe', 'Unexpected multiverse state no base universe but universes exist.');
1040        usim_dbif.set_crashed;
1041        RETURN NULL;
1042      END IF;
1043      l_result := usim_mlv.insert_universe( p_usim_energy_start_value
1044                                          , p_usim_planck_time_unit
1045                                          , p_usim_planck_length_unit
1046                                          , p_usim_planck_speed_unit
1047                                          , p_usim_planck_stable
1048                                          , p_usim_ultimate_border
1049                                          , FALSE
1050                                          )
1051      ;
1052      IF l_result IS NULL
1053      THEN
1054        ROLLBACK;
1055        usim_erl.log_error('usim_dbif.create_universe', 'Could not insert new universe.');
1056      ELSE
1057        IF p_do_commit
1058        THEN
1059          COMMIT;
1060        END IF;
1061      END IF;
1062      RETURN l_result;
1063    EXCEPTION
1064      WHEN OTHERS THEN
1065        ROLLBACK;
1066        -- write error might still work
1067        usim_erl.log_error('usim_dbif.create_universe', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1068        -- try to set all to crashed
1069        usim_dbif.set_crashed;
1070        -- raise in any case
1071        RAISE;
1072    END create_universe
1073    ;
1074
1075    FUNCTION create_dim_axis( p_usim_id_mlv        IN  usim_multiverse.usim_id_mlv%TYPE
1076                            , p_usim_n_dimension   IN  usim_dimension.usim_n_dimension%TYPE
1077                            , p_usim_id_rmd_parent IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
1078                            , p_usim_id_rmd_pos    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
1079                            , p_usim_id_rmd_neg    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
1080                            , p_do_commit          IN  BOOLEAN                              DEFAULT TRUE
1081                            )
1082      RETURN NUMBER
1083    IS
1084      l_sign    usim_rel_mlv_dim.usim_sign%TYPE;
1085      l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
1086    BEGIN
1087      IF     usim_dim.has_data(p_usim_n_dimension) = 1
1088         AND usim_mlv.has_data(p_usim_id_mlv)      = 1
1089      THEN
1090        -- do not commit until everything is processed
1091        IF p_usim_n_dimension = 0
1092        THEN
1093          p_usim_id_rmd_pos := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, 0, NULL, FALSE);
1094          p_usim_id_rmd_neg := usim_rmd.get_id_rmd(p_usim_id_mlv, p_usim_n_dimension, 0, NULL);
1095        ELSE
1096          IF p_usim_n_dimension > 1
1097          THEN
1098            IF p_usim_id_rmd_parent IS NOT NULL
1099            THEN
1100              l_sign := usim_rmd.get_dim_n1_sign(p_usim_id_rmd_parent);
1101              IF l_sign != 0
1102              THEN
1103                p_usim_id_rmd_pos := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, 1, l_sign, FALSE);
1104                p_usim_id_rmd_neg := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, -1, l_sign, FALSE);
1105              ELSE
1106                usim_erl.log_error('usim_dbif.create_dim_axis', 'Pparent rmd id returns invalid n1 sign 0.');
1107                RETURN 0;
1108              END IF;
1109            ELSE
1110              usim_erl.log_error('usim_dbif.create_dim_axis', 'Dimension > 1 but NULL parent rmd id given.');
1111              RETURN 0;
1112            END IF;
1113          ELSIF p_usim_n_dimension = 1
1114          THEN
1115            p_usim_id_rmd_pos := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, 1, 1, FALSE);
1116            p_usim_id_rmd_neg := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, -1, -1, FALSE);
1117          ELSE
1118            usim_erl.log_error('usim_dbif.create_dim_axis', 'Invalid dimension [' || p_usim_n_dimension || '].');
1119            RETURN 0;
1120          END IF;
1121        END IF;
1122        -- now check out values if we arrive here
1123        IF      p_usim_id_rmd_pos IS NOT NULL
1124            AND p_usim_id_rmd_neg IS NOT NULL
1125        THEN
1126          -- commit everything
1127          IF p_do_commit
1128          THEN
1129            COMMIT;
1130          END IF;
1131          RETURN 1;
1132        ELSE
1133          ROLLBACK;
1134          usim_erl.log_error('usim_dbif.create_dim_axis', 'Error creating dimension axis for [' || p_usim_n_dimension || '].');
1135          RETURN 0;
1136        END IF;
1137      ELSE
1138        usim_erl.log_error('usim_dbif.create_dim_axis', 'Invalid mlv [' || p_usim_id_mlv || '] or dimension [' || p_usim_n_dimension || '].');
1139        RETURN 0;
1140      END IF;
1141    EXCEPTION
1142      WHEN OTHERS THEN
1143        ROLLBACK;
1144        -- write error might still work
1145        usim_erl.log_error('usim_dbif.create_dim_axis', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1146        -- try to set all to crashed
1147        usim_dbif.set_crashed;
1148        -- raise in any case
1149        RAISE;
1150    END create_dim_axis
1151    ;
1152
1153    FUNCTION create_space_node( p_usim_id_rmd  IN usim_rel_mlv_dim.usim_id_rmd%TYPE
1154                              , p_usim_id_pos  IN usim_position.usim_id_pos%TYPE
1155                              , p_usim_parents IN usim_static.usim_ids_type
1156                              , p_do_commit    IN BOOLEAN                           DEFAULT TRUE
1157                              )
1158      RETURN usim_space.usim_id_spc%TYPE
1159    IS
1160      l_usim_id_mlv     usim_multiverse.usim_id_mlv%TYPE;
1161      l_usim_id_nod     usim_node.usim_id_nod%TYPE;
1162      l_usim_id_spc     usim_space.usim_id_spc%TYPE;
1163      l_usim_coordinate usim_position.usim_coordinate%TYPE;
1164      l_count           NUMBER;
1165      l_spin            NUMBER;
1166      l_return          NUMBER;
1167    BEGIN
1168      IF     usim_rmd.has_data(p_usim_id_rmd) = 1
1169         AND usim_pos.has_data(p_usim_id_pos) = 1
1170      THEN
1171        -- pos and rmd not unique, inbetween nodes
1172        -- check situation
1173        l_usim_id_mlv     := usim_rmd.get_id_mlv(p_usim_id_rmd);
1174        IF l_usim_id_mlv IS NULL
1175        THEN
1176          usim_erl.log_error('usim_dbif.create_space_node', 'Could not get universe for rmd [' || p_usim_id_rmd || '].');
1177          usim_dbif.set_crashed;
1178          RETURN NULL;
1179        END IF;
1180        l_usim_coordinate := usim_pos.get_coordinate(p_usim_id_pos);
1181        IF l_usim_coordinate IS NULL
1182        THEN
1183          usim_erl.log_error('usim_dbif.create_space_node', 'Could not get coordinate for pos [' || p_usim_id_pos || '].');
1184          usim_dbif.set_crashed;
1185          RETURN NULL;
1186        END IF;
1187        IF     usim_mlv.is_base(l_usim_id_mlv) = 0
1188           AND l_usim_coordinate              != 0
1189           AND p_usim_parents.COUNT            = 0
1190        THEN
1191          usim_erl.log_error('usim_dbif.create_space_node', 'Missing parent for not base universe and position not 0.');
1192          RETURN NULL;
1193        END IF;
1194        IF p_usim_parents.COUNT = 0
1195        THEN
1196          -- check if not already set
1197          SELECT COUNT(*)
1198            INTO l_count
1199            FROM usim_spc_v
1200           WHERE usim_id_mlv           = l_usim_id_mlv
1201             AND usim_is_base_universe = 1
1202             AND dim_sign              = 0
1203             AND dim_n1_sign          IS NULL
1204             AND usim_coordinate       = 0
1205          ;
1206          IF l_count != 0
1207          THEN
1208            usim_erl.log_error('usim_dbif.create_space_node', 'Base universe node at position 0, dimension 0 already exists.');
1209            RETURN NULL;
1210          END IF;
1211        END IF;
1212        -- define process spin, new childs normally are at the end of the row, so direction would be -1 (parent)
1213        -- whereas a node without parent is always in direction 1 (childs). The sign is initially direction child. As soon as
1214        -- processing begins, it will be flipped by processing to the correct direction, whenever the process encounters
1215        -- a border space node as defined by border rule.
1216        l_spin := 1;
1217        -- all checks passed, create node, do not commit until all is done
1218        l_usim_id_nod := usim_nod.insert_node(FALSE);
1219        l_usim_id_spc := usim_spc.insert_spc(p_usim_id_rmd, p_usim_id_pos, l_usim_id_nod, l_spin, FALSE);
1220        IF l_usim_id_spc IS NULL
1221        THEN
1222          ROLLBACK;
1223          usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node for rmd [' || p_usim_id_rmd || '] and position [' || p_usim_id_pos || '] .');
1224          usim_dbif.set_crashed;
1225          RETURN NULL;
1226        END IF;
1227        -- update position for parents
1228        IF p_usim_parents.COUNT > 0
1229        THEN
1230          FOR i IN p_usim_parents.FIRST..p_usim_parents.LAST
1231          LOOP
1232            l_return := usim_spo.insert_spc_pos(l_usim_id_spc, p_usim_parents(i), FALSE);
1233            IF l_return = 0
1234            THEN
1235              ROLLBACK;
1236              usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node position for spc [' || l_usim_id_spc || '] and parent [' || p_usim_parents(i) || '] .');
1237              usim_dbif.set_crashed;
1238              RETURN NULL;
1239            END IF;
1240            -- check parent child relation only same n1 sign apart from base universe nodes
1241            IF    usim_spc.get_dim_n1_sign(p_usim_parents(i))  = usim_spc.get_dim_n1_sign(l_usim_id_spc)
1242               OR usim_spc.is_universe_base(p_usim_parents(i)) = 1
1243               OR usim_spc.is_universe_base(l_usim_id_spc)     = 1
1244            THEN
1245              -- define relationship if parent is set
1246              l_return := usim_chi.insert_chi(p_usim_parents(i), l_usim_id_spc, FALSE);
1247              IF l_return = 0
1248              THEN
1249                ROLLBACK;
1250                usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node relation for spc [' || l_usim_id_spc || '] and parent [' || p_usim_parents(i) || '] .');
1251                usim_dbif.set_crashed;
1252                RETURN NULL;
1253              END IF;
1254            ELSE
1255              ROLLBACK;
1256              usim_erl.log_error('usim_dbif.create_space_node', 'Space node relation not allowed due to different n1 sign for spc [' || l_usim_id_spc || '] and parent [' || p_usim_parents(i) || '] not base node.');
1257              usim_dbif.set_crashed;
1258              RETURN NULL;
1259            END IF;
1260          END LOOP;
1261        ELSE
1262          l_return := usim_spo.insert_spc_pos(l_usim_id_spc, NULL, FALSE);
1263          IF l_return = 0
1264          THEN
1265            ROLLBACK;
1266            usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node position for spc [' || l_usim_id_spc || '] and parent NULL.');
1267            usim_dbif.set_crashed;
1268            RETURN NULL;
1269          END IF;
1270        END IF;
1271        -- creation done, commit if given
1272        IF p_do_commit
1273        THEN
1274          COMMIT;
1275        END IF;
1276        RETURN l_usim_id_spc;
1277      ELSE
1278        usim_erl.log_error('usim_dbif.create_space_node', 'Invalid rmd [' || p_usim_id_rmd || '] or position [' || p_usim_id_pos || '].');
1279        RETURN NULL;
1280      END IF;
1281    EXCEPTION
1282      WHEN OTHERS THEN
1283        ROLLBACK;
1284        -- write error might still work
1285        usim_erl.log_error('usim_dbif.create_space_node', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1286        -- try to set all to crashed
1287        usim_dbif.set_crashed;
1288        -- raise in any case
1289        RAISE;
1290    END create_space_node
1291    ;
1292
1293    FUNCTION create_process( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
1294                           , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
1295                           , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
1296                           , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
1297                           , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
1298                           , p_do_commit          IN BOOLEAN                                  DEFAULT TRUE
1299                           )
1300      RETURN usim_spc_process.usim_id_spr%TYPE
1301    IS
1302      l_result usim_spc_process.usim_id_spr%TYPE;
1303    BEGIN
1304      l_result := usim_spr.insert_spr(p_usim_id_spc_source, p_usim_id_spc_target, p_usim_energy_source, p_usim_energy_target, p_usim_energy_output, FALSE);
1305      IF l_result IS NOT NULL
1306      THEN
1307        IF p_do_commit
1308        THEN
1309          COMMIT;
1310        END IF;
1311      ELSE
1312        usim_erl.log_error('usim_dbif.create_process', 'Failed to insert process record.');
1313        ROLLBACK;
1314      END IF;
1315      RETURN l_result;
1316    EXCEPTION
1317      WHEN OTHERS THEN
1318        ROLLBACK;
1319        -- write error might still work
1320        usim_erl.log_error('usim_dbif.create_process', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1321        -- try to set all to crashed
1322        usim_dbif.set_crashed;
1323        -- raise in any case
1324        RAISE;
1325    END create_process
1326    ;
1327
1328    FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
1329                              , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
1330                              )
1331      RETURN NUMBER
1332    IS
1333      l_result NUMBER;
1334    BEGIN
1335      l_result := usim_spc.flip_process_spin(p_usim_id_spc, FALSE);
1336      IF l_result = 0
1337      THEN
1338        ROLLBACK;
1339        usim_erl.log_error('usim_dbif.flip_process_spin', 'Failed to flip process spin for space id [' || p_usim_id_spc || '].');
1340      ELSE
1341        IF p_do_commit
1342        THEN
1343          COMMIT;
1344        END IF;
1345      END IF;
1346      RETURN l_result;
1347    EXCEPTION
1348      WHEN OTHERS THEN
1349        ROLLBACK;
1350        -- write error might still work
1351        usim_erl.log_error('usim_dbif.flip_process_spin', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1352        -- try to set all to crashed
1353        usim_dbif.set_crashed;
1354        -- raise in any case
1355        RAISE;
1356    END flip_process_spin
1357    ;
1358
1359    FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
1360                          , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
1361                          , p_do_commit     IN BOOLEAN                            DEFAULT TRUE
1362                          )
1363      RETURN NUMBER
1364    IS
1365      l_result NUMBER;
1366    BEGIN
1367      l_result := usim_spr.set_processed(p_usim_id_spr, p_process_state, FALSE);
1368      IF l_result = 0
1369      THEN
1370        ROLLBACK;
1371        usim_erl.log_error('usim_dbif.set_processed', 'Failed to set processed state for id [' || p_usim_id_spr || '] and state [' || p_process_state || '].');
1372      ELSE
1373        IF p_do_commit
1374        THEN
1375          COMMIT;
1376        END IF;
1377      END IF;
1378      RETURN l_result;
1379    EXCEPTION
1380      WHEN OTHERS THEN
1381        ROLLBACK;
1382        -- write error might still work
1383        usim_erl.log_error('usim_dbif.set_processed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1384        -- try to set all to crashed
1385        usim_dbif.set_crashed;
1386        -- raise in any case
1387        RAISE;
1388    END set_processed
1389    ;
1390
1391    FUNCTION check_border( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
1392                         , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
1393                         )
1394      RETURN NUMBER
1395    IS
1396      l_usim_id_mlv   usim_multiverse.usim_id_mlv%TYPE;
1397      l_border_rule   usim_multiverse.usim_ultimate_border%TYPE;
1398      l_process_spin  usim_space.usim_process_spin%TYPE;
1399      l_result        INTEGER;
1400    BEGIN
1401      l_usim_id_mlv  := usim_spc.get_id_mlv(p_usim_id_spc);
1402      l_border_rule  := usim_mlv.get_ultimate_border(l_usim_id_mlv);
1403      l_process_spin := usim_spc.get_process_spin(p_usim_id_spc);
1404      IF l_border_rule = 1
1405      THEN
1406        -- if no child and direction is child flip to parent
1407        IF     usim_chi.child_count(p_usim_id_spc) = 0
1408           AND l_process_spin                      = 1
1409        THEN
1410          l_result := usim_spc.flip_process_spin(p_usim_id_spc, FALSE);
1411          -- check fail
1412          IF l_result = 1
1413          THEN
1414            IF p_do_commit
1415            THEN
1416              COMMIT;
1417            END IF;
1418            RETURN 1;
1419          ELSE
1420            usim_erl.log_error('usim_dbif.check_border', 'Could not flip process spin on space id [' || p_usim_id_spc || '].');
1421            -- set all to crashed
1422            usim_dbif.set_crashed;
1423            ROLLBACK;
1424            RETURN 0;
1425          END IF;
1426        ELSE
1427          RETURN 1;
1428        END IF;
1429      ELSE
1430        -- if no child in dimension and direction is child flip to parent
1431        IF     usim_chi.has_child_same_dim(p_usim_id_spc) = 0
1432           AND l_process_spin                             = 1
1433        THEN
1434          l_result := usim_spc.flip_process_spin(p_usim_id_spc, FALSE);
1435          -- check fail
1436          IF l_result = 1
1437          THEN
1438            IF p_do_commit
1439            THEN
1440              COMMIT;
1441            END IF;
1442            RETURN 1;
1443          ELSE
1444            usim_erl.log_error('usim_dbif.check_border', 'Could not flip process spin on space id [' || p_usim_id_spc || '].');
1445            -- set all to crashed
1446            usim_dbif.set_crashed;
1447            ROLLBACK;
1448            RETURN 0;
1449          END IF;
1450        END IF;
1451      END IF;
1452      RETURN 1;
1453    EXCEPTION
1454      WHEN OTHERS THEN
1455        ROLLBACK;
1456        -- write error might still work
1457        usim_erl.log_error('usim_dbif.check_border', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1458        -- try to set all to crashed
1459        usim_dbif.set_crashed;
1460        -- raise in any case
1461        RAISE;
1462    END check_border
1463    ;
1464
1465    FUNCTION get_id_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
1466      RETURN usim_position.usim_id_pos%TYPE
1467    IS
1468      l_usim_id_pos usim_position.usim_id_pos%TYPE;
1469    BEGIN
1470      IF usim_pos.has_data(p_usim_coordinate) = 1
1471      THEN
1472        l_usim_id_pos := usim_pos.get_id_pos(p_usim_coordinate);
1473        IF l_usim_id_pos IS NULL
1474        THEN
1475          usim_erl.log_error('usim_dbif.get_id_pos', 'Could not get position id for coordinate [' || p_usim_coordinate || '].');
1476        END IF;
1477        RETURN l_usim_id_pos;
1478      ELSE
1479        usim_erl.log_error('usim_dbif.get_id_pos', 'Invalid coordinate [' || p_usim_coordinate || '], maybe overflow.');
1480        RETURN NULL;
1481      END IF;
1482    EXCEPTION
1483      WHEN OTHERS THEN
1484        -- write error might still work
1485        usim_erl.log_error('usim_dbif.get_id_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1486        -- try to set all to crashed
1487        usim_dbif.set_crashed;
1488        -- raise in any case
1489        RAISE;
1490    END get_id_pos
1491    ;
1492
1493    FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1494      RETURN usim_position.usim_id_pos%TYPE
1495    IS
1496      l_usim_id_pos usim_position.usim_id_pos%TYPE;
1497    BEGIN
1498      IF usim_spc.has_data(p_usim_id_spc) = 1
1499      THEN
1500        l_usim_id_pos := usim_spc.get_id_pos(p_usim_id_spc);
1501        IF l_usim_id_pos IS NULL
1502        THEN
1503          usim_erl.log_error('usim_dbif.get_id_pos', 'Could not get position id for space node [' || p_usim_id_spc || '].');
1504        END IF;
1505        RETURN l_usim_id_pos;
1506      ELSE
1507        usim_erl.log_error('usim_dbif.get_id_pos', 'Invalid space id [' || p_usim_id_spc || '].');
1508        RETURN NULL;
1509      END IF;
1510    EXCEPTION
1511      WHEN OTHERS THEN
1512        -- write error might still work
1513        usim_erl.log_error('usim_dbif.get_id_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1514        -- try to set all to crashed
1515        usim_dbif.set_crashed;
1516        -- raise in any case
1517        RAISE;
1518    END get_id_pos
1519    ;
1520
1521    FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1522      RETURN usim_node.usim_id_nod%TYPE
1523    IS
1524      l_result usim_node.usim_id_nod%TYPE;
1525    BEGIN
1526      l_result := usim_spc.get_id_nod(p_usim_id_spc);
1527      IF l_result IS NULL
1528      THEN
1529        usim_erl.log_error('usim_dbif.get_id_nod', 'Invalid space id [' || p_usim_id_spc || '] or no node found.');
1530        usim_dbif.set_crashed;
1531      END IF;
1532      RETURN l_result;
1533    EXCEPTION
1534      WHEN OTHERS THEN
1535        -- write error might still work
1536        usim_erl.log_error('usim_dbif.get_id_nod', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1537        -- try to set all to crashed
1538        usim_dbif.set_crashed;
1539        -- raise in any case
1540        RAISE;
1541    END get_id_nod
1542    ;
1543
1544    FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1545      RETURN usim_multiverse.usim_id_mlv%TYPE
1546    IS
1547      l_result usim_multiverse.usim_id_mlv%TYPE;
1548    BEGIN
1549      l_result := usim_spc.get_id_mlv(p_usim_id_spc);
1550      IF l_result IS NULL
1551      THEN
1552        usim_erl.log_error('usim_dbif.get_id_mlv', 'Invalid space id [' || p_usim_id_spc || '] or no node found.');
1553        usim_dbif.set_crashed;
1554      END IF;
1555      RETURN l_result;
1556    EXCEPTION
1557      WHEN OTHERS THEN
1558        -- write error might still work
1559        usim_erl.log_error('usim_dbif.get_id_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1560        -- try to set all to crashed
1561        usim_dbif.set_crashed;
1562        -- raise in any case
1563        RAISE;
1564    END get_id_mlv
1565    ;
1566
1567    FUNCTION get_id_spc_base_universe
1568      RETURN usim_space.usim_id_spc%TYPE
1569    IS
1570      l_result usim_space.usim_id_spc%TYPE;
1571    BEGIN
1572      l_result := usim_spc.get_id_spc_base_universe;
1573      RETURN l_result;
1574    EXCEPTION
1575      WHEN OTHERS THEN
1576        -- write error might still work
1577        usim_erl.log_error('usim_dbif.get_id_spc_base_universe', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1578        -- try to set all to crashed
1579        usim_dbif.set_crashed;
1580        -- raise in any case
1581        RAISE;
1582    END get_id_spc_base_universe
1583    ;
1584
1585    FUNCTION get_spc_dim_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
1586                                , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
1587                                , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
1588                                , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
1589                                , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
1590                                )
1591      RETURN NUMBER
1592    IS
1593    BEGIN
1594      IF usim_spc.has_data(p_usim_id_spc) = 1
1595      THEN
1596        p_usim_id_mlv   := usim_spc.get_id_mlv(p_usim_id_spc);
1597        p_usim_id_rmd   := usim_spc.get_id_rmd(p_usim_id_spc);
1598        p_usim_sign     := usim_spc.get_dim_sign(p_usim_id_spc);
1599        p_usim_n1_sign  := usim_spc.get_dim_n1_sign(p_usim_id_spc);
1600        RETURN 1;
1601      ELSE
1602        usim_erl.log_error('usim_dbif.get_spc_dim_details', 'Not existing space id [' || p_usim_id_spc || '].');
1603        usim_dbif.set_crashed;
1604        RETURN 0;
1605      END IF;
1606    EXCEPTION
1607      WHEN OTHERS THEN
1608        -- write error might still work
1609        usim_erl.log_error('usim_dbif.get_spc_dim_details', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1610        -- try to set all to crashed
1611        usim_dbif.set_crashed;
1612        -- raise in any case
1613        RAISE;
1614    END get_spc_dim_details
1615    ;
1616
1617    FUNCTION get_abs_max_number
1618      RETURN NUMBER
1619    IS
1620      l_result NUMBER;
1621    BEGIN
1622      l_result := usim_base.get_abs_max_number;
1623      IF l_result IS NULL
1624      THEN
1625        usim_erl.log_error('usim_dbif.get_abs_max_number', 'Base data not initialized.');
1626      END IF;
1627      RETURN l_result;
1628    EXCEPTION
1629      WHEN OTHERS THEN
1630        -- write error might still work
1631        usim_erl.log_error('usim_dbif.get_abs_max_number', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1632        -- try to set all to crashed
1633        usim_dbif.set_crashed;
1634        -- raise in any case
1635        RAISE;
1636    END get_abs_max_number
1637    ;
1638
1639    FUNCTION get_dim_coord( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
1640                          , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
1641                          )
1642      RETURN usim_position.usim_coordinate%TYPE
1643    IS
1644      l_result usim_position.usim_coordinate%TYPE;
1645    BEGIN
1646      l_result := usim_spo.get_dim_coord(p_usim_id_spc, p_usim_n_dimension);
1647      IF l_result IS NULL
1648      THEN
1649        usim_erl.log_error('usim_dbif.get_dim_coord', 'Invalid space id [' || p_usim_id_spc || '] or dimension [' || p_usim_n_dimension || '].');
1650      END IF;
1651      RETURN l_result;
1652    EXCEPTION
1653      WHEN OTHERS THEN
1654        -- write error might still work
1655        usim_erl.log_error('usim_dbif.get_dim_coord', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1656        -- try to set all to crashed
1657        usim_dbif.set_crashed;
1658        -- raise in any case
1659        RAISE;
1660    END get_dim_coord
1661    ;
1662
1663    FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1664      RETURN usim_dimension.usim_n_dimension%TYPE
1665    IS
1666      l_result usim_dimension.usim_n_dimension%TYPE;
1667    BEGIN
1668      l_result := usim_spc.get_dimension(p_usim_id_spc);
1669      IF l_result = -1
1670      THEN
1671        usim_erl.log_error('usim_dbif.get_dimension', 'Invalid space id [' || p_usim_id_spc || '].');
1672      END IF;
1673      RETURN l_result;
1674    EXCEPTION
1675      WHEN OTHERS THEN
1676        -- write error might still work
1677        usim_erl.log_error('usim_dbif.get_dimension', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1678        -- try to set all to crashed
1679        usim_dbif.set_crashed;
1680        -- raise in any case
1681        RAISE;
1682    END get_dimension
1683    ;
1684
1685    FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1686      RETURN usim_rel_mlv_dim.usim_sign%TYPE
1687    IS
1688      l_result usim_rel_mlv_dim.usim_sign%TYPE;
1689    BEGIN
1690      l_result := usim_spc.get_dim_sign(p_usim_id_spc);
1691      IF l_result IS NULL
1692      THEN
1693        usim_erl.log_error('usim_dbif.get_dim_sign', 'Invalid space id [' || p_usim_id_spc || '].');
1694      END IF;
1695      RETURN l_result;
1696    EXCEPTION
1697      WHEN OTHERS THEN
1698        -- write error might still work
1699        usim_erl.log_error('usim_dbif.get_dim_sign', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1700        -- try to set all to crashed
1701        usim_dbif.set_crashed;
1702        -- raise in any case
1703        RAISE;
1704    END get_dim_sign
1705    ;
1706
1707    FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1708      RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
1709    IS
1710      l_result usim_rel_mlv_dim.usim_n1_sign%TYPE;
1711    BEGIN
1712      l_result := usim_spc.get_dim_n1_sign(p_usim_id_spc);
1713      IF l_result IS NULL
1714      THEN
1715        usim_erl.log_error('usim_dbif.get_dim_n1_sign', 'Invalid space id [' || p_usim_id_spc || '].');
1716      END IF;
1717      RETURN l_result;
1718    EXCEPTION
1719      WHEN OTHERS THEN
1720        -- write error might still work
1721        usim_erl.log_error('usim_dbif.get_dim_n1_sign', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1722        -- try to set all to crashed
1723        usim_dbif.set_crashed;
1724        -- raise in any case
1725        RAISE;
1726    END get_dim_n1_sign
1727    ;
1728
1729    FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1730      RETURN VARCHAR2
1731    IS
1732      l_result VARCHAR2(32000);
1733    BEGIN
1734      l_result := usim_spo.get_xyz(p_usim_id_spc);
1735      IF l_result IS NULL
1736      THEN
1737        usim_erl.log_error('usim_dbif.get_xyz', 'Invalid space id [' || p_usim_id_spc || '].');
1738      END IF;
1739      RETURN l_result;
1740    EXCEPTION
1741      WHEN OTHERS THEN
1742        -- write error might still work
1743        usim_erl.log_error('usim_dbif.get_xyz', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1744        -- try to set all to crashed
1745        usim_dbif.set_crashed;
1746        -- raise in any case
1747        RAISE;
1748    END get_xyz
1749    ;
1750
1751    FUNCTION get_magnitude( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
1752                          , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
1753                          )
1754      RETURN NUMBER
1755    IS
1756      l_result  NUMBER;
1757    BEGIN
1758      l_result := usim_spo.get_magnitude(p_usim_id_spc, p_usim_n_dimension);
1759      RETURN l_result;
1760    EXCEPTION
1761      WHEN OTHERS THEN
1762        -- write error might still work
1763        usim_erl.log_error('usim_dbif.get_magnitude', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1764        -- try to set all to crashed
1765        usim_dbif.set_crashed;
1766        -- raise in any case
1767        RAISE;
1768    END get_magnitude
1769    ;
1770
1771    FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1772      RETURN usim_space.usim_process_spin%TYPE
1773    IS
1774      l_result usim_space.usim_process_spin%TYPE;
1775    BEGIN
1776      l_result := usim_spc.get_process_spin(p_usim_id_spc);
1777      IF l_result IS NULL
1778      THEN
1779        usim_erl.log_error('usim_dbif.get_process_spin', 'Used with invalid space id [' || p_usim_id_spc || '].');
1780      END IF;
1781      RETURN l_result;
1782    EXCEPTION
1783      WHEN OTHERS THEN
1784        -- write error might still work
1785        usim_erl.log_error('usim_dbif.get_process_spin', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1786        -- try to set all to crashed
1787        usim_dbif.set_crashed;
1788        -- raise in any case
1789        RAISE;
1790    END get_process_spin
1791    ;
1792
1793    FUNCTION get_universe_state_desc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1794      RETURN VARCHAR2
1795    IS
1796      l_mlv_id    usim_multiverse.usim_id_mlv%TYPE;
1797      l_state     usim_multiverse.usim_universe_status%TYPE;
1798      l_result    VARCHAR2(8);
1799    BEGIN
1800      -- get universe
1801      l_mlv_id := usim_spc.get_id_mlv(p_usim_id_spc);
1802      IF l_mlv_id IS NULL
1803      THEN
1804        RETURN 'UNKNOWN';
1805      END IF;
1806      l_state  := usim_mlv.get_state(l_mlv_id);
1807      l_result := usim_static.get_multiverse_status(l_state);
1808      RETURN l_result;
1809    EXCEPTION
1810      WHEN OTHERS THEN
1811        -- write error might still work
1812        usim_erl.log_error('usim_dbif.get_universe_state_desc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1813        -- try to set all to crashed
1814        usim_dbif.set_crashed;
1815        -- raise in any case
1816        RAISE;
1817    END get_universe_state_desc
1818    ;
1819
1820    FUNCTION get_planck_time_current
1821      RETURN NUMBER
1822    IS
1823      l_result NUMBER;
1824    BEGIN
1825      l_result := usim_base.get_planck_time_current;
1826      IF l_result IS NULL
1827      THEN
1828        usim_erl.log_error('usim_dbif.get_planck_time_current', 'Planck time not initialized.');
1829        usim_dbif.set_crashed;
1830      END IF;
1831      RETURN l_result;
1832    EXCEPTION
1833      WHEN OTHERS THEN
1834        -- write error might still work
1835        usim_erl.log_error('usim_dbif.get_planck_time_current', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1836        -- try to set all to crashed
1837        usim_dbif.set_crashed;
1838        -- raise in any case
1839        RAISE;
1840    END get_planck_time_current
1841    ;
1842
1843    FUNCTION get_planck_aeon_seq_current
1844      RETURN VARCHAR2
1845    IS
1846      l_result CHAR(55);
1847    BEGIN
1848      l_result := usim_base.get_planck_aeon_seq_current;
1849      IF l_result IS NULL
1850      THEN
1851        usim_erl.log_error('usim_dbif.get_planck_aeon_seq_current', 'Planck aeon not initialized.');
1852        usim_dbif.set_crashed;
1853      END IF;
1854      RETURN l_result;
1855    EXCEPTION
1856      WHEN OTHERS THEN
1857        -- write error might still work
1858        usim_erl.log_error('usim_dbif.get_planck_aeon_seq_current', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1859        -- try to set all to crashed
1860        usim_dbif.set_crashed;
1861        -- raise in any case
1862        RAISE;
1863    END get_planck_aeon_seq_current
1864    ;
1865
1866    FUNCTION get_planck_time_next
1867      RETURN NUMBER
1868    IS
1869      l_result NUMBER;
1870    BEGIN
1871      l_result := usim_base.get_planck_time_next;
1872      IF l_result IS NULL
1873      THEN
1874        usim_erl.log_error('usim_dbif.get_planck_time_next', 'Planck time initialization error.');
1875        usim_dbif.set_crashed;
1876      END IF;
1877      RETURN l_result;
1878    EXCEPTION
1879      WHEN OTHERS THEN
1880        -- write error might still work
1881        usim_erl.log_error('usim_dbif.get_planck_time_next', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1882        -- try to set all to crashed
1883        usim_dbif.set_crashed;
1884        -- raise in any case
1885        RAISE;
1886    END get_planck_time_next
1887    ;
1888
1889    FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
1890                                   , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
1891                                   )
1892      RETURN NUMBER
1893    IS
1894      l_return NUMBER;
1895    BEGIN
1896      l_return := usim_spr.get_unprocessed_planck(p_usim_planck_aeon, p_usim_planck_time);
1897      RETURN l_return;
1898    EXCEPTION
1899      WHEN OTHERS THEN
1900        -- write error might still work
1901        usim_erl.log_error('usim_dbif.get_unprocessed_planck', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1902        -- try to set all to crashed
1903        usim_dbif.set_crashed;
1904        -- raise in any case
1905        RAISE;
1906    END get_unprocessed_planck
1907    ;
1908
1909    FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1910      RETURN usim_space.usim_id_spc%TYPE
1911    IS
1912      l_result usim_space.usim_id_spc%TYPE;
1913    BEGIN
1914      l_result := usim_spo.get_axis_max_pos_parent(p_usim_id_spc);
1915      RETURN l_result;
1916    EXCEPTION
1917      WHEN OTHERS THEN
1918        -- write error might still work
1919        usim_erl.log_error('usim_dbif.get_axis_max_pos_parent', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1920        -- try to set all to crashed
1921        usim_dbif.set_crashed;
1922        -- raise in any case
1923        RAISE;
1924    END get_axis_max_pos_parent
1925    ;
1926
1927    FUNCTION get_axis_max_pos_dim1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1928      RETURN usim_position.usim_coordinate%TYPE
1929    IS
1930      l_id_mlv  usim_multiverse.usim_id_mlv%TYPE;
1931      l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
1932      l_id_spc  usim_space.usim_id_spc%TYPE;
1933      l_parent  usim_space.usim_id_spc%TYPE;
1934      l_max_pos usim_position.usim_coordinate%TYPE;
1935    BEGIN
1936      l_id_mlv  := usim_spc.get_id_mlv(p_usim_id_spc);
1937      l_n1_sign := usim_spc.get_dim_n1_sign(p_usim_id_spc);
1938      IF usim_spc.get_cur_max_dim_n1(p_usim_id_spc) > 0
1939      THEN
1940        -- get dimension 1 by universe parent
1941        WITH rmd AS
1942             (SELECT usim_id_rmd
1943                FROM usim_rmd_v
1944               WHERE usim_id_mlv = l_id_mlv
1945                 AND usim_n_dimension = 0
1946             )
1947           , spc AS
1948             (SELECT spcv.usim_id_spc
1949                FROM usim_spc_v spcv
1950               INNER JOIN rmd
1951                  ON spcv.usim_id_rmd = rmd.usim_id_rmd
1952             )
1953        SELECT chiv.usim_id_spc_child
1954          INTO l_id_spc
1955          FROM usim_chi_v chiv
1956         INNER JOIN spc
1957            ON chiv.usim_id_spc = spc.usim_id_spc
1958         WHERE child_dim_n1_sign = l_n1_sign
1959        ;
1960        l_parent  := usim_spo.get_axis_max_pos_parent(l_id_spc);
1961        IF l_parent IS NULL
1962        THEN
1963          usim_erl.log_error('usim_dbif.get_axis_max_pos_dim1', 'Could not get max axis dimension 1 coordinate for [' || p_usim_id_spc || '] axis 1 pos 0 id [' || l_id_spc || '].');
1964          usim_dbif.set_crashed;
1965        END IF;
1966        l_max_pos := usim_spc.get_coordinate(l_parent);
1967        IF l_max_pos IS NULL
1968        THEN
1969          usim_erl.log_error('usim_dbif.get_axis_max_pos_dim1', 'Could not get max coordinate for [' || p_usim_id_spc || '] max pos space id [' || l_parent || '].');
1970          usim_dbif.set_crashed;
1971        END IF;
1972        RETURN l_max_pos;
1973      ELSE
1974        RETURN 0;
1975      END IF;
1976    EXCEPTION
1977      WHEN OTHERS THEN
1978        -- write error might still work
1979        usim_erl.log_error('usim_dbif.get_axis_max_pos_dim1', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1980        -- try to set all to crashed
1981        usim_dbif.set_crashed;
1982        -- raise in any case
1983        RAISE;
1984    END get_axis_max_pos_dim1
1985    ;
1986
1987    FUNCTION get_next_pos_on_axis( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
1988                                 , p_usim_id_pos OUT usim_position.usim_id_pos%TYPE
1989                                 , p_usim_id_rmd OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
1990                                 )
1991      RETURN NUMBER
1992    IS
1993      l_new_pos NUMBER;
1994    BEGIN
1995      IF usim_spc.has_data(p_usim_id_spc) = 1
1996      THEN
1997        -- determine the sign of the coordinate by dim sign
1998        IF usim_spc.get_dim_sign(p_usim_id_spc) = 1
1999        THEN
2000          l_new_pos := usim_spc.get_coordinate(p_usim_id_spc) + 1;
2001        ELSE
2002          l_new_pos := usim_spc.get_coordinate(p_usim_id_spc) - 1;
2003        END IF;
2004        p_usim_id_pos := usim_pos.get_id_pos(l_new_pos);
2005        p_usim_id_rmd := usim_spc.get_id_rmd(p_usim_id_spc);
2006        RETURN 1;
2007      ELSE
2008        usim_erl.log_error('usim_dbif.get_next_pos_on_axis', 'Invalid space id [' || p_usim_id_spc || '].');
2009        RETURN 0;
2010      END IF;
2011    EXCEPTION
2012      WHEN OTHERS THEN
2013        -- write error might still work
2014        usim_erl.log_error('usim_dbif.get_next_pos_on_axis', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2015        -- try to set all to crashed
2016        usim_dbif.set_crashed;
2017        -- raise in any case
2018        RAISE;
2019    END get_next_pos_on_axis
2020    ;
2021
2022    FUNCTION overflow_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
2023      RETURN NUMBER
2024    IS
2025    BEGIN
2026      -- do we have overflow on dimensions and positions
2027      IF      usim_dbif.is_overflow_dim_spc(p_usim_id_spc) = 1
2028         AND  usim_dbif.is_overflow_pos_spc(p_usim_id_spc) = 1
2029      THEN
2030        -- total overflow, no possible dimension or position open
2031        RETURN 0;
2032      ELSIF usim_dbif.max_childs(p_usim_id_spc) = usim_dbif.child_count(p_usim_id_spc)
2033      THEN
2034        -- total overflow, all possible childs connected
2035        RETURN 0;
2036      ELSIF usim_dbif.is_overflow_pos_spc(p_usim_id_spc) = 1
2037      THEN
2038        -- position overflow
2039        RETURN 2;
2040      ELSIF usim_dbif.is_overflow_dim_spc(p_usim_id_spc) = 1
2041      THEN
2042        -- dimension overflow
2043        RETURN 3;
2044      ELSE
2045        -- no overflow
2046        RETURN 1;
2047      END IF;
2048    EXCEPTION
2049      WHEN OTHERS THEN
2050        -- write error might still work
2051        usim_erl.log_error('usim_dbif.overflow_rating', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2052        -- try to set all to crashed
2053        usim_dbif.set_crashed;
2054        -- raise in any case
2055        RAISE;
2056    END overflow_rating
2057    ;
2058
2059    FUNCTION dimension_rating( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
2060                             , p_max_childs  OUT NUMBER
2061                             )
2062      RETURN NUMBER
2063    IS
2064      l_return       NUMBER;
2065      l_count        NUMBER;
2066      l_max_dim      NUMBER;
2067      l_usim_id_rmd  usim_rel_mlv_dim.usim_id_rmd%TYPE;
2068      l_usim_id_pos  usim_position.usim_id_pos%TYPE;
2069      l_usim_id_nod  usim_node.usim_id_nod%TYPE;
2070      l_process_spin usim_space.usim_process_spin%TYPE;
2071      l_usim_id_mlv  usim_multiverse.usim_id_mlv%TYPE;
2072      l_n_dimension  usim_dimension.usim_n_dimension%TYPE;
2073      l_dim_sign     usim_rel_mlv_dim.usim_sign%TYPE;
2074      l_dim_n1_sign  usim_rel_mlv_dim.usim_n1_sign%TYPE;
2075      l_coordinate   usim_position.usim_coordinate%TYPE;
2076      l_is_base      usim_multiverse.usim_is_base_universe%TYPE;
2077      l_energy       usim_node.usim_energy%TYPE;
2078     BEGIN
2079      IF usim_spc.has_data(p_usim_id_spc) = 1
2080      THEN
2081        -- get details
2082        l_return := usim_spc.get_spc_details( p_usim_id_spc
2083                                            , l_usim_id_rmd
2084                                            , l_usim_id_pos
2085                                            , l_usim_id_nod
2086                                            , l_process_spin
2087                                            , l_usim_id_mlv
2088                                            , l_n_dimension
2089                                            , l_dim_sign
2090                                            , l_dim_n1_sign
2091                                            , l_coordinate
2092                                            , l_is_base
2093                                            , l_energy
2094                                            )
2095        ;
2096        IF l_return = 0
2097        THEN
2098          usim_erl.log_error('usim_dbif.dimension_rating', 'Failed to get details for space id [' || p_usim_id_spc || '].');
2099          RETURN -1;
2100        END IF;
2101        IF     l_n_dimension = 0
2102           AND l_coordinate  = 0
2103        THEN
2104          -- only 2 special childs with opposite energy output sign possible
2105          p_max_childs := 2;
2106          RETURN 0;
2107        END IF;
2108        l_max_dim := NVL(usim_spc.get_cur_max_dim_n1(p_usim_id_spc), 0) + 1;
2109        IF usim_base.get_max_dimension < l_max_dim
2110        THEN
2111          l_max_dim := usim_base.get_max_dimension;
2112        END IF;
2113        IF     l_n_dimension = 1
2114           AND l_coordinate  = 0
2115        THEN
2116          -- zero pos dimension axis at dimension 1
2117          -- all dimension axis and position on dimension axis: (max n - n) x 2 + 1 axis child
2118          p_max_childs := ((l_max_dim - l_n_dimension) * 2) + 1;
2119          RETURN 1;
2120        END IF;
2121        IF     l_n_dimension > 1
2122           AND l_coordinate  = 0
2123        THEN
2124          -- zero pos dimension axis dimension > 1
2125          -- only position on dimension axis and 1 inbetween node: 2 childs
2126          p_max_childs := 2;
2127          RETURN 2;
2128        END IF;
2129        -- count coordinates not 0 for space id
2130        SELECT COUNT(*) INTO l_count FROM usim_spo_v WHERE usim_id_spc = p_usim_id_spc AND usim_coordinate != 0;
2131        IF     l_count       = 1
2132           AND l_coordinate != 0
2133        THEN
2134          -- pure dimension axis, possible childs: (max n - n) + 1 axis child
2135          p_max_childs := (l_max_dim  - l_n_dimension) + 1;
2136          RETURN 3;
2137        ELSE
2138          -- anywhere, possible childs: max n
2139          p_max_childs := l_max_dim;
2140          RETURN 4;
2141        END IF;
2142      ELSE
2143        usim_erl.log_error('usim_dbif.dimension_rating', 'Invalid space id [' || p_usim_id_spc || '].');
2144        RETURN -1;
2145      END IF;
2146    EXCEPTION
2147      WHEN OTHERS THEN
2148        -- write error might still work
2149        usim_erl.log_error('usim_dbif.dimension_rating', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2150        -- try to set all to crashed
2151        usim_dbif.set_crashed;
2152        -- raise in any case
2153        RAISE;
2154    END dimension_rating
2155    ;
2156
2157    FUNCTION dimension_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
2158      RETURN NUMBER
2159    IS
2160      l_max_childs NUMBER;
2161      l_rating     NUMBER;
2162    BEGIN
2163      l_rating := usim_dbif.dimension_rating(p_usim_id_spc, l_max_childs);
2164      RETURN l_rating;
2165    EXCEPTION
2166      WHEN OTHERS THEN
2167        -- write error might still work
2168        usim_erl.log_error('usim_dbif.dimension_rating', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2169        -- try to set all to crashed
2170        usim_dbif.set_crashed;
2171        -- raise in any case
2172        RAISE;
2173    END dimension_rating
2174    ;
2175
2176    FUNCTION max_childs(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
2177      RETURN NUMBER
2178    IS
2179      l_max_childs NUMBER;
2180      l_rating     NUMBER;
2181    BEGIN
2182      l_rating := usim_dbif.dimension_rating(p_usim_id_spc, l_max_childs);
2183      RETURN l_max_childs;
2184    EXCEPTION
2185      WHEN OTHERS THEN
2186        -- write error might still work
2187        usim_erl.log_error('usim_dbif.max_childs', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2188        -- try to set all to crashed
2189        usim_dbif.set_crashed;
2190        -- raise in any case
2191        RAISE;
2192    END max_childs
2193    ;
2194
2195    FUNCTION classify_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
2196      RETURN NUMBER
2197    IS
2198      l_count        NUMBER;
2199      l_return       NUMBER;
2200      l_dim_rating   NUMBER;
2201      l_parent_count NUMBER;
2202      l_child_count  NUMBER;
2203      l_connections  NUMBER;
2204      l_max_dim      NUMBER;
2205      l_max_child    NUMBER;
2206      l_dimension    NUMBER;
2207      l_max_pos      NUMBER;
2208      l_has_n1       NUMBER;
2209    BEGIN
2210      IF usim_spc.has_data(p_usim_id_spc) = 0
2211      THEN
2212        RETURN -1;
2213      END IF;
2214      -- get details
2215      l_dim_rating := usim_dbif.dimension_rating(p_usim_id_spc, l_max_child);
2216      IF l_dim_rating = -1
2217      THEN
2218        usim_erl.log_error('usim_dbif.classify_parent', 'Failed to get a dimension rating for space id [' || p_usim_id_spc || '].');
2219        RETURN -1;
2220      END IF;
2221      -- ignore errors like no child or parent, we get values anyway
2222      l_return      := usim_chi.get_chi_details(p_usim_id_spc, l_parent_count, l_child_count);
2223      IF l_dim_rating = 0 -- center of a universe dimension
2224      THEN
2225        -- no more childs possible
2226        IF l_child_count = l_max_child
2227        THEN
2228          -- fully connected
2229          RETURN 0;
2230        ELSE
2231          -- only next dimension possible
2232          RETURN 2;
2233        END IF;
2234      ELSIF l_dim_rating = 1 -- center dimension axis with pos 0 dimension > 0
2235      THEN
2236        -- only 2 childs possible
2237        IF l_child_count = l_max_child
2238        THEN
2239          -- fully connected
2240          RETURN 0;
2241        ELSE
2242          IF l_child_count > 0
2243          THEN
2244            -- find free node
2245            IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
2246            THEN
2247              -- if the position number on x axis that equals next dimension does not exist only position on X axis possible
2248              l_dimension := usim_spc.get_dimension(p_usim_id_spc) + 1;
2249              l_max_pos := ABS(NVL(usim_spc.get_coordinate(usim_spo.get_axis_max_pos_parent(p_usim_id_spc)), 1));
2250              IF l_max_pos >= l_dimension
2251              THEN
2252                -- only next dimension possible
2253                RETURN 2;
2254              ELSE
2255                -- first extend dimension axis
2256                RETURN 4;
2257              END IF;
2258            ELSE
2259              -- position or dimension (not checking upper dimensions available)
2260              RETURN 1;
2261            END IF;
2262          ELSE
2263            -- no childs at all
2264            -- position or dimension (not checking upper dimensions available)
2265            RETURN 1;
2266          END IF;
2267        END IF;
2268      ELSIF l_dim_rating = 2 -- on dimension axis pos > 0
2269      THEN
2270        IF l_child_count = l_max_child
2271        THEN
2272          -- fully connected
2273          RETURN 0;
2274        ELSE
2275          -- find free node
2276          IF l_child_count > 0
2277          THEN
2278            IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
2279            THEN
2280              -- only next dimension possible
2281              RETURN 2;
2282            ELSE
2283              -- position or dimension (not checking upper dimensions available)
2284              RETURN 1;
2285            END IF;
2286          ELSE
2287            -- position or dimension (not checking upper dimensions available)
2288            RETURN 1;
2289          END IF;
2290        END IF;
2291      ELSE -- everywhere else
2292        IF l_child_count = l_max_child
2293        THEN
2294          -- fully connected
2295          RETURN 0;
2296        ELSE
2297          IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
2298          THEN
2299            -- only next dimension possible
2300            RETURN 2;
2301          ELSE
2302            -- position or dimension (not checking upper dimensions available)
2303            RETURN 1;
2304          END IF;
2305        END IF;
2306      END IF;
2307    EXCEPTION
2308      WHEN OTHERS THEN
2309        -- write error might still work
2310        usim_erl.log_error('usim_dbif.classify_parent', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2311        -- try to set all to crashed
2312        usim_dbif.set_crashed;
2313        -- raise in any case
2314        RAISE;
2315    END classify_parent
2316    ;
2317
2318    FUNCTION classify_escape(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
2319      RETURN NUMBER
2320    IS
2321      l_parent_classification NUMBER;
2322      l_max_dim               NUMBER;
2323      l_max_cur_dim           NUMBER;
2324      l_max_pos               NUMBER;
2325      l_max_cur_pos           NUMBER;
2326      l_max_n1_pos            NUMBER;
2327      l_max_childs            NUMBER;
2328      l_childs                NUMBER;
2329    BEGIN
2330      IF usim_spc.has_data(p_usim_id_spc) = 1
2331      THEN
2332        l_max_dim               := usim_base.get_max_dimension;
2333        l_max_pos               := usim_base.get_abs_max_number;
2334        l_max_cur_dim           := usim_spc.get_cur_max_dim_n1(p_usim_id_spc);
2335        l_max_cur_pos           := usim_spc.get_cur_max_pos(p_usim_id_spc);
2336        l_max_childs            := usim_dbif.max_childs(p_usim_id_spc);
2337        l_childs                := usim_dbif.child_count(p_usim_id_spc);
2338        l_parent_classification := usim_dbif.classify_parent(p_usim_id_spc);
2339        l_max_n1_pos            := ABS(usim_dbif.get_axis_max_pos_dim1(p_usim_id_spc));
2340
2341        -- check all classifications against all kinds of overflow
2342        IF l_parent_classification < 0
2343        THEN
2344          -- classification error, we should stop here
2345          usim_erl.log_error('usim_dbif.classify_escape', 'Classification error parent on id [' || p_usim_id_spc || '].');
2346          usim_dbif.set_crashed;
2347          RETURN -1;
2348        ELSIF l_parent_classification = 0
2349        THEN
2350          RETURN l_parent_classification;
2351        ELSIF l_parent_classification = 1
2352        THEN
2353          -- check if dimension and positions are over the max for n1 side of space node
2354          IF     l_max_cur_dim  < l_max_dim
2355             AND l_max_cur_pos  < l_max_pos
2356             AND l_max_n1_pos  >= l_max_cur_dim
2357          THEN
2358            -- everything available
2359            RETURN l_parent_classification;
2360          ELSIF     l_max_cur_dim  < l_max_dim
2361                AND l_max_n1_pos  >= l_max_cur_dim
2362          THEN
2363            -- only dimensions available
2364            RETURN 2;
2365          ELSIF     l_max_cur_dim < l_max_dim
2366                AND l_max_n1_pos  < l_max_cur_dim
2367          THEN
2368            IF usim_dbif.has_free_between(p_usim_id_spc) = 1
2369            THEN
2370              -- prefer filling between nodes
2371              RETURN 7;
2372            ELSE
2373              -- only position dim axis 1 delegate available
2374              RETURN 6;
2375            END IF;
2376          ELSIF l_max_cur_pos < l_max_pos
2377          THEN
2378            -- only positions available
2379            RETURN 3;
2380          -- full only new universe or delegate between
2381          ELSIF usim_dbif.has_free_between(p_usim_id_spc) = 1
2382          THEN
2383              -- delegate between
2384              RETURN 7;
2385          ELSE
2386            -- no delegate options
2387            RETURN 0;
2388          END IF;
2389        ELSIF l_parent_classification = 2
2390        THEN
2391          -- check
2392          IF     l_max_cur_dim  < l_max_dim
2393             AND l_max_n1_pos  >= l_max_cur_dim
2394          THEN
2395            -- everything available
2396            RETURN l_parent_classification;
2397          ELSIF     l_max_cur_dim < l_max_dim
2398                AND l_max_n1_pos  < l_max_cur_dim
2399          THEN
2400            IF usim_dbif.has_free_between(p_usim_id_spc) = 1
2401            THEN
2402              -- prefer filling between nodes
2403              RETURN 7;
2404            ELSE
2405              -- only position dim axis 1 delegate available
2406              RETURN 6;
2407            END IF;
2408          -- full only new universe or delegate
2409          ELSIF     l_max_cur_pos                             < l_max_pos
2410                AND usim_dbif.has_free_between(p_usim_id_spc) = 0
2411          THEN
2412            -- delegate position, if no between nodes are free
2413            RETURN 5;
2414          ELSIF usim_dbif.has_free_between(p_usim_id_spc) = 1
2415          THEN
2416            -- delegate between
2417            RETURN 7;
2418          ELSE
2419            -- no delegate options
2420            RETURN 0;
2421          END IF;
2422        ELSIF l_parent_classification IN (3, 4)
2423        THEN
2424          -- check
2425          IF l_max_cur_pos < l_max_pos
2426          THEN
2427            -- everything available
2428            RETURN l_parent_classification;
2429          -- full only new universe or delegate
2430          ELSIF     l_parent_classification                   = 4
2431                AND usim_dbif.has_free_between(p_usim_id_spc) = 0
2432          THEN
2433            RETURN l_parent_classification;
2434          ELSIF     l_max_cur_dim                             < l_max_dim
2435                AND usim_dbif.has_free_between(p_usim_id_spc) = 0
2436          THEN
2437            -- delegate new dimension, if no between nodes are free
2438            RETURN 4;
2439          ELSIF usim_dbif.has_free_between(p_usim_id_spc) = 1
2440          THEN
2441            -- delegate between
2442            RETURN 7;
2443          ELSE
2444            -- no delegate options
2445            RETURN 0;
2446          END IF;
2447        ELSE
2448          -- classification unknown
2449          usim_erl.log_error('usim_dbif.classify_escape', 'Unknown parent classfication [' || l_parent_classification || '] for id [' || p_usim_id_spc || '].');
2450          usim_dbif.set_crashed;
2451          RETURN -1;
2452        END IF;
2453      ELSE
2454        RETURN -1;
2455      END IF;
2456    EXCEPTION
2457      WHEN OTHERS THEN
2458        -- write error might still work
2459        usim_erl.log_error('usim_dbif.classify_escape', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2460        -- try to set all to crashed
2461        usim_dbif.set_crashed;
2462        -- raise in any case
2463        RAISE;
2464    END classify_escape
2465    ;
2466
2467    FUNCTION get_dim_G( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
2468                      , p_node_G      OUT NUMBER
2469                      )
2470      RETURN NUMBER
2471    IS
2472      l_dimension   usim_dimension.usim_n_dimension%TYPE;
2473      l_G           NUMBER;
2474    BEGIN
2475      IF usim_spc.has_data(p_usim_id_spc) = 0
2476      THEN
2477        usim_erl.log_error('usim_process.get_dim_G', 'Used with invalid space id [' || p_usim_id_spc || '].');
2478        RETURN -1;
2479      END IF;
2480      l_dimension := usim_spc.get_dimension(p_usim_id_spc);
2481      IF l_dimension = -1
2482      THEN
2483        usim_erl.log_error('usim_process.get_dim_G', 'Failed to get_dimension for space id [' || p_usim_id_spc || '].');
2484        RETURN -1;
2485      END IF;
2486      l_G := usim_maths.calc_dim_G(l_dimension);
2487      IF usim_base.num_has_overflow(l_G) = 1
2488      THEN
2489        usim_erl.log_error('usim_dbif.get_dim_G', 'Numerical overflow for l_G[' || l_G || '] overflow [' || usim_base.get_abs_max_number || ',-' || usim_base.get_abs_max_number || '] underflow[' || usim_base.get_max_underflow || ',' || usim_base.get_min_underflow || '].');
2490        RETURN 0;
2491      ELSE
2492        -- only set out value if valid value
2493        p_node_G := l_G;
2494        RETURN 1;
2495      END IF;
2496    EXCEPTION
2497      WHEN OTHERS THEN
2498        IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
2499        THEN
2500          -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
2501          -- -1487: packed decimal number too large
2502          usim_erl.log_error('usim_dbif.get_dim_G', 'Numerical error on G calculate [' || SQLCODE || '] error message: ' || SQLERRM);
2503          RETURN 0;
2504        ELSE
2505          usim_erl.log_error('usim_dbif.get_dim_G', 'Unknown error [' || SQLCODE || '] error message: ' || SQLERRM);
2506          -- try to set all to crashed
2507          usim_dbif.set_crashed;
2508          -- return -1 handling is up to caller
2509          RETURN -1;
2510        END IF;
2511    END get_dim_G
2512    ;
2513
2514    FUNCTION get_outer_planck_r( p_usim_id_spc    IN  usim_space.usim_id_spc%TYPE
2515                               , p_outer_planck_r OUT NUMBER
2516                               )
2517      RETURN NUMBER
2518    IS
2519      l_planck_length NUMBER;
2520      l_radius        NUMBER;
2521    BEGIN
2522      IF usim_spc.has_data(p_usim_id_spc) = 0
2523      THEN
2524        usim_erl.log_error('usim_process.get_dim_G', 'Used with invalid space id [' || p_usim_id_spc || '].');
2525        RETURN -1;
2526      END IF;
2527      SELECT usim_planck_length_unit
2528        INTO l_planck_length
2529        FROM usim_spc_v
2530       WHERE usim_id_spc = p_usim_id_spc
2531      ;
2532      l_radius := usim_maths.apply_planck(1, l_planck_length);
2533      IF usim_base.num_has_overflow(l_radius) = 1
2534      THEN
2535        usim_erl.log_error('usim_dbif.get_outer_planck_r', 'Numerical overflow for l_radius[' || l_radius || '] overflow [' || usim_base.get_abs_max_number || ',-' || usim_base.get_abs_max_number || '] underflow[' || usim_base.get_max_underflow || ',' || usim_base.get_min_underflow || '].');
2536        RETURN 0;
2537      ELSE
2538        -- only set out value if valid value
2539        p_outer_planck_r := l_radius;
2540        RETURN 1;
2541      END IF;
2542    EXCEPTION
2543      WHEN OTHERS THEN
2544        IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
2545        THEN
2546          -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
2547          -- -1487: packed decimal number too large
2548          usim_erl.log_error('usim_dbif.get_outer_planck_r', 'Numerical error on outer planck r calculation [' || SQLCODE || '] error message: ' || SQLERRM);
2549          RETURN 0;
2550        ELSE
2551          usim_erl.log_error('usim_process.get_outer_planck_r', 'Unknown error [' || SQLCODE || '] error message: ' || SQLERRM);
2552          -- try to set all to crashed
2553          usim_dbif.set_crashed;
2554          -- return -1 handling is up to caller
2555          RETURN -1;
2556        END IF;
2557    END get_outer_planck_r
2558    ;
2559
2560    FUNCTION get_acceleration( p_energy         IN  NUMBER
2561                             , p_radius         IN  NUMBER
2562                             , p_G              IN  NUMBER
2563                             , p_target_energy  OUT NUMBER
2564                             )
2565      RETURN NUMBER
2566    IS
2567      l_energy NUMBER;
2568    BEGIN
2569      l_energy := usim_maths.calc_planck_a2(p_energy, p_radius, p_G);
2570      IF usim_base.num_has_overflow(l_energy) = 1
2571      THEN
2572        usim_debug.debug_log('usim_dbif.get_acceleration', 'Numerical overflow for l_energy[' || l_energy || '] overflow [' || usim_base.get_abs_max_number || ',-' || usim_base.get_abs_max_number || '] underflow[' || usim_base.get_max_underflow || ',' || usim_base.get_min_underflow || '].');
2573        RETURN 0;
2574      ELSE
2575        -- only set out value if valid value
2576        p_target_energy := l_energy;
2577        RETURN 1;
2578      END IF;
2579    EXCEPTION
2580      WHEN OTHERS THEN
2581        IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
2582        THEN
2583          -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
2584          -- -1487: packed decimal number too large
2585          usim_debug.debug_log('usim_dbif.get_acceleration', 'Numerical error on acceleration calculation [' || SQLCODE || '] error message: ' || SQLERRM);
2586          RETURN 0;
2587        ELSE
2588          usim_erl.log_error('usim_process.get_acceleration', 'Unknown error [' || SQLCODE || '] error message: ' || SQLERRM);
2589          -- try to set all to crashed
2590          usim_dbif.set_crashed;
2591          -- return -1 handling is up to caller
2592          RETURN -1;
2593        END IF;
2594    END get_acceleration
2595    ;
2596
2597  END usim_dbif;
2598  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_dbif
IS
  -- see header for documentation

  PROCEDURE set_crashed
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    UPDATE usim_multiverse
       SET usim_universe_status = usim_static.usim_multiverse_status_crashed
    ;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.set_crashed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END set_crashed
  ;

  FUNCTION set_universe_state( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
                             , p_do_commit   IN BOOLEAN                          DEFAULT TRUE
                             )
    RETURN usim_multiverse.usim_universe_status%TYPE
  IS
    l_return            NUMBER;
    l_status_valid      NUMBER;
    l_status_calculated usim_multiverse.usim_universe_status%TYPE;
  BEGIN
    -- check parameter
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      -- check state and correct it if mismatch
      SELECT status_valid, status_calculated INTO l_status_valid, l_status_calculated FROM usim_mlv_state_v WHERE usim_id_mlv = p_usim_id_mlv;
      IF l_status_calculated != usim_static.usim_multiverse_status_active
      THEN
        -- we have an error in the universe
        usim_erl.log_error('usim_dbif.set_universe_state', 'Current invalid status not running for mlv id [' || p_usim_id_mlv || '] is [' || l_status_valid || '] calculated [' || l_status_calculated || '].');
        IF l_status_valid != 1
        THEN
          l_return := usim_mlv.update_state(p_usim_id_mlv, l_status_calculated, FALSE);
          IF l_return IS NULL
          THEN
            ROLLBACK;
            usim_erl.log_error('usim_dbif.set_universe_state', 'Could not update state for mlv id [' || p_usim_id_mlv || '].');
          END IF;
          RETURN l_return;
        ELSE
          RETURN l_status_calculated;
        END IF;
      ELSE
        -- update state, if current state not valid
        IF l_status_valid != 1
        THEN
          l_return := usim_mlv.update_state(p_usim_id_mlv, l_status_calculated, FALSE);
          IF l_return IS NULL
          THEN
            ROLLBACK;
            usim_erl.log_error('usim_dbif.set_universe_state', 'Could not update state for mlv id [' || p_usim_id_mlv || '].');
          END IF;
          RETURN l_return;
        ELSE
          RETURN l_status_calculated;
        END IF;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.set_universe_state', 'Invalid parameter mlv id [' || p_usim_id_mlv || '].');
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.set_universe_state', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END set_universe_state
  ;

  FUNCTION set_universe_state_spc( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                                 , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                                 )
    RETURN usim_multiverse.usim_universe_status%TYPE
  IS
    l_usim_id_mlv       usim_multiverse.usim_id_mlv%TYPE;
    l_status_calculated usim_multiverse.usim_universe_status%TYPE;
    l_return            NUMBER;
    l_status_valid      NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
      IF l_usim_id_mlv IS NULL
      THEN
        usim_erl.log_error('usim_dbif.set_universe_state_spc', 'No valid universe found for space id [' || p_usim_id_spc || '].');
        RETURN NULL;
      END IF;
      -- check state and correct it if mismatch
      SELECT status_valid, status_calculated INTO l_status_valid, l_status_calculated FROM usim_mlv_state_v WHERE usim_id_mlv = l_usim_id_mlv;
      -- do only something, is status is not valid
      IF l_status_valid = 0
      THEN
        l_return := usim_mlv.update_state(l_usim_id_mlv, l_status_calculated, FALSE);
        IF l_return IS NULL
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Could not update state for mlv id [' || l_usim_id_mlv || '].');
        ELSE
          IF p_do_commit
          THEN
            COMMIT;
          END IF;
        END IF;
        RETURN l_return;
      ELSIF l_status_valid = -1
      THEN
        usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Invalid calculation state for mlv id [' || l_usim_id_mlv || '].');
        RETURN NULL;
      ELSE
        RETURN l_status_calculated;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Invalid parameter space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END set_universe_state_spc
  ;

  FUNCTION set_seed_active(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN usim_multiverse.usim_universe_status%TYPE
  IS
    l_return      usim_multiverse.usim_universe_status%TYPE;
    l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    IF usim_mlv.has_base = 1
    THEN
      SELECT usim_id_mlv INTO l_usim_id_mlv FROM usim_multiverse WHERE usim_is_base_universe = 1;
      l_return := usim_mlv.update_state(l_usim_id_mlv, usim_static.usim_multiverse_status_active, FALSE);
      IF l_return != usim_static.usim_multiverse_status_active
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_dbif.set_seed_active', 'Could not update state to active on universe seed id [' || l_usim_id_mlv || '] getting status [' || l_return || '].');
        RETURN NULL;
      ELSE
        IF p_do_commit
        THEN
          COMMIT;
        END IF;
        RETURN l_return;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.set_seed_active', 'No base universe found.');
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.set_seed_active', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END set_seed_active
  ;

  FUNCTION init_basedata( p_max_dimension            IN NUMBER DEFAULT 42
                        , p_usim_abs_max_number      IN NUMBER DEFAULT 99999999999999999999999999999999999999
                        , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
                        )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_base.has_basedata = 0
    THEN
      usim_base.init_basedata(p_max_dimension, p_usim_abs_max_number, p_usim_overflow_node_seed);
    END IF;
    IF usim_base.has_basedata = 0
    THEN
      usim_erl.log_error('usim_dbif.init_basedata', 'Could not initialize base data for max dim [' || p_max_dimension || '] max num [' || p_usim_abs_max_number || '] and overflow seed [' || p_usim_overflow_node_seed || '].');
    END IF;
    l_result := usim_base.has_basedata;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.init_basedata', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END init_basedata
  ;

  FUNCTION init_dimensions(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  IS
    l_max_dim usim_dimension.usim_n_dimension%TYPE;
    l_return  NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      l_max_dim := usim_base.get_max_dimension;
      l_return  := usim_dim.init_dimensions(l_max_dim, FALSE);
      IF l_return != 1
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_dbif.init_dimensions', 'Could not init dimensions up to max [' || l_max_dim || '].');
        RETURN -1;
      ELSE
        IF p_do_commit
        THEN
          COMMIT;
         END IF;
      END IF;
      RETURN l_return;
    ELSE
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.init_dimensions', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END init_dimensions
  ;

  FUNCTION has_basedata
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_base.has_basedata;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_basedata', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_basedata
  ;

  FUNCTION has_data_spc
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spc.has_data;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_data_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_data_spc
  ;

  FUNCTION has_data_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spc.has_data(p_usim_id_spc);
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_data_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_data_spc
  ;

  FUNCTION has_data_spr
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spr.has_data;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_data_spr', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_data_spr
  ;

  FUNCTION has_data_spr(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spr.has_data(p_usim_id_spr);
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_data_spr', 'Unexpected error for id [' || p_usim_id_spr || '], SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_data_spr
  ;

  FUNCTION has_unprocessed
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spr.has_unprocessed;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_unprocessed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_unprocessed
  ;

  FUNCTION has_data_mlv
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_mlv.has_data;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_data_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_data_mlv
  ;

  FUNCTION has_data_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_mlv.has_data(p_usim_id_mlv);
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_data_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_data_mlv
  ;

  FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spo.has_axis_max_pos_parent(p_usim_id_spc);
    IF l_result > 1
    THEN
      usim_erl.log_error('usim_dbif.has_axis_max_pos_parent', 'Error dimension symmetry, more than one maximum position on dimension axis found for space node [' || p_usim_id_spc || '].');
      usim_dbif.set_crashed;
      RETURN -1;
    ELSE
      RETURN l_result;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_axis_max_pos_parent', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_axis_max_pos_parent
  ;

  FUNCTION has_free_between(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    -- if not related to all dimensions, relying on dimensions are built and assigned in order
    IF usim_chi.get_cur_max_dimension(p_usim_id_spc) < usim_spc.get_cur_max_dim_n1(p_usim_id_spc)
    THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_free_between', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_free_between
  ;

  FUNCTION is_seed_active
    RETURN NUMBER
  IS
    l_status_calculated NUMBER;
    l_planck_aeon       usim_static.usim_id;
    l_planck_time       NUMBER;
    l_energy_total      NUMBER;
    l_energy_positive   NUMBER;
    l_energy_negative   NUMBER;
    l_has_process_data  NUMBER;
    l_has_unprocessed   NUMBER;
  BEGIN
    IF usim_mlv.has_base = 1
    THEN
      SELECT status_calculated INTO l_status_calculated FROM usim_mlv_state_v WHERE usim_is_base_universe = 1;
      IF l_status_calculated = usim_static.usim_multiverse_status_active
      THEN
        RETURN 1;
      ELSE
        SELECT planck_aeon
             , planck_time
             , energy_base
             , energy_positive
             , energy_negative
             , has_process_data
             , has_unprocessed
          INTO l_planck_aeon
             , l_planck_time
             , l_energy_total
             , l_energy_positive
             , l_energy_negative
             , l_has_process_data
             , l_has_unprocessed
          FROM usim_mlv_state_v
         WHERE usim_is_base_universe = 1
        ;
        usim_erl.log_error('usim_dbif.is_seed_active', 'Seed not active at planck aeon [' || l_planck_aeon || '], time [' || l_planck_time || '], total e [' || l_energy_total || '], e+ [' || l_energy_positive || '], e- [' || l_energy_negative || '], process data [' || l_has_process_data || '], unprocessed [' || l_has_unprocessed || '].');
        RETURN 0;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.is_seed_active', 'No base universe found.');
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_seed_active', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_seed_active
  ;

  FUNCTION is_universe_active(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_mlv_id    usim_multiverse.usim_id_mlv%TYPE;
    l_state     usim_multiverse.usim_universe_status%TYPE;
  BEGIN
    -- get universe
    l_mlv_id := usim_spc.get_id_mlv(p_usim_id_spc);
    IF l_mlv_id IS NULL
    THEN
      RETURN 0;
    END IF;
    l_state  := usim_mlv.get_state(l_mlv_id);
    IF l_state = usim_static.usim_multiverse_status_active
    THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_universe_active', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_universe_active
  ;

  FUNCTION is_universe_base_type(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_return NUMBER;
  BEGIN
    l_return := usim_spc.is_universe_base(p_usim_id_spc);
    RETURN l_return;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_universe_base', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_universe_base_type
  ;

  FUNCTION init_positions(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  IS
    l_max_pos usim_position.usim_coordinate%TYPE;
    l_return  NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      l_max_pos := usim_base.get_abs_max_number;
      l_return  := usim_pos.init_positions(l_max_pos, FALSE);
      IF l_return != 1
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_dbif.init_positions', 'Could not init positions up to max [' || l_max_pos || '].');
        RETURN -1;
      ELSE
        IF p_do_commit
        THEN
          COMMIT;
        END IF;
      END IF;
      RETURN l_return;
    ELSE
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.init_positions', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END init_positions
  ;

  FUNCTION is_overflow_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    IF usim_pos.has_data = 0
    THEN
      -- no data
      RETURN 0;
    END IF;
    IF usim_pos.has_data(p_usim_coordinate) = 1
    THEN
      RETURN 0;
    ELSE
      RETURN 1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_overflow_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_overflow_pos
  ;

  FUNCTION is_overflow_pos_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  IS
    l_max_pos1 usim_position.usim_coordinate%TYPE;
    l_max_neg1 usim_position.usim_coordinate%TYPE;
    l_max_pos2 usim_position.usim_coordinate%TYPE;
    l_max_neg2 usim_position.usim_coordinate%TYPE;
    l_max      NUMBER;
  BEGIN
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      -- universe does not exist
      RETURN 0;
    END IF;
    IF usim_base.has_basedata = 1
    THEN
      SELECT MAX(usim_n_dimension) INTO l_max_pos1 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = 1 AND usim_coordinate >= 0;
      SELECT MIN(usim_n_dimension) INTO l_max_neg1 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = 1 AND usim_coordinate <= 0;
      SELECT MAX(usim_n_dimension) INTO l_max_pos2 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = -1 AND usim_coordinate >= 0;
      SELECT MIN(usim_n_dimension) INTO l_max_neg2 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = -1 AND usim_coordinate <= 0;
      l_max := usim_base.get_abs_max_number;
      IF     l_max_pos1      >= l_max
         AND ABS(l_max_neg1) >= l_max
         AND l_max_pos2      >= l_max
         AND ABS(l_max_neg2) >= l_max
      THEN
        RETURN 1;
      ELSE
        RETURN 0;
      END IF;
    ELSE
      -- can't check
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_overflow_pos_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_overflow_pos_mlv
  ;

  FUNCTION is_overflow_dim_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  IS
    l_max_dim_pos usim_dimension.usim_n_dimension%TYPE;
    l_max_dim_neg usim_dimension.usim_n_dimension%TYPE;
    l_max         NUMBER;
  BEGIN
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      -- universe does not exist
      RETURN 0;
    END IF;
    IF usim_base.has_basedata = 1
    THEN
      SELECT MAX(usim_n_dimension) INTO l_max_dim_pos FROM usim_rmd_v WHERE usim_id_mlv = p_usim_id_mlv AND usim_n1_sign = 1;
      SELECT MAX(usim_n_dimension) INTO l_max_dim_neg FROM usim_rmd_v WHERE usim_id_mlv = p_usim_id_mlv AND usim_n1_sign = -1;
      l_max := usim_base.get_max_dimension;
      IF     l_max_dim_neg >= l_max
         AND l_max_dim_pos >= l_max
      THEN
        RETURN 1;
      ELSE
        RETURN 0;
      END IF;
    ELSE
      -- can't check
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_overflow_dim_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_overflow_dim_mlv
  ;

  FUNCTION is_overflow_dim_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
    l_max_dim     NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
      IF l_usim_id_mlv IS NULL
      THEN
        -- no overflow for not existing mlv
        RETURN 0;
      END IF;
      -- check if is base at dimension 0 and has two childs = overflow
      IF     usim_spc.is_universe_base(p_usim_id_spc) = 1
         AND usim_chi.child_count(p_usim_id_spc)      = 2
      THEN
        RETURN 1;
      ELSIF usim_spc.is_universe_base(p_usim_id_spc) = 1
      THEN
        RETURN 0;
      ELSE
        -- check if is not base and childs have all dimensions = overflow
        SELECT MAX(usim_n_dimension)
          INTO l_max_dim
          FROM usim_spo_v
         WHERE usim_id_spc = p_usim_id_spc
           AND usim_id_mlv = l_usim_id_mlv
        ;
        IF l_max_dim >= usim_base.get_max_dimension
        THEN
          RETURN 1;
        ELSE
          RETURN 0;
        END IF;
      END IF;
    ELSE
      -- no overflow for not existing space id
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_overflow_dim_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_overflow_dim_spc
  ;

  FUNCTION is_overflow_pos_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      -- no position free on base
      IF usim_spc.is_universe_base(p_usim_id_spc) = 1
      THEN
        -- base node has no position free
        RETURN 1;
      END IF;
      -- if child in same dimension we are in overflow
      IF     usim_chi.has_child_same_dim(p_usim_id_spc) = 1
             -- if node is on position 0 on all axis, the node can trigger position extension, so it should not be a zero axis position
         AND usim_spo.is_axis_zero_pos(p_usim_id_spc)   = 0
      THEN
        RETURN 1;
      ELSE
        RETURN 0;
      END IF;
    ELSE
      -- no overflow if space id does not exist
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_overflow_dim_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_overflow_pos_spc
  ;

  FUNCTION is_overflow_energy(p_energy IN NUMBER)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      l_result := usim_base.num_has_overflow(p_energy);
      IF l_result = 1
      THEN
        RETURN 1;
      ELSE
        RETURN 0;
      END IF;
    ELSE
      -- we can't check
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
      THEN
        -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
        -- -1487: packed decimal number too large
        usim_erl.log_error('usim_dbif.is_overflow_energy', 'Numerical error on energy overflow check for [' || SQLCODE || '] error message: ' || SQLERRM);
        RETURN 1;
      ELSE
        -- write error might still work
        usim_erl.log_error('usim_dbif.is_overflow_energy', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
        -- try to set all to crashed
        usim_dbif.set_crashed;
        -- raise in any case
        RAISE;
      END IF;
  END is_overflow_energy
  ;

  FUNCTION is_overflow_energy_add( p_energy IN NUMBER
                                 , p_add    IN NUMBER
                                 )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      -- check against base
      l_result := usim_base.num_add_has_overflow(p_energy, p_add);
      RETURN l_result;
    ELSE
      -- check against system, if fails with numerical exception we have overflow state
      l_result := p_energy + p_add;
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
      THEN
        -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
        -- -1487: packed decimal number too large
        usim_erl.log_error('usim_dbif.is_overflow_energy_add', 'Numerical error on add energy overflow check [' || SQLCODE || '] error message: ' || SQLERRM);
        RETURN 1;
      ELSE
        -- write error might still work
        usim_erl.log_error('usim_dbif.is_overflow_energy_add', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
        -- try to set all to crashed
        usim_dbif.set_crashed;
        -- raise in any case
        RAISE;
      END IF;
  END is_overflow_energy_add
  ;

  FUNCTION is_base_universe_seed(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    IF usim_spc.get_id_spc_base_universe = p_usim_id_spc
    THEN
      RETURN 1;
    ELSE
      IF usim_spc.has_base_universe = 0
      THEN
        usim_erl.log_error('usim_dbif.is_base_universe_seed', 'Used function without a base universe seed currently available.');
      END IF;
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_base_universe_seed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_base_universe_seed
  ;

  FUNCTION is_queue_valid
    RETURN NUMBER
  IS
    l_return NUMBER;
  BEGIN
    l_return := usim_spr.is_queue_valid;
    RETURN l_return;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_queue_valid', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_queue_valid
  ;

  FUNCTION is_pos_extendable(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    IF usim_chi.has_child_same_dim(p_usim_id_spc) = 0
    THEN
      RETURN 1;
    END IF;
    IF usim_spo.is_axis_zero_pos(p_usim_id_spc) = 1
    THEN
      RETURN 2;
    END IF;
    -- no check passed
    usim_erl.log_error('usim_dbif.is_pos_extendable', 'Given space node id [' || p_usim_id_spc || '] is not extendable on position.');
    RETURN 0;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_pos_extendable', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_pos_extendable
  ;

  FUNCTION is_dim_extendable( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                            , p_use_parent  OUT usim_space.usim_id_spc%TYPE
                            , p_next_dim    OUT usim_dimension.usim_n_dimension%TYPE
                            )
    RETURN NUMBER
  IS
    l_max_cur_dim NUMBER;
    l_max_chi_dim NUMBER;
    l_max_dim     NUMBER;
  BEGIN
    l_max_cur_dim := usim_spc.get_cur_max_dim_n1(p_usim_id_spc);
    l_max_chi_dim := usim_chi.get_cur_max_dimension(p_usim_id_spc);
    l_max_dim     := usim_base.get_max_dimension;
    IF usim_spo.is_axis_zero_pos(p_usim_id_spc) = 1
    THEN
      IF l_max_chi_dim < l_max_dim
      THEN
        p_use_parent := p_usim_id_spc;
        p_next_dim   := l_max_chi_dim + 1;
        RETURN 2;
      ELSE
        -- no dimension left
        p_use_parent := NULL;
        p_next_dim   := NULL;
        RETURN 0;
      END IF;
    END IF;
    IF l_max_chi_dim < l_max_cur_dim
    THEN
      -- free available dimensions
      p_use_parent := p_usim_id_spc;
      p_next_dim   := l_max_chi_dim + 1;
      RETURN 1;
    ELSIF l_max_chi_dim < l_max_dim
    THEN
      -- free dimension, but dimension has to be build
      p_use_parent := usim_spo.get_axis_zero_pos_parent(p_usim_id_spc);
      p_next_dim   := l_max_chi_dim + 1;
      RETURN 2;
    ELSE
      p_use_parent := NULL;
      p_next_dim   := NULL;
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_dim_extendable', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_dim_extendable
  ;

  FUNCTION child_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                      , p_ignore_mlv  IN NUMBER                      DEFAULT 0
                      )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF p_ignore_mlv = 0
    THEN
      l_result := usim_chi.child_count(p_usim_id_spc);
    ELSE
      l_result := usim_chi.child_count_all(p_usim_id_spc);
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.child_count', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END child_count
  ;

  FUNCTION parent_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                       , p_ignore_mlv  IN NUMBER                      DEFAULT 0
                       )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF p_ignore_mlv = 0
    THEN
      l_result := usim_chi.parent_count(p_usim_id_spc);
    ELSE
      l_result := usim_chi.parent_count_all(p_usim_id_spc);
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.parent_count', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END parent_count
  ;

  FUNCTION create_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                          , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                          , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                          , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                          , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                          )
    RETURN usim_multiverse.usim_id_mlv%TYPE
  IS
    l_result usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    IF usim_mlv.has_data     = 1
       AND usim_mlv.has_base = 0
    THEN
      -- wrong state
      usim_erl.log_error('usim_dbif.create_universe', 'Unexpected multiverse state no base universe but universes exist.');
      usim_dbif.set_crashed;
      RETURN NULL;
    END IF;
    l_result := usim_mlv.insert_universe( p_usim_energy_start_value
                                        , p_usim_planck_time_unit
                                        , p_usim_planck_length_unit
                                        , p_usim_planck_speed_unit
                                        , p_usim_planck_stable
                                        , p_usim_ultimate_border
                                        , FALSE
                                        )
    ;
    IF l_result IS NULL
    THEN
      ROLLBACK;
      usim_erl.log_error('usim_dbif.create_universe', 'Could not insert new universe.');
    ELSE
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.create_universe', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END create_universe
  ;

  FUNCTION create_dim_axis( p_usim_id_mlv        IN  usim_multiverse.usim_id_mlv%TYPE
                          , p_usim_n_dimension   IN  usim_dimension.usim_n_dimension%TYPE
                          , p_usim_id_rmd_parent IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_rmd_pos    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_rmd_neg    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_do_commit          IN  BOOLEAN                              DEFAULT TRUE
                          )
    RETURN NUMBER
  IS
    l_sign    usim_rel_mlv_dim.usim_sign%TYPE;
    l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
  BEGIN
    IF     usim_dim.has_data(p_usim_n_dimension) = 1
       AND usim_mlv.has_data(p_usim_id_mlv)      = 1
    THEN
      -- do not commit until everything is processed
      IF p_usim_n_dimension = 0
      THEN
        p_usim_id_rmd_pos := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, 0, NULL, FALSE);
        p_usim_id_rmd_neg := usim_rmd.get_id_rmd(p_usim_id_mlv, p_usim_n_dimension, 0, NULL);
      ELSE
        IF p_usim_n_dimension > 1
        THEN
          IF p_usim_id_rmd_parent IS NOT NULL
          THEN
            l_sign := usim_rmd.get_dim_n1_sign(p_usim_id_rmd_parent);
            IF l_sign != 0
            THEN
              p_usim_id_rmd_pos := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, 1, l_sign, FALSE);
              p_usim_id_rmd_neg := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, -1, l_sign, FALSE);
            ELSE
              usim_erl.log_error('usim_dbif.create_dim_axis', 'Pparent rmd id returns invalid n1 sign 0.');
              RETURN 0;
            END IF;
          ELSE
            usim_erl.log_error('usim_dbif.create_dim_axis', 'Dimension > 1 but NULL parent rmd id given.');
            RETURN 0;
          END IF;
        ELSIF p_usim_n_dimension = 1
        THEN
          p_usim_id_rmd_pos := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, 1, 1, FALSE);
          p_usim_id_rmd_neg := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, -1, -1, FALSE);
        ELSE
          usim_erl.log_error('usim_dbif.create_dim_axis', 'Invalid dimension [' || p_usim_n_dimension || '].');
          RETURN 0;
        END IF;
      END IF;
      -- now check out values if we arrive here
      IF      p_usim_id_rmd_pos IS NOT NULL
          AND p_usim_id_rmd_neg IS NOT NULL
      THEN
        -- commit everything
        IF p_do_commit
        THEN
          COMMIT;
        END IF;
        RETURN 1;
      ELSE
        ROLLBACK;
        usim_erl.log_error('usim_dbif.create_dim_axis', 'Error creating dimension axis for [' || p_usim_n_dimension || '].');
        RETURN 0;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.create_dim_axis', 'Invalid mlv [' || p_usim_id_mlv || '] or dimension [' || p_usim_n_dimension || '].');
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.create_dim_axis', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END create_dim_axis
  ;

  FUNCTION create_space_node( p_usim_id_rmd  IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                            , p_usim_id_pos  IN usim_position.usim_id_pos%TYPE
                            , p_usim_parents IN usim_static.usim_ids_type
                            , p_do_commit    IN BOOLEAN                           DEFAULT TRUE
                            )
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_usim_id_mlv     usim_multiverse.usim_id_mlv%TYPE;
    l_usim_id_nod     usim_node.usim_id_nod%TYPE;
    l_usim_id_spc     usim_space.usim_id_spc%TYPE;
    l_usim_coordinate usim_position.usim_coordinate%TYPE;
    l_count           NUMBER;
    l_spin            NUMBER;
    l_return          NUMBER;
  BEGIN
    IF     usim_rmd.has_data(p_usim_id_rmd) = 1
       AND usim_pos.has_data(p_usim_id_pos) = 1
    THEN
      -- pos and rmd not unique, inbetween nodes
      -- check situation
      l_usim_id_mlv     := usim_rmd.get_id_mlv(p_usim_id_rmd);
      IF l_usim_id_mlv IS NULL
      THEN
        usim_erl.log_error('usim_dbif.create_space_node', 'Could not get universe for rmd [' || p_usim_id_rmd || '].');
        usim_dbif.set_crashed;
        RETURN NULL;
      END IF;
      l_usim_coordinate := usim_pos.get_coordinate(p_usim_id_pos);
      IF l_usim_coordinate IS NULL
      THEN
        usim_erl.log_error('usim_dbif.create_space_node', 'Could not get coordinate for pos [' || p_usim_id_pos || '].');
        usim_dbif.set_crashed;
        RETURN NULL;
      END IF;
      IF     usim_mlv.is_base(l_usim_id_mlv) = 0
         AND l_usim_coordinate              != 0
         AND p_usim_parents.COUNT            = 0
      THEN
        usim_erl.log_error('usim_dbif.create_space_node', 'Missing parent for not base universe and position not 0.');
        RETURN NULL;
      END IF;
      IF p_usim_parents.COUNT = 0
      THEN
        -- check if not already set
        SELECT COUNT(*)
          INTO l_count
          FROM usim_spc_v
         WHERE usim_id_mlv           = l_usim_id_mlv
           AND usim_is_base_universe = 1
           AND dim_sign              = 0
           AND dim_n1_sign          IS NULL
           AND usim_coordinate       = 0
        ;
        IF l_count != 0
        THEN
          usim_erl.log_error('usim_dbif.create_space_node', 'Base universe node at position 0, dimension 0 already exists.');
          RETURN NULL;
        END IF;
      END IF;
      -- define process spin, new childs normally are at the end of the row, so direction would be -1 (parent)
      -- whereas a node without parent is always in direction 1 (childs). The sign is initially direction child. As soon as
      -- processing begins, it will be flipped by processing to the correct direction, whenever the process encounters
      -- a border space node as defined by border rule.
      l_spin := 1;
      -- all checks passed, create node, do not commit until all is done
      l_usim_id_nod := usim_nod.insert_node(FALSE);
      l_usim_id_spc := usim_spc.insert_spc(p_usim_id_rmd, p_usim_id_pos, l_usim_id_nod, l_spin, FALSE);
      IF l_usim_id_spc IS NULL
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node for rmd [' || p_usim_id_rmd || '] and position [' || p_usim_id_pos || '] .');
        usim_dbif.set_crashed;
        RETURN NULL;
      END IF;
      -- update position for parents
      IF p_usim_parents.COUNT > 0
      THEN
        FOR i IN p_usim_parents.FIRST..p_usim_parents.LAST
        LOOP
          l_return := usim_spo.insert_spc_pos(l_usim_id_spc, p_usim_parents(i), FALSE);
          IF l_return = 0
          THEN
            ROLLBACK;
            usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node position for spc [' || l_usim_id_spc || '] and parent [' || p_usim_parents(i) || '] .');
            usim_dbif.set_crashed;
            RETURN NULL;
          END IF;
          -- check parent child relation only same n1 sign apart from base universe nodes
          IF    usim_spc.get_dim_n1_sign(p_usim_parents(i))  = usim_spc.get_dim_n1_sign(l_usim_id_spc)
             OR usim_spc.is_universe_base(p_usim_parents(i)) = 1
             OR usim_spc.is_universe_base(l_usim_id_spc)     = 1
          THEN
            -- define relationship if parent is set
            l_return := usim_chi.insert_chi(p_usim_parents(i), l_usim_id_spc, FALSE);
            IF l_return = 0
            THEN
              ROLLBACK;
              usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node relation for spc [' || l_usim_id_spc || '] and parent [' || p_usim_parents(i) || '] .');
              usim_dbif.set_crashed;
              RETURN NULL;
            END IF;
          ELSE
            ROLLBACK;
            usim_erl.log_error('usim_dbif.create_space_node', 'Space node relation not allowed due to different n1 sign for spc [' || l_usim_id_spc || '] and parent [' || p_usim_parents(i) || '] not base node.');
            usim_dbif.set_crashed;
            RETURN NULL;
          END IF;
        END LOOP;
      ELSE
        l_return := usim_spo.insert_spc_pos(l_usim_id_spc, NULL, FALSE);
        IF l_return = 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node position for spc [' || l_usim_id_spc || '] and parent NULL.');
          usim_dbif.set_crashed;
          RETURN NULL;
        END IF;
      END IF;
      -- creation done, commit if given
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN l_usim_id_spc;
    ELSE
      usim_erl.log_error('usim_dbif.create_space_node', 'Invalid rmd [' || p_usim_id_rmd || '] or position [' || p_usim_id_pos || '].');
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.create_space_node', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END create_space_node
  ;

  FUNCTION create_process( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
                         , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
                         , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
                         , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
                         , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
                         , p_do_commit          IN BOOLEAN                                  DEFAULT TRUE
                         )
    RETURN usim_spc_process.usim_id_spr%TYPE
  IS
    l_result usim_spc_process.usim_id_spr%TYPE;
  BEGIN
    l_result := usim_spr.insert_spr(p_usim_id_spc_source, p_usim_id_spc_target, p_usim_energy_source, p_usim_energy_target, p_usim_energy_output, FALSE);
    IF l_result IS NOT NULL
    THEN
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.create_process', 'Failed to insert process record.');
      ROLLBACK;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.create_process', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END create_process
  ;

  FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                            , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                            )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spc.flip_process_spin(p_usim_id_spc, FALSE);
    IF l_result = 0
    THEN
      ROLLBACK;
      usim_erl.log_error('usim_dbif.flip_process_spin', 'Failed to flip process spin for space id [' || p_usim_id_spc || '].');
    ELSE
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.flip_process_spin', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END flip_process_spin
  ;

  FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
                        , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
                        , p_do_commit     IN BOOLEAN                            DEFAULT TRUE
                        )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spr.set_processed(p_usim_id_spr, p_process_state, FALSE);
    IF l_result = 0
    THEN
      ROLLBACK;
      usim_erl.log_error('usim_dbif.set_processed', 'Failed to set processed state for id [' || p_usim_id_spr || '] and state [' || p_process_state || '].');
    ELSE
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.set_processed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END set_processed
  ;

  FUNCTION check_border( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                       , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                       )
    RETURN NUMBER
  IS
    l_usim_id_mlv   usim_multiverse.usim_id_mlv%TYPE;
    l_border_rule   usim_multiverse.usim_ultimate_border%TYPE;
    l_process_spin  usim_space.usim_process_spin%TYPE;
    l_result        INTEGER;
  BEGIN
    l_usim_id_mlv  := usim_spc.get_id_mlv(p_usim_id_spc);
    l_border_rule  := usim_mlv.get_ultimate_border(l_usim_id_mlv);
    l_process_spin := usim_spc.get_process_spin(p_usim_id_spc);
    IF l_border_rule = 1
    THEN
      -- if no child and direction is child flip to parent
      IF     usim_chi.child_count(p_usim_id_spc) = 0
         AND l_process_spin                      = 1
      THEN
        l_result := usim_spc.flip_process_spin(p_usim_id_spc, FALSE);
        -- check fail
        IF l_result = 1
        THEN
          IF p_do_commit
          THEN
            COMMIT;
          END IF;
          RETURN 1;
        ELSE
          usim_erl.log_error('usim_dbif.check_border', 'Could not flip process spin on space id [' || p_usim_id_spc || '].');
          -- set all to crashed
          usim_dbif.set_crashed;
          ROLLBACK;
          RETURN 0;
        END IF;
      ELSE
        RETURN 1;
      END IF;
    ELSE
      -- if no child in dimension and direction is child flip to parent
      IF     usim_chi.has_child_same_dim(p_usim_id_spc) = 0
         AND l_process_spin                             = 1
      THEN
        l_result := usim_spc.flip_process_spin(p_usim_id_spc, FALSE);
        -- check fail
        IF l_result = 1
        THEN
          IF p_do_commit
          THEN
            COMMIT;
          END IF;
          RETURN 1;
        ELSE
          usim_erl.log_error('usim_dbif.check_border', 'Could not flip process spin on space id [' || p_usim_id_spc || '].');
          -- set all to crashed
          usim_dbif.set_crashed;
          ROLLBACK;
          RETURN 0;
        END IF;
      END IF;
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.check_border', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END check_border
  ;

  FUNCTION get_id_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_usim_id_pos usim_position.usim_id_pos%TYPE;
  BEGIN
    IF usim_pos.has_data(p_usim_coordinate) = 1
    THEN
      l_usim_id_pos := usim_pos.get_id_pos(p_usim_coordinate);
      IF l_usim_id_pos IS NULL
      THEN
        usim_erl.log_error('usim_dbif.get_id_pos', 'Could not get position id for coordinate [' || p_usim_coordinate || '].');
      END IF;
      RETURN l_usim_id_pos;
    ELSE
      usim_erl.log_error('usim_dbif.get_id_pos', 'Invalid coordinate [' || p_usim_coordinate || '], maybe overflow.');
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_id_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_id_pos
  ;

  FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_usim_id_pos usim_position.usim_id_pos%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_usim_id_pos := usim_spc.get_id_pos(p_usim_id_spc);
      IF l_usim_id_pos IS NULL
      THEN
        usim_erl.log_error('usim_dbif.get_id_pos', 'Could not get position id for space node [' || p_usim_id_spc || '].');
      END IF;
      RETURN l_usim_id_pos;
    ELSE
      usim_erl.log_error('usim_dbif.get_id_pos', 'Invalid space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_id_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_id_pos
  ;

  FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_node.usim_id_nod%TYPE
  IS
    l_result usim_node.usim_id_nod%TYPE;
  BEGIN
    l_result := usim_spc.get_id_nod(p_usim_id_spc);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_id_nod', 'Invalid space id [' || p_usim_id_spc || '] or no node found.');
      usim_dbif.set_crashed;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_id_nod', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_id_nod
  ;

  FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_multiverse.usim_id_mlv%TYPE
  IS
    l_result usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    l_result := usim_spc.get_id_mlv(p_usim_id_spc);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_id_mlv', 'Invalid space id [' || p_usim_id_spc || '] or no node found.');
      usim_dbif.set_crashed;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_id_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_id_mlv
  ;

  FUNCTION get_id_spc_base_universe
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    l_result := usim_spc.get_id_spc_base_universe;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_id_spc_base_universe', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_id_spc_base_universe
  ;

  FUNCTION get_spc_dim_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                              , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
                              , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                              , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
                              , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                              )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      p_usim_id_mlv   := usim_spc.get_id_mlv(p_usim_id_spc);
      p_usim_id_rmd   := usim_spc.get_id_rmd(p_usim_id_spc);
      p_usim_sign     := usim_spc.get_dim_sign(p_usim_id_spc);
      p_usim_n1_sign  := usim_spc.get_dim_n1_sign(p_usim_id_spc);
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_dbif.get_spc_dim_details', 'Not existing space id [' || p_usim_id_spc || '].');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_spc_dim_details', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_spc_dim_details
  ;

  FUNCTION get_abs_max_number
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_base.get_abs_max_number;
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_abs_max_number', 'Base data not initialized.');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_abs_max_number', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_abs_max_number
  ;

  FUNCTION get_dim_coord( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_result usim_position.usim_coordinate%TYPE;
  BEGIN
    l_result := usim_spo.get_dim_coord(p_usim_id_spc, p_usim_n_dimension);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_dim_coord', 'Invalid space id [' || p_usim_id_spc || '] or dimension [' || p_usim_n_dimension || '].');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_dim_coord', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_dim_coord
  ;

  FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result usim_dimension.usim_n_dimension%TYPE;
  BEGIN
    l_result := usim_spc.get_dimension(p_usim_id_spc);
    IF l_result = -1
    THEN
      usim_erl.log_error('usim_dbif.get_dimension', 'Invalid space id [' || p_usim_id_spc || '].');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_dimension', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_dimension
  ;

  FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_sign%TYPE;
  BEGIN
    l_result := usim_spc.get_dim_sign(p_usim_id_spc);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_dim_sign', 'Invalid space id [' || p_usim_id_spc || '].');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_dim_sign', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_dim_sign
  ;

  FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_n1_sign%TYPE;
  BEGIN
    l_result := usim_spc.get_dim_n1_sign(p_usim_id_spc);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_dim_n1_sign', 'Invalid space id [' || p_usim_id_spc || '].');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_dim_n1_sign', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_dim_n1_sign
  ;

  FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  IS
    l_result VARCHAR2(32000);
  BEGIN
    l_result := usim_spo.get_xyz(p_usim_id_spc);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_xyz', 'Invalid space id [' || p_usim_id_spc || '].');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_xyz', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_xyz
  ;

  FUNCTION get_magnitude( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    l_result := usim_spo.get_magnitude(p_usim_id_spc, p_usim_n_dimension);
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_magnitude', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_magnitude
  ;

  FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_process_spin%TYPE
  IS
    l_result usim_space.usim_process_spin%TYPE;
  BEGIN
    l_result := usim_spc.get_process_spin(p_usim_id_spc);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_process_spin', 'Used with invalid space id [' || p_usim_id_spc || '].');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_process_spin', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_process_spin
  ;

  FUNCTION get_universe_state_desc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  IS
    l_mlv_id    usim_multiverse.usim_id_mlv%TYPE;
    l_state     usim_multiverse.usim_universe_status%TYPE;
    l_result    VARCHAR2(8);
  BEGIN
    -- get universe
    l_mlv_id := usim_spc.get_id_mlv(p_usim_id_spc);
    IF l_mlv_id IS NULL
    THEN
      RETURN 'UNKNOWN';
    END IF;
    l_state  := usim_mlv.get_state(l_mlv_id);
    l_result := usim_static.get_multiverse_status(l_state);
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_universe_state_desc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_universe_state_desc
  ;

  FUNCTION get_planck_time_current
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_base.get_planck_time_current;
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_planck_time_current', 'Planck time not initialized.');
      usim_dbif.set_crashed;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_planck_time_current', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_planck_time_current
  ;

  FUNCTION get_planck_aeon_seq_current
    RETURN VARCHAR2
  IS
    l_result CHAR(55);
  BEGIN
    l_result := usim_base.get_planck_aeon_seq_current;
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_planck_aeon_seq_current', 'Planck aeon not initialized.');
      usim_dbif.set_crashed;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_planck_aeon_seq_current', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_planck_aeon_seq_current
  ;

  FUNCTION get_planck_time_next
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_base.get_planck_time_next;
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_planck_time_next', 'Planck time initialization error.');
      usim_dbif.set_crashed;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_planck_time_next', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_planck_time_next
  ;

  FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
                                 , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
                                 )
    RETURN NUMBER
  IS
    l_return NUMBER;
  BEGIN
    l_return := usim_spr.get_unprocessed_planck(p_usim_planck_aeon, p_usim_planck_time);
    RETURN l_return;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_unprocessed_planck', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_unprocessed_planck
  ;

  FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    l_result := usim_spo.get_axis_max_pos_parent(p_usim_id_spc);
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_axis_max_pos_parent', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_axis_max_pos_parent
  ;

  FUNCTION get_axis_max_pos_dim1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_id_mlv  usim_multiverse.usim_id_mlv%TYPE;
    l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
    l_id_spc  usim_space.usim_id_spc%TYPE;
    l_parent  usim_space.usim_id_spc%TYPE;
    l_max_pos usim_position.usim_coordinate%TYPE;
  BEGIN
    l_id_mlv  := usim_spc.get_id_mlv(p_usim_id_spc);
    l_n1_sign := usim_spc.get_dim_n1_sign(p_usim_id_spc);
    IF usim_spc.get_cur_max_dim_n1(p_usim_id_spc) > 0
    THEN
      -- get dimension 1 by universe parent
      WITH rmd AS
           (SELECT usim_id_rmd
              FROM usim_rmd_v
             WHERE usim_id_mlv = l_id_mlv
               AND usim_n_dimension = 0
           )
         , spc AS
           (SELECT spcv.usim_id_spc
              FROM usim_spc_v spcv
             INNER JOIN rmd
                ON spcv.usim_id_rmd = rmd.usim_id_rmd
           )
      SELECT chiv.usim_id_spc_child
        INTO l_id_spc
        FROM usim_chi_v chiv
       INNER JOIN spc
          ON chiv.usim_id_spc = spc.usim_id_spc
       WHERE child_dim_n1_sign = l_n1_sign
      ;
      l_parent  := usim_spo.get_axis_max_pos_parent(l_id_spc);
      IF l_parent IS NULL
      THEN
        usim_erl.log_error('usim_dbif.get_axis_max_pos_dim1', 'Could not get max axis dimension 1 coordinate for [' || p_usim_id_spc || '] axis 1 pos 0 id [' || l_id_spc || '].');
        usim_dbif.set_crashed;
      END IF;
      l_max_pos := usim_spc.get_coordinate(l_parent);
      IF l_max_pos IS NULL
      THEN
        usim_erl.log_error('usim_dbif.get_axis_max_pos_dim1', 'Could not get max coordinate for [' || p_usim_id_spc || '] max pos space id [' || l_parent || '].');
        usim_dbif.set_crashed;
      END IF;
      RETURN l_max_pos;
    ELSE
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_axis_max_pos_dim1', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_axis_max_pos_dim1
  ;

  FUNCTION get_next_pos_on_axis( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                               , p_usim_id_pos OUT usim_position.usim_id_pos%TYPE
                               , p_usim_id_rmd OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                               )
    RETURN NUMBER
  IS
    l_new_pos NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      -- determine the sign of the coordinate by dim sign
      IF usim_spc.get_dim_sign(p_usim_id_spc) = 1
      THEN
        l_new_pos := usim_spc.get_coordinate(p_usim_id_spc) + 1;
      ELSE
        l_new_pos := usim_spc.get_coordinate(p_usim_id_spc) - 1;
      END IF;
      p_usim_id_pos := usim_pos.get_id_pos(l_new_pos);
      p_usim_id_rmd := usim_spc.get_id_rmd(p_usim_id_spc);
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_dbif.get_next_pos_on_axis', 'Invalid space id [' || p_usim_id_spc || '].');
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_next_pos_on_axis', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_next_pos_on_axis
  ;

  FUNCTION overflow_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    -- do we have overflow on dimensions and positions
    IF      usim_dbif.is_overflow_dim_spc(p_usim_id_spc) = 1
       AND  usim_dbif.is_overflow_pos_spc(p_usim_id_spc) = 1
    THEN
      -- total overflow, no possible dimension or position open
      RETURN 0;
    ELSIF usim_dbif.max_childs(p_usim_id_spc) = usim_dbif.child_count(p_usim_id_spc)
    THEN
      -- total overflow, all possible childs connected
      RETURN 0;
    ELSIF usim_dbif.is_overflow_pos_spc(p_usim_id_spc) = 1
    THEN
      -- position overflow
      RETURN 2;
    ELSIF usim_dbif.is_overflow_dim_spc(p_usim_id_spc) = 1
    THEN
      -- dimension overflow
      RETURN 3;
    ELSE
      -- no overflow
      RETURN 1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.overflow_rating', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END overflow_rating
  ;

  FUNCTION dimension_rating( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                           , p_max_childs  OUT NUMBER
                           )
    RETURN NUMBER
  IS
    l_return       NUMBER;
    l_count        NUMBER;
    l_max_dim      NUMBER;
    l_usim_id_rmd  usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_usim_id_pos  usim_position.usim_id_pos%TYPE;
    l_usim_id_nod  usim_node.usim_id_nod%TYPE;
    l_process_spin usim_space.usim_process_spin%TYPE;
    l_usim_id_mlv  usim_multiverse.usim_id_mlv%TYPE;
    l_n_dimension  usim_dimension.usim_n_dimension%TYPE;
    l_dim_sign     usim_rel_mlv_dim.usim_sign%TYPE;
    l_dim_n1_sign  usim_rel_mlv_dim.usim_n1_sign%TYPE;
    l_coordinate   usim_position.usim_coordinate%TYPE;
    l_is_base      usim_multiverse.usim_is_base_universe%TYPE;
    l_energy       usim_node.usim_energy%TYPE;
   BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      -- get details
      l_return := usim_spc.get_spc_details( p_usim_id_spc
                                          , l_usim_id_rmd
                                          , l_usim_id_pos
                                          , l_usim_id_nod
                                          , l_process_spin
                                          , l_usim_id_mlv
                                          , l_n_dimension
                                          , l_dim_sign
                                          , l_dim_n1_sign
                                          , l_coordinate
                                          , l_is_base
                                          , l_energy
                                          )
      ;
      IF l_return = 0
      THEN
        usim_erl.log_error('usim_dbif.dimension_rating', 'Failed to get details for space id [' || p_usim_id_spc || '].');
        RETURN -1;
      END IF;
      IF     l_n_dimension = 0
         AND l_coordinate  = 0
      THEN
        -- only 2 special childs with opposite energy output sign possible
        p_max_childs := 2;
        RETURN 0;
      END IF;
      l_max_dim := NVL(usim_spc.get_cur_max_dim_n1(p_usim_id_spc), 0) + 1;
      IF usim_base.get_max_dimension < l_max_dim
      THEN
        l_max_dim := usim_base.get_max_dimension;
      END IF;
      IF     l_n_dimension = 1
         AND l_coordinate  = 0
      THEN
        -- zero pos dimension axis at dimension 1
        -- all dimension axis and position on dimension axis: (max n - n) x 2 + 1 axis child
        p_max_childs := ((l_max_dim - l_n_dimension) * 2) + 1;
        RETURN 1;
      END IF;
      IF     l_n_dimension > 1
         AND l_coordinate  = 0
      THEN
        -- zero pos dimension axis dimension > 1
        -- only position on dimension axis and 1 inbetween node: 2 childs
        p_max_childs := 2;
        RETURN 2;
      END IF;
      -- count coordinates not 0 for space id
      SELECT COUNT(*) INTO l_count FROM usim_spo_v WHERE usim_id_spc = p_usim_id_spc AND usim_coordinate != 0;
      IF     l_count       = 1
         AND l_coordinate != 0
      THEN
        -- pure dimension axis, possible childs: (max n - n) + 1 axis child
        p_max_childs := (l_max_dim  - l_n_dimension) + 1;
        RETURN 3;
      ELSE
        -- anywhere, possible childs: max n
        p_max_childs := l_max_dim;
        RETURN 4;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.dimension_rating', 'Invalid space id [' || p_usim_id_spc || '].');
      RETURN -1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.dimension_rating', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END dimension_rating
  ;

  FUNCTION dimension_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_max_childs NUMBER;
    l_rating     NUMBER;
  BEGIN
    l_rating := usim_dbif.dimension_rating(p_usim_id_spc, l_max_childs);
    RETURN l_rating;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.dimension_rating', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END dimension_rating
  ;

  FUNCTION max_childs(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_max_childs NUMBER;
    l_rating     NUMBER;
  BEGIN
    l_rating := usim_dbif.dimension_rating(p_usim_id_spc, l_max_childs);
    RETURN l_max_childs;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.max_childs', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END max_childs
  ;

  FUNCTION classify_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_count        NUMBER;
    l_return       NUMBER;
    l_dim_rating   NUMBER;
    l_parent_count NUMBER;
    l_child_count  NUMBER;
    l_connections  NUMBER;
    l_max_dim      NUMBER;
    l_max_child    NUMBER;
    l_dimension    NUMBER;
    l_max_pos      NUMBER;
    l_has_n1       NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 0
    THEN
      RETURN -1;
    END IF;
    -- get details
    l_dim_rating := usim_dbif.dimension_rating(p_usim_id_spc, l_max_child);
    IF l_dim_rating = -1
    THEN
      usim_erl.log_error('usim_dbif.classify_parent', 'Failed to get a dimension rating for space id [' || p_usim_id_spc || '].');
      RETURN -1;
    END IF;
    -- ignore errors like no child or parent, we get values anyway
    l_return      := usim_chi.get_chi_details(p_usim_id_spc, l_parent_count, l_child_count);
    IF l_dim_rating = 0 -- center of a universe dimension
    THEN
      -- no more childs possible
      IF l_child_count = l_max_child
      THEN
        -- fully connected
        RETURN 0;
      ELSE
        -- only next dimension possible
        RETURN 2;
      END IF;
    ELSIF l_dim_rating = 1 -- center dimension axis with pos 0 dimension > 0
    THEN
      -- only 2 childs possible
      IF l_child_count = l_max_child
      THEN
        -- fully connected
        RETURN 0;
      ELSE
        IF l_child_count > 0
        THEN
          -- find free node
          IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
          THEN
            -- if the position number on x axis that equals next dimension does not exist only position on X axis possible
            l_dimension := usim_spc.get_dimension(p_usim_id_spc) + 1;
            l_max_pos := ABS(NVL(usim_spc.get_coordinate(usim_spo.get_axis_max_pos_parent(p_usim_id_spc)), 1));
            IF l_max_pos >= l_dimension
            THEN
              -- only next dimension possible
              RETURN 2;
            ELSE
              -- first extend dimension axis
              RETURN 4;
            END IF;
          ELSE
            -- position or dimension (not checking upper dimensions available)
            RETURN 1;
          END IF;
        ELSE
          -- no childs at all
          -- position or dimension (not checking upper dimensions available)
          RETURN 1;
        END IF;
      END IF;
    ELSIF l_dim_rating = 2 -- on dimension axis pos > 0
    THEN
      IF l_child_count = l_max_child
      THEN
        -- fully connected
        RETURN 0;
      ELSE
        -- find free node
        IF l_child_count > 0
        THEN
          IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
          THEN
            -- only next dimension possible
            RETURN 2;
          ELSE
            -- position or dimension (not checking upper dimensions available)
            RETURN 1;
          END IF;
        ELSE
          -- position or dimension (not checking upper dimensions available)
          RETURN 1;
        END IF;
      END IF;
    ELSE -- everywhere else
      IF l_child_count = l_max_child
      THEN
        -- fully connected
        RETURN 0;
      ELSE
        IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
        THEN
          -- only next dimension possible
          RETURN 2;
        ELSE
          -- position or dimension (not checking upper dimensions available)
          RETURN 1;
        END IF;
      END IF;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.classify_parent', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END classify_parent
  ;

  FUNCTION classify_escape(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_parent_classification NUMBER;
    l_max_dim               NUMBER;
    l_max_cur_dim           NUMBER;
    l_max_pos               NUMBER;
    l_max_cur_pos           NUMBER;
    l_max_n1_pos            NUMBER;
    l_max_childs            NUMBER;
    l_childs                NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_max_dim               := usim_base.get_max_dimension;
      l_max_pos               := usim_base.get_abs_max_number;
      l_max_cur_dim           := usim_spc.get_cur_max_dim_n1(p_usim_id_spc);
      l_max_cur_pos           := usim_spc.get_cur_max_pos(p_usim_id_spc);
      l_max_childs            := usim_dbif.max_childs(p_usim_id_spc);
      l_childs                := usim_dbif.child_count(p_usim_id_spc);
      l_parent_classification := usim_dbif.classify_parent(p_usim_id_spc);
      l_max_n1_pos            := ABS(usim_dbif.get_axis_max_pos_dim1(p_usim_id_spc));

      -- check all classifications against all kinds of overflow
      IF l_parent_classification < 0
      THEN
        -- classification error, we should stop here
        usim_erl.log_error('usim_dbif.classify_escape', 'Classification error parent on id [' || p_usim_id_spc || '].');
        usim_dbif.set_crashed;
        RETURN -1;
      ELSIF l_parent_classification = 0
      THEN
        RETURN l_parent_classification;
      ELSIF l_parent_classification = 1
      THEN
        -- check if dimension and positions are over the max for n1 side of space node
        IF     l_max_cur_dim  < l_max_dim
           AND l_max_cur_pos  < l_max_pos
           AND l_max_n1_pos  >= l_max_cur_dim
        THEN
          -- everything available
          RETURN l_parent_classification;
        ELSIF     l_max_cur_dim  < l_max_dim
              AND l_max_n1_pos  >= l_max_cur_dim
        THEN
          -- only dimensions available
          RETURN 2;
        ELSIF     l_max_cur_dim < l_max_dim
              AND l_max_n1_pos  < l_max_cur_dim
        THEN
          IF usim_dbif.has_free_between(p_usim_id_spc) = 1
          THEN
            -- prefer filling between nodes
            RETURN 7;
          ELSE
            -- only position dim axis 1 delegate available
            RETURN 6;
          END IF;
        ELSIF l_max_cur_pos < l_max_pos
        THEN
          -- only positions available
          RETURN 3;
        -- full only new universe or delegate between
        ELSIF usim_dbif.has_free_between(p_usim_id_spc) = 1
        THEN
            -- delegate between
            RETURN 7;
        ELSE
          -- no delegate options
          RETURN 0;
        END IF;
      ELSIF l_parent_classification = 2
      THEN
        -- check
        IF     l_max_cur_dim  < l_max_dim
           AND l_max_n1_pos  >= l_max_cur_dim
        THEN
          -- everything available
          RETURN l_parent_classification;
        ELSIF     l_max_cur_dim < l_max_dim
              AND l_max_n1_pos  < l_max_cur_dim
        THEN
          IF usim_dbif.has_free_between(p_usim_id_spc) = 1
          THEN
            -- prefer filling between nodes
            RETURN 7;
          ELSE
            -- only position dim axis 1 delegate available
            RETURN 6;
          END IF;
        -- full only new universe or delegate
        ELSIF     l_max_cur_pos                             < l_max_pos
              AND usim_dbif.has_free_between(p_usim_id_spc) = 0
        THEN
          -- delegate position, if no between nodes are free
          RETURN 5;
        ELSIF usim_dbif.has_free_between(p_usim_id_spc) = 1
        THEN
          -- delegate between
          RETURN 7;
        ELSE
          -- no delegate options
          RETURN 0;
        END IF;
      ELSIF l_parent_classification IN (3, 4)
      THEN
        -- check
        IF l_max_cur_pos < l_max_pos
        THEN
          -- everything available
          RETURN l_parent_classification;
        -- full only new universe or delegate
        ELSIF     l_parent_classification                   = 4
              AND usim_dbif.has_free_between(p_usim_id_spc) = 0
        THEN
          RETURN l_parent_classification;
        ELSIF     l_max_cur_dim                             < l_max_dim
              AND usim_dbif.has_free_between(p_usim_id_spc) = 0
        THEN
          -- delegate new dimension, if no between nodes are free
          RETURN 4;
        ELSIF usim_dbif.has_free_between(p_usim_id_spc) = 1
        THEN
          -- delegate between
          RETURN 7;
        ELSE
          -- no delegate options
          RETURN 0;
        END IF;
      ELSE
        -- classification unknown
        usim_erl.log_error('usim_dbif.classify_escape', 'Unknown parent classfication [' || l_parent_classification || '] for id [' || p_usim_id_spc || '].');
        usim_dbif.set_crashed;
        RETURN -1;
      END IF;
    ELSE
      RETURN -1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.classify_escape', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END classify_escape
  ;

  FUNCTION get_dim_G( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                    , p_node_G      OUT NUMBER
                    )
    RETURN NUMBER
  IS
    l_dimension   usim_dimension.usim_n_dimension%TYPE;
    l_G           NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 0
    THEN
      usim_erl.log_error('usim_process.get_dim_G', 'Used with invalid space id [' || p_usim_id_spc || '].');
      RETURN -1;
    END IF;
    l_dimension := usim_spc.get_dimension(p_usim_id_spc);
    IF l_dimension = -1
    THEN
      usim_erl.log_error('usim_process.get_dim_G', 'Failed to get_dimension for space id [' || p_usim_id_spc || '].');
      RETURN -1;
    END IF;
    l_G := usim_maths.calc_dim_G(l_dimension);
    IF usim_base.num_has_overflow(l_G) = 1
    THEN
      usim_erl.log_error('usim_dbif.get_dim_G', 'Numerical overflow for l_G[' || l_G || '] overflow [' || usim_base.get_abs_max_number || ',-' || usim_base.get_abs_max_number || '] underflow[' || usim_base.get_max_underflow || ',' || usim_base.get_min_underflow || '].');
      RETURN 0;
    ELSE
      -- only set out value if valid value
      p_node_G := l_G;
      RETURN 1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
      THEN
        -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
        -- -1487: packed decimal number too large
        usim_erl.log_error('usim_dbif.get_dim_G', 'Numerical error on G calculate [' || SQLCODE || '] error message: ' || SQLERRM);
        RETURN 0;
      ELSE
        usim_erl.log_error('usim_dbif.get_dim_G', 'Unknown error [' || SQLCODE || '] error message: ' || SQLERRM);
        -- try to set all to crashed
        usim_dbif.set_crashed;
        -- return -1 handling is up to caller
        RETURN -1;
      END IF;
  END get_dim_G
  ;

  FUNCTION get_outer_planck_r( p_usim_id_spc    IN  usim_space.usim_id_spc%TYPE
                             , p_outer_planck_r OUT NUMBER
                             )
    RETURN NUMBER
  IS
    l_planck_length NUMBER;
    l_radius        NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 0
    THEN
      usim_erl.log_error('usim_process.get_dim_G', 'Used with invalid space id [' || p_usim_id_spc || '].');
      RETURN -1;
    END IF;
    SELECT usim_planck_length_unit
      INTO l_planck_length
      FROM usim_spc_v
     WHERE usim_id_spc = p_usim_id_spc
    ;
    l_radius := usim_maths.apply_planck(1, l_planck_length);
    IF usim_base.num_has_overflow(l_radius) = 1
    THEN
      usim_erl.log_error('usim_dbif.get_outer_planck_r', 'Numerical overflow for l_radius[' || l_radius || '] overflow [' || usim_base.get_abs_max_number || ',-' || usim_base.get_abs_max_number || '] underflow[' || usim_base.get_max_underflow || ',' || usim_base.get_min_underflow || '].');
      RETURN 0;
    ELSE
      -- only set out value if valid value
      p_outer_planck_r := l_radius;
      RETURN 1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
      THEN
        -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
        -- -1487: packed decimal number too large
        usim_erl.log_error('usim_dbif.get_outer_planck_r', 'Numerical error on outer planck r calculation [' || SQLCODE || '] error message: ' || SQLERRM);
        RETURN 0;
      ELSE
        usim_erl.log_error('usim_process.get_outer_planck_r', 'Unknown error [' || SQLCODE || '] error message: ' || SQLERRM);
        -- try to set all to crashed
        usim_dbif.set_crashed;
        -- return -1 handling is up to caller
        RETURN -1;
      END IF;
  END get_outer_planck_r
  ;

  FUNCTION get_acceleration( p_energy         IN  NUMBER
                           , p_radius         IN  NUMBER
                           , p_G              IN  NUMBER
                           , p_target_energy  OUT NUMBER
                           )
    RETURN NUMBER
  IS
    l_energy NUMBER;
  BEGIN
    l_energy := usim_maths.calc_planck_a2(p_energy, p_radius, p_G);
    IF usim_base.num_has_overflow(l_energy) = 1
    THEN
      usim_debug.debug_log('usim_dbif.get_acceleration', 'Numerical overflow for l_energy[' || l_energy || '] overflow [' || usim_base.get_abs_max_number || ',-' || usim_base.get_abs_max_number || '] underflow[' || usim_base.get_max_underflow || ',' || usim_base.get_min_underflow || '].');
      RETURN 0;
    ELSE
      -- only set out value if valid value
      p_target_energy := l_energy;
      RETURN 1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
      THEN
        -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
        -- -1487: packed decimal number too large
        usim_debug.debug_log('usim_dbif.get_acceleration', 'Numerical error on acceleration calculation [' || SQLCODE || '] error message: ' || SQLERRM);
        RETURN 0;
      ELSE
        usim_erl.log_error('usim_process.get_acceleration', 'Unknown error [' || SQLCODE || '] error message: ' || SQLERRM);
        -- try to set all to crashed
        usim_dbif.set_crashed;
        -- return -1 handling is up to caller
        RETURN -1;
      END IF;
  END get_acceleration
  ;

END usim_dbif;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_dbif
IS
  -- see header for documentation

  PROCEDURE set_crashed
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    UPDATE usim_multiverse
       SET usim_universe_status = usim_static.usim_multiverse_status_crashed
    ;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.set_crashed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END set_crashed
  ;

  FUNCTION set_universe_state( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
                             , p_do_commit   IN BOOLEAN                          DEFAULT TRUE
                             )
    RETURN usim_multiverse.usim_universe_status%TYPE
  IS
    l_return            NUMBER;
    l_status_valid      NUMBER;
    l_status_calculated usim_multiverse.usim_universe_status%TYPE;
  BEGIN
    -- check parameter
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      -- check state and correct it if mismatch
      SELECT status_valid, status_calculated INTO l_status_valid, l_status_calculated FROM usim_mlv_state_v WHERE usim_id_mlv = p_usim_id_mlv;
      IF l_status_calculated != usim_static.usim_multiverse_status_active
      THEN
        -- we have an error in the universe
        usim_erl.log_error('usim_dbif.set_universe_state', 'Current invalid status not running for mlv id [' || p_usim_id_mlv || '] is [' || l_status_valid || '] calculated [' || l_status_calculated || '].');
        IF l_status_valid != 1
        THEN
          l_return := usim_mlv.update_state(p_usim_id_mlv, l_status_calculated, FALSE);
          IF l_return IS NULL
          THEN
            ROLLBACK;
            usim_erl.log_error('usim_dbif.set_universe_state', 'Could not update state for mlv id [' || p_usim_id_mlv || '].');
          END IF;
          RETURN l_return;
        ELSE
          RETURN l_status_calculated;
        END IF;
      ELSE
        -- update state, if current state not valid
        IF l_status_valid != 1
        THEN
          l_return := usim_mlv.update_state(p_usim_id_mlv, l_status_calculated, FALSE);
          IF l_return IS NULL
          THEN
            ROLLBACK;
            usim_erl.log_error('usim_dbif.set_universe_state', 'Could not update state for mlv id [' || p_usim_id_mlv || '].');
          END IF;
          RETURN l_return;
        ELSE
          RETURN l_status_calculated;
        END IF;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.set_universe_state', 'Invalid parameter mlv id [' || p_usim_id_mlv || '].');
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.set_universe_state', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END set_universe_state
  ;

  FUNCTION set_universe_state_spc( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                                 , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                                 )
    RETURN usim_multiverse.usim_universe_status%TYPE
  IS
    l_usim_id_mlv       usim_multiverse.usim_id_mlv%TYPE;
    l_status_calculated usim_multiverse.usim_universe_status%TYPE;
    l_return            NUMBER;
    l_status_valid      NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
      IF l_usim_id_mlv IS NULL
      THEN
        usim_erl.log_error('usim_dbif.set_universe_state_spc', 'No valid universe found for space id [' || p_usim_id_spc || '].');
        RETURN NULL;
      END IF;
      -- check state and correct it if mismatch
      SELECT status_valid, status_calculated INTO l_status_valid, l_status_calculated FROM usim_mlv_state_v WHERE usim_id_mlv = l_usim_id_mlv;
      -- do only something, is status is not valid
      IF l_status_valid = 0
      THEN
        l_return := usim_mlv.update_state(l_usim_id_mlv, l_status_calculated, FALSE);
        IF l_return IS NULL
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Could not update state for mlv id [' || l_usim_id_mlv || '].');
        ELSE
          IF p_do_commit
          THEN
            COMMIT;
          END IF;
        END IF;
        RETURN l_return;
      ELSIF l_status_valid = -1
      THEN
        usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Invalid calculation state for mlv id [' || l_usim_id_mlv || '].');
        RETURN NULL;
      ELSE
        RETURN l_status_calculated;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Invalid parameter space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END set_universe_state_spc
  ;

  FUNCTION set_seed_active(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN usim_multiverse.usim_universe_status%TYPE
  IS
    l_return      usim_multiverse.usim_universe_status%TYPE;
    l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    IF usim_mlv.has_base = 1
    THEN
      SELECT usim_id_mlv INTO l_usim_id_mlv FROM usim_multiverse WHERE usim_is_base_universe = 1;
      l_return := usim_mlv.update_state(l_usim_id_mlv, usim_static.usim_multiverse_status_active, FALSE);
      IF l_return != usim_static.usim_multiverse_status_active
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_dbif.set_seed_active', 'Could not update state to active on universe seed id [' || l_usim_id_mlv || '] getting status [' || l_return || '].');
        RETURN NULL;
      ELSE
        IF p_do_commit
        THEN
          COMMIT;
        END IF;
        RETURN l_return;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.set_seed_active', 'No base universe found.');
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.set_seed_active', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END set_seed_active
  ;

  FUNCTION init_basedata( p_max_dimension            IN NUMBER DEFAULT 42
                        , p_usim_abs_max_number      IN NUMBER DEFAULT 99999999999999999999999999999999999999
                        , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
                        )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_base.has_basedata = 0
    THEN
      usim_base.init_basedata(p_max_dimension, p_usim_abs_max_number, p_usim_overflow_node_seed);
    END IF;
    IF usim_base.has_basedata = 0
    THEN
      usim_erl.log_error('usim_dbif.init_basedata', 'Could not initialize base data for max dim [' || p_max_dimension || '] max num [' || p_usim_abs_max_number || '] and overflow seed [' || p_usim_overflow_node_seed || '].');
    END IF;
    l_result := usim_base.has_basedata;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.init_basedata', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END init_basedata
  ;

  FUNCTION init_dimensions(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  IS
    l_max_dim usim_dimension.usim_n_dimension%TYPE;
    l_return  NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      l_max_dim := usim_base.get_max_dimension;
      l_return  := usim_dim.init_dimensions(l_max_dim, FALSE);
      IF l_return != 1
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_dbif.init_dimensions', 'Could not init dimensions up to max [' || l_max_dim || '].');
        RETURN -1;
      ELSE
        IF p_do_commit
        THEN
          COMMIT;
         END IF;
      END IF;
      RETURN l_return;
    ELSE
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.init_dimensions', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END init_dimensions
  ;

  FUNCTION has_basedata
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_base.has_basedata;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_basedata', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_basedata
  ;

  FUNCTION has_data_spc
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spc.has_data;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_data_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_data_spc
  ;

  FUNCTION has_data_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spc.has_data(p_usim_id_spc);
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_data_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_data_spc
  ;

  FUNCTION has_data_spr
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spr.has_data;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_data_spr', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_data_spr
  ;

  FUNCTION has_data_spr(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spr.has_data(p_usim_id_spr);
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_data_spr', 'Unexpected error for id [' || p_usim_id_spr || '], SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_data_spr
  ;

  FUNCTION has_unprocessed
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spr.has_unprocessed;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_unprocessed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_unprocessed
  ;

  FUNCTION has_data_mlv
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_mlv.has_data;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_data_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_data_mlv
  ;

  FUNCTION has_data_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_mlv.has_data(p_usim_id_mlv);
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_data_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_data_mlv
  ;

  FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spo.has_axis_max_pos_parent(p_usim_id_spc);
    IF l_result > 1
    THEN
      usim_erl.log_error('usim_dbif.has_axis_max_pos_parent', 'Error dimension symmetry, more than one maximum position on dimension axis found for space node [' || p_usim_id_spc || '].');
      usim_dbif.set_crashed;
      RETURN -1;
    ELSE
      RETURN l_result;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_axis_max_pos_parent', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_axis_max_pos_parent
  ;

  FUNCTION has_free_between(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    -- if not related to all dimensions, relying on dimensions are built and assigned in order
    IF usim_chi.get_cur_max_dimension(p_usim_id_spc) < usim_spc.get_cur_max_dim_n1(p_usim_id_spc)
    THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.has_free_between', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END has_free_between
  ;

  FUNCTION is_seed_active
    RETURN NUMBER
  IS
    l_status_calculated NUMBER;
    l_planck_aeon       usim_static.usim_id;
    l_planck_time       NUMBER;
    l_energy_total      NUMBER;
    l_energy_positive   NUMBER;
    l_energy_negative   NUMBER;
    l_has_process_data  NUMBER;
    l_has_unprocessed   NUMBER;
  BEGIN
    IF usim_mlv.has_base = 1
    THEN
      SELECT status_calculated INTO l_status_calculated FROM usim_mlv_state_v WHERE usim_is_base_universe = 1;
      IF l_status_calculated = usim_static.usim_multiverse_status_active
      THEN
        RETURN 1;
      ELSE
        SELECT planck_aeon
             , planck_time
             , energy_base
             , energy_positive
             , energy_negative
             , has_process_data
             , has_unprocessed
          INTO l_planck_aeon
             , l_planck_time
             , l_energy_total
             , l_energy_positive
             , l_energy_negative
             , l_has_process_data
             , l_has_unprocessed
          FROM usim_mlv_state_v
         WHERE usim_is_base_universe = 1
        ;
        usim_erl.log_error('usim_dbif.is_seed_active', 'Seed not active at planck aeon [' || l_planck_aeon || '], time [' || l_planck_time || '], total e [' || l_energy_total || '], e+ [' || l_energy_positive || '], e- [' || l_energy_negative || '], process data [' || l_has_process_data || '], unprocessed [' || l_has_unprocessed || '].');
        RETURN 0;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.is_seed_active', 'No base universe found.');
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_seed_active', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_seed_active
  ;

  FUNCTION is_universe_active(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_mlv_id    usim_multiverse.usim_id_mlv%TYPE;
    l_state     usim_multiverse.usim_universe_status%TYPE;
  BEGIN
    -- get universe
    l_mlv_id := usim_spc.get_id_mlv(p_usim_id_spc);
    IF l_mlv_id IS NULL
    THEN
      RETURN 0;
    END IF;
    l_state  := usim_mlv.get_state(l_mlv_id);
    IF l_state = usim_static.usim_multiverse_status_active
    THEN
      RETURN 1;
    ELSE
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_universe_active', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_universe_active
  ;

  FUNCTION is_universe_base_type(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_return NUMBER;
  BEGIN
    l_return := usim_spc.is_universe_base(p_usim_id_spc);
    RETURN l_return;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_universe_base', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_universe_base_type
  ;

  FUNCTION init_positions(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  IS
    l_max_pos usim_position.usim_coordinate%TYPE;
    l_return  NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      l_max_pos := usim_base.get_abs_max_number;
      l_return  := usim_pos.init_positions(l_max_pos, FALSE);
      IF l_return != 1
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_dbif.init_positions', 'Could not init positions up to max [' || l_max_pos || '].');
        RETURN -1;
      ELSE
        IF p_do_commit
        THEN
          COMMIT;
        END IF;
      END IF;
      RETURN l_return;
    ELSE
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.init_positions', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END init_positions
  ;

  FUNCTION is_overflow_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    IF usim_pos.has_data = 0
    THEN
      -- no data
      RETURN 0;
    END IF;
    IF usim_pos.has_data(p_usim_coordinate) = 1
    THEN
      RETURN 0;
    ELSE
      RETURN 1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_overflow_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_overflow_pos
  ;

  FUNCTION is_overflow_pos_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  IS
    l_max_pos1 usim_position.usim_coordinate%TYPE;
    l_max_neg1 usim_position.usim_coordinate%TYPE;
    l_max_pos2 usim_position.usim_coordinate%TYPE;
    l_max_neg2 usim_position.usim_coordinate%TYPE;
    l_max      NUMBER;
  BEGIN
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      -- universe does not exist
      RETURN 0;
    END IF;
    IF usim_base.has_basedata = 1
    THEN
      SELECT MAX(usim_n_dimension) INTO l_max_pos1 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = 1 AND usim_coordinate >= 0;
      SELECT MIN(usim_n_dimension) INTO l_max_neg1 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = 1 AND usim_coordinate <= 0;
      SELECT MAX(usim_n_dimension) INTO l_max_pos2 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = -1 AND usim_coordinate >= 0;
      SELECT MIN(usim_n_dimension) INTO l_max_neg2 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = -1 AND usim_coordinate <= 0;
      l_max := usim_base.get_abs_max_number;
      IF     l_max_pos1      >= l_max
         AND ABS(l_max_neg1) >= l_max
         AND l_max_pos2      >= l_max
         AND ABS(l_max_neg2) >= l_max
      THEN
        RETURN 1;
      ELSE
        RETURN 0;
      END IF;
    ELSE
      -- can't check
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_overflow_pos_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_overflow_pos_mlv
  ;

  FUNCTION is_overflow_dim_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    RETURN NUMBER
  IS
    l_max_dim_pos usim_dimension.usim_n_dimension%TYPE;
    l_max_dim_neg usim_dimension.usim_n_dimension%TYPE;
    l_max         NUMBER;
  BEGIN
    IF usim_mlv.has_data(p_usim_id_mlv) = 1
    THEN
      -- universe does not exist
      RETURN 0;
    END IF;
    IF usim_base.has_basedata = 1
    THEN
      SELECT MAX(usim_n_dimension) INTO l_max_dim_pos FROM usim_rmd_v WHERE usim_id_mlv = p_usim_id_mlv AND usim_n1_sign = 1;
      SELECT MAX(usim_n_dimension) INTO l_max_dim_neg FROM usim_rmd_v WHERE usim_id_mlv = p_usim_id_mlv AND usim_n1_sign = -1;
      l_max := usim_base.get_max_dimension;
      IF     l_max_dim_neg >= l_max
         AND l_max_dim_pos >= l_max
      THEN
        RETURN 1;
      ELSE
        RETURN 0;
      END IF;
    ELSE
      -- can't check
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_overflow_dim_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_overflow_dim_mlv
  ;

  FUNCTION is_overflow_dim_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
    l_max_dim     NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
      IF l_usim_id_mlv IS NULL
      THEN
        -- no overflow for not existing mlv
        RETURN 0;
      END IF;
      -- check if is base at dimension 0 and has two childs = overflow
      IF     usim_spc.is_universe_base(p_usim_id_spc) = 1
         AND usim_chi.child_count(p_usim_id_spc)      = 2
      THEN
        RETURN 1;
      ELSIF usim_spc.is_universe_base(p_usim_id_spc) = 1
      THEN
        RETURN 0;
      ELSE
        -- check if is not base and childs have all dimensions = overflow
        SELECT MAX(usim_n_dimension)
          INTO l_max_dim
          FROM usim_spo_v
         WHERE usim_id_spc = p_usim_id_spc
           AND usim_id_mlv = l_usim_id_mlv
        ;
        IF l_max_dim >= usim_base.get_max_dimension
        THEN
          RETURN 1;
        ELSE
          RETURN 0;
        END IF;
      END IF;
    ELSE
      -- no overflow for not existing space id
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_overflow_dim_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_overflow_dim_spc
  ;

  FUNCTION is_overflow_pos_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      -- no position free on base
      IF usim_spc.is_universe_base(p_usim_id_spc) = 1
      THEN
        -- base node has no position free
        RETURN 1;
      END IF;
      -- if child in same dimension we are in overflow
      IF     usim_chi.has_child_same_dim(p_usim_id_spc) = 1
             -- if node is on position 0 on all axis, the node can trigger position extension, so it should not be a zero axis position
         AND usim_spo.is_axis_zero_pos(p_usim_id_spc)   = 0
      THEN
        RETURN 1;
      ELSE
        RETURN 0;
      END IF;
    ELSE
      -- no overflow if space id does not exist
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_overflow_dim_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_overflow_pos_spc
  ;

  FUNCTION is_overflow_energy(p_energy IN NUMBER)
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      l_result := usim_base.num_has_overflow(p_energy);
      IF l_result = 1
      THEN
        RETURN 1;
      ELSE
        RETURN 0;
      END IF;
    ELSE
      -- we can't check
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
      THEN
        -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
        -- -1487: packed decimal number too large
        usim_erl.log_error('usim_dbif.is_overflow_energy', 'Numerical error on energy overflow check for [' || SQLCODE || '] error message: ' || SQLERRM);
        RETURN 1;
      ELSE
        -- write error might still work
        usim_erl.log_error('usim_dbif.is_overflow_energy', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
        -- try to set all to crashed
        usim_dbif.set_crashed;
        -- raise in any case
        RAISE;
      END IF;
  END is_overflow_energy
  ;

  FUNCTION is_overflow_energy_add( p_energy IN NUMBER
                                 , p_add    IN NUMBER
                                 )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF usim_base.has_basedata = 1
    THEN
      -- check against base
      l_result := usim_base.num_add_has_overflow(p_energy, p_add);
      RETURN l_result;
    ELSE
      -- check against system, if fails with numerical exception we have overflow state
      l_result := p_energy + p_add;
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
      THEN
        -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
        -- -1487: packed decimal number too large
        usim_erl.log_error('usim_dbif.is_overflow_energy_add', 'Numerical error on add energy overflow check [' || SQLCODE || '] error message: ' || SQLERRM);
        RETURN 1;
      ELSE
        -- write error might still work
        usim_erl.log_error('usim_dbif.is_overflow_energy_add', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
        -- try to set all to crashed
        usim_dbif.set_crashed;
        -- raise in any case
        RAISE;
      END IF;
  END is_overflow_energy_add
  ;

  FUNCTION is_base_universe_seed(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    IF usim_spc.get_id_spc_base_universe = p_usim_id_spc
    THEN
      RETURN 1;
    ELSE
      IF usim_spc.has_base_universe = 0
      THEN
        usim_erl.log_error('usim_dbif.is_base_universe_seed', 'Used function without a base universe seed currently available.');
      END IF;
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_base_universe_seed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_base_universe_seed
  ;

  FUNCTION is_queue_valid
    RETURN NUMBER
  IS
    l_return NUMBER;
  BEGIN
    l_return := usim_spr.is_queue_valid;
    RETURN l_return;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_queue_valid', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_queue_valid
  ;

  FUNCTION is_pos_extendable(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    IF usim_chi.has_child_same_dim(p_usim_id_spc) = 0
    THEN
      RETURN 1;
    END IF;
    IF usim_spo.is_axis_zero_pos(p_usim_id_spc) = 1
    THEN
      RETURN 2;
    END IF;
    -- no check passed
    usim_erl.log_error('usim_dbif.is_pos_extendable', 'Given space node id [' || p_usim_id_spc || '] is not extendable on position.');
    RETURN 0;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_pos_extendable', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_pos_extendable
  ;

  FUNCTION is_dim_extendable( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                            , p_use_parent  OUT usim_space.usim_id_spc%TYPE
                            , p_next_dim    OUT usim_dimension.usim_n_dimension%TYPE
                            )
    RETURN NUMBER
  IS
    l_max_cur_dim NUMBER;
    l_max_chi_dim NUMBER;
    l_max_dim     NUMBER;
  BEGIN
    l_max_cur_dim := usim_spc.get_cur_max_dim_n1(p_usim_id_spc);
    l_max_chi_dim := usim_chi.get_cur_max_dimension(p_usim_id_spc);
    l_max_dim     := usim_base.get_max_dimension;
    IF usim_spo.is_axis_zero_pos(p_usim_id_spc) = 1
    THEN
      IF l_max_chi_dim < l_max_dim
      THEN
        p_use_parent := p_usim_id_spc;
        p_next_dim   := l_max_chi_dim + 1;
        RETURN 2;
      ELSE
        -- no dimension left
        p_use_parent := NULL;
        p_next_dim   := NULL;
        RETURN 0;
      END IF;
    END IF;
    IF l_max_chi_dim < l_max_cur_dim
    THEN
      -- free available dimensions
      p_use_parent := p_usim_id_spc;
      p_next_dim   := l_max_chi_dim + 1;
      RETURN 1;
    ELSIF l_max_chi_dim < l_max_dim
    THEN
      -- free dimension, but dimension has to be build
      p_use_parent := usim_spo.get_axis_zero_pos_parent(p_usim_id_spc);
      p_next_dim   := l_max_chi_dim + 1;
      RETURN 2;
    ELSE
      p_use_parent := NULL;
      p_next_dim   := NULL;
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.is_dim_extendable', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END is_dim_extendable
  ;

  FUNCTION child_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                      , p_ignore_mlv  IN NUMBER                      DEFAULT 0
                      )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF p_ignore_mlv = 0
    THEN
      l_result := usim_chi.child_count(p_usim_id_spc);
    ELSE
      l_result := usim_chi.child_count_all(p_usim_id_spc);
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.child_count', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END child_count
  ;

  FUNCTION parent_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                       , p_ignore_mlv  IN NUMBER                      DEFAULT 0
                       )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    IF p_ignore_mlv = 0
    THEN
      l_result := usim_chi.parent_count(p_usim_id_spc);
    ELSE
      l_result := usim_chi.parent_count_all(p_usim_id_spc);
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.parent_count', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END parent_count
  ;

  FUNCTION create_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                          , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                          , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                          , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                          , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                          , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                          , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                          )
    RETURN usim_multiverse.usim_id_mlv%TYPE
  IS
    l_result usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    IF usim_mlv.has_data     = 1
       AND usim_mlv.has_base = 0
    THEN
      -- wrong state
      usim_erl.log_error('usim_dbif.create_universe', 'Unexpected multiverse state no base universe but universes exist.');
      usim_dbif.set_crashed;
      RETURN NULL;
    END IF;
    l_result := usim_mlv.insert_universe( p_usim_energy_start_value
                                        , p_usim_planck_time_unit
                                        , p_usim_planck_length_unit
                                        , p_usim_planck_speed_unit
                                        , p_usim_planck_stable
                                        , p_usim_ultimate_border
                                        , FALSE
                                        )
    ;
    IF l_result IS NULL
    THEN
      ROLLBACK;
      usim_erl.log_error('usim_dbif.create_universe', 'Could not insert new universe.');
    ELSE
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.create_universe', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END create_universe
  ;

  FUNCTION create_dim_axis( p_usim_id_mlv        IN  usim_multiverse.usim_id_mlv%TYPE
                          , p_usim_n_dimension   IN  usim_dimension.usim_n_dimension%TYPE
                          , p_usim_id_rmd_parent IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_rmd_pos    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_usim_id_rmd_neg    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                          , p_do_commit          IN  BOOLEAN                              DEFAULT TRUE
                          )
    RETURN NUMBER
  IS
    l_sign    usim_rel_mlv_dim.usim_sign%TYPE;
    l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
  BEGIN
    IF     usim_dim.has_data(p_usim_n_dimension) = 1
       AND usim_mlv.has_data(p_usim_id_mlv)      = 1
    THEN
      -- do not commit until everything is processed
      IF p_usim_n_dimension = 0
      THEN
        p_usim_id_rmd_pos := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, 0, NULL, FALSE);
        p_usim_id_rmd_neg := usim_rmd.get_id_rmd(p_usim_id_mlv, p_usim_n_dimension, 0, NULL);
      ELSE
        IF p_usim_n_dimension > 1
        THEN
          IF p_usim_id_rmd_parent IS NOT NULL
          THEN
            l_sign := usim_rmd.get_dim_n1_sign(p_usim_id_rmd_parent);
            IF l_sign != 0
            THEN
              p_usim_id_rmd_pos := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, 1, l_sign, FALSE);
              p_usim_id_rmd_neg := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, -1, l_sign, FALSE);
            ELSE
              usim_erl.log_error('usim_dbif.create_dim_axis', 'Pparent rmd id returns invalid n1 sign 0.');
              RETURN 0;
            END IF;
          ELSE
            usim_erl.log_error('usim_dbif.create_dim_axis', 'Dimension > 1 but NULL parent rmd id given.');
            RETURN 0;
          END IF;
        ELSIF p_usim_n_dimension = 1
        THEN
          p_usim_id_rmd_pos := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, 1, 1, FALSE);
          p_usim_id_rmd_neg := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, -1, -1, FALSE);
        ELSE
          usim_erl.log_error('usim_dbif.create_dim_axis', 'Invalid dimension [' || p_usim_n_dimension || '].');
          RETURN 0;
        END IF;
      END IF;
      -- now check out values if we arrive here
      IF      p_usim_id_rmd_pos IS NOT NULL
          AND p_usim_id_rmd_neg IS NOT NULL
      THEN
        -- commit everything
        IF p_do_commit
        THEN
          COMMIT;
        END IF;
        RETURN 1;
      ELSE
        ROLLBACK;
        usim_erl.log_error('usim_dbif.create_dim_axis', 'Error creating dimension axis for [' || p_usim_n_dimension || '].');
        RETURN 0;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.create_dim_axis', 'Invalid mlv [' || p_usim_id_mlv || '] or dimension [' || p_usim_n_dimension || '].');
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.create_dim_axis', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END create_dim_axis
  ;

  FUNCTION create_space_node( p_usim_id_rmd  IN usim_rel_mlv_dim.usim_id_rmd%TYPE
                            , p_usim_id_pos  IN usim_position.usim_id_pos%TYPE
                            , p_usim_parents IN usim_static.usim_ids_type
                            , p_do_commit    IN BOOLEAN                           DEFAULT TRUE
                            )
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_usim_id_mlv     usim_multiverse.usim_id_mlv%TYPE;
    l_usim_id_nod     usim_node.usim_id_nod%TYPE;
    l_usim_id_spc     usim_space.usim_id_spc%TYPE;
    l_usim_coordinate usim_position.usim_coordinate%TYPE;
    l_count           NUMBER;
    l_spin            NUMBER;
    l_return          NUMBER;
  BEGIN
    IF     usim_rmd.has_data(p_usim_id_rmd) = 1
       AND usim_pos.has_data(p_usim_id_pos) = 1
    THEN
      -- pos and rmd not unique, inbetween nodes
      -- check situation
      l_usim_id_mlv     := usim_rmd.get_id_mlv(p_usim_id_rmd);
      IF l_usim_id_mlv IS NULL
      THEN
        usim_erl.log_error('usim_dbif.create_space_node', 'Could not get universe for rmd [' || p_usim_id_rmd || '].');
        usim_dbif.set_crashed;
        RETURN NULL;
      END IF;
      l_usim_coordinate := usim_pos.get_coordinate(p_usim_id_pos);
      IF l_usim_coordinate IS NULL
      THEN
        usim_erl.log_error('usim_dbif.create_space_node', 'Could not get coordinate for pos [' || p_usim_id_pos || '].');
        usim_dbif.set_crashed;
        RETURN NULL;
      END IF;
      IF     usim_mlv.is_base(l_usim_id_mlv) = 0
         AND l_usim_coordinate              != 0
         AND p_usim_parents.COUNT            = 0
      THEN
        usim_erl.log_error('usim_dbif.create_space_node', 'Missing parent for not base universe and position not 0.');
        RETURN NULL;
      END IF;
      IF p_usim_parents.COUNT = 0
      THEN
        -- check if not already set
        SELECT COUNT(*)
          INTO l_count
          FROM usim_spc_v
         WHERE usim_id_mlv           = l_usim_id_mlv
           AND usim_is_base_universe = 1
           AND dim_sign              = 0
           AND dim_n1_sign          IS NULL
           AND usim_coordinate       = 0
        ;
        IF l_count != 0
        THEN
          usim_erl.log_error('usim_dbif.create_space_node', 'Base universe node at position 0, dimension 0 already exists.');
          RETURN NULL;
        END IF;
      END IF;
      -- define process spin, new childs normally are at the end of the row, so direction would be -1 (parent)
      -- whereas a node without parent is always in direction 1 (childs). The sign is initially direction child. As soon as
      -- processing begins, it will be flipped by processing to the correct direction, whenever the process encounters
      -- a border space node as defined by border rule.
      l_spin := 1;
      -- all checks passed, create node, do not commit until all is done
      l_usim_id_nod := usim_nod.insert_node(FALSE);
      l_usim_id_spc := usim_spc.insert_spc(p_usim_id_rmd, p_usim_id_pos, l_usim_id_nod, l_spin, FALSE);
      IF l_usim_id_spc IS NULL
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node for rmd [' || p_usim_id_rmd || '] and position [' || p_usim_id_pos || '] .');
        usim_dbif.set_crashed;
        RETURN NULL;
      END IF;
      -- update position for parents
      IF p_usim_parents.COUNT > 0
      THEN
        FOR i IN p_usim_parents.FIRST..p_usim_parents.LAST
        LOOP
          l_return := usim_spo.insert_spc_pos(l_usim_id_spc, p_usim_parents(i), FALSE);
          IF l_return = 0
          THEN
            ROLLBACK;
            usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node position for spc [' || l_usim_id_spc || '] and parent [' || p_usim_parents(i) || '] .');
            usim_dbif.set_crashed;
            RETURN NULL;
          END IF;
          -- check parent child relation only same n1 sign apart from base universe nodes
          IF    usim_spc.get_dim_n1_sign(p_usim_parents(i))  = usim_spc.get_dim_n1_sign(l_usim_id_spc)
             OR usim_spc.is_universe_base(p_usim_parents(i)) = 1
             OR usim_spc.is_universe_base(l_usim_id_spc)     = 1
          THEN
            -- define relationship if parent is set
            l_return := usim_chi.insert_chi(p_usim_parents(i), l_usim_id_spc, FALSE);
            IF l_return = 0
            THEN
              ROLLBACK;
              usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node relation for spc [' || l_usim_id_spc || '] and parent [' || p_usim_parents(i) || '] .');
              usim_dbif.set_crashed;
              RETURN NULL;
            END IF;
          ELSE
            ROLLBACK;
            usim_erl.log_error('usim_dbif.create_space_node', 'Space node relation not allowed due to different n1 sign for spc [' || l_usim_id_spc || '] and parent [' || p_usim_parents(i) || '] not base node.');
            usim_dbif.set_crashed;
            RETURN NULL;
          END IF;
        END LOOP;
      ELSE
        l_return := usim_spo.insert_spc_pos(l_usim_id_spc, NULL, FALSE);
        IF l_return = 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node position for spc [' || l_usim_id_spc || '] and parent NULL.');
          usim_dbif.set_crashed;
          RETURN NULL;
        END IF;
      END IF;
      -- creation done, commit if given
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
      RETURN l_usim_id_spc;
    ELSE
      usim_erl.log_error('usim_dbif.create_space_node', 'Invalid rmd [' || p_usim_id_rmd || '] or position [' || p_usim_id_pos || '].');
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.create_space_node', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END create_space_node
  ;

  FUNCTION create_process( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
                         , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
                         , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
                         , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
                         , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
                         , p_do_commit          IN BOOLEAN                                  DEFAULT TRUE
                         )
    RETURN usim_spc_process.usim_id_spr%TYPE
  IS
    l_result usim_spc_process.usim_id_spr%TYPE;
  BEGIN
    l_result := usim_spr.insert_spr(p_usim_id_spc_source, p_usim_id_spc_target, p_usim_energy_source, p_usim_energy_target, p_usim_energy_output, FALSE);
    IF l_result IS NOT NULL
    THEN
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.create_process', 'Failed to insert process record.');
      ROLLBACK;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.create_process', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END create_process
  ;

  FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                            , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                            )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spc.flip_process_spin(p_usim_id_spc, FALSE);
    IF l_result = 0
    THEN
      ROLLBACK;
      usim_erl.log_error('usim_dbif.flip_process_spin', 'Failed to flip process spin for space id [' || p_usim_id_spc || '].');
    ELSE
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.flip_process_spin', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END flip_process_spin
  ;

  FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
                        , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
                        , p_do_commit     IN BOOLEAN                            DEFAULT TRUE
                        )
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_spr.set_processed(p_usim_id_spr, p_process_state, FALSE);
    IF l_result = 0
    THEN
      ROLLBACK;
      usim_erl.log_error('usim_dbif.set_processed', 'Failed to set processed state for id [' || p_usim_id_spr || '] and state [' || p_process_state || '].');
    ELSE
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.set_processed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END set_processed
  ;

  FUNCTION check_border( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                       , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                       )
    RETURN NUMBER
  IS
    l_usim_id_mlv   usim_multiverse.usim_id_mlv%TYPE;
    l_border_rule   usim_multiverse.usim_ultimate_border%TYPE;
    l_process_spin  usim_space.usim_process_spin%TYPE;
    l_result        INTEGER;
  BEGIN
    l_usim_id_mlv  := usim_spc.get_id_mlv(p_usim_id_spc);
    l_border_rule  := usim_mlv.get_ultimate_border(l_usim_id_mlv);
    l_process_spin := usim_spc.get_process_spin(p_usim_id_spc);
    IF l_border_rule = 1
    THEN
      -- if no child and direction is child flip to parent
      IF     usim_chi.child_count(p_usim_id_spc) = 0
         AND l_process_spin                      = 1
      THEN
        l_result := usim_spc.flip_process_spin(p_usim_id_spc, FALSE);
        -- check fail
        IF l_result = 1
        THEN
          IF p_do_commit
          THEN
            COMMIT;
          END IF;
          RETURN 1;
        ELSE
          usim_erl.log_error('usim_dbif.check_border', 'Could not flip process spin on space id [' || p_usim_id_spc || '].');
          -- set all to crashed
          usim_dbif.set_crashed;
          ROLLBACK;
          RETURN 0;
        END IF;
      ELSE
        RETURN 1;
      END IF;
    ELSE
      -- if no child in dimension and direction is child flip to parent
      IF     usim_chi.has_child_same_dim(p_usim_id_spc) = 0
         AND l_process_spin                             = 1
      THEN
        l_result := usim_spc.flip_process_spin(p_usim_id_spc, FALSE);
        -- check fail
        IF l_result = 1
        THEN
          IF p_do_commit
          THEN
            COMMIT;
          END IF;
          RETURN 1;
        ELSE
          usim_erl.log_error('usim_dbif.check_border', 'Could not flip process spin on space id [' || p_usim_id_spc || '].');
          -- set all to crashed
          usim_dbif.set_crashed;
          ROLLBACK;
          RETURN 0;
        END IF;
      END IF;
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_dbif.check_border', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END check_border
  ;

  FUNCTION get_id_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_usim_id_pos usim_position.usim_id_pos%TYPE;
  BEGIN
    IF usim_pos.has_data(p_usim_coordinate) = 1
    THEN
      l_usim_id_pos := usim_pos.get_id_pos(p_usim_coordinate);
      IF l_usim_id_pos IS NULL
      THEN
        usim_erl.log_error('usim_dbif.get_id_pos', 'Could not get position id for coordinate [' || p_usim_coordinate || '].');
      END IF;
      RETURN l_usim_id_pos;
    ELSE
      usim_erl.log_error('usim_dbif.get_id_pos', 'Invalid coordinate [' || p_usim_coordinate || '], maybe overflow.');
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_id_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_id_pos
  ;

  FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_id_pos%TYPE
  IS
    l_usim_id_pos usim_position.usim_id_pos%TYPE;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_usim_id_pos := usim_spc.get_id_pos(p_usim_id_spc);
      IF l_usim_id_pos IS NULL
      THEN
        usim_erl.log_error('usim_dbif.get_id_pos', 'Could not get position id for space node [' || p_usim_id_spc || '].');
      END IF;
      RETURN l_usim_id_pos;
    ELSE
      usim_erl.log_error('usim_dbif.get_id_pos', 'Invalid space id [' || p_usim_id_spc || '].');
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_id_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_id_pos
  ;

  FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_node.usim_id_nod%TYPE
  IS
    l_result usim_node.usim_id_nod%TYPE;
  BEGIN
    l_result := usim_spc.get_id_nod(p_usim_id_spc);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_id_nod', 'Invalid space id [' || p_usim_id_spc || '] or no node found.');
      usim_dbif.set_crashed;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_id_nod', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_id_nod
  ;

  FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_multiverse.usim_id_mlv%TYPE
  IS
    l_result usim_multiverse.usim_id_mlv%TYPE;
  BEGIN
    l_result := usim_spc.get_id_mlv(p_usim_id_spc);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_id_mlv', 'Invalid space id [' || p_usim_id_spc || '] or no node found.');
      usim_dbif.set_crashed;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_id_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_id_mlv
  ;

  FUNCTION get_id_spc_base_universe
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    l_result := usim_spc.get_id_spc_base_universe;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_id_spc_base_universe', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_id_spc_base_universe
  ;

  FUNCTION get_spc_dim_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
                              , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
                              , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                              , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
                              , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
                              )
    RETURN NUMBER
  IS
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      p_usim_id_mlv   := usim_spc.get_id_mlv(p_usim_id_spc);
      p_usim_id_rmd   := usim_spc.get_id_rmd(p_usim_id_spc);
      p_usim_sign     := usim_spc.get_dim_sign(p_usim_id_spc);
      p_usim_n1_sign  := usim_spc.get_dim_n1_sign(p_usim_id_spc);
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_dbif.get_spc_dim_details', 'Not existing space id [' || p_usim_id_spc || '].');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_spc_dim_details', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_spc_dim_details
  ;

  FUNCTION get_abs_max_number
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_base.get_abs_max_number;
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_abs_max_number', 'Base data not initialized.');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_abs_max_number', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_abs_max_number
  ;

  FUNCTION get_dim_coord( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_result usim_position.usim_coordinate%TYPE;
  BEGIN
    l_result := usim_spo.get_dim_coord(p_usim_id_spc, p_usim_n_dimension);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_dim_coord', 'Invalid space id [' || p_usim_id_spc || '] or dimension [' || p_usim_n_dimension || '].');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_dim_coord', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_dim_coord
  ;

  FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_dimension.usim_n_dimension%TYPE
  IS
    l_result usim_dimension.usim_n_dimension%TYPE;
  BEGIN
    l_result := usim_spc.get_dimension(p_usim_id_spc);
    IF l_result = -1
    THEN
      usim_erl.log_error('usim_dbif.get_dimension', 'Invalid space id [' || p_usim_id_spc || '].');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_dimension', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_dimension
  ;

  FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_sign%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_sign%TYPE;
  BEGIN
    l_result := usim_spc.get_dim_sign(p_usim_id_spc);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_dim_sign', 'Invalid space id [' || p_usim_id_spc || '].');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_dim_sign', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_dim_sign
  ;

  FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
  IS
    l_result usim_rel_mlv_dim.usim_n1_sign%TYPE;
  BEGIN
    l_result := usim_spc.get_dim_n1_sign(p_usim_id_spc);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_dim_n1_sign', 'Invalid space id [' || p_usim_id_spc || '].');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_dim_n1_sign', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_dim_n1_sign
  ;

  FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  IS
    l_result VARCHAR2(32000);
  BEGIN
    l_result := usim_spo.get_xyz(p_usim_id_spc);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_xyz', 'Invalid space id [' || p_usim_id_spc || '].');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_xyz', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_xyz
  ;

  FUNCTION get_magnitude( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
                        , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                        )
    RETURN NUMBER
  IS
    l_result  NUMBER;
  BEGIN
    l_result := usim_spo.get_magnitude(p_usim_id_spc, p_usim_n_dimension);
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_magnitude', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_magnitude
  ;

  FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_process_spin%TYPE
  IS
    l_result usim_space.usim_process_spin%TYPE;
  BEGIN
    l_result := usim_spc.get_process_spin(p_usim_id_spc);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_process_spin', 'Used with invalid space id [' || p_usim_id_spc || '].');
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_process_spin', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_process_spin
  ;

  FUNCTION get_universe_state_desc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN VARCHAR2
  IS
    l_mlv_id    usim_multiverse.usim_id_mlv%TYPE;
    l_state     usim_multiverse.usim_universe_status%TYPE;
    l_result    VARCHAR2(8);
  BEGIN
    -- get universe
    l_mlv_id := usim_spc.get_id_mlv(p_usim_id_spc);
    IF l_mlv_id IS NULL
    THEN
      RETURN 'UNKNOWN';
    END IF;
    l_state  := usim_mlv.get_state(l_mlv_id);
    l_result := usim_static.get_multiverse_status(l_state);
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_universe_state_desc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_universe_state_desc
  ;

  FUNCTION get_planck_time_current
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_base.get_planck_time_current;
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_planck_time_current', 'Planck time not initialized.');
      usim_dbif.set_crashed;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_planck_time_current', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_planck_time_current
  ;

  FUNCTION get_planck_aeon_seq_current
    RETURN VARCHAR2
  IS
    l_result CHAR(55);
  BEGIN
    l_result := usim_base.get_planck_aeon_seq_current;
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_planck_aeon_seq_current', 'Planck aeon not initialized.');
      usim_dbif.set_crashed;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_planck_aeon_seq_current', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_planck_aeon_seq_current
  ;

  FUNCTION get_planck_time_next
    RETURN NUMBER
  IS
    l_result NUMBER;
  BEGIN
    l_result := usim_base.get_planck_time_next;
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_dbif.get_planck_time_next', 'Planck time initialization error.');
      usim_dbif.set_crashed;
    END IF;
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_planck_time_next', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_planck_time_next
  ;

  FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
                                 , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
                                 )
    RETURN NUMBER
  IS
    l_return NUMBER;
  BEGIN
    l_return := usim_spr.get_unprocessed_planck(p_usim_planck_aeon, p_usim_planck_time);
    RETURN l_return;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_unprocessed_planck', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_unprocessed_planck
  ;

  FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_space.usim_id_spc%TYPE
  IS
    l_result usim_space.usim_id_spc%TYPE;
  BEGIN
    l_result := usim_spo.get_axis_max_pos_parent(p_usim_id_spc);
    RETURN l_result;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_axis_max_pos_parent', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_axis_max_pos_parent
  ;

  FUNCTION get_axis_max_pos_dim1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN usim_position.usim_coordinate%TYPE
  IS
    l_id_mlv  usim_multiverse.usim_id_mlv%TYPE;
    l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
    l_id_spc  usim_space.usim_id_spc%TYPE;
    l_parent  usim_space.usim_id_spc%TYPE;
    l_max_pos usim_position.usim_coordinate%TYPE;
  BEGIN
    l_id_mlv  := usim_spc.get_id_mlv(p_usim_id_spc);
    l_n1_sign := usim_spc.get_dim_n1_sign(p_usim_id_spc);
    IF usim_spc.get_cur_max_dim_n1(p_usim_id_spc) > 0
    THEN
      -- get dimension 1 by universe parent
      WITH rmd AS
           (SELECT usim_id_rmd
              FROM usim_rmd_v
             WHERE usim_id_mlv = l_id_mlv
               AND usim_n_dimension = 0
           )
         , spc AS
           (SELECT spcv.usim_id_spc
              FROM usim_spc_v spcv
             INNER JOIN rmd
                ON spcv.usim_id_rmd = rmd.usim_id_rmd
           )
      SELECT chiv.usim_id_spc_child
        INTO l_id_spc
        FROM usim_chi_v chiv
       INNER JOIN spc
          ON chiv.usim_id_spc = spc.usim_id_spc
       WHERE child_dim_n1_sign = l_n1_sign
      ;
      l_parent  := usim_spo.get_axis_max_pos_parent(l_id_spc);
      IF l_parent IS NULL
      THEN
        usim_erl.log_error('usim_dbif.get_axis_max_pos_dim1', 'Could not get max axis dimension 1 coordinate for [' || p_usim_id_spc || '] axis 1 pos 0 id [' || l_id_spc || '].');
        usim_dbif.set_crashed;
      END IF;
      l_max_pos := usim_spc.get_coordinate(l_parent);
      IF l_max_pos IS NULL
      THEN
        usim_erl.log_error('usim_dbif.get_axis_max_pos_dim1', 'Could not get max coordinate for [' || p_usim_id_spc || '] max pos space id [' || l_parent || '].');
        usim_dbif.set_crashed;
      END IF;
      RETURN l_max_pos;
    ELSE
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_axis_max_pos_dim1', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_axis_max_pos_dim1
  ;

  FUNCTION get_next_pos_on_axis( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                               , p_usim_id_pos OUT usim_position.usim_id_pos%TYPE
                               , p_usim_id_rmd OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
                               )
    RETURN NUMBER
  IS
    l_new_pos NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      -- determine the sign of the coordinate by dim sign
      IF usim_spc.get_dim_sign(p_usim_id_spc) = 1
      THEN
        l_new_pos := usim_spc.get_coordinate(p_usim_id_spc) + 1;
      ELSE
        l_new_pos := usim_spc.get_coordinate(p_usim_id_spc) - 1;
      END IF;
      p_usim_id_pos := usim_pos.get_id_pos(l_new_pos);
      p_usim_id_rmd := usim_spc.get_id_rmd(p_usim_id_spc);
      RETURN 1;
    ELSE
      usim_erl.log_error('usim_dbif.get_next_pos_on_axis', 'Invalid space id [' || p_usim_id_spc || '].');
      RETURN 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.get_next_pos_on_axis', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END get_next_pos_on_axis
  ;

  FUNCTION overflow_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    -- do we have overflow on dimensions and positions
    IF      usim_dbif.is_overflow_dim_spc(p_usim_id_spc) = 1
       AND  usim_dbif.is_overflow_pos_spc(p_usim_id_spc) = 1
    THEN
      -- total overflow, no possible dimension or position open
      RETURN 0;
    ELSIF usim_dbif.max_childs(p_usim_id_spc) = usim_dbif.child_count(p_usim_id_spc)
    THEN
      -- total overflow, all possible childs connected
      RETURN 0;
    ELSIF usim_dbif.is_overflow_pos_spc(p_usim_id_spc) = 1
    THEN
      -- position overflow
      RETURN 2;
    ELSIF usim_dbif.is_overflow_dim_spc(p_usim_id_spc) = 1
    THEN
      -- dimension overflow
      RETURN 3;
    ELSE
      -- no overflow
      RETURN 1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.overflow_rating', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END overflow_rating
  ;

  FUNCTION dimension_rating( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                           , p_max_childs  OUT NUMBER
                           )
    RETURN NUMBER
  IS
    l_return       NUMBER;
    l_count        NUMBER;
    l_max_dim      NUMBER;
    l_usim_id_rmd  usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_usim_id_pos  usim_position.usim_id_pos%TYPE;
    l_usim_id_nod  usim_node.usim_id_nod%TYPE;
    l_process_spin usim_space.usim_process_spin%TYPE;
    l_usim_id_mlv  usim_multiverse.usim_id_mlv%TYPE;
    l_n_dimension  usim_dimension.usim_n_dimension%TYPE;
    l_dim_sign     usim_rel_mlv_dim.usim_sign%TYPE;
    l_dim_n1_sign  usim_rel_mlv_dim.usim_n1_sign%TYPE;
    l_coordinate   usim_position.usim_coordinate%TYPE;
    l_is_base      usim_multiverse.usim_is_base_universe%TYPE;
    l_energy       usim_node.usim_energy%TYPE;
   BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      -- get details
      l_return := usim_spc.get_spc_details( p_usim_id_spc
                                          , l_usim_id_rmd
                                          , l_usim_id_pos
                                          , l_usim_id_nod
                                          , l_process_spin
                                          , l_usim_id_mlv
                                          , l_n_dimension
                                          , l_dim_sign
                                          , l_dim_n1_sign
                                          , l_coordinate
                                          , l_is_base
                                          , l_energy
                                          )
      ;
      IF l_return = 0
      THEN
        usim_erl.log_error('usim_dbif.dimension_rating', 'Failed to get details for space id [' || p_usim_id_spc || '].');
        RETURN -1;
      END IF;
      IF     l_n_dimension = 0
         AND l_coordinate  = 0
      THEN
        -- only 2 special childs with opposite energy output sign possible
        p_max_childs := 2;
        RETURN 0;
      END IF;
      l_max_dim := NVL(usim_spc.get_cur_max_dim_n1(p_usim_id_spc), 0) + 1;
      IF usim_base.get_max_dimension < l_max_dim
      THEN
        l_max_dim := usim_base.get_max_dimension;
      END IF;
      IF     l_n_dimension = 1
         AND l_coordinate  = 0
      THEN
        -- zero pos dimension axis at dimension 1
        -- all dimension axis and position on dimension axis: (max n - n) x 2 + 1 axis child
        p_max_childs := ((l_max_dim - l_n_dimension) * 2) + 1;
        RETURN 1;
      END IF;
      IF     l_n_dimension > 1
         AND l_coordinate  = 0
      THEN
        -- zero pos dimension axis dimension > 1
        -- only position on dimension axis and 1 inbetween node: 2 childs
        p_max_childs := 2;
        RETURN 2;
      END IF;
      -- count coordinates not 0 for space id
      SELECT COUNT(*) INTO l_count FROM usim_spo_v WHERE usim_id_spc = p_usim_id_spc AND usim_coordinate != 0;
      IF     l_count       = 1
         AND l_coordinate != 0
      THEN
        -- pure dimension axis, possible childs: (max n - n) + 1 axis child
        p_max_childs := (l_max_dim  - l_n_dimension) + 1;
        RETURN 3;
      ELSE
        -- anywhere, possible childs: max n
        p_max_childs := l_max_dim;
        RETURN 4;
      END IF;
    ELSE
      usim_erl.log_error('usim_dbif.dimension_rating', 'Invalid space id [' || p_usim_id_spc || '].');
      RETURN -1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.dimension_rating', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END dimension_rating
  ;

  FUNCTION dimension_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_max_childs NUMBER;
    l_rating     NUMBER;
  BEGIN
    l_rating := usim_dbif.dimension_rating(p_usim_id_spc, l_max_childs);
    RETURN l_rating;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.dimension_rating', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END dimension_rating
  ;

  FUNCTION max_childs(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_max_childs NUMBER;
    l_rating     NUMBER;
  BEGIN
    l_rating := usim_dbif.dimension_rating(p_usim_id_spc, l_max_childs);
    RETURN l_max_childs;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.max_childs', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END max_childs
  ;

  FUNCTION classify_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_count        NUMBER;
    l_return       NUMBER;
    l_dim_rating   NUMBER;
    l_parent_count NUMBER;
    l_child_count  NUMBER;
    l_connections  NUMBER;
    l_max_dim      NUMBER;
    l_max_child    NUMBER;
    l_dimension    NUMBER;
    l_max_pos      NUMBER;
    l_has_n1       NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 0
    THEN
      RETURN -1;
    END IF;
    -- get details
    l_dim_rating := usim_dbif.dimension_rating(p_usim_id_spc, l_max_child);
    IF l_dim_rating = -1
    THEN
      usim_erl.log_error('usim_dbif.classify_parent', 'Failed to get a dimension rating for space id [' || p_usim_id_spc || '].');
      RETURN -1;
    END IF;
    -- ignore errors like no child or parent, we get values anyway
    l_return      := usim_chi.get_chi_details(p_usim_id_spc, l_parent_count, l_child_count);
    IF l_dim_rating = 0 -- center of a universe dimension
    THEN
      -- no more childs possible
      IF l_child_count = l_max_child
      THEN
        -- fully connected
        RETURN 0;
      ELSE
        -- only next dimension possible
        RETURN 2;
      END IF;
    ELSIF l_dim_rating = 1 -- center dimension axis with pos 0 dimension > 0
    THEN
      -- only 2 childs possible
      IF l_child_count = l_max_child
      THEN
        -- fully connected
        RETURN 0;
      ELSE
        IF l_child_count > 0
        THEN
          -- find free node
          IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
          THEN
            -- if the position number on x axis that equals next dimension does not exist only position on X axis possible
            l_dimension := usim_spc.get_dimension(p_usim_id_spc) + 1;
            l_max_pos := ABS(NVL(usim_spc.get_coordinate(usim_spo.get_axis_max_pos_parent(p_usim_id_spc)), 1));
            IF l_max_pos >= l_dimension
            THEN
              -- only next dimension possible
              RETURN 2;
            ELSE
              -- first extend dimension axis
              RETURN 4;
            END IF;
          ELSE
            -- position or dimension (not checking upper dimensions available)
            RETURN 1;
          END IF;
        ELSE
          -- no childs at all
          -- position or dimension (not checking upper dimensions available)
          RETURN 1;
        END IF;
      END IF;
    ELSIF l_dim_rating = 2 -- on dimension axis pos > 0
    THEN
      IF l_child_count = l_max_child
      THEN
        -- fully connected
        RETURN 0;
      ELSE
        -- find free node
        IF l_child_count > 0
        THEN
          IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
          THEN
            -- only next dimension possible
            RETURN 2;
          ELSE
            -- position or dimension (not checking upper dimensions available)
            RETURN 1;
          END IF;
        ELSE
          -- position or dimension (not checking upper dimensions available)
          RETURN 1;
        END IF;
      END IF;
    ELSE -- everywhere else
      IF l_child_count = l_max_child
      THEN
        -- fully connected
        RETURN 0;
      ELSE
        IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
        THEN
          -- only next dimension possible
          RETURN 2;
        ELSE
          -- position or dimension (not checking upper dimensions available)
          RETURN 1;
        END IF;
      END IF;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.classify_parent', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END classify_parent
  ;

  FUNCTION classify_escape(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
    l_parent_classification NUMBER;
    l_max_dim               NUMBER;
    l_max_cur_dim           NUMBER;
    l_max_pos               NUMBER;
    l_max_cur_pos           NUMBER;
    l_max_n1_pos            NUMBER;
    l_max_childs            NUMBER;
    l_childs                NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 1
    THEN
      l_max_dim               := usim_base.get_max_dimension;
      l_max_pos               := usim_base.get_abs_max_number;
      l_max_cur_dim           := usim_spc.get_cur_max_dim_n1(p_usim_id_spc);
      l_max_cur_pos           := usim_spc.get_cur_max_pos(p_usim_id_spc);
      l_max_childs            := usim_dbif.max_childs(p_usim_id_spc);
      l_childs                := usim_dbif.child_count(p_usim_id_spc);
      l_parent_classification := usim_dbif.classify_parent(p_usim_id_spc);
      l_max_n1_pos            := ABS(usim_dbif.get_axis_max_pos_dim1(p_usim_id_spc));

      -- check all classifications against all kinds of overflow
      IF l_parent_classification < 0
      THEN
        -- classification error, we should stop here
        usim_erl.log_error('usim_dbif.classify_escape', 'Classification error parent on id [' || p_usim_id_spc || '].');
        usim_dbif.set_crashed;
        RETURN -1;
      ELSIF l_parent_classification = 0
      THEN
        RETURN l_parent_classification;
      ELSIF l_parent_classification = 1
      THEN
        -- check if dimension and positions are over the max for n1 side of space node
        IF     l_max_cur_dim  < l_max_dim
           AND l_max_cur_pos  < l_max_pos
           AND l_max_n1_pos  >= l_max_cur_dim
        THEN
          -- everything available
          RETURN l_parent_classification;
        ELSIF     l_max_cur_dim  < l_max_dim
              AND l_max_n1_pos  >= l_max_cur_dim
        THEN
          -- only dimensions available
          RETURN 2;
        ELSIF     l_max_cur_dim < l_max_dim
              AND l_max_n1_pos  < l_max_cur_dim
        THEN
          IF usim_dbif.has_free_between(p_usim_id_spc) = 1
          THEN
            -- prefer filling between nodes
            RETURN 7;
          ELSE
            -- only position dim axis 1 delegate available
            RETURN 6;
          END IF;
        ELSIF l_max_cur_pos < l_max_pos
        THEN
          -- only positions available
          RETURN 3;
        -- full only new universe or delegate between
        ELSIF usim_dbif.has_free_between(p_usim_id_spc) = 1
        THEN
            -- delegate between
            RETURN 7;
        ELSE
          -- no delegate options
          RETURN 0;
        END IF;
      ELSIF l_parent_classification = 2
      THEN
        -- check
        IF     l_max_cur_dim  < l_max_dim
           AND l_max_n1_pos  >= l_max_cur_dim
        THEN
          -- everything available
          RETURN l_parent_classification;
        ELSIF     l_max_cur_dim < l_max_dim
              AND l_max_n1_pos  < l_max_cur_dim
        THEN
          IF usim_dbif.has_free_between(p_usim_id_spc) = 1
          THEN
            -- prefer filling between nodes
            RETURN 7;
          ELSE
            -- only position dim axis 1 delegate available
            RETURN 6;
          END IF;
        -- full only new universe or delegate
        ELSIF     l_max_cur_pos                             < l_max_pos
              AND usim_dbif.has_free_between(p_usim_id_spc) = 0
        THEN
          -- delegate position, if no between nodes are free
          RETURN 5;
        ELSIF usim_dbif.has_free_between(p_usim_id_spc) = 1
        THEN
          -- delegate between
          RETURN 7;
        ELSE
          -- no delegate options
          RETURN 0;
        END IF;
      ELSIF l_parent_classification IN (3, 4)
      THEN
        -- check
        IF l_max_cur_pos < l_max_pos
        THEN
          -- everything available
          RETURN l_parent_classification;
        -- full only new universe or delegate
        ELSIF     l_parent_classification                   = 4
              AND usim_dbif.has_free_between(p_usim_id_spc) = 0
        THEN
          RETURN l_parent_classification;
        ELSIF     l_max_cur_dim                             < l_max_dim
              AND usim_dbif.has_free_between(p_usim_id_spc) = 0
        THEN
          -- delegate new dimension, if no between nodes are free
          RETURN 4;
        ELSIF usim_dbif.has_free_between(p_usim_id_spc) = 1
        THEN
          -- delegate between
          RETURN 7;
        ELSE
          -- no delegate options
          RETURN 0;
        END IF;
      ELSE
        -- classification unknown
        usim_erl.log_error('usim_dbif.classify_escape', 'Unknown parent classfication [' || l_parent_classification || '] for id [' || p_usim_id_spc || '].');
        usim_dbif.set_crashed;
        RETURN -1;
      END IF;
    ELSE
      RETURN -1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_dbif.classify_escape', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END classify_escape
  ;

  FUNCTION get_dim_G( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
                    , p_node_G      OUT NUMBER
                    )
    RETURN NUMBER
  IS
    l_dimension   usim_dimension.usim_n_dimension%TYPE;
    l_G           NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 0
    THEN
      usim_erl.log_error('usim_process.get_dim_G', 'Used with invalid space id [' || p_usim_id_spc || '].');
      RETURN -1;
    END IF;
    l_dimension := usim_spc.get_dimension(p_usim_id_spc);
    IF l_dimension = -1
    THEN
      usim_erl.log_error('usim_process.get_dim_G', 'Failed to get_dimension for space id [' || p_usim_id_spc || '].');
      RETURN -1;
    END IF;
    l_G := usim_maths.calc_dim_G(l_dimension);
    IF usim_base.num_has_overflow(l_G) = 1
    THEN
      usim_erl.log_error('usim_dbif.get_dim_G', 'Numerical overflow for l_G[' || l_G || '] overflow [' || usim_base.get_abs_max_number || ',-' || usim_base.get_abs_max_number || '] underflow[' || usim_base.get_max_underflow || ',' || usim_base.get_min_underflow || '].');
      RETURN 0;
    ELSE
      -- only set out value if valid value
      p_node_G := l_G;
      RETURN 1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
      THEN
        -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
        -- -1487: packed decimal number too large
        usim_erl.log_error('usim_dbif.get_dim_G', 'Numerical error on G calculate [' || SQLCODE || '] error message: ' || SQLERRM);
        RETURN 0;
      ELSE
        usim_erl.log_error('usim_dbif.get_dim_G', 'Unknown error [' || SQLCODE || '] error message: ' || SQLERRM);
        -- try to set all to crashed
        usim_dbif.set_crashed;
        -- return -1 handling is up to caller
        RETURN -1;
      END IF;
  END get_dim_G
  ;

  FUNCTION get_outer_planck_r( p_usim_id_spc    IN  usim_space.usim_id_spc%TYPE
                             , p_outer_planck_r OUT NUMBER
                             )
    RETURN NUMBER
  IS
    l_planck_length NUMBER;
    l_radius        NUMBER;
  BEGIN
    IF usim_spc.has_data(p_usim_id_spc) = 0
    THEN
      usim_erl.log_error('usim_process.get_dim_G', 'Used with invalid space id [' || p_usim_id_spc || '].');
      RETURN -1;
    END IF;
    SELECT usim_planck_length_unit
      INTO l_planck_length
      FROM usim_spc_v
     WHERE usim_id_spc = p_usim_id_spc
    ;
    l_radius := usim_maths.apply_planck(1, l_planck_length);
    IF usim_base.num_has_overflow(l_radius) = 1
    THEN
      usim_erl.log_error('usim_dbif.get_outer_planck_r', 'Numerical overflow for l_radius[' || l_radius || '] overflow [' || usim_base.get_abs_max_number || ',-' || usim_base.get_abs_max_number || '] underflow[' || usim_base.get_max_underflow || ',' || usim_base.get_min_underflow || '].');
      RETURN 0;
    ELSE
      -- only set out value if valid value
      p_outer_planck_r := l_radius;
      RETURN 1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
      THEN
        -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
        -- -1487: packed decimal number too large
        usim_erl.log_error('usim_dbif.get_outer_planck_r', 'Numerical error on outer planck r calculation [' || SQLCODE || '] error message: ' || SQLERRM);
        RETURN 0;
      ELSE
        usim_erl.log_error('usim_process.get_outer_planck_r', 'Unknown error [' || SQLCODE || '] error message: ' || SQLERRM);
        -- try to set all to crashed
        usim_dbif.set_crashed;
        -- return -1 handling is up to caller
        RETURN -1;
      END IF;
  END get_outer_planck_r
  ;

  FUNCTION get_acceleration( p_energy         IN  NUMBER
                           , p_radius         IN  NUMBER
                           , p_G              IN  NUMBER
                           , p_target_energy  OUT NUMBER
                           )
    RETURN NUMBER
  IS
    l_energy NUMBER;
  BEGIN
    l_energy := usim_maths.calc_planck_a2(p_energy, p_radius, p_G);
    IF usim_base.num_has_overflow(l_energy) = 1
    THEN
      usim_debug.debug_log('usim_dbif.get_acceleration', 'Numerical overflow for l_energy[' || l_energy || '] overflow [' || usim_base.get_abs_max_number || ',-' || usim_base.get_abs_max_number || '] underflow[' || usim_base.get_max_underflow || ',' || usim_base.get_min_underflow || '].');
      RETURN 0;
    ELSE
      -- only set out value if valid value
      p_target_energy := l_energy;
      RETURN 1;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
      THEN
        -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
        -- -1487: packed decimal number too large
        usim_debug.debug_log('usim_dbif.get_acceleration', 'Numerical error on acceleration calculation [' || SQLCODE || '] error message: ' || SQLERRM);
        RETURN 0;
      ELSE
        usim_erl.log_error('usim_process.get_acceleration', 'Unknown error [' || SQLCODE || '] error message: ' || SQLERRM);
        -- try to set all to crashed
        usim_dbif.set_crashed;
        -- return -1 handling is up to caller
        RETURN -1;
      END IF;
  END get_acceleration
  ;

END usim_dbif;

Package Body USIM_DBIF kompiliert

SQL> --== interface package end ==--
SQL>
SQL> --== processing packages start ==--
SQL> @@../PACKAGES/USIM_CREATOR.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_creator
  2  IS
  3    /**A package providing creator function on objects needed */
  4
  5    /**
  6    * Writes a given CLOB with JSON data to the given filename with extension .json in directory USIM_DIR. Copies existing files
  7    * to the directory USIM_HIST_DIR and renames them to [filename]_YYYYMMDDHH24MISS.json.
  8    * @param p_json_clob The JSON formatted CLOB to write to [p_filename].json.
  9    * @param p_filename The filename for the JSON file to write. Do not use special chars and spaces. Lenght limited to 100.
 10    * @return Return 1 if file was written, 0 on errors.
 11    */
 12    FUNCTION write_json_file( p_json_clob IN CLOB
 13                            , p_filename  IN VARCHAR2 DEFAULT 'usim_space_log'
 14                            )
 15      RETURN NUMBER
 16    ;
 17
 18    /**
 19    * Builds a JSON representation of the USIM_SPC_PROCESS content for the given range. If size too long for JS P5 limit the size by choosen range.
 20    * Will also create an assoziated structure.
 21    * @param p_planck_aeon The valid planck time aeon for the log.
 22    * @param p_from_planck_time The valid planck time tick for start of log.
 23    * @param p_to_planck_time The valid planck time tick for end of log.
 24    * @param p_json_log The JSON formatted log chunk as CLOB.
 25    * @return Return 1 if log was completely delivered or -1 on errors.
 26    */
 27    FUNCTION get_json_log( p_planck_aeon      IN     usim_spc_process.usim_planck_aeon%TYPE
 28                         , p_from_planck_time IN     usim_spc_process.usim_planck_time%TYPE
 29                         , p_to_planck_time   IN     usim_spc_process.usim_planck_time%TYPE
 30                         , p_json_log            OUT CLOB
 31                         )
 32      RETURN NUMBER
 33    ;
 34
 35    /**
 36    * Builds a JSON representation of the USIM_SPACE content in means of coordinates and child relations for all
 37    * existing universes. No limitation in size. The given aeon and from to ticks will only mark current log content range
 38    * as active for display from the first tick they occured in the log. Structure will not know current energy of node.
 39    * @param p_planck_aeon The valid planck time aeon for the log to mark node as active.
 40    * @param p_from_planck_time The valid planck time tick for start of log to mark node as active.
 41    * @param p_to_planck_time The valid planck time tick for end of log to mark node as active.
 42    * @param p_json_struct The JSON formatted structure chunk as CLOB.
 43    * @return Return 1 if structure was completely delivered or -1 on errors.
 44    */
 45    FUNCTION get_json_struct( p_planck_aeon      IN     usim_spc_process.usim_planck_aeon%TYPE
 46                            , p_from_planck_time IN     usim_spc_process.usim_planck_time%TYPE
 47                            , p_to_planck_time   IN     usim_spc_process.usim_planck_time%TYPE
 48                            , p_json_struct         OUT CLOB
 49                            )
 50      RETURN NUMBER
 51    ;
 52
 53    /**
 54    * Writes a space structure file in JSON format. The name of the file is fixed to usim_space_struct.json.
 55    * The file is written to the directory USIM_DIR. If a file already exists, it is copied before to the directory
 56    * USIM_HIST_DIR and renamed to a unique file name by current date extension. The given aeon and from to ticks will only mark current log content range
 57    * as active for display from the first tick they occured in the log. Structure will not know current energy of node.
 58    * As the structure for all existing universes is build, the file may get too big for JS P5. Row Order:</br>
 59    * 0:from x, 1:from y, 2:from z, 3:from dimension, 4:from dim sign, 5:from n1 sign, 6:first from tick active, 7:to x, 8:to y, 9:to z, 10:to dimension, 11:to dim sign, 12:to n1 sign, 13:first to tick active</br>
 60    * @param p_planck_aeon The valid planck time aeon for the log to mark node as active or ignored.
 61    * @param p_from_planck_time The valid planck time tick for start of log to mark node as active or ignored.
 62    * @param p_to_planck_time The valid planck time tick for end of log to mark node as active or ignored.
 63    * @return Return 1 if operation was successful otherwise 0.
 64    */
 65    FUNCTION create_json_struct( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
 66                               , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
 67                               , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
 68                               )
 69      RETURN NUMBER
 70    ;
 71
 72    /**
 73    * Writes a space log file in JSON format. The name of the file is fixed to usim_space_log.json. The file is written to the directory USIM_DIR.
 74    * If a file already exists, it is copied before to the directory USIM_HIST_DIR and renamed to a unique file name by
 75    * current date extension. Only one planck aeon supported. Will create also an associated structure, where log content is marked as active in
 76    * the created structure. To keep space as low as possible an array structure is used per row. Order:</br>
 77    * 0:from x, 1:from y, 2:from z, 3:from dimension, 4:from dim sign, 5:from n1 sign, 6:from energy, 7:to x, 8:to y, 9:to z, 10:to dimension, 11:to dim sign, 12:to n1 sign, 13:to energy, 14:output energy</br>
 78    * @param p_planck_aeon The planck time aeon for of the log. If NULL, p_from_planck_time is ignored and log starts with current aeon.
 79    * @param p_from_planck_time The planck time tick for start of log. Ignored if p_from_planck_aeon is NULL using first planck time tick in aeon given or found.
 80    * @param p_to_planck_time The planck time tick for end of log. if NULL, log contains every record of USIM_SPC_PROCESS for aeon given or found.
 81    * @return Return 1 if operation was successful otherwise 0.
 82    */
 83    FUNCTION create_space_log( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
 84                             , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
 85                             , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
 86                             )
 87      RETURN NUMBER
 88    ;
 89
 90    FUNCTION create_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 91      RETURN NUMBER
 92    ;
 93
 94    /**
 95    * Retrieves the dimension id for a given dimension and creates necessary dimensions, if they
 96    * do not exist. Given dimension must be within the base data limits.
 97    * @param p_usim_n_dimension The dimension to verify.
 98    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 99    * @return The dimension id for given dimension or NULL if error or base data are not available.
100    */
101    FUNCTION init_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
102                           , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
103                           )
104      RETURN usim_dimension.usim_id_dim%TYPE
105    ;
106
107    /**
108    * Retrieves the universe dimension axis id for a given universe and dimension id. Creates necessary dimension axis, if it
109    * does not exist.
110    * @param p_usim_id_mlv The universe id for the dimension axis.
111    * @param p_usim_id_dim The dimension id for the dimension axis.
112    * @param p_usim_sign The sign of the dimension axis.
113    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
114    * @return The rmd id of the dimension axis or NULL if error or base data are not available.
115    */
116    FUNCTION init_dim_axis( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
117                          , p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE
118                          , p_usim_sign   IN usim_rel_mlv_dim.usim_sign%TYPE
119                          , p_do_commit   IN BOOLEAN                          DEFAULT TRUE
120                          )
121      RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
122    ;
123
124    /**
125    * Verifies that dimension and dimension axis exist for the given universe. Creates all necessary objects.
126    * @param p_usim_id_mlv The universe id for the dimension.
127    * @param p_usim_n_dimension The dimension to verify.
128    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
129    * @return Return 1 if all was successfully verified or created otherwise 0.
130    */
131    FUNCTION init_dim_all( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
132                         , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
133                         , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
134                         )
135      RETURN NUMBER
136    ;
137
138    /**
139    * Verifies that a zero position has all connected space nodes. Creates all necessary objects.
140    * Positions are set (0, 1, -1) and connections are defined.
141    * @param p_usim_id_mlv The universe id for the space nodes. Mandatory.
142    * @param p_usim_id_spc_parent The parent space node with position 0 and dimension one lower than the given dimension. Mandatory.
143    * @param p_usim_n_dimension The dimension to use. Given dimension must be one greater than parent dimension. Mandatory.
144    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
145    * @return Return 1 if all was successfully verified or created otherwise 0.
146    */
147    FUNCTION init_zero_dim_nodes( p_usim_id_mlv        IN usim_multiverse.usim_id_mlv%TYPE
148                                , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
149                                , p_usim_n_dimension   IN usim_dimension.usim_n_dimension%TYPE
150                                , p_do_commit          IN BOOLEAN                              DEFAULT TRUE
151                                )
152      RETURN NUMBER
153    ;
154
155    /**
156    * Creates a universe, with a basic position coordinate 0, dimension 0 and node for it. If first universe, it will be the base universe. Will
157    * create also the basic connections to dimension 1 with positions +0/-0 and +1/-1 for both dimension axis.
158    * Will only commit changes (if p_do_commit is TRUE) if all steps have been executed without errors. On errors always a rollback is executed.
159    * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used and default if NULL or 0.
160    * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value and default if NULL or 0.
161    * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value and default if NULL or 0.
162    * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value and default if NULL or 0.
163    * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct.
164    * @param p_usim_ultimate_border The energy flow rule for ultimate border (1) or any dimension border (0). NULL is interpreted as 1.
165    * @param p_usim_id_spc_parent The usim_space id of the node, that is the parent of this universe. Ignored, if universe is base universe. Mandatory for non-base universes.
166    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
167    * @return The new usim_space id for dimension 0 or NULL if error or base data / mandatory parent in populated universe are not available.
168    */
169    FUNCTION create_new_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
170                                , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
171                                , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
172                                , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
173                                , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
174                                , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
175                                , p_usim_id_spc_parent      IN usim_space.usim_id_spc%TYPE                  DEFAULT NULL
176                                , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
177                                )
178      RETURN usim_space.usim_id_spc%TYPE
179    ;
180
181    /**
182    * In case of dimension overflow either a new node is created, if a higher free dimension is available
183    * or the creation of a new dimension with pos 0 and 1 is triggered.
184    * @param p_usim_id_spc The space node id causing the overflow.
185    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
186    * @return Returns 1 on success or 0 on errors.
187    */
188    FUNCTION handle_overflow_dim( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
189                                , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
190                                )
191      RETURN NUMBER
192    ;
193
194    /**
195    * Creates a new node in case of position overflow. Will add a new position on the axis the
196    * given node is. Depends on correct identified escape strategy (3, 4) which imply the creation
197    * of a new position. Will only accept nodes that are either 0 coordinate on the dimension axis or
198    * nodes that have no child in current dimension.
199    * @param p_usim_id_spc The space node id causing the overflow.
200    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
201    * @return Returns 1 on success or 0 on errors.
202    */
203    FUNCTION handle_overflow_pos( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
204                                , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
205                                )
206      RETURN NUMBER
207    ;
208
209    /**
210    * Creates a new node in case of between node is needed. Between nodes are filled from bottom up.
211    * @param p_usim_id_spc The space node id causing the overflow.
212    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
213    * @return Returns 1 on success or 0 on errors.
214    */
215    FUNCTION handle_overflow_between( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
216                                    , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
217                                    )
218      RETURN NUMBER
219    ;
220
221    /**
222    * Main hub to handle overflow situations. Depending on escape classify an appropriate
223    * action is executed. Will create necessary space nodes for positions, dimensions or universes.
224    * @param p_usim_id_spc The usim_space id causing the overflow.
225    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
226    * @return Returns 1 if overflow could be handled otherwise 0.
227    */
228    FUNCTION handle_overflow( p_usim_id_spc   IN usim_space.usim_id_spc%TYPE
229                            , p_do_commit     IN BOOLEAN                     DEFAULT TRUE
230                            )
231      RETURN NUMBER
232    ;
233
234  END usim_creator;
235  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_creator
IS
  /**A package providing creator function on objects needed */

  /**
  * Writes a given CLOB with JSON data to the given filename with extension .json in directory USIM_DIR. Copies existing files
  * to the directory USIM_HIST_DIR and renames them to [filename]_YYYYMMDDHH24MISS.json.
  * @param p_json_clob The JSON formatted CLOB to write to [p_filename].json.
  * @param p_filename The filename for the JSON file to write. Do not use special chars and spaces. Lenght limited to 100.
  * @return Return 1 if file was written, 0 on errors.
  */
  FUNCTION write_json_file( p_json_clob IN CLOB
                          , p_filename  IN VARCHAR2 DEFAULT 'usim_space_log'
                          )
    RETURN NUMBER
  ;

  /**
  * Builds a JSON representation of the USIM_SPC_PROCESS content for the given range. If size too long for JS P5 limit the size by choosen range.
  * Will also create an assoziated structure.
  * @param p_planck_aeon The valid planck time aeon for the log.
  * @param p_from_planck_time The valid planck time tick for start of log.
  * @param p_to_planck_time The valid planck time tick for end of log.
  * @param p_json_log The JSON formatted log chunk as CLOB.
  * @return Return 1 if log was completely delivered or -1 on errors.
  */
  FUNCTION get_json_log( p_planck_aeon      IN     usim_spc_process.usim_planck_aeon%TYPE
                       , p_from_planck_time IN     usim_spc_process.usim_planck_time%TYPE
                       , p_to_planck_time   IN     usim_spc_process.usim_planck_time%TYPE
                       , p_json_log            OUT CLOB
                       )
    RETURN NUMBER
  ;

  /**
  * Builds a JSON representation of the USIM_SPACE content in means of coordinates and child relations for all
  * existing universes. No limitation in size. The given aeon and from to ticks will only mark current log content range
  * as active for display from the first tick they occured in the log. Structure will not know current energy of node.
  * @param p_planck_aeon The valid planck time aeon for the log to mark node as active.
  * @param p_from_planck_time The valid planck time tick for start of log to mark node as active.
  * @param p_to_planck_time The valid planck time tick for end of log to mark node as active.
  * @param p_json_struct The JSON formatted structure chunk as CLOB.
  * @return Return 1 if structure was completely delivered or -1 on errors.
  */
  FUNCTION get_json_struct( p_planck_aeon      IN     usim_spc_process.usim_planck_aeon%TYPE
                          , p_from_planck_time IN     usim_spc_process.usim_planck_time%TYPE
                          , p_to_planck_time   IN     usim_spc_process.usim_planck_time%TYPE
                          , p_json_struct         OUT CLOB
                          )
    RETURN NUMBER
  ;

  /**
  * Writes a space structure file in JSON format. The name of the file is fixed to usim_space_struct.json.
  * The file is written to the directory USIM_DIR. If a file already exists, it is copied before to the directory
  * USIM_HIST_DIR and renamed to a unique file name by current date extension. The given aeon and from to ticks will only mark current log content range
  * as active for display from the first tick they occured in the log. Structure will not know current energy of node.
  * As the structure for all existing universes is build, the file may get too big for JS P5. Row Order:</br>
  * 0:from x, 1:from y, 2:from z, 3:from dimension, 4:from dim sign, 5:from n1 sign, 6:first from tick active, 7:to x, 8:to y, 9:to z, 10:to dimension, 11:to dim sign, 12:to n1 sign, 13:first to tick active</br>
  * @param p_planck_aeon The valid planck time aeon for the log to mark node as active or ignored.
  * @param p_from_planck_time The valid planck time tick for start of log to mark node as active or ignored.
  * @param p_to_planck_time The valid planck time tick for end of log to mark node as active or ignored.
  * @return Return 1 if operation was successful otherwise 0.
  */
  FUNCTION create_json_struct( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
                             , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
                             , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
                             )
    RETURN NUMBER
  ;

  /**
  * Writes a space log file in JSON format. The name of the file is fixed to usim_space_log.json. The file is written to the directory USIM_DIR.
  * If a file already exists, it is copied before to the directory USIM_HIST_DIR and renamed to a unique file name by
  * current date extension. Only one planck aeon supported. Will create also an associated structure, where log content is marked as active in
  * the created structure. To keep space as low as possible an array structure is used per row. Order:</br>
  * 0:from x, 1:from y, 2:from z, 3:from dimension, 4:from dim sign, 5:from n1 sign, 6:from energy, 7:to x, 8:to y, 9:to z, 10:to dimension, 11:to dim sign, 12:to n1 sign, 13:to energy, 14:output energy</br>
  * @param p_planck_aeon The planck time aeon for of the log. If NULL, p_from_planck_time is ignored and log starts with current aeon.
  * @param p_from_planck_time The planck time tick for start of log. Ignored if p_from_planck_aeon is NULL using first planck time tick in aeon given or found.
  * @param p_to_planck_time The planck time tick for end of log. if NULL, log contains every record of USIM_SPC_PROCESS for aeon given or found.
  * @return Return 1 if operation was successful otherwise 0.
  */
  FUNCTION create_space_log( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
                           , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
                           , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
                           )
    RETURN NUMBER
  ;

  FUNCTION create_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the dimension id for a given dimension and creates necessary dimensions, if they
  * do not exist. Given dimension must be within the base data limits.
  * @param p_usim_n_dimension The dimension to verify.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return The dimension id for given dimension or NULL if error or base data are not available.
  */
  FUNCTION init_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                         , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                         )
    RETURN usim_dimension.usim_id_dim%TYPE
  ;

  /**
  * Retrieves the universe dimension axis id for a given universe and dimension id. Creates necessary dimension axis, if it
  * does not exist.
  * @param p_usim_id_mlv The universe id for the dimension axis.
  * @param p_usim_id_dim The dimension id for the dimension axis.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return The rmd id of the dimension axis or NULL if error or base data are not available.
  */
  FUNCTION init_dim_axis( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
                        , p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE
                        , p_usim_sign   IN usim_rel_mlv_dim.usim_sign%TYPE
                        , p_do_commit   IN BOOLEAN                          DEFAULT TRUE
                        )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  ;

  /**
  * Verifies that dimension and dimension axis exist for the given universe. Creates all necessary objects.
  * @param p_usim_id_mlv The universe id for the dimension.
  * @param p_usim_n_dimension The dimension to verify.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Return 1 if all was successfully verified or created otherwise 0.
  */
  FUNCTION init_dim_all( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                       , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                       , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                       )
    RETURN NUMBER
  ;

  /**
  * Verifies that a zero position has all connected space nodes. Creates all necessary objects.
  * Positions are set (0, 1, -1) and connections are defined.
  * @param p_usim_id_mlv The universe id for the space nodes. Mandatory.
  * @param p_usim_id_spc_parent The parent space node with position 0 and dimension one lower than the given dimension. Mandatory.
  * @param p_usim_n_dimension The dimension to use. Given dimension must be one greater than parent dimension. Mandatory.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Return 1 if all was successfully verified or created otherwise 0.
  */
  FUNCTION init_zero_dim_nodes( p_usim_id_mlv        IN usim_multiverse.usim_id_mlv%TYPE
                              , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
                              , p_usim_n_dimension   IN usim_dimension.usim_n_dimension%TYPE
                              , p_do_commit          IN BOOLEAN                              DEFAULT TRUE
                              )
    RETURN NUMBER
  ;

  /**
  * Creates a universe, with a basic position coordinate 0, dimension 0 and node for it. If first universe, it will be the base universe. Will
  * create also the basic connections to dimension 1 with positions +0/-0 and +1/-1 for both dimension axis.
  * Will only commit changes (if p_do_commit is TRUE) if all steps have been executed without errors. On errors always a rollback is executed.
  * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used and default if NULL or 0.
  * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value and default if NULL or 0.
  * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value and default if NULL or 0.
  * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value and default if NULL or 0.
  * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct.
  * @param p_usim_ultimate_border The energy flow rule for ultimate border (1) or any dimension border (0). NULL is interpreted as 1.
  * @param p_usim_id_spc_parent The usim_space id of the node, that is the parent of this universe. Ignored, if universe is base universe. Mandatory for non-base universes.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return The new usim_space id for dimension 0 or NULL if error or base data / mandatory parent in populated universe are not available.
  */
  FUNCTION create_new_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                              , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                              , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                              , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                              , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                              , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                              , p_usim_id_spc_parent      IN usim_space.usim_id_spc%TYPE                  DEFAULT NULL
                              , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                              )
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * In case of dimension overflow either a new node is created, if a higher free dimension is available
  * or the creation of a new dimension with pos 0 and 1 is triggered.
  * @param p_usim_id_spc The space node id causing the overflow.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 on success or 0 on errors.
  */
  FUNCTION handle_overflow_dim( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                              , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                              )
    RETURN NUMBER
  ;

  /**
  * Creates a new node in case of position overflow. Will add a new position on the axis the
  * given node is. Depends on correct identified escape strategy (3, 4) which imply the creation
  * of a new position. Will only accept nodes that are either 0 coordinate on the dimension axis or
  * nodes that have no child in current dimension.
  * @param p_usim_id_spc The space node id causing the overflow.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 on success or 0 on errors.
  */
  FUNCTION handle_overflow_pos( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                              , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                              )
    RETURN NUMBER
  ;

  /**
  * Creates a new node in case of between node is needed. Between nodes are filled from bottom up.
  * @param p_usim_id_spc The space node id causing the overflow.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 on success or 0 on errors.
  */
  FUNCTION handle_overflow_between( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                                  , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                                  )
    RETURN NUMBER
  ;

  /**
  * Main hub to handle overflow situations. Depending on escape classify an appropriate
  * action is executed. Will create necessary space nodes for positions, dimensions or universes.
  * @param p_usim_id_spc The usim_space id causing the overflow.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if overflow could be handled otherwise 0.
  */
  FUNCTION handle_overflow( p_usim_id_spc   IN usim_space.usim_id_spc%TYPE
                          , p_do_commit     IN BOOLEAN                     DEFAULT TRUE
                          )
    RETURN NUMBER
  ;

END usim_creator;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_creator
IS
  /**A package providing creator function on objects needed */

  /**
  * Writes a given CLOB with JSON data to the given filename with extension .json in directory USIM_DIR. Copies existing files
  * to the directory USIM_HIST_DIR and renames them to [filename]_YYYYMMDDHH24MISS.json.
  * @param p_json_clob The JSON formatted CLOB to write to [p_filename].json.
  * @param p_filename The filename for the JSON file to write. Do not use special chars and spaces. Lenght limited to 100.
  * @return Return 1 if file was written, 0 on errors.
  */
  FUNCTION write_json_file( p_json_clob IN CLOB
                          , p_filename  IN VARCHAR2 DEFAULT 'usim_space_log'
                          )
    RETURN NUMBER
  ;

  /**
  * Builds a JSON representation of the USIM_SPC_PROCESS content for the given range. If size too long for JS P5 limit the size by choosen range.
  * Will also create an assoziated structure.
  * @param p_planck_aeon The valid planck time aeon for the log.
  * @param p_from_planck_time The valid planck time tick for start of log.
  * @param p_to_planck_time The valid planck time tick for end of log.
  * @param p_json_log The JSON formatted log chunk as CLOB.
  * @return Return 1 if log was completely delivered or -1 on errors.
  */
  FUNCTION get_json_log( p_planck_aeon      IN     usim_spc_process.usim_planck_aeon%TYPE
                       , p_from_planck_time IN     usim_spc_process.usim_planck_time%TYPE
                       , p_to_planck_time   IN     usim_spc_process.usim_planck_time%TYPE
                       , p_json_log            OUT CLOB
                       )
    RETURN NUMBER
  ;

  /**
  * Builds a JSON representation of the USIM_SPACE content in means of coordinates and child relations for all
  * existing universes. No limitation in size. The given aeon and from to ticks will only mark current log content range
  * as active for display from the first tick they occured in the log. Structure will not know current energy of node.
  * @param p_planck_aeon The valid planck time aeon for the log to mark node as active.
  * @param p_from_planck_time The valid planck time tick for start of log to mark node as active.
  * @param p_to_planck_time The valid planck time tick for end of log to mark node as active.
  * @param p_json_struct The JSON formatted structure chunk as CLOB.
  * @return Return 1 if structure was completely delivered or -1 on errors.
  */
  FUNCTION get_json_struct( p_planck_aeon      IN     usim_spc_process.usim_planck_aeon%TYPE
                          , p_from_planck_time IN     usim_spc_process.usim_planck_time%TYPE
                          , p_to_planck_time   IN     usim_spc_process.usim_planck_time%TYPE
                          , p_json_struct         OUT CLOB
                          )
    RETURN NUMBER
  ;

  /**
  * Writes a space structure file in JSON format. The name of the file is fixed to usim_space_struct.json.
  * The file is written to the directory USIM_DIR. If a file already exists, it is copied before to the directory
  * USIM_HIST_DIR and renamed to a unique file name by current date extension. The given aeon and from to ticks will only mark current log content range
  * as active for display from the first tick they occured in the log. Structure will not know current energy of node.
  * As the structure for all existing universes is build, the file may get too big for JS P5. Row Order:</br>
  * 0:from x, 1:from y, 2:from z, 3:from dimension, 4:from dim sign, 5:from n1 sign, 6:first from tick active, 7:to x, 8:to y, 9:to z, 10:to dimension, 11:to dim sign, 12:to n1 sign, 13:first to tick active</br>
  * @param p_planck_aeon The valid planck time aeon for the log to mark node as active or ignored.
  * @param p_from_planck_time The valid planck time tick for start of log to mark node as active or ignored.
  * @param p_to_planck_time The valid planck time tick for end of log to mark node as active or ignored.
  * @return Return 1 if operation was successful otherwise 0.
  */
  FUNCTION create_json_struct( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
                             , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
                             , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
                             )
    RETURN NUMBER
  ;

  /**
  * Writes a space log file in JSON format. The name of the file is fixed to usim_space_log.json. The file is written to the directory USIM_DIR.
  * If a file already exists, it is copied before to the directory USIM_HIST_DIR and renamed to a unique file name by
  * current date extension. Only one planck aeon supported. Will create also an associated structure, where log content is marked as active in
  * the created structure. To keep space as low as possible an array structure is used per row. Order:</br>
  * 0:from x, 1:from y, 2:from z, 3:from dimension, 4:from dim sign, 5:from n1 sign, 6:from energy, 7:to x, 8:to y, 9:to z, 10:to dimension, 11:to dim sign, 12:to n1 sign, 13:to energy, 14:output energy</br>
  * @param p_planck_aeon The planck time aeon for of the log. If NULL, p_from_planck_time is ignored and log starts with current aeon.
  * @param p_from_planck_time The planck time tick for start of log. Ignored if p_from_planck_aeon is NULL using first planck time tick in aeon given or found.
  * @param p_to_planck_time The planck time tick for end of log. if NULL, log contains every record of USIM_SPC_PROCESS for aeon given or found.
  * @return Return 1 if operation was successful otherwise 0.
  */
  FUNCTION create_space_log( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
                           , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
                           , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
                           )
    RETURN NUMBER
  ;

  FUNCTION create_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  ;

  /**
  * Retrieves the dimension id for a given dimension and creates necessary dimensions, if they
  * do not exist. Given dimension must be within the base data limits.
  * @param p_usim_n_dimension The dimension to verify.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return The dimension id for given dimension or NULL if error or base data are not available.
  */
  FUNCTION init_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                         , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                         )
    RETURN usim_dimension.usim_id_dim%TYPE
  ;

  /**
  * Retrieves the universe dimension axis id for a given universe and dimension id. Creates necessary dimension axis, if it
  * does not exist.
  * @param p_usim_id_mlv The universe id for the dimension axis.
  * @param p_usim_id_dim The dimension id for the dimension axis.
  * @param p_usim_sign The sign of the dimension axis.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return The rmd id of the dimension axis or NULL if error or base data are not available.
  */
  FUNCTION init_dim_axis( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
                        , p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE
                        , p_usim_sign   IN usim_rel_mlv_dim.usim_sign%TYPE
                        , p_do_commit   IN BOOLEAN                          DEFAULT TRUE
                        )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  ;

  /**
  * Verifies that dimension and dimension axis exist for the given universe. Creates all necessary objects.
  * @param p_usim_id_mlv The universe id for the dimension.
  * @param p_usim_n_dimension The dimension to verify.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Return 1 if all was successfully verified or created otherwise 0.
  */
  FUNCTION init_dim_all( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                       , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                       , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                       )
    RETURN NUMBER
  ;

  /**
  * Verifies that a zero position has all connected space nodes. Creates all necessary objects.
  * Positions are set (0, 1, -1) and connections are defined.
  * @param p_usim_id_mlv The universe id for the space nodes. Mandatory.
  * @param p_usim_id_spc_parent The parent space node with position 0 and dimension one lower than the given dimension. Mandatory.
  * @param p_usim_n_dimension The dimension to use. Given dimension must be one greater than parent dimension. Mandatory.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Return 1 if all was successfully verified or created otherwise 0.
  */
  FUNCTION init_zero_dim_nodes( p_usim_id_mlv        IN usim_multiverse.usim_id_mlv%TYPE
                              , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
                              , p_usim_n_dimension   IN usim_dimension.usim_n_dimension%TYPE
                              , p_do_commit          IN BOOLEAN                              DEFAULT TRUE
                              )
    RETURN NUMBER
  ;

  /**
  * Creates a universe, with a basic position coordinate 0, dimension 0 and node for it. If first universe, it will be the base universe. Will
  * create also the basic connections to dimension 1 with positions +0/-0 and +1/-1 for both dimension axis.
  * Will only commit changes (if p_do_commit is TRUE) if all steps have been executed without errors. On errors always a rollback is executed.
  * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used and default if NULL or 0.
  * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value and default if NULL or 0.
  * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value and default if NULL or 0.
  * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value and default if NULL or 0.
  * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct.
  * @param p_usim_ultimate_border The energy flow rule for ultimate border (1) or any dimension border (0). NULL is interpreted as 1.
  * @param p_usim_id_spc_parent The usim_space id of the node, that is the parent of this universe. Ignored, if universe is base universe. Mandatory for non-base universes.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return The new usim_space id for dimension 0 or NULL if error or base data / mandatory parent in populated universe are not available.
  */
  FUNCTION create_new_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                              , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                              , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                              , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                              , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                              , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                              , p_usim_id_spc_parent      IN usim_space.usim_id_spc%TYPE                  DEFAULT NULL
                              , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                              )
    RETURN usim_space.usim_id_spc%TYPE
  ;

  /**
  * In case of dimension overflow either a new node is created, if a higher free dimension is available
  * or the creation of a new dimension with pos 0 and 1 is triggered.
  * @param p_usim_id_spc The space node id causing the overflow.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 on success or 0 on errors.
  */
  FUNCTION handle_overflow_dim( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                              , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                              )
    RETURN NUMBER
  ;

  /**
  * Creates a new node in case of position overflow. Will add a new position on the axis the
  * given node is. Depends on correct identified escape strategy (3, 4) which imply the creation
  * of a new position. Will only accept nodes that are either 0 coordinate on the dimension axis or
  * nodes that have no child in current dimension.
  * @param p_usim_id_spc The space node id causing the overflow.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 on success or 0 on errors.
  */
  FUNCTION handle_overflow_pos( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                              , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                              )
    RETURN NUMBER
  ;

  /**
  * Creates a new node in case of between node is needed. Between nodes are filled from bottom up.
  * @param p_usim_id_spc The space node id causing the overflow.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 on success or 0 on errors.
  */
  FUNCTION handle_overflow_between( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                                  , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                                  )
    RETURN NUMBER
  ;

  /**
  * Main hub to handle overflow situations. Depending on escape classify an appropriate
  * action is executed. Will create necessary space nodes for positions, dimensions or universes.
  * @param p_usim_id_spc The usim_space id causing the overflow.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Returns 1 if overflow could be handled otherwise 0.
  */
  FUNCTION handle_overflow( p_usim_id_spc   IN usim_space.usim_id_spc%TYPE
                          , p_do_commit     IN BOOLEAN                     DEFAULT TRUE
                          )
    RETURN NUMBER
  ;

END usim_creator;

Package USIM_CREATOR kompiliert

SQL> @@../PACKAGES/USIM_CREATOR.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_creator
  2  IS
  3    -- see header for documentation
  4
  5    FUNCTION write_json_file( p_json_clob IN CLOB
  6                            , p_filename  IN VARCHAR2 DEFAULT 'usim_space_log'
  7                            )
  8      RETURN NUMBER
  9    IS
 10      l_file        UTL_FILE.FILE_TYPE;
 11      l_filename    VARCHAR2(100);
 12      l_backup      VARCHAR2(100);
 13      l_buffer      VARCHAR2(8191);
 14      l_bufsize     CONSTANT BINARY_INTEGER := 8191;
 15      l_pos         PLS_INTEGER;
 16      l_clob_len    PLS_INTEGER;
 17      l_clob        CLOB;
 18      l_file_exist  BOOLEAN;
 19      l_file_length NUMBER;
 20      l_block_size  BINARY_INTEGER;
 21    BEGIN
 22      IF LENGTH(p_filename) > 100
 23      THEN
 24        usim_erl.log_error('usim_creator.write_json_file', 'Filename [' || p_filename || '] too long.');
 25        RETURN 0;
 26      END IF;
 27      l_clob  := p_json_clob;
 28      l_filename := TRIM(p_filename) || '.json';
 29      UTL_FILE.FGETATTR('USIM_DIR', l_filename, l_file_exist, l_file_length, l_block_size);
 30      IF l_file_exist
 31      THEN
 32        l_backup := TRIM(p_filename) || '_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '.json';
 33        -- "copy" file first by rename, FCOPY requires reading content with required CR limiter before 32767 bytes
 34        -- furthermore with rename no FREMOVE is required
 35        UTL_FILE.FRENAME('USIM_DIR', l_filename, 'USIM_HIST_DIR', l_backup);
 36      END IF;
 37      -- now write new file
 38      -- prepare
 39      l_pos      := 1;
 40      l_clob_len := DBMS_LOB.GETLENGTH(l_clob);
 41      l_file     := UTL_FILE.FOPEN('USIM_DIR', l_filename, 'WB', l_bufsize);
 42      -- get first buffer chunk
 43      l_buffer   := DBMS_LOB.SUBSTR(l_clob, l_bufsize, l_pos);
 44      -- loop until last chunk
 45      WHILE l_pos < l_clob_len
 46      LOOP
 47        EXIT WHEN l_buffer IS NULL;
 48        UTL_FILE.PUT_RAW(l_file, UTL_RAW.CAST_TO_RAW(l_buffer));
 49        l_pos := l_pos + LEAST(LENGTH(l_buffer) + 1, l_bufsize);
 50        UTL_FILE.FFLUSH(l_file);
 51        -- load next buffer chunk
 52        l_buffer := DBMS_LOB.SUBSTR(l_clob, l_bufsize, l_pos);
 53      END LOOP;
 54      -- close file
 55      UTL_FILE.FCLOSE(l_file);
 56      RETURN 1;
 57    EXCEPTION
 58      WHEN OTHERS THEN
 59        IF UTL_FILE.IS_OPEN(l_file)
 60        THEN
 61          UTL_FILE.FCLOSE(l_file);
 62        END IF;
 63        usim_erl.log_error('usim_creator.write_json_file', 'Unexpected exception writing JSON log SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
 64        RETURN 0;
 65    END write_json_file
 66    ;
 67
 68    FUNCTION get_json_log( p_planck_aeon      IN     usim_spc_process.usim_planck_aeon%TYPE
 69                         , p_from_planck_time IN     usim_spc_process.usim_planck_time%TYPE
 70                         , p_to_planck_time   IN     usim_spc_process.usim_planck_time%TYPE
 71                         , p_json_log            OUT CLOB
 72                         )
 73      RETURN NUMBER
 74    IS
 75      l_main_object         JSON_OBJECT_T;
 76      l_universe_object     JSON_OBJECT_T;
 77      l_universe_array      JSON_ARRAY_T;
 78      l_universe_select     JSON_ARRAY_T;
 79      l_planck_times_array  JSON_ARRAY_T;
 80      l_planck_detail_array JSON_ARRAY_T;
 81      l_planck_time_details JSON_OBJECT_T;
 82      l_planck_time_main    JSON_OBJECT_T;
 83      l_fromto_array        VARCHAR2(32000);
 84      l_return              NUMBER;
 85
 86      -- get all known universes
 87      CURSOR cur_universes
 88      IS
 89        SELECT usim_id_mlv
 90          FROM usim_multiverse
 91         ORDER BY usim_is_base_universe DESC
 92             , usim_id_mlv
 93      ;
 94      -- get needed planck pieces with associated universe
 95      CURSOR cur_planck_pieces( cp_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
 96                              , cp_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
 97                              , cp_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
 98                              , cp_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
 99                              )
100      IS
101        SELECT usim_planck_aeon
102             , usim_planck_time
103             , src_id_mlv
104          FROM usim_spr_v
105         WHERE src_id_mlv             = tgt_id_mlv
106           AND src_id_mlv             = cp_usim_id_mlv
107           AND usim_planck_aeon       = cp_planck_aeon
108           AND usim_planck_time BETWEEN cp_from_planck_time AND cp_to_planck_time
109         GROUP BY src_id_mlv
110                , usim_planck_aeon
111                , usim_planck_time
112         ORDER BY src_id_mlv
113                , usim_planck_aeon
114                , usim_planck_time
115      ;
116      -- get details on a specific planck aeon and time using ordered view
117      CURSOR cur_log_details( cp_planck_aeon IN usim_spc_process.usim_planck_aeon%TYPE
118                            , cp_planck_time IN usim_spc_process.usim_planck_time%TYPE
119                            , cp_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
120                            )
121      IS
122        SELECT usim_planck_aeon
123             , usim_planck_time
124             , usim_id_spc_source
125             , usim_id_spc_target
126             , usim_real_time
127             , is_processed
128             , usim_energy_source
129             , usim_energy_target
130             , usim_energy_output
131          FROM usim_spr_v
132         WHERE src_id_mlv       = tgt_id_mlv
133           AND src_id_mlv       = cp_usim_id_mlv
134           AND usim_planck_aeon = cp_planck_aeon
135           AND usim_planck_time = cp_planck_time
136      ;
137    BEGIN
138      -- check the parameters for given range without universe specified
139      SELECT COUNT(*)
140        INTO l_return
141        FROM (SELECT usim_planck_time
142                FROM usim_spc_process
143               WHERE usim_planck_aeon = p_planck_aeon
144                 AND usim_planck_time IN (p_from_planck_time, p_to_planck_time)
145               GROUP BY usim_planck_aeon
146                      , usim_planck_time
147             )
148      ;
149      IF l_return         NOT IN (1, 2)
150         OR p_from_planck_time > p_to_planck_time
151      THEN
152        usim_erl.log_error('usim_creator.get_json_log', 'Invalid input parameter aeon [' || p_planck_aeon || '], from [' || p_from_planck_time || '] or to [' || p_to_planck_time || '].');
153        RETURN -1;
154      END IF;
155      -- start processing
156      l_main_object         := new JSON_OBJECT_T;
157      l_planck_times_array  := new JSON_ARRAY_T;
158      l_universe_array      := new JSON_ARRAY_T;
159      l_universe_select     := new JSON_ARRAY_T;
160      l_main_object.put('aeon', p_planck_aeon);
161      l_main_object.put('max', usim_dbif.get_abs_max_number);
162      -- cycle through universes
163      FOR usim_rec IN cur_universes
164      LOOP
165        l_universe_object := new JSON_OBJECT_T;
166        l_universe_object.put('id', usim_rec.usim_id_mlv);
167        -- Collect all universes in a separate array for fast and easy JS selection and access
168        l_universe_select.append(usim_rec.usim_id_mlv);
169        FOR mainrec IN cur_planck_pieces(p_planck_aeon, p_from_planck_time, p_to_planck_time, usim_rec.usim_id_mlv)
170        LOOP
171          l_planck_detail_array := new JSON_ARRAY_T;
172          l_planck_time_main    := new JSON_OBJECT_T;
173          -- get details for time tick
174          FOR rec IN cur_log_details(mainrec.usim_planck_aeon, mainrec.usim_planck_time, usim_rec.usim_id_mlv)
175          LOOP
176            -- build JSON array like csv to save space
177            l_fromto_array :=  '[' || usim_dbif.get_xyz(rec.usim_id_spc_source) || ',' ||
178                                      usim_dbif.get_dimension(rec.usim_id_spc_source) || ',' ||
179                                      usim_dbif.get_dim_sign(rec.usim_id_spc_source) || ',' ||
180                                      usim_dbif.get_dim_n1_sign(rec.usim_id_spc_source) || ',' ||
181                                      NVL(rec.usim_energy_source, 0) || ',' ||
182                                      usim_dbif.get_xyz(rec.usim_id_spc_target) || ',' ||
183                                      usim_dbif.get_dimension(rec.usim_id_spc_target) || ',' ||
184                                      usim_dbif.get_dim_sign(rec.usim_id_spc_target) || ',' ||
185                                      usim_dbif.get_dim_n1_sign(rec.usim_id_spc_target) || ',' ||
186                                      NVL(rec.usim_energy_target,0) || ',' ||
187                                      rec.usim_energy_output || ']'
188            ;
189            l_planck_time_details := new JSON_OBJECT_T;
190            l_planck_time_details.put('row', JSON_ARRAY_T.parse(l_fromto_array));
191            -- put structure for this tick
192            l_planck_detail_array.append(l_planck_time_details);
193          END LOOP;
194          l_planck_time_main.put('tick', mainrec.usim_planck_time);
195          l_planck_time_main.put('data', l_planck_detail_array);
196          l_planck_times_array.append(l_planck_time_main);
197        END LOOP;
198        l_universe_object.put('ticks', l_planck_times_array);
199        l_universe_array.append(l_universe_object);
200      END LOOP;
201      l_main_object.put('select', l_universe_select);
202      l_main_object.put('usims', l_universe_array);
203      p_json_log := l_main_object.to_clob;
204      RETURN 1;
205    EXCEPTION
206      WHEN OTHERS THEN
207        usim_erl.log_error('usim_creator.get_json_log', 'Unexpected exception SQL code [' || SQLCODE || '] message [' || SQLERRM || '].');
208        RETURN -1;
209    END get_json_log
210    ;
211
212    FUNCTION get_json_struct( p_planck_aeon      IN     usim_spc_process.usim_planck_aeon%TYPE
213                            , p_from_planck_time IN     usim_spc_process.usim_planck_time%TYPE
214                            , p_to_planck_time   IN     usim_spc_process.usim_planck_time%TYPE
215                            , p_json_struct         OUT CLOB
216                            )
217      RETURN NUMBER
218    IS
219      l_has_data         NUMBER;
220      l_main_object      JSON_OBJECT_T;
221      l_universe_object  JSON_OBJECT_T;
222      l_universe_array   JSON_ARRAY_T;
223      l_zero_array       JSON_ARRAY_T;
224      l_zero_node        JSON_OBJECT_T;
225      l_node             JSON_OBJECT_T;
226      l_node_array       JSON_ARRAY_T;
227      l_fromto_array     VARCHAR2(32000);
228      l_src_first_tick   INTEGER;
229      l_tgt_first_tick   INTEGER;
230
231      -- get all known universes
232      CURSOR cur_universes
233      IS
234        SELECT usim_id_mlv
235          FROM usim_multiverse
236         ORDER BY usim_is_base_universe DESC
237             , usim_id_mlv
238      ;
239      CURSOR cur_structure(cp_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
240      IS
241        SELECT src_xyz
242             , tgt_xyz
243             , src_mag
244             , src_dim
245             , tgt_dim
246             , src_dim_sign
247             , tgt_dim_sign
248             , 0 AS src_n1_sign
249             , 0 AS tgt_n1_sign
250             , usim_id_mlv
251          FROM usim_spo_base3d_v
252         WHERE usim_id_mlv = cp_usim_id_mlv
253      ;
254      CURSOR cur_zero_structure(cp_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
255      IS
256        SELECT src_xyz
257             , tgt_xyz
258             , src_mag
259             , src_dim
260             , tgt_dim
261             , src_dim_sign
262             , tgt_dim_sign
263             , NVL(src_n1_sign, 0) AS src_n1_sign
264             , NVL(tgt_n1_sign, 0) AS tgt_n1_sign
265             , usim_id_mlv
266          FROM usim_spo_zero3d_v
267         WHERE usim_id_mlv = cp_usim_id_mlv
268      ;
269
270    BEGIN
271      l_main_object     := new JSON_OBJECT_T;
272      l_node_array      := new JSON_ARRAY_T;
273      l_zero_array      := new JSON_ARRAY_T;
274      l_universe_array  := new JSON_ARRAY_T;
275      -- cycle through universes
276      FOR usim_rec IN cur_universes
277      LOOP
278        l_universe_object := new JSON_OBJECT_T;
279        l_universe_object.put('id', usim_rec.usim_id_mlv);
280        -- zero structure
281        FOR mainrec IN cur_zero_structure(usim_rec.usim_id_mlv)
282        LOOP
283          -- get min planck ticks for first active source and target
284          SELECT NVL(MIN(usim_planck_time), -1)
285            INTO l_src_first_tick
286            FROM usim_spr_v
287           WHERE src_id_mlv             = usim_rec.usim_id_mlv
288             AND usim_planck_aeon       = p_planck_aeon
289             AND usim_planck_time BETWEEN p_from_planck_time
290                                      AND p_to_planck_time
291             AND src_xyz                = mainrec.src_xyz
292             AND src_dim                = mainrec.src_dim
293             AND src_dim_sign           = mainrec.src_dim_sign
294             AND src_dim_n1_sign        = mainrec.src_n1_sign
295          ;
296          SELECT NVL(MIN(usim_planck_time), -1)
297            INTO l_tgt_first_tick
298            FROM usim_spr_v
299           WHERE src_id_mlv             = usim_rec.usim_id_mlv
300             AND usim_planck_aeon       = p_planck_aeon
301             AND usim_planck_time BETWEEN p_from_planck_time
302                                      AND p_to_planck_time
303             AND tgt_xyz                = mainrec.tgt_xyz
304             AND tgt_dim                = mainrec.tgt_dim
305             AND tgt_dim_sign           = mainrec.tgt_dim_sign
306             AND tgt_dim_n1_sign        = mainrec.tgt_n1_sign
307          ;
308          -- build JSON array like csv to save space
309          l_fromto_array :=  '[' || mainrec.src_xyz || ',' ||
310                                    mainrec.src_dim || ',' ||
311                                    mainrec.src_dim_sign || ',' ||
312                                    mainrec.src_n1_sign || ',' ||
313                                    l_src_first_tick || ',' ||
314                                    mainrec.tgt_xyz || ',' ||
315                                    mainrec.tgt_dim || ',' ||
316                                    mainrec.tgt_dim_sign || ',' ||
317                                    mainrec.tgt_n1_sign || ',' ||
318                                    l_tgt_first_tick || ']'
319          ;
320          l_zero_node := new JSON_OBJECT_T;
321          l_zero_node.put('row', JSON_ARRAY_T.parse(l_fromto_array));
322          l_zero_array.append(l_zero_node);
323        END LOOP;
324        l_universe_object.put('zero', l_zero_array);
325        -- xyz relations
326        FOR mainrec IN cur_structure(usim_rec.usim_id_mlv)
327        LOOP
328          -- get min planck ticks for first active source and target
329          SELECT NVL(MIN(usim_planck_time), -1)
330            INTO l_src_first_tick
331            FROM usim_spr_v
332           WHERE src_id_mlv             = usim_rec.usim_id_mlv
333             AND usim_planck_aeon       = p_planck_aeon
334             AND usim_planck_time BETWEEN p_from_planck_time
335                                      AND p_to_planck_time
336             AND src_xyz                = mainrec.src_xyz
337          ;
338          SELECT NVL(MIN(usim_planck_time), -1)
339            INTO l_tgt_first_tick
340            FROM usim_spr_v
341           WHERE src_id_mlv             = usim_rec.usim_id_mlv
342             AND usim_planck_aeon       = p_planck_aeon
343             AND usim_planck_time BETWEEN p_from_planck_time
344                                      AND p_to_planck_time
345             AND tgt_xyz                = mainrec.tgt_xyz
346          ;
347          -- build JSON array like csv to save space
348          l_fromto_array :=  '[' || mainrec.src_xyz || ',' ||
349                                    mainrec.src_dim || ',' ||
350                                    mainrec.src_dim_sign || ',' ||
351                                    '0,' ||
352                                    l_src_first_tick || ',' ||
353                                    mainrec.tgt_xyz || ',' ||
354                                    mainrec.tgt_dim || ',' ||
355                                    mainrec.tgt_dim_sign || ',' ||
356                                    '0,' ||
357                                    l_tgt_first_tick || ']'
358          ;
359          -- build main node
360          l_node     := new JSON_OBJECT_T;
361          l_node.put('row', JSON_ARRAY_T.parse(l_fromto_array));
362          l_node_array.append(l_node);
363        END LOOP;
364        l_universe_object.put('data', l_node_array);
365        l_universe_array.append(l_universe_object);
366      END LOOP;
367      -- add to main object
368      l_main_object.put('usims', l_universe_array);
369      p_json_struct := l_main_object.to_clob;
370      RETURN 1;
371    EXCEPTION
372      WHEN OTHERS THEN
373        usim_erl.log_error('usim_creator.get_json_struct', 'Unexpected exception SQL code [' || SQLCODE || '] message [' || SQLERRM || '].');
374        RETURN NULL;
375    END get_json_struct
376    ;
377
378    FUNCTION create_json_struct( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
379                               , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
380                               , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
381                               )
382      RETURN NUMBER
383    IS
384      l_json_struct CLOB;
385      l_return      NUMBER;
386      l_file        NUMBER;
387    BEGIN
388      IF usim_dbif.has_data_spc = 0
389      THEN
390        usim_erl.log_error('usim_creator.create_json_struct', 'No data in USIM_SPACE for structure JSON.');
391        RETURN 0;
392      END IF;
393      l_return := usim_creator.get_json_struct(p_planck_aeon, p_from_planck_time, p_to_planck_time, l_json_struct);
394      IF l_return = 0
395      THEN
396        usim_erl.log_error('usim_creator.create_json_struct', 'ERROR getting json space structure.');
397        RETURN 0;
398      END IF;
399      -- write file
400      l_file := usim_creator.write_json_file(l_json_struct, 'usim_space_struct');
401      IF l_file = 0
402      THEN
403        usim_erl.log_error('usim_creator.create_json_struct', 'ERROR writing json space structure.');
404        RETURN 0;
405      END IF;
406      RETURN 1;
407    END create_json_struct
408    ;
409
410    FUNCTION create_space_log( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
411                             , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
412                             , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
413                             )
414      RETURN NUMBER
415    IS
416      l_has_data          NUMBER;
417      l_result            NUMBER;
418      l_file              NUMBER;
419      l_planck_aeon       usim_spc_process.usim_planck_aeon%TYPE;
420      l_from_planck_time  usim_spc_process.usim_planck_time%TYPE;
421      l_to_planck_time    usim_spc_process.usim_planck_time%TYPE;
422      l_json_log          CLOB;
423    BEGIN
424      SELECT COUNT(*) INTO l_has_data FROM usim_spc_process;
425      IF l_has_data = 0
426      THEN
427        usim_erl.log_error('usim_creator.create_space_log', 'Could not write log without logging data in USIM_SPC_PROCESS, table is empty.');
428        RETURN 0;
429      END IF;
430      -- get aeon to use if NULL
431      SELECT COUNT(*) INTO l_has_data FROM usim_spc_process WHERE usim_planck_aeon = NVL(p_planck_aeon, usim_dbif.get_planck_aeon_seq_current);
432      IF l_has_data = 0
433      THEN
434        -- get max aeon in process, maybe a switch has occured after last processing
435        SELECT MAX(usim_planck_aeon) INTO l_planck_aeon FROM usim_spc_process;
436      ELSE
437        l_planck_aeon := NVL(p_planck_aeon, usim_dbif.get_planck_aeon_seq_current);
438      END IF;
439      -- check from record
440      SELECT COUNT(*) INTO l_has_data FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon AND usim_planck_time = p_from_planck_time;
441      IF l_has_data = 0
442      THEN
443        SELECT MIN(usim_planck_time) INTO l_from_planck_time FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon;
444      ELSE
445        l_from_planck_time := p_from_planck_time;
446      END IF;
447      -- check to record
448      SELECT COUNT(*) INTO l_has_data FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon AND usim_planck_time = p_to_planck_time;
449      IF l_has_data = 0
450      THEN
451        SELECT MAX(usim_planck_time) INTO l_from_planck_time FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon;
452      ELSE
453        l_to_planck_time := p_to_planck_time;
454      END IF;
455      -- write JSON log file
456      l_result := usim_creator.get_json_log(l_planck_aeon, l_from_planck_time, l_to_planck_time, l_json_log);
457      IF l_result = -1
458      THEN
459        usim_erl.log_error('usim_creator.create_space_log', 'Could not get json space log for from [' || l_planck_aeon || '], [' || l_from_planck_time || '] or to [' || l_to_planck_time || '].');
460        RETURN 0;
461      ELSE
462        l_file := usim_creator.write_json_file(l_json_log, 'usim_space_log');
463      END IF;
464      -- write associated JSON structure file
465      l_result := usim_creator.create_json_struct(l_planck_aeon, l_from_planck_time, l_to_planck_time);
466      IF l_result = 0
467      THEN
468        usim_erl.log_error('usim_creator.create_space_log', 'Could not create associated structure for from [' || l_planck_aeon || '], [' || l_from_planck_time || '] or to [' || l_to_planck_time || '].');
469        RETURN 0;
470      END IF;
471      RETURN 1;
472    END create_space_log
473    ;
474
475    FUNCTION create_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
476      RETURN NUMBER
477    IS
478    BEGIN
479      usim_erl.log_error('usim_creator.create_next_dimension', 'NOT IMPLEMENTED.');
480      RETURN 1;
481    END create_next_dimension
482    ;
483
484    FUNCTION init_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
485                           , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
486                           )
487      RETURN usim_dimension.usim_id_dim%TYPE
488    IS
489    BEGIN
490      usim_erl.log_error('usim_creator.init_dimension', 'NOT IMPLEMENTED.');
491      RETURN NULL;
492    END init_dimension
493    ;
494
495    FUNCTION init_dim_axis( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
496                          , p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE
497                          , p_usim_sign   IN usim_rel_mlv_dim.usim_sign%TYPE
498                          , p_do_commit   IN BOOLEAN                          DEFAULT TRUE
499                          )
500      RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
501    IS
502    BEGIN
503      usim_debug.debug_log('usim_creator.init_dim_axis', 'NOT IMPLEMENTED.');
504      RETURN NULL;
505    END init_dim_axis
506    ;
507
508    FUNCTION init_dim_all( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
509                         , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
510                         , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
511                         )
512      RETURN NUMBER
513    IS
514    BEGIN
515      usim_debug.debug_log('usim_creator.init_dim_all', 'NOT IMPLEMENTED.');
516      RETURN 0;
517    END init_dim_all
518    ;
519
520    FUNCTION init_zero_dim_nodes( p_usim_id_mlv        IN usim_multiverse.usim_id_mlv%TYPE
521                                , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
522                                , p_usim_n_dimension   IN usim_dimension.usim_n_dimension%TYPE
523                                , p_do_commit          IN BOOLEAN                              DEFAULT TRUE
524                                )
525      RETURN NUMBER
526    IS
527    BEGIN
528      usim_debug.debug_log('usim_creator.init_zero_dim_nodes', 'NOT IMPLEMENTED.');
529      RETURN 0;
530    END init_zero_dim_nodes
531    ;
532
533    FUNCTION create_new_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
534                                , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
535                                , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
536                                , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
537                                , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
538                                , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
539                                , p_usim_id_spc_parent      IN usim_space.usim_id_spc%TYPE                  DEFAULT NULL
540                                , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
541                                )
542      RETURN usim_space.usim_id_spc%TYPE
543    IS
544      -- zero node dim 0 pos 0
545      l_usim_id_spc           usim_space.usim_id_spc%TYPE;
546      -- used for parent check
547      l_usim_id_spc_parent    usim_space.usim_id_spc%TYPE;
548      -- dim 1 n1+ pos +0
549      l_id_spc0_n1p_1p        usim_space.usim_id_spc%TYPE;
550      -- dim 1 n1- pos -0
551      l_id_spc0_n1n_1n        usim_space.usim_id_spc%TYPE;
552      -- dim 1 n1+ pos +1
553      l_id_spc1p_n1p_1p       usim_space.usim_id_spc%TYPE;
554      -- dim 1 n1- pos -1
555      l_id_spc1n_n1n_1n       usim_space.usim_id_spc%TYPE;
556      -- universe id
557      l_usim_id_mlv           usim_multiverse.usim_id_mlv%TYPE;
558      -- dim axis 0
559      l_usim_id_rmd           usim_rel_mlv_dim.usim_id_rmd%TYPE;
560      -- pos 0
561      l_usim_id_pos           usim_position.usim_id_pos%TYPE;
562      -- pos +1
563      l_usim_id_pos_1p        usim_position.usim_id_pos%TYPE;
564      -- pos -1
565      l_usim_id_pos_1n        usim_position.usim_id_pos%TYPE;
566      -- dim axis 1+
567      l_id_rmd_n1p_1p         usim_rel_mlv_dim.usim_id_rmd%TYPE;
568      -- dim axis 1-
569      l_id_rmd_n1n_1n         usim_rel_mlv_dim.usim_id_rmd%TYPE;
570      -- dummy of dim axis 0 creation
571      l_rmd_dummy             usim_rel_mlv_dim.usim_id_rmd%TYPE;
572      -- parents array
573      l_parents               usim_static.usim_ids_type;
574      l_return                NUMBER;
575    BEGIN
576      -- check base data, must exist
577      IF usim_dbif.has_basedata = 0
578      THEN
579        usim_erl.log_error('usim_creator.create_new_universe', 'Base data not initialized.');
580        RETURN NULL;
581      END IF;
582      -- a parent must be given, if usim_space has already data, assuming an existing base universe seed.
583      IF     usim_dbif.has_data_mlv = 1
584         AND p_usim_id_spc_parent  IS NULL
585      THEN
586        usim_erl.log_error('usim_creator.create_new_universe', 'Parent for new universe missing, as already data in usim_multiverse exist.');
587        RETURN NULL;
588      END IF;
589      -- ignore parent if usim_space is empty
590      IF     usim_dbif.has_data_mlv = 0
591         AND p_usim_id_spc_parent  IS NOT NULL
592      THEN
593        usim_erl.log_error('usim_creator.create_new_universe', 'Ignoring parent assignment [' || p_usim_id_spc_parent || '] on empty multiverse.');
594        l_usim_id_spc_parent := NULL;
595      ELSE
596        l_usim_id_spc_parent := p_usim_id_spc_parent;
597      END IF;
598      -- create universe
599      l_usim_id_mlv := usim_dbif.create_universe( p_usim_energy_start_value
600                                                , p_usim_planck_time_unit
601                                                , p_usim_planck_length_unit
602                                                , p_usim_planck_speed_unit
603                                                , p_usim_planck_stable
604                                                , p_usim_ultimate_border
605                                                , FALSE
606                                                )
607      ;
608      -- if universe creation failed rollback everything
609      IF l_usim_id_mlv IS NULL
610      THEN
611        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create new universe with data energy start [' || p_usim_energy_start_value || '], planck time [' || p_usim_planck_time_unit || '], planck length [' || p_usim_planck_length_unit || '], planck speed [' || p_usim_planck_speed_unit || '], planck stable [' || p_usim_planck_stable || '] and ultimate border rule [' || p_usim_ultimate_border || '].');
612        ROLLBACK;
613        RETURN NULL;
614      END IF;
615      -- check and create dimension, if necessary
616      l_return := usim_dbif.init_dimensions(FALSE);
617      IF l_return = 0
618      THEN
619        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to init dimensions.');
620        ROLLBACK;
621        RETURN NULL;
622      END IF;
623      -- check and create positions, if necessary
624      l_return := usim_dbif.init_positions(FALSE);
625      IF l_return = 0
626      THEN
627        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to init positions.');
628        ROLLBACK;
629        RETURN NULL;
630      END IF;
631      -- get position 0
632      l_usim_id_pos := usim_dbif.get_id_pos(0);
633      IF l_usim_id_pos IS NULL
634      THEN
635        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to get position 0.');
636        ROLLBACK;
637        RETURN NULL;
638      END IF;
639      -- create dim axis
640      l_return  := usim_dbif.create_dim_axis(l_usim_id_mlv, 0, NULL, l_usim_id_rmd, l_rmd_dummy, FALSE);
641      IF l_return = 0
642      THEN
643        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create dimension axis for dimension 0 universe id [' || l_usim_id_mlv || '].');
644        ROLLBACK;
645        RETURN NULL;
646      END IF;
647      -- set parent if available
648      IF l_usim_id_spc_parent IS NOT NULL
649      THEN
650        l_parents(1) := l_usim_id_spc_parent;
651      END IF;
652      -- create basic space node
653      l_usim_id_spc := usim_dbif.create_space_node(l_usim_id_rmd, l_usim_id_pos, l_parents, FALSE);
654      IF l_usim_id_spc IS NULL
655      THEN
656        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node for rmd id [' || l_usim_id_rmd || '], pos id [' || l_usim_id_pos || '] and parent [' || NVL(l_usim_id_spc_parent, 'NONE') || '].');
657        ROLLBACK;
658        RETURN NULL;
659      END IF;
660      -- create dim axis (+/-) for dimension 1
661      l_return := usim_dbif.create_dim_axis(l_usim_id_mlv, 1, l_usim_id_rmd, l_id_rmd_n1p_1p, l_id_rmd_n1n_1n, FALSE);
662      IF l_return = 0
663      THEN
664        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create dimension axis for dimension 1 universe id [' || l_usim_id_mlv || '] and rmd id [' || l_usim_id_rmd || '].');
665        ROLLBACK;
666        RETURN NULL;
667      END IF;
668      -- create space nodes on dimension 1
669      l_parents(1) := l_usim_id_spc;
670      -- +0,0,0
671      l_id_spc0_n1p_1p  := usim_dbif.create_space_node(l_id_rmd_n1p_1p, l_usim_id_pos, l_parents, FALSE);
672      IF l_id_spc0_n1p_1p IS NULL
673      THEN
674        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position +0 at dimension 1, n1+ for rmd id [' || l_id_rmd_n1p_1p || '], pos id [' || l_usim_id_pos || '] and parent [' || NVL(l_usim_id_spc_parent, 'NONE') || '].');
675        ROLLBACK;
676        RETURN NULL;
677      END IF;
678      -- -0,0,0
679      l_id_spc0_n1n_1n  := usim_dbif.create_space_node(l_id_rmd_n1n_1n, l_usim_id_pos, l_parents, FALSE);
680      IF l_id_spc0_n1p_1p IS NULL
681      THEN
682        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position -0 at dimension 1, n1- for rmd id [' || l_id_rmd_n1n_1n || '], pos id [' || l_usim_id_pos || '] and parent [' || NVL(l_usim_id_spc_parent, 'NONE') || '].');
683        ROLLBACK;
684        RETURN NULL;
685      END IF;
686      -- get positions 1 (+/-)
687      l_usim_id_pos_1p := usim_dbif.get_id_pos(1);
688      IF l_usim_id_pos_1p IS NULL
689      THEN
690        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to get position +1.');
691        ROLLBACK;
692        RETURN NULL;
693      END IF;
694      l_usim_id_pos_1n := usim_dbif.get_id_pos(-1);
695      IF l_usim_id_pos_1n IS NULL
696      THEN
697        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to get position -1.');
698        ROLLBACK;
699        RETURN NULL;
700      END IF;
701      -- from here on parents have to have the same dim n1 sign
702      -- +1,0,0
703      l_parents(1) := l_id_spc0_n1p_1p;
704      l_id_spc1p_n1p_1p := usim_dbif.create_space_node(l_id_rmd_n1p_1p, l_usim_id_pos_1p, l_parents, FALSE);
705      IF l_id_spc1p_n1p_1p IS NULL
706      THEN
707        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position +1 at dimension 1, n1+ for rmd id [' || l_id_rmd_n1p_1p || '], pos id [' || l_usim_id_pos_1p || '] and parent [' || NVL(l_parents(1), 'NONE') || '].');
708        ROLLBACK;
709        RETURN NULL;
710      END IF;
711      -- -1,0,0
712      l_parents(1) := l_id_spc0_n1n_1n;
713      l_id_spc1n_n1n_1n := usim_dbif.create_space_node(l_id_rmd_n1n_1n, l_usim_id_pos_1n, l_parents, FALSE);
714      IF l_id_spc1p_n1p_1p IS NULL
715      THEN
716        usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position -1 at dimension 1, n1- for rmd id [' || l_id_rmd_n1n_1n || '], pos id [' || l_usim_id_pos_1n || '] and parent [' || NVL(l_parents(1), 'NONE') || '].');
717        ROLLBACK;
718        RETURN NULL;
719      END IF;
720      -- now commit if coming so far and do commit is set
721      IF p_do_commit
722      THEN
723        COMMIT;
724      END IF;
725      RETURN l_usim_id_spc;
726    EXCEPTION
727      WHEN OTHERS THEN
728        -- write error might still work
729        usim_erl.log_error('usim_creator.create_new_universe', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
730        -- try to set all to crashed
731        usim_dbif.set_crashed;
732        -- raise in any case
733        RAISE;
734    END create_new_universe
735    ;
736
737    FUNCTION handle_overflow_dim( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
738                                , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
739                                )
740      RETURN NUMBER
741    IS
742      l_dim_parent      usim_space.usim_id_spc%TYPE;
743      l_spc_id_pos0p    usim_space.usim_id_spc%TYPE;
744      l_spc_id_pos1p    usim_space.usim_id_spc%TYPE;
745      l_spc_id_pos0n    usim_space.usim_id_spc%TYPE;
746      l_spc_id_pos1n    usim_space.usim_id_spc%TYPE;
747      l_id_pos0         usim_position.usim_id_pos%TYPE;
748      l_id_pos1p        usim_position.usim_id_pos%TYPE;
749      l_id_pos1n        usim_position.usim_id_pos%TYPE;
750      l_parents         usim_static.usim_ids_type;
751      l_next_dim        usim_dimension.usim_n_dimension%TYPE;
752      l_usim_id_mlv     usim_multiverse.usim_id_mlv%TYPE;
753      l_usim_id_rmd     usim_rel_mlv_dim.usim_id_rmd%TYPE;
754      l_usim_id_rmd_p   usim_rel_mlv_dim.usim_id_rmd%TYPE;
755      l_usim_id_rmd_n   usim_rel_mlv_dim.usim_id_rmd%TYPE;
756      l_dim_sign        usim_rel_mlv_dim.usim_sign%TYPE;
757      l_dim_n1_sign     usim_rel_mlv_dim.usim_n1_sign%TYPE;
758      l_result          NUMBER;
759      l_classify        NUMBER;
760    BEGIN
761      l_classify := usim_dbif.is_dim_extendable(p_usim_id_spc, l_dim_parent, l_next_dim);
762      IF l_classify = 2
763      THEN
764        -- get data for create dimension
765        l_result := usim_dbif.get_spc_dim_details(l_dim_parent, l_usim_id_mlv, l_usim_id_rmd, l_dim_sign, l_dim_n1_sign);
766        IF l_result = 0
767        THEN
768          usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not fetch data for space id [' || p_usim_id_spc || '].');
769          usim_dbif.set_crashed;
770          RETURN 0;
771        END IF;
772        -- create a new dimension on zero pos axis node
773        l_result := usim_dbif.create_dim_axis(l_usim_id_mlv, l_next_dim, l_usim_id_rmd, l_usim_id_rmd_p, l_usim_id_rmd_n);
774        -- create position 0 and 1 on new dimension
775        l_id_pos0      := usim_dbif.get_id_pos(0);
776        l_id_pos1p     := usim_dbif.get_id_pos(1);
777        l_id_pos1n     := usim_dbif.get_id_pos(-1);
778        l_parents(1)   := l_dim_parent;
779        l_spc_id_pos0p := usim_dbif.create_space_node(l_usim_id_rmd_p, l_id_pos0, l_parents);
780        IF l_spc_id_pos0p IS NULL
781        THEN
782          usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_p || '], pos [' || l_id_pos0 || '] and parent [' || l_parents(1) || '].');
783          usim_dbif.set_crashed;
784          RETURN 0;
785        END IF;
786        l_parents(1)   := l_spc_id_pos0p;
787        l_spc_id_pos1p := usim_dbif.create_space_node(l_usim_id_rmd_p, l_id_pos1p, l_parents);
788        IF l_spc_id_pos1p IS NULL
789        THEN
790          usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_p || '], pos [' || l_id_pos1p || '] and parent [' || l_parents(1) || '].');
791          usim_dbif.set_crashed;
792          RETURN 0;
793        END IF;
794        l_parents(1)   := l_dim_parent;
795        l_spc_id_pos0n := usim_dbif.create_space_node(l_usim_id_rmd_n, l_id_pos0, l_parents);
796        IF l_spc_id_pos0n IS NULL
797        THEN
798          usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_n || '], pos [' || l_id_pos0 || '] and parent [' || l_parents(1) || '].');
799          usim_dbif.set_crashed;
800          RETURN 0;
801        END IF;
802        l_parents(1)   := l_spc_id_pos0n;
803        l_spc_id_pos1n := usim_dbif.create_space_node(l_usim_id_rmd_n, l_id_pos1n, l_parents);
804        IF l_spc_id_pos1n IS NULL
805        THEN
806          usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_n || '], pos [' || l_id_pos1n || '] and parent [' || l_parents(1) || '].');
807          usim_dbif.set_crashed;
808          RETURN 0;
809        END IF;
810        usim_debug.debug_log('usim_creator.handle_overflow_dim', 'Handle new dimension in zero pos for space id [' || p_usim_id_spc || '].');
811        RETURN 1;
812      ELSIF l_classify = 1
813      THEN
814        -- connect node to available dimension
815        usim_debug.debug_log('usim_creator.handle_overflow_dim', 'Not implemented for space id [' || p_usim_id_spc || '].');
816      ELSE
817        usim_debug.debug_log('usim_creator.handle_overflow_dim', 'Not implemented for space id [' || p_usim_id_spc || '].');
818      END IF;
819      RETURN 1;
820    EXCEPTION
821      WHEN OTHERS THEN
822        -- write error might still work
823        usim_erl.log_error('usim_creator.handle_overflow_dim', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
824        -- try to set all to crashed
825        usim_dbif.set_crashed;
826        -- raise in any case
827        RAISE;
828    END handle_overflow_dim
829    ;
830
831
832    FUNCTION handle_overflow_pos( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
833                                , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
834                                )
835      RETURN NUMBER
836    IS
837      l_result    usim_space.usim_id_spc%TYPE;
838      l_parent    usim_space.usim_id_spc%TYPE;
839      l_parents   usim_static.usim_ids_type;
840      l_id_pos    usim_position.usim_id_pos%TYPE;
841      l_id_rmd    usim_rel_mlv_dim.usim_id_rmd%TYPE;
842      l_is_valid  NUMBER;
843      l_return    NUMBER;
844    BEGIN
845      l_is_valid := usim_dbif.is_pos_extendable(p_usim_id_spc);
846      IF l_is_valid = 0
847      THEN
848        usim_erl.log_error('usim_creator.handle_overflow_pos', 'Used invalid node id [' || p_usim_id_spc || '] no axis zero pos or no position free.');
849        RETURN 0;
850      END IF;
851      IF l_is_valid = 1
852      THEN
853        -- new position with parent current given node
854        l_parent := p_usim_id_spc;
855      ELSE
856        -- get max pos for zero nodes using their dimension settings
857        l_parent := usim_dbif.get_axis_max_pos_parent(p_usim_id_spc);
858        IF l_parent IS NULL
859        THEN
860          usim_erl.log_error('usim_creator.handle_overflow_pos', 'Could not retrieve max pos parent id from space node [' || p_usim_id_spc || '].');
861          RETURN 0;
862        END IF;
863      END IF;
864      l_parents(1) := l_parent;
865      -- get next position and axis
866      l_return := usim_dbif.get_next_pos_on_axis(l_parent, l_id_pos, l_id_rmd);
867      IF l_return = 0
868      THEN
869        usim_erl.log_error('usim_creator.handle_overflow_pos', 'usim_dbif.get_next_pos_on_axis failed for parent [' || l_parent || '].');
870        RETURN 0;
871      END IF;
872      -- create space node with parent identified
873      l_result := usim_dbif.create_space_node(l_id_rmd, l_id_pos, l_parents, p_do_commit);
874      IF l_result IS NULL
875      THEN
876        usim_erl.log_error('usim_creator.handle_overflow_pos', 'Failed to create space node for rmd [' || l_id_rmd || '], pos [' || l_id_pos || '] and parent [' || l_parents(1) || '].');
877        RETURN 0;
878      END IF;
879      RETURN 1;
880    EXCEPTION
881      WHEN OTHERS THEN
882        -- write error might still work
883        usim_erl.log_error('usim_creator.handle_overflow_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
884        -- try to set all to crashed
885        usim_dbif.set_crashed;
886        -- raise in any case
887        RAISE;
888    END handle_overflow_pos
889    ;
890
891    FUNCTION handle_overflow_between( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
892                                    , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
893                                    )
894      RETURN NUMBER
895    IS
896    BEGIN
897      -- where are we
898      -- if zero pos
899      -- if axis, next dimension only a 1 coordinate for connect is possible
900      IF usim_spo.is_axis_pos(p_usim_id_spc) = 1
901      THEN
902
903        -- has child next dim with pos 1?
904        -- no, then delegate next free low pos inbetween.
905        NULL;
906      ELSE
907        -- positions free lower dimension
908        -- positions free higher dimension
909        NULL;
910      END IF;
911      usim_debug.debug_log('usim_creator.handle_overflow_between', 'Not implemented yet.');
912      RETURN 0;
913    EXCEPTION
914      WHEN OTHERS THEN
915        -- write error might still work
916        usim_erl.log_error('usim_creator.handle_overflow_between', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
917        -- try to set all to crashed
918        usim_dbif.set_crashed;
919        -- raise in any case
920        RAISE;
921    END handle_overflow_between
922    ;
923
924
925    FUNCTION handle_overflow( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
926                            , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
927                            )
928      RETURN NUMBER
929    IS
930      l_escape        NUMBER;
931      l_result        NUMBER;
932      l_id_spc_parent usim_space.usim_id_spc%TYPE;
933    BEGIN
934      l_escape := usim_dbif.classify_escape(p_usim_id_spc);
935
936      IF l_escape IN (3, 5)
937      THEN
938        -- escape position 5 and 3 can be handled together
939        l_result := usim_creator.handle_overflow_pos(p_usim_id_spc, p_do_commit);
940        IF l_result = 0
941        THEN
942          usim_erl.log_error('usim_creator.handle_overflow', 'Pos overflow handling error for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
943          usim_dbif.set_crashed;
944          RETURN 0;
945        END IF;
946        usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Handle pos overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
947      ELSIF l_escape IN (2, 4)
948      THEN
949        l_result := usim_creator.handle_overflow_dim(p_usim_id_spc, p_do_commit);
950        IF l_result = 0
951        THEN
952          usim_erl.log_error('usim_creator.handle_overflow', 'Dim overflow handling error for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
953          usim_dbif.set_crashed;
954          RETURN 0;
955        END IF;
956        usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Handle dim overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
957      ELSIF l_escape = 1
958      THEN
959        IF usim_dbif.is_pos_extendable(p_usim_id_spc) = 1
960        THEN
961          l_result := usim_creator.handle_overflow_pos(p_usim_id_spc, p_do_commit);
962        ELSE
963          l_result := usim_creator.handle_overflow_dim(p_usim_id_spc, p_do_commit);
964        END IF;
965        IF l_result = 0
966        THEN
967          usim_erl.log_error('usim_creator.handle_overflow', 'Pos/dim overflow handling error for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
968          usim_dbif.set_crashed;
969          RETURN 0;
970        END IF;
971        usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Handle overflow pos/dim for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
972      -- delegate options
973      ELSIF l_escape = 7
974      THEN
975        l_result := usim_creator.handle_overflow_between(p_usim_id_spc, p_do_commit);
976        usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
977      ELSIF l_escape = 6
978      THEN
979        usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
980      ELSIF l_escape = 5
981      THEN
982        usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
983      ELSIF l_escape = 0
984      THEN
985        usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
986      ELSE
987        usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] with unknown escape strategy [' || l_escape || '].');
988      END IF;
989      RETURN 1;
990    EXCEPTION
991      WHEN OTHERS THEN
992        -- write error might still work
993        usim_erl.log_error('usim_creator.handle_overflow', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
994        -- try to set all to crashed
995        usim_dbif.set_crashed;
996        -- raise in any case
997        RAISE;
998    END handle_overflow
999    ;
1000
1001  END usim_creator;
1002  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_creator
IS
  -- see header for documentation

  FUNCTION write_json_file( p_json_clob IN CLOB
                          , p_filename  IN VARCHAR2 DEFAULT 'usim_space_log'
                          )
    RETURN NUMBER
  IS
    l_file        UTL_FILE.FILE_TYPE;
    l_filename    VARCHAR2(100);
    l_backup      VARCHAR2(100);
    l_buffer      VARCHAR2(8191);
    l_bufsize     CONSTANT BINARY_INTEGER := 8191;
    l_pos         PLS_INTEGER;
    l_clob_len    PLS_INTEGER;
    l_clob        CLOB;
    l_file_exist  BOOLEAN;
    l_file_length NUMBER;
    l_block_size  BINARY_INTEGER;
  BEGIN
    IF LENGTH(p_filename) > 100
    THEN
      usim_erl.log_error('usim_creator.write_json_file', 'Filename [' || p_filename || '] too long.');
      RETURN 0;
    END IF;
    l_clob  := p_json_clob;
    l_filename := TRIM(p_filename) || '.json';
    UTL_FILE.FGETATTR('USIM_DIR', l_filename, l_file_exist, l_file_length, l_block_size);
    IF l_file_exist
    THEN
      l_backup := TRIM(p_filename) || '_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '.json';
      -- "copy" file first by rename, FCOPY requires reading content with required CR limiter before 32767 bytes
      -- furthermore with rename no FREMOVE is required
      UTL_FILE.FRENAME('USIM_DIR', l_filename, 'USIM_HIST_DIR', l_backup);
    END IF;
    -- now write new file
    -- prepare
    l_pos      := 1;
    l_clob_len := DBMS_LOB.GETLENGTH(l_clob);
    l_file     := UTL_FILE.FOPEN('USIM_DIR', l_filename, 'WB', l_bufsize);
    -- get first buffer chunk
    l_buffer   := DBMS_LOB.SUBSTR(l_clob, l_bufsize, l_pos);
    -- loop until last chunk
    WHILE l_pos < l_clob_len
    LOOP
      EXIT WHEN l_buffer IS NULL;
      UTL_FILE.PUT_RAW(l_file, UTL_RAW.CAST_TO_RAW(l_buffer));
      l_pos := l_pos + LEAST(LENGTH(l_buffer) + 1, l_bufsize);
      UTL_FILE.FFLUSH(l_file);
      -- load next buffer chunk
      l_buffer := DBMS_LOB.SUBSTR(l_clob, l_bufsize, l_pos);
    END LOOP;
    -- close file
    UTL_FILE.FCLOSE(l_file);
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      IF UTL_FILE.IS_OPEN(l_file)
      THEN
        UTL_FILE.FCLOSE(l_file);
      END IF;
      usim_erl.log_error('usim_creator.write_json_file', 'Unexpected exception writing JSON log SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      RETURN 0;
  END write_json_file
  ;

  FUNCTION get_json_log( p_planck_aeon      IN     usim_spc_process.usim_planck_aeon%TYPE
                       , p_from_planck_time IN     usim_spc_process.usim_planck_time%TYPE
                       , p_to_planck_time   IN     usim_spc_process.usim_planck_time%TYPE
                       , p_json_log            OUT CLOB
                       )
    RETURN NUMBER
  IS
    l_main_object         JSON_OBJECT_T;
    l_universe_object     JSON_OBJECT_T;
    l_universe_array      JSON_ARRAY_T;
    l_universe_select     JSON_ARRAY_T;
    l_planck_times_array  JSON_ARRAY_T;
    l_planck_detail_array JSON_ARRAY_T;
    l_planck_time_details JSON_OBJECT_T;
    l_planck_time_main    JSON_OBJECT_T;
    l_fromto_array        VARCHAR2(32000);
    l_return              NUMBER;

    -- get all known universes
    CURSOR cur_universes
    IS
      SELECT usim_id_mlv
        FROM usim_multiverse
       ORDER BY usim_is_base_universe DESC
           , usim_id_mlv
    ;
    -- get needed planck pieces with associated universe
    CURSOR cur_planck_pieces( cp_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
                            , cp_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
                            , cp_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
                            , cp_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                            )
    IS
      SELECT usim_planck_aeon
           , usim_planck_time
           , src_id_mlv
        FROM usim_spr_v
       WHERE src_id_mlv             = tgt_id_mlv
         AND src_id_mlv             = cp_usim_id_mlv
         AND usim_planck_aeon       = cp_planck_aeon
         AND usim_planck_time BETWEEN cp_from_planck_time AND cp_to_planck_time
       GROUP BY src_id_mlv
              , usim_planck_aeon
              , usim_planck_time
       ORDER BY src_id_mlv
              , usim_planck_aeon
              , usim_planck_time
    ;
    -- get details on a specific planck aeon and time using ordered view
    CURSOR cur_log_details( cp_planck_aeon IN usim_spc_process.usim_planck_aeon%TYPE
                          , cp_planck_time IN usim_spc_process.usim_planck_time%TYPE
                          , cp_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
                          )
    IS
      SELECT usim_planck_aeon
           , usim_planck_time
           , usim_id_spc_source
           , usim_id_spc_target
           , usim_real_time
           , is_processed
           , usim_energy_source
           , usim_energy_target
           , usim_energy_output
        FROM usim_spr_v
       WHERE src_id_mlv       = tgt_id_mlv
         AND src_id_mlv       = cp_usim_id_mlv
         AND usim_planck_aeon = cp_planck_aeon
         AND usim_planck_time = cp_planck_time
    ;
  BEGIN
    -- check the parameters for given range without universe specified
    SELECT COUNT(*)
      INTO l_return
      FROM (SELECT usim_planck_time
              FROM usim_spc_process
             WHERE usim_planck_aeon = p_planck_aeon
               AND usim_planck_time IN (p_from_planck_time, p_to_planck_time)
             GROUP BY usim_planck_aeon
                    , usim_planck_time
           )
    ;
    IF l_return         NOT IN (1, 2)
       OR p_from_planck_time > p_to_planck_time
    THEN
      usim_erl.log_error('usim_creator.get_json_log', 'Invalid input parameter aeon [' || p_planck_aeon || '], from [' || p_from_planck_time || '] or to [' || p_to_planck_time || '].');
      RETURN -1;
    END IF;
    -- start processing
    l_main_object         := new JSON_OBJECT_T;
    l_planck_times_array  := new JSON_ARRAY_T;
    l_universe_array      := new JSON_ARRAY_T;
    l_universe_select     := new JSON_ARRAY_T;
    l_main_object.put('aeon', p_planck_aeon);
    l_main_object.put('max', usim_dbif.get_abs_max_number);
    -- cycle through universes
    FOR usim_rec IN cur_universes
    LOOP
      l_universe_object := new JSON_OBJECT_T;
      l_universe_object.put('id', usim_rec.usim_id_mlv);
      -- Collect all universes in a separate array for fast and easy JS selection and access
      l_universe_select.append(usim_rec.usim_id_mlv);
      FOR mainrec IN cur_planck_pieces(p_planck_aeon, p_from_planck_time, p_to_planck_time, usim_rec.usim_id_mlv)
      LOOP
        l_planck_detail_array := new JSON_ARRAY_T;
        l_planck_time_main    := new JSON_OBJECT_T;
        -- get details for time tick
        FOR rec IN cur_log_details(mainrec.usim_planck_aeon, mainrec.usim_planck_time, usim_rec.usim_id_mlv)
        LOOP
          -- build JSON array like csv to save space
          l_fromto_array :=  '[' || usim_dbif.get_xyz(rec.usim_id_spc_source) || ',' ||
                                    usim_dbif.get_dimension(rec.usim_id_spc_source) || ',' ||
                                    usim_dbif.get_dim_sign(rec.usim_id_spc_source) || ',' ||
                                    usim_dbif.get_dim_n1_sign(rec.usim_id_spc_source) || ',' ||
                                    NVL(rec.usim_energy_source, 0) || ',' ||
                                    usim_dbif.get_xyz(rec.usim_id_spc_target) || ',' ||
                                    usim_dbif.get_dimension(rec.usim_id_spc_target) || ',' ||
                                    usim_dbif.get_dim_sign(rec.usim_id_spc_target) || ',' ||
                                    usim_dbif.get_dim_n1_sign(rec.usim_id_spc_target) || ',' ||
                                    NVL(rec.usim_energy_target,0) || ',' ||
                                    rec.usim_energy_output || ']'
          ;
          l_planck_time_details := new JSON_OBJECT_T;
          l_planck_time_details.put('row', JSON_ARRAY_T.parse(l_fromto_array));
          -- put structure for this tick
          l_planck_detail_array.append(l_planck_time_details);
        END LOOP;
        l_planck_time_main.put('tick', mainrec.usim_planck_time);
        l_planck_time_main.put('data', l_planck_detail_array);
        l_planck_times_array.append(l_planck_time_main);
      END LOOP;
      l_universe_object.put('ticks', l_planck_times_array);
      l_universe_array.append(l_universe_object);
    END LOOP;
    l_main_object.put('select', l_universe_select);
    l_main_object.put('usims', l_universe_array);
    p_json_log := l_main_object.to_clob;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      usim_erl.log_error('usim_creator.get_json_log', 'Unexpected exception SQL code [' || SQLCODE || '] message [' || SQLERRM || '].');
      RETURN -1;
  END get_json_log
  ;

  FUNCTION get_json_struct( p_planck_aeon      IN     usim_spc_process.usim_planck_aeon%TYPE
                          , p_from_planck_time IN     usim_spc_process.usim_planck_time%TYPE
                          , p_to_planck_time   IN     usim_spc_process.usim_planck_time%TYPE
                          , p_json_struct         OUT CLOB
                          )
    RETURN NUMBER
  IS
    l_has_data         NUMBER;
    l_main_object      JSON_OBJECT_T;
    l_universe_object  JSON_OBJECT_T;
    l_universe_array   JSON_ARRAY_T;
    l_zero_array       JSON_ARRAY_T;
    l_zero_node        JSON_OBJECT_T;
    l_node             JSON_OBJECT_T;
    l_node_array       JSON_ARRAY_T;
    l_fromto_array     VARCHAR2(32000);
    l_src_first_tick   INTEGER;
    l_tgt_first_tick   INTEGER;

    -- get all known universes
    CURSOR cur_universes
    IS
      SELECT usim_id_mlv
        FROM usim_multiverse
       ORDER BY usim_is_base_universe DESC
           , usim_id_mlv
    ;
    CURSOR cur_structure(cp_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    IS
      SELECT src_xyz
           , tgt_xyz
           , src_mag
           , src_dim
           , tgt_dim
           , src_dim_sign
           , tgt_dim_sign
           , 0 AS src_n1_sign
           , 0 AS tgt_n1_sign
           , usim_id_mlv
        FROM usim_spo_base3d_v
       WHERE usim_id_mlv = cp_usim_id_mlv
    ;
    CURSOR cur_zero_structure(cp_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    IS
      SELECT src_xyz
           , tgt_xyz
           , src_mag
           , src_dim
           , tgt_dim
           , src_dim_sign
           , tgt_dim_sign
           , NVL(src_n1_sign, 0) AS src_n1_sign
           , NVL(tgt_n1_sign, 0) AS tgt_n1_sign
           , usim_id_mlv
        FROM usim_spo_zero3d_v
       WHERE usim_id_mlv = cp_usim_id_mlv
    ;

  BEGIN
    l_main_object     := new JSON_OBJECT_T;
    l_node_array      := new JSON_ARRAY_T;
    l_zero_array      := new JSON_ARRAY_T;
    l_universe_array  := new JSON_ARRAY_T;
    -- cycle through universes
    FOR usim_rec IN cur_universes
    LOOP
      l_universe_object := new JSON_OBJECT_T;
      l_universe_object.put('id', usim_rec.usim_id_mlv);
      -- zero structure
      FOR mainrec IN cur_zero_structure(usim_rec.usim_id_mlv)
      LOOP
        -- get min planck ticks for first active source and target
        SELECT NVL(MIN(usim_planck_time), -1)
          INTO l_src_first_tick
          FROM usim_spr_v
         WHERE src_id_mlv             = usim_rec.usim_id_mlv
           AND usim_planck_aeon       = p_planck_aeon
           AND usim_planck_time BETWEEN p_from_planck_time
                                    AND p_to_planck_time
           AND src_xyz                = mainrec.src_xyz
           AND src_dim                = mainrec.src_dim
           AND src_dim_sign           = mainrec.src_dim_sign
           AND src_dim_n1_sign        = mainrec.src_n1_sign
        ;
        SELECT NVL(MIN(usim_planck_time), -1)
          INTO l_tgt_first_tick
          FROM usim_spr_v
         WHERE src_id_mlv             = usim_rec.usim_id_mlv
           AND usim_planck_aeon       = p_planck_aeon
           AND usim_planck_time BETWEEN p_from_planck_time
                                    AND p_to_planck_time
           AND tgt_xyz                = mainrec.tgt_xyz
           AND tgt_dim                = mainrec.tgt_dim
           AND tgt_dim_sign           = mainrec.tgt_dim_sign
           AND tgt_dim_n1_sign        = mainrec.tgt_n1_sign
        ;
        -- build JSON array like csv to save space
        l_fromto_array :=  '[' || mainrec.src_xyz || ',' ||
                                  mainrec.src_dim || ',' ||
                                  mainrec.src_dim_sign || ',' ||
                                  mainrec.src_n1_sign || ',' ||
                                  l_src_first_tick || ',' ||
                                  mainrec.tgt_xyz || ',' ||
                                  mainrec.tgt_dim || ',' ||
                                  mainrec.tgt_dim_sign || ',' ||
                                  mainrec.tgt_n1_sign || ',' ||
                                  l_tgt_first_tick || ']'
        ;
        l_zero_node := new JSON_OBJECT_T;
        l_zero_node.put('row', JSON_ARRAY_T.parse(l_fromto_array));
        l_zero_array.append(l_zero_node);
      END LOOP;
      l_universe_object.put('zero', l_zero_array);
      -- xyz relations
      FOR mainrec IN cur_structure(usim_rec.usim_id_mlv)
      LOOP
        -- get min planck ticks for first active source and target
        SELECT NVL(MIN(usim_planck_time), -1)
          INTO l_src_first_tick
          FROM usim_spr_v
         WHERE src_id_mlv             = usim_rec.usim_id_mlv
           AND usim_planck_aeon       = p_planck_aeon
           AND usim_planck_time BETWEEN p_from_planck_time
                                    AND p_to_planck_time
           AND src_xyz                = mainrec.src_xyz
        ;
        SELECT NVL(MIN(usim_planck_time), -1)
          INTO l_tgt_first_tick
          FROM usim_spr_v
         WHERE src_id_mlv             = usim_rec.usim_id_mlv
           AND usim_planck_aeon       = p_planck_aeon
           AND usim_planck_time BETWEEN p_from_planck_time
                                    AND p_to_planck_time
           AND tgt_xyz                = mainrec.tgt_xyz
        ;
        -- build JSON array like csv to save space
        l_fromto_array :=  '[' || mainrec.src_xyz || ',' ||
                                  mainrec.src_dim || ',' ||
                                  mainrec.src_dim_sign || ',' ||
                                  '0,' ||
                                  l_src_first_tick || ',' ||
                                  mainrec.tgt_xyz || ',' ||
                                  mainrec.tgt_dim || ',' ||
                                  mainrec.tgt_dim_sign || ',' ||
                                  '0,' ||
                                  l_tgt_first_tick || ']'
        ;
        -- build main node
        l_node     := new JSON_OBJECT_T;
        l_node.put('row', JSON_ARRAY_T.parse(l_fromto_array));
        l_node_array.append(l_node);
      END LOOP;
      l_universe_object.put('data', l_node_array);
      l_universe_array.append(l_universe_object);
    END LOOP;
    -- add to main object
    l_main_object.put('usims', l_universe_array);
    p_json_struct := l_main_object.to_clob;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      usim_erl.log_error('usim_creator.get_json_struct', 'Unexpected exception SQL code [' || SQLCODE || '] message [' || SQLERRM || '].');
      RETURN NULL;
  END get_json_struct
  ;

  FUNCTION create_json_struct( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
                             , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
                             , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
                             )
    RETURN NUMBER
  IS
    l_json_struct CLOB;
    l_return      NUMBER;
    l_file        NUMBER;
  BEGIN
    IF usim_dbif.has_data_spc = 0
    THEN
      usim_erl.log_error('usim_creator.create_json_struct', 'No data in USIM_SPACE for structure JSON.');
      RETURN 0;
    END IF;
    l_return := usim_creator.get_json_struct(p_planck_aeon, p_from_planck_time, p_to_planck_time, l_json_struct);
    IF l_return = 0
    THEN
      usim_erl.log_error('usim_creator.create_json_struct', 'ERROR getting json space structure.');
      RETURN 0;
    END IF;
    -- write file
    l_file := usim_creator.write_json_file(l_json_struct, 'usim_space_struct');
    IF l_file = 0
    THEN
      usim_erl.log_error('usim_creator.create_json_struct', 'ERROR writing json space structure.');
      RETURN 0;
    END IF;
    RETURN 1;
  END create_json_struct
  ;

  FUNCTION create_space_log( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
                           , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
                           , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
                           )
    RETURN NUMBER
  IS
    l_has_data          NUMBER;
    l_result            NUMBER;
    l_file              NUMBER;
    l_planck_aeon       usim_spc_process.usim_planck_aeon%TYPE;
    l_from_planck_time  usim_spc_process.usim_planck_time%TYPE;
    l_to_planck_time    usim_spc_process.usim_planck_time%TYPE;
    l_json_log          CLOB;
  BEGIN
    SELECT COUNT(*) INTO l_has_data FROM usim_spc_process;
    IF l_has_data = 0
    THEN
      usim_erl.log_error('usim_creator.create_space_log', 'Could not write log without logging data in USIM_SPC_PROCESS, table is empty.');
      RETURN 0;
    END IF;
    -- get aeon to use if NULL
    SELECT COUNT(*) INTO l_has_data FROM usim_spc_process WHERE usim_planck_aeon = NVL(p_planck_aeon, usim_dbif.get_planck_aeon_seq_current);
    IF l_has_data = 0
    THEN
      -- get max aeon in process, maybe a switch has occured after last processing
      SELECT MAX(usim_planck_aeon) INTO l_planck_aeon FROM usim_spc_process;
    ELSE
      l_planck_aeon := NVL(p_planck_aeon, usim_dbif.get_planck_aeon_seq_current);
    END IF;
    -- check from record
    SELECT COUNT(*) INTO l_has_data FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon AND usim_planck_time = p_from_planck_time;
    IF l_has_data = 0
    THEN
      SELECT MIN(usim_planck_time) INTO l_from_planck_time FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon;
    ELSE
      l_from_planck_time := p_from_planck_time;
    END IF;
    -- check to record
    SELECT COUNT(*) INTO l_has_data FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon AND usim_planck_time = p_to_planck_time;
    IF l_has_data = 0
    THEN
      SELECT MAX(usim_planck_time) INTO l_from_planck_time FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon;
    ELSE
      l_to_planck_time := p_to_planck_time;
    END IF;
    -- write JSON log file
    l_result := usim_creator.get_json_log(l_planck_aeon, l_from_planck_time, l_to_planck_time, l_json_log);
    IF l_result = -1
    THEN
      usim_erl.log_error('usim_creator.create_space_log', 'Could not get json space log for from [' || l_planck_aeon || '], [' || l_from_planck_time || '] or to [' || l_to_planck_time || '].');
      RETURN 0;
    ELSE
      l_file := usim_creator.write_json_file(l_json_log, 'usim_space_log');
    END IF;
    -- write associated JSON structure file
    l_result := usim_creator.create_json_struct(l_planck_aeon, l_from_planck_time, l_to_planck_time);
    IF l_result = 0
    THEN
      usim_erl.log_error('usim_creator.create_space_log', 'Could not create associated structure for from [' || l_planck_aeon || '], [' || l_from_planck_time || '] or to [' || l_to_planck_time || '].');
      RETURN 0;
    END IF;
    RETURN 1;
  END create_space_log
  ;

  FUNCTION create_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    usim_erl.log_error('usim_creator.create_next_dimension', 'NOT IMPLEMENTED.');
    RETURN 1;
  END create_next_dimension
  ;

  FUNCTION init_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                         , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                         )
    RETURN usim_dimension.usim_id_dim%TYPE
  IS
  BEGIN
    usim_erl.log_error('usim_creator.init_dimension', 'NOT IMPLEMENTED.');
    RETURN NULL;
  END init_dimension
  ;

  FUNCTION init_dim_axis( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
                        , p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE
                        , p_usim_sign   IN usim_rel_mlv_dim.usim_sign%TYPE
                        , p_do_commit   IN BOOLEAN                          DEFAULT TRUE
                        )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  IS
  BEGIN
    usim_debug.debug_log('usim_creator.init_dim_axis', 'NOT IMPLEMENTED.');
    RETURN NULL;
  END init_dim_axis
  ;

  FUNCTION init_dim_all( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                       , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                       , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                       )
    RETURN NUMBER
  IS
  BEGIN
    usim_debug.debug_log('usim_creator.init_dim_all', 'NOT IMPLEMENTED.');
    RETURN 0;
  END init_dim_all
  ;

  FUNCTION init_zero_dim_nodes( p_usim_id_mlv        IN usim_multiverse.usim_id_mlv%TYPE
                              , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
                              , p_usim_n_dimension   IN usim_dimension.usim_n_dimension%TYPE
                              , p_do_commit          IN BOOLEAN                              DEFAULT TRUE
                              )
    RETURN NUMBER
  IS
  BEGIN
    usim_debug.debug_log('usim_creator.init_zero_dim_nodes', 'NOT IMPLEMENTED.');
    RETURN 0;
  END init_zero_dim_nodes
  ;

  FUNCTION create_new_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                              , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                              , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                              , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                              , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                              , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                              , p_usim_id_spc_parent      IN usim_space.usim_id_spc%TYPE                  DEFAULT NULL
                              , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                              )
    RETURN usim_space.usim_id_spc%TYPE
  IS
    -- zero node dim 0 pos 0
    l_usim_id_spc           usim_space.usim_id_spc%TYPE;
    -- used for parent check
    l_usim_id_spc_parent    usim_space.usim_id_spc%TYPE;
    -- dim 1 n1+ pos +0
    l_id_spc0_n1p_1p        usim_space.usim_id_spc%TYPE;
    -- dim 1 n1- pos -0
    l_id_spc0_n1n_1n        usim_space.usim_id_spc%TYPE;
    -- dim 1 n1+ pos +1
    l_id_spc1p_n1p_1p       usim_space.usim_id_spc%TYPE;
    -- dim 1 n1- pos -1
    l_id_spc1n_n1n_1n       usim_space.usim_id_spc%TYPE;
    -- universe id
    l_usim_id_mlv           usim_multiverse.usim_id_mlv%TYPE;
    -- dim axis 0
    l_usim_id_rmd           usim_rel_mlv_dim.usim_id_rmd%TYPE;
    -- pos 0
    l_usim_id_pos           usim_position.usim_id_pos%TYPE;
    -- pos +1
    l_usim_id_pos_1p        usim_position.usim_id_pos%TYPE;
    -- pos -1
    l_usim_id_pos_1n        usim_position.usim_id_pos%TYPE;
    -- dim axis 1+
    l_id_rmd_n1p_1p         usim_rel_mlv_dim.usim_id_rmd%TYPE;
    -- dim axis 1-
    l_id_rmd_n1n_1n         usim_rel_mlv_dim.usim_id_rmd%TYPE;
    -- dummy of dim axis 0 creation
    l_rmd_dummy             usim_rel_mlv_dim.usim_id_rmd%TYPE;
    -- parents array
    l_parents               usim_static.usim_ids_type;
    l_return                NUMBER;
  BEGIN
    -- check base data, must exist
    IF usim_dbif.has_basedata = 0
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Base data not initialized.');
      RETURN NULL;
    END IF;
    -- a parent must be given, if usim_space has already data, assuming an existing base universe seed.
    IF     usim_dbif.has_data_mlv = 1
       AND p_usim_id_spc_parent  IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Parent for new universe missing, as already data in usim_multiverse exist.');
      RETURN NULL;
    END IF;
    -- ignore parent if usim_space is empty
    IF     usim_dbif.has_data_mlv = 0
       AND p_usim_id_spc_parent  IS NOT NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Ignoring parent assignment [' || p_usim_id_spc_parent || '] on empty multiverse.');
      l_usim_id_spc_parent := NULL;
    ELSE
      l_usim_id_spc_parent := p_usim_id_spc_parent;
    END IF;
    -- create universe
    l_usim_id_mlv := usim_dbif.create_universe( p_usim_energy_start_value
                                              , p_usim_planck_time_unit
                                              , p_usim_planck_length_unit
                                              , p_usim_planck_speed_unit
                                              , p_usim_planck_stable
                                              , p_usim_ultimate_border
                                              , FALSE
                                              )
    ;
    -- if universe creation failed rollback everything
    IF l_usim_id_mlv IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create new universe with data energy start [' || p_usim_energy_start_value || '], planck time [' || p_usim_planck_time_unit || '], planck length [' || p_usim_planck_length_unit || '], planck speed [' || p_usim_planck_speed_unit || '], planck stable [' || p_usim_planck_stable || '] and ultimate border rule [' || p_usim_ultimate_border || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- check and create dimension, if necessary
    l_return := usim_dbif.init_dimensions(FALSE);
    IF l_return = 0
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to init dimensions.');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- check and create positions, if necessary
    l_return := usim_dbif.init_positions(FALSE);
    IF l_return = 0
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to init positions.');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- get position 0
    l_usim_id_pos := usim_dbif.get_id_pos(0);
    IF l_usim_id_pos IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to get position 0.');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- create dim axis
    l_return  := usim_dbif.create_dim_axis(l_usim_id_mlv, 0, NULL, l_usim_id_rmd, l_rmd_dummy, FALSE);
    IF l_return = 0
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create dimension axis for dimension 0 universe id [' || l_usim_id_mlv || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- set parent if available
    IF l_usim_id_spc_parent IS NOT NULL
    THEN
      l_parents(1) := l_usim_id_spc_parent;
    END IF;
    -- create basic space node
    l_usim_id_spc := usim_dbif.create_space_node(l_usim_id_rmd, l_usim_id_pos, l_parents, FALSE);
    IF l_usim_id_spc IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node for rmd id [' || l_usim_id_rmd || '], pos id [' || l_usim_id_pos || '] and parent [' || NVL(l_usim_id_spc_parent, 'NONE') || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- create dim axis (+/-) for dimension 1
    l_return := usim_dbif.create_dim_axis(l_usim_id_mlv, 1, l_usim_id_rmd, l_id_rmd_n1p_1p, l_id_rmd_n1n_1n, FALSE);
    IF l_return = 0
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create dimension axis for dimension 1 universe id [' || l_usim_id_mlv || '] and rmd id [' || l_usim_id_rmd || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- create space nodes on dimension 1
    l_parents(1) := l_usim_id_spc;
    -- +0,0,0
    l_id_spc0_n1p_1p  := usim_dbif.create_space_node(l_id_rmd_n1p_1p, l_usim_id_pos, l_parents, FALSE);
    IF l_id_spc0_n1p_1p IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position +0 at dimension 1, n1+ for rmd id [' || l_id_rmd_n1p_1p || '], pos id [' || l_usim_id_pos || '] and parent [' || NVL(l_usim_id_spc_parent, 'NONE') || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- -0,0,0
    l_id_spc0_n1n_1n  := usim_dbif.create_space_node(l_id_rmd_n1n_1n, l_usim_id_pos, l_parents, FALSE);
    IF l_id_spc0_n1p_1p IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position -0 at dimension 1, n1- for rmd id [' || l_id_rmd_n1n_1n || '], pos id [' || l_usim_id_pos || '] and parent [' || NVL(l_usim_id_spc_parent, 'NONE') || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- get positions 1 (+/-)
    l_usim_id_pos_1p := usim_dbif.get_id_pos(1);
    IF l_usim_id_pos_1p IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to get position +1.');
      ROLLBACK;
      RETURN NULL;
    END IF;
    l_usim_id_pos_1n := usim_dbif.get_id_pos(-1);
    IF l_usim_id_pos_1n IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to get position -1.');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- from here on parents have to have the same dim n1 sign
    -- +1,0,0
    l_parents(1) := l_id_spc0_n1p_1p;
    l_id_spc1p_n1p_1p := usim_dbif.create_space_node(l_id_rmd_n1p_1p, l_usim_id_pos_1p, l_parents, FALSE);
    IF l_id_spc1p_n1p_1p IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position +1 at dimension 1, n1+ for rmd id [' || l_id_rmd_n1p_1p || '], pos id [' || l_usim_id_pos_1p || '] and parent [' || NVL(l_parents(1), 'NONE') || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- -1,0,0
    l_parents(1) := l_id_spc0_n1n_1n;
    l_id_spc1n_n1n_1n := usim_dbif.create_space_node(l_id_rmd_n1n_1n, l_usim_id_pos_1n, l_parents, FALSE);
    IF l_id_spc1p_n1p_1p IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position -1 at dimension 1, n1- for rmd id [' || l_id_rmd_n1n_1n || '], pos id [' || l_usim_id_pos_1n || '] and parent [' || NVL(l_parents(1), 'NONE') || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- now commit if coming so far and do commit is set
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN l_usim_id_spc;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_creator.create_new_universe', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END create_new_universe
  ;

  FUNCTION handle_overflow_dim( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                              , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                              )
    RETURN NUMBER
  IS
    l_dim_parent      usim_space.usim_id_spc%TYPE;
    l_spc_id_pos0p    usim_space.usim_id_spc%TYPE;
    l_spc_id_pos1p    usim_space.usim_id_spc%TYPE;
    l_spc_id_pos0n    usim_space.usim_id_spc%TYPE;
    l_spc_id_pos1n    usim_space.usim_id_spc%TYPE;
    l_id_pos0         usim_position.usim_id_pos%TYPE;
    l_id_pos1p        usim_position.usim_id_pos%TYPE;
    l_id_pos1n        usim_position.usim_id_pos%TYPE;
    l_parents         usim_static.usim_ids_type;
    l_next_dim        usim_dimension.usim_n_dimension%TYPE;
    l_usim_id_mlv     usim_multiverse.usim_id_mlv%TYPE;
    l_usim_id_rmd     usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_usim_id_rmd_p   usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_usim_id_rmd_n   usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_dim_sign        usim_rel_mlv_dim.usim_sign%TYPE;
    l_dim_n1_sign     usim_rel_mlv_dim.usim_n1_sign%TYPE;
    l_result          NUMBER;
    l_classify        NUMBER;
  BEGIN
    l_classify := usim_dbif.is_dim_extendable(p_usim_id_spc, l_dim_parent, l_next_dim);
    IF l_classify = 2
    THEN
      -- get data for create dimension
      l_result := usim_dbif.get_spc_dim_details(l_dim_parent, l_usim_id_mlv, l_usim_id_rmd, l_dim_sign, l_dim_n1_sign);
      IF l_result = 0
      THEN
        usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not fetch data for space id [' || p_usim_id_spc || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      -- create a new dimension on zero pos axis node
      l_result := usim_dbif.create_dim_axis(l_usim_id_mlv, l_next_dim, l_usim_id_rmd, l_usim_id_rmd_p, l_usim_id_rmd_n);
      -- create position 0 and 1 on new dimension
      l_id_pos0      := usim_dbif.get_id_pos(0);
      l_id_pos1p     := usim_dbif.get_id_pos(1);
      l_id_pos1n     := usim_dbif.get_id_pos(-1);
      l_parents(1)   := l_dim_parent;
      l_spc_id_pos0p := usim_dbif.create_space_node(l_usim_id_rmd_p, l_id_pos0, l_parents);
      IF l_spc_id_pos0p IS NULL
      THEN
        usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_p || '], pos [' || l_id_pos0 || '] and parent [' || l_parents(1) || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      l_parents(1)   := l_spc_id_pos0p;
      l_spc_id_pos1p := usim_dbif.create_space_node(l_usim_id_rmd_p, l_id_pos1p, l_parents);
      IF l_spc_id_pos1p IS NULL
      THEN
        usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_p || '], pos [' || l_id_pos1p || '] and parent [' || l_parents(1) || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      l_parents(1)   := l_dim_parent;
      l_spc_id_pos0n := usim_dbif.create_space_node(l_usim_id_rmd_n, l_id_pos0, l_parents);
      IF l_spc_id_pos0n IS NULL
      THEN
        usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_n || '], pos [' || l_id_pos0 || '] and parent [' || l_parents(1) || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      l_parents(1)   := l_spc_id_pos0n;
      l_spc_id_pos1n := usim_dbif.create_space_node(l_usim_id_rmd_n, l_id_pos1n, l_parents);
      IF l_spc_id_pos1n IS NULL
      THEN
        usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_n || '], pos [' || l_id_pos1n || '] and parent [' || l_parents(1) || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      usim_debug.debug_log('usim_creator.handle_overflow_dim', 'Handle new dimension in zero pos for space id [' || p_usim_id_spc || '].');
      RETURN 1;
    ELSIF l_classify = 1
    THEN
      -- connect node to available dimension
      usim_debug.debug_log('usim_creator.handle_overflow_dim', 'Not implemented for space id [' || p_usim_id_spc || '].');
    ELSE
      usim_debug.debug_log('usim_creator.handle_overflow_dim', 'Not implemented for space id [' || p_usim_id_spc || '].');
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_creator.handle_overflow_dim', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END handle_overflow_dim
  ;


  FUNCTION handle_overflow_pos( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                              , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                              )
    RETURN NUMBER
  IS
    l_result    usim_space.usim_id_spc%TYPE;
    l_parent    usim_space.usim_id_spc%TYPE;
    l_parents   usim_static.usim_ids_type;
    l_id_pos    usim_position.usim_id_pos%TYPE;
    l_id_rmd    usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_is_valid  NUMBER;
    l_return    NUMBER;
  BEGIN
    l_is_valid := usim_dbif.is_pos_extendable(p_usim_id_spc);
    IF l_is_valid = 0
    THEN
      usim_erl.log_error('usim_creator.handle_overflow_pos', 'Used invalid node id [' || p_usim_id_spc || '] no axis zero pos or no position free.');
      RETURN 0;
    END IF;
    IF l_is_valid = 1
    THEN
      -- new position with parent current given node
      l_parent := p_usim_id_spc;
    ELSE
      -- get max pos for zero nodes using their dimension settings
      l_parent := usim_dbif.get_axis_max_pos_parent(p_usim_id_spc);
      IF l_parent IS NULL
      THEN
        usim_erl.log_error('usim_creator.handle_overflow_pos', 'Could not retrieve max pos parent id from space node [' || p_usim_id_spc || '].');
        RETURN 0;
      END IF;
    END IF;
    l_parents(1) := l_parent;
    -- get next position and axis
    l_return := usim_dbif.get_next_pos_on_axis(l_parent, l_id_pos, l_id_rmd);
    IF l_return = 0
    THEN
      usim_erl.log_error('usim_creator.handle_overflow_pos', 'usim_dbif.get_next_pos_on_axis failed for parent [' || l_parent || '].');
      RETURN 0;
    END IF;
    -- create space node with parent identified
    l_result := usim_dbif.create_space_node(l_id_rmd, l_id_pos, l_parents, p_do_commit);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_creator.handle_overflow_pos', 'Failed to create space node for rmd [' || l_id_rmd || '], pos [' || l_id_pos || '] and parent [' || l_parents(1) || '].');
      RETURN 0;
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_creator.handle_overflow_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END handle_overflow_pos
  ;

  FUNCTION handle_overflow_between( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                                  , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                                  )
    RETURN NUMBER
  IS
  BEGIN
    -- where are we
    -- if zero pos
    -- if axis, next dimension only a 1 coordinate for connect is possible
    IF usim_spo.is_axis_pos(p_usim_id_spc) = 1
    THEN

      -- has child next dim with pos 1?
      -- no, then delegate next free low pos inbetween.
      NULL;
    ELSE
      -- positions free lower dimension
      -- positions free higher dimension
      NULL;
    END IF;
    usim_debug.debug_log('usim_creator.handle_overflow_between', 'Not implemented yet.');
    RETURN 0;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_creator.handle_overflow_between', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END handle_overflow_between
  ;


  FUNCTION handle_overflow( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                          , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                          )
    RETURN NUMBER
  IS
    l_escape        NUMBER;
    l_result        NUMBER;
    l_id_spc_parent usim_space.usim_id_spc%TYPE;
  BEGIN
    l_escape := usim_dbif.classify_escape(p_usim_id_spc);

    IF l_escape IN (3, 5)
    THEN
      -- escape position 5 and 3 can be handled together
      l_result := usim_creator.handle_overflow_pos(p_usim_id_spc, p_do_commit);
      IF l_result = 0
      THEN
        usim_erl.log_error('usim_creator.handle_overflow', 'Pos overflow handling error for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Handle pos overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    ELSIF l_escape IN (2, 4)
    THEN
      l_result := usim_creator.handle_overflow_dim(p_usim_id_spc, p_do_commit);
      IF l_result = 0
      THEN
        usim_erl.log_error('usim_creator.handle_overflow', 'Dim overflow handling error for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Handle dim overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    ELSIF l_escape = 1
    THEN
      IF usim_dbif.is_pos_extendable(p_usim_id_spc) = 1
      THEN
        l_result := usim_creator.handle_overflow_pos(p_usim_id_spc, p_do_commit);
      ELSE
        l_result := usim_creator.handle_overflow_dim(p_usim_id_spc, p_do_commit);
      END IF;
      IF l_result = 0
      THEN
        usim_erl.log_error('usim_creator.handle_overflow', 'Pos/dim overflow handling error for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Handle overflow pos/dim for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    -- delegate options
    ELSIF l_escape = 7
    THEN
      l_result := usim_creator.handle_overflow_between(p_usim_id_spc, p_do_commit);
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    ELSIF l_escape = 6
    THEN
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    ELSIF l_escape = 5
    THEN
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    ELSIF l_escape = 0
    THEN
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    ELSE
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] with unknown escape strategy [' || l_escape || '].');
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_creator.handle_overflow', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END handle_overflow
  ;

END usim_creator;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_creator
IS
  -- see header for documentation

  FUNCTION write_json_file( p_json_clob IN CLOB
                          , p_filename  IN VARCHAR2 DEFAULT 'usim_space_log'
                          )
    RETURN NUMBER
  IS
    l_file        UTL_FILE.FILE_TYPE;
    l_filename    VARCHAR2(100);
    l_backup      VARCHAR2(100);
    l_buffer      VARCHAR2(8191);
    l_bufsize     CONSTANT BINARY_INTEGER := 8191;
    l_pos         PLS_INTEGER;
    l_clob_len    PLS_INTEGER;
    l_clob        CLOB;
    l_file_exist  BOOLEAN;
    l_file_length NUMBER;
    l_block_size  BINARY_INTEGER;
  BEGIN
    IF LENGTH(p_filename) > 100
    THEN
      usim_erl.log_error('usim_creator.write_json_file', 'Filename [' || p_filename || '] too long.');
      RETURN 0;
    END IF;
    l_clob  := p_json_clob;
    l_filename := TRIM(p_filename) || '.json';
    UTL_FILE.FGETATTR('USIM_DIR', l_filename, l_file_exist, l_file_length, l_block_size);
    IF l_file_exist
    THEN
      l_backup := TRIM(p_filename) || '_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '.json';
      -- "copy" file first by rename, FCOPY requires reading content with required CR limiter before 32767 bytes
      -- furthermore with rename no FREMOVE is required
      UTL_FILE.FRENAME('USIM_DIR', l_filename, 'USIM_HIST_DIR', l_backup);
    END IF;
    -- now write new file
    -- prepare
    l_pos      := 1;
    l_clob_len := DBMS_LOB.GETLENGTH(l_clob);
    l_file     := UTL_FILE.FOPEN('USIM_DIR', l_filename, 'WB', l_bufsize);
    -- get first buffer chunk
    l_buffer   := DBMS_LOB.SUBSTR(l_clob, l_bufsize, l_pos);
    -- loop until last chunk
    WHILE l_pos < l_clob_len
    LOOP
      EXIT WHEN l_buffer IS NULL;
      UTL_FILE.PUT_RAW(l_file, UTL_RAW.CAST_TO_RAW(l_buffer));
      l_pos := l_pos + LEAST(LENGTH(l_buffer) + 1, l_bufsize);
      UTL_FILE.FFLUSH(l_file);
      -- load next buffer chunk
      l_buffer := DBMS_LOB.SUBSTR(l_clob, l_bufsize, l_pos);
    END LOOP;
    -- close file
    UTL_FILE.FCLOSE(l_file);
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      IF UTL_FILE.IS_OPEN(l_file)
      THEN
        UTL_FILE.FCLOSE(l_file);
      END IF;
      usim_erl.log_error('usim_creator.write_json_file', 'Unexpected exception writing JSON log SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      RETURN 0;
  END write_json_file
  ;

  FUNCTION get_json_log( p_planck_aeon      IN     usim_spc_process.usim_planck_aeon%TYPE
                       , p_from_planck_time IN     usim_spc_process.usim_planck_time%TYPE
                       , p_to_planck_time   IN     usim_spc_process.usim_planck_time%TYPE
                       , p_json_log            OUT CLOB
                       )
    RETURN NUMBER
  IS
    l_main_object         JSON_OBJECT_T;
    l_universe_object     JSON_OBJECT_T;
    l_universe_array      JSON_ARRAY_T;
    l_universe_select     JSON_ARRAY_T;
    l_planck_times_array  JSON_ARRAY_T;
    l_planck_detail_array JSON_ARRAY_T;
    l_planck_time_details JSON_OBJECT_T;
    l_planck_time_main    JSON_OBJECT_T;
    l_fromto_array        VARCHAR2(32000);
    l_return              NUMBER;

    -- get all known universes
    CURSOR cur_universes
    IS
      SELECT usim_id_mlv
        FROM usim_multiverse
       ORDER BY usim_is_base_universe DESC
           , usim_id_mlv
    ;
    -- get needed planck pieces with associated universe
    CURSOR cur_planck_pieces( cp_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
                            , cp_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
                            , cp_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
                            , cp_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                            )
    IS
      SELECT usim_planck_aeon
           , usim_planck_time
           , src_id_mlv
        FROM usim_spr_v
       WHERE src_id_mlv             = tgt_id_mlv
         AND src_id_mlv             = cp_usim_id_mlv
         AND usim_planck_aeon       = cp_planck_aeon
         AND usim_planck_time BETWEEN cp_from_planck_time AND cp_to_planck_time
       GROUP BY src_id_mlv
              , usim_planck_aeon
              , usim_planck_time
       ORDER BY src_id_mlv
              , usim_planck_aeon
              , usim_planck_time
    ;
    -- get details on a specific planck aeon and time using ordered view
    CURSOR cur_log_details( cp_planck_aeon IN usim_spc_process.usim_planck_aeon%TYPE
                          , cp_planck_time IN usim_spc_process.usim_planck_time%TYPE
                          , cp_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
                          )
    IS
      SELECT usim_planck_aeon
           , usim_planck_time
           , usim_id_spc_source
           , usim_id_spc_target
           , usim_real_time
           , is_processed
           , usim_energy_source
           , usim_energy_target
           , usim_energy_output
        FROM usim_spr_v
       WHERE src_id_mlv       = tgt_id_mlv
         AND src_id_mlv       = cp_usim_id_mlv
         AND usim_planck_aeon = cp_planck_aeon
         AND usim_planck_time = cp_planck_time
    ;
  BEGIN
    -- check the parameters for given range without universe specified
    SELECT COUNT(*)
      INTO l_return
      FROM (SELECT usim_planck_time
              FROM usim_spc_process
             WHERE usim_planck_aeon = p_planck_aeon
               AND usim_planck_time IN (p_from_planck_time, p_to_planck_time)
             GROUP BY usim_planck_aeon
                    , usim_planck_time
           )
    ;
    IF l_return         NOT IN (1, 2)
       OR p_from_planck_time > p_to_planck_time
    THEN
      usim_erl.log_error('usim_creator.get_json_log', 'Invalid input parameter aeon [' || p_planck_aeon || '], from [' || p_from_planck_time || '] or to [' || p_to_planck_time || '].');
      RETURN -1;
    END IF;
    -- start processing
    l_main_object         := new JSON_OBJECT_T;
    l_planck_times_array  := new JSON_ARRAY_T;
    l_universe_array      := new JSON_ARRAY_T;
    l_universe_select     := new JSON_ARRAY_T;
    l_main_object.put('aeon', p_planck_aeon);
    l_main_object.put('max', usim_dbif.get_abs_max_number);
    -- cycle through universes
    FOR usim_rec IN cur_universes
    LOOP
      l_universe_object := new JSON_OBJECT_T;
      l_universe_object.put('id', usim_rec.usim_id_mlv);
      -- Collect all universes in a separate array for fast and easy JS selection and access
      l_universe_select.append(usim_rec.usim_id_mlv);
      FOR mainrec IN cur_planck_pieces(p_planck_aeon, p_from_planck_time, p_to_planck_time, usim_rec.usim_id_mlv)
      LOOP
        l_planck_detail_array := new JSON_ARRAY_T;
        l_planck_time_main    := new JSON_OBJECT_T;
        -- get details for time tick
        FOR rec IN cur_log_details(mainrec.usim_planck_aeon, mainrec.usim_planck_time, usim_rec.usim_id_mlv)
        LOOP
          -- build JSON array like csv to save space
          l_fromto_array :=  '[' || usim_dbif.get_xyz(rec.usim_id_spc_source) || ',' ||
                                    usim_dbif.get_dimension(rec.usim_id_spc_source) || ',' ||
                                    usim_dbif.get_dim_sign(rec.usim_id_spc_source) || ',' ||
                                    usim_dbif.get_dim_n1_sign(rec.usim_id_spc_source) || ',' ||
                                    NVL(rec.usim_energy_source, 0) || ',' ||
                                    usim_dbif.get_xyz(rec.usim_id_spc_target) || ',' ||
                                    usim_dbif.get_dimension(rec.usim_id_spc_target) || ',' ||
                                    usim_dbif.get_dim_sign(rec.usim_id_spc_target) || ',' ||
                                    usim_dbif.get_dim_n1_sign(rec.usim_id_spc_target) || ',' ||
                                    NVL(rec.usim_energy_target,0) || ',' ||
                                    rec.usim_energy_output || ']'
          ;
          l_planck_time_details := new JSON_OBJECT_T;
          l_planck_time_details.put('row', JSON_ARRAY_T.parse(l_fromto_array));
          -- put structure for this tick
          l_planck_detail_array.append(l_planck_time_details);
        END LOOP;
        l_planck_time_main.put('tick', mainrec.usim_planck_time);
        l_planck_time_main.put('data', l_planck_detail_array);
        l_planck_times_array.append(l_planck_time_main);
      END LOOP;
      l_universe_object.put('ticks', l_planck_times_array);
      l_universe_array.append(l_universe_object);
    END LOOP;
    l_main_object.put('select', l_universe_select);
    l_main_object.put('usims', l_universe_array);
    p_json_log := l_main_object.to_clob;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      usim_erl.log_error('usim_creator.get_json_log', 'Unexpected exception SQL code [' || SQLCODE || '] message [' || SQLERRM || '].');
      RETURN -1;
  END get_json_log
  ;

  FUNCTION get_json_struct( p_planck_aeon      IN     usim_spc_process.usim_planck_aeon%TYPE
                          , p_from_planck_time IN     usim_spc_process.usim_planck_time%TYPE
                          , p_to_planck_time   IN     usim_spc_process.usim_planck_time%TYPE
                          , p_json_struct         OUT CLOB
                          )
    RETURN NUMBER
  IS
    l_has_data         NUMBER;
    l_main_object      JSON_OBJECT_T;
    l_universe_object  JSON_OBJECT_T;
    l_universe_array   JSON_ARRAY_T;
    l_zero_array       JSON_ARRAY_T;
    l_zero_node        JSON_OBJECT_T;
    l_node             JSON_OBJECT_T;
    l_node_array       JSON_ARRAY_T;
    l_fromto_array     VARCHAR2(32000);
    l_src_first_tick   INTEGER;
    l_tgt_first_tick   INTEGER;

    -- get all known universes
    CURSOR cur_universes
    IS
      SELECT usim_id_mlv
        FROM usim_multiverse
       ORDER BY usim_is_base_universe DESC
           , usim_id_mlv
    ;
    CURSOR cur_structure(cp_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    IS
      SELECT src_xyz
           , tgt_xyz
           , src_mag
           , src_dim
           , tgt_dim
           , src_dim_sign
           , tgt_dim_sign
           , 0 AS src_n1_sign
           , 0 AS tgt_n1_sign
           , usim_id_mlv
        FROM usim_spo_base3d_v
       WHERE usim_id_mlv = cp_usim_id_mlv
    ;
    CURSOR cur_zero_structure(cp_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
    IS
      SELECT src_xyz
           , tgt_xyz
           , src_mag
           , src_dim
           , tgt_dim
           , src_dim_sign
           , tgt_dim_sign
           , NVL(src_n1_sign, 0) AS src_n1_sign
           , NVL(tgt_n1_sign, 0) AS tgt_n1_sign
           , usim_id_mlv
        FROM usim_spo_zero3d_v
       WHERE usim_id_mlv = cp_usim_id_mlv
    ;

  BEGIN
    l_main_object     := new JSON_OBJECT_T;
    l_node_array      := new JSON_ARRAY_T;
    l_zero_array      := new JSON_ARRAY_T;
    l_universe_array  := new JSON_ARRAY_T;
    -- cycle through universes
    FOR usim_rec IN cur_universes
    LOOP
      l_universe_object := new JSON_OBJECT_T;
      l_universe_object.put('id', usim_rec.usim_id_mlv);
      -- zero structure
      FOR mainrec IN cur_zero_structure(usim_rec.usim_id_mlv)
      LOOP
        -- get min planck ticks for first active source and target
        SELECT NVL(MIN(usim_planck_time), -1)
          INTO l_src_first_tick
          FROM usim_spr_v
         WHERE src_id_mlv             = usim_rec.usim_id_mlv
           AND usim_planck_aeon       = p_planck_aeon
           AND usim_planck_time BETWEEN p_from_planck_time
                                    AND p_to_planck_time
           AND src_xyz                = mainrec.src_xyz
           AND src_dim                = mainrec.src_dim
           AND src_dim_sign           = mainrec.src_dim_sign
           AND src_dim_n1_sign        = mainrec.src_n1_sign
        ;
        SELECT NVL(MIN(usim_planck_time), -1)
          INTO l_tgt_first_tick
          FROM usim_spr_v
         WHERE src_id_mlv             = usim_rec.usim_id_mlv
           AND usim_planck_aeon       = p_planck_aeon
           AND usim_planck_time BETWEEN p_from_planck_time
                                    AND p_to_planck_time
           AND tgt_xyz                = mainrec.tgt_xyz
           AND tgt_dim                = mainrec.tgt_dim
           AND tgt_dim_sign           = mainrec.tgt_dim_sign
           AND tgt_dim_n1_sign        = mainrec.tgt_n1_sign
        ;
        -- build JSON array like csv to save space
        l_fromto_array :=  '[' || mainrec.src_xyz || ',' ||
                                  mainrec.src_dim || ',' ||
                                  mainrec.src_dim_sign || ',' ||
                                  mainrec.src_n1_sign || ',' ||
                                  l_src_first_tick || ',' ||
                                  mainrec.tgt_xyz || ',' ||
                                  mainrec.tgt_dim || ',' ||
                                  mainrec.tgt_dim_sign || ',' ||
                                  mainrec.tgt_n1_sign || ',' ||
                                  l_tgt_first_tick || ']'
        ;
        l_zero_node := new JSON_OBJECT_T;
        l_zero_node.put('row', JSON_ARRAY_T.parse(l_fromto_array));
        l_zero_array.append(l_zero_node);
      END LOOP;
      l_universe_object.put('zero', l_zero_array);
      -- xyz relations
      FOR mainrec IN cur_structure(usim_rec.usim_id_mlv)
      LOOP
        -- get min planck ticks for first active source and target
        SELECT NVL(MIN(usim_planck_time), -1)
          INTO l_src_first_tick
          FROM usim_spr_v
         WHERE src_id_mlv             = usim_rec.usim_id_mlv
           AND usim_planck_aeon       = p_planck_aeon
           AND usim_planck_time BETWEEN p_from_planck_time
                                    AND p_to_planck_time
           AND src_xyz                = mainrec.src_xyz
        ;
        SELECT NVL(MIN(usim_planck_time), -1)
          INTO l_tgt_first_tick
          FROM usim_spr_v
         WHERE src_id_mlv             = usim_rec.usim_id_mlv
           AND usim_planck_aeon       = p_planck_aeon
           AND usim_planck_time BETWEEN p_from_planck_time
                                    AND p_to_planck_time
           AND tgt_xyz                = mainrec.tgt_xyz
        ;
        -- build JSON array like csv to save space
        l_fromto_array :=  '[' || mainrec.src_xyz || ',' ||
                                  mainrec.src_dim || ',' ||
                                  mainrec.src_dim_sign || ',' ||
                                  '0,' ||
                                  l_src_first_tick || ',' ||
                                  mainrec.tgt_xyz || ',' ||
                                  mainrec.tgt_dim || ',' ||
                                  mainrec.tgt_dim_sign || ',' ||
                                  '0,' ||
                                  l_tgt_first_tick || ']'
        ;
        -- build main node
        l_node     := new JSON_OBJECT_T;
        l_node.put('row', JSON_ARRAY_T.parse(l_fromto_array));
        l_node_array.append(l_node);
      END LOOP;
      l_universe_object.put('data', l_node_array);
      l_universe_array.append(l_universe_object);
    END LOOP;
    -- add to main object
    l_main_object.put('usims', l_universe_array);
    p_json_struct := l_main_object.to_clob;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      usim_erl.log_error('usim_creator.get_json_struct', 'Unexpected exception SQL code [' || SQLCODE || '] message [' || SQLERRM || '].');
      RETURN NULL;
  END get_json_struct
  ;

  FUNCTION create_json_struct( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
                             , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
                             , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
                             )
    RETURN NUMBER
  IS
    l_json_struct CLOB;
    l_return      NUMBER;
    l_file        NUMBER;
  BEGIN
    IF usim_dbif.has_data_spc = 0
    THEN
      usim_erl.log_error('usim_creator.create_json_struct', 'No data in USIM_SPACE for structure JSON.');
      RETURN 0;
    END IF;
    l_return := usim_creator.get_json_struct(p_planck_aeon, p_from_planck_time, p_to_planck_time, l_json_struct);
    IF l_return = 0
    THEN
      usim_erl.log_error('usim_creator.create_json_struct', 'ERROR getting json space structure.');
      RETURN 0;
    END IF;
    -- write file
    l_file := usim_creator.write_json_file(l_json_struct, 'usim_space_struct');
    IF l_file = 0
    THEN
      usim_erl.log_error('usim_creator.create_json_struct', 'ERROR writing json space structure.');
      RETURN 0;
    END IF;
    RETURN 1;
  END create_json_struct
  ;

  FUNCTION create_space_log( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
                           , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
                           , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
                           )
    RETURN NUMBER
  IS
    l_has_data          NUMBER;
    l_result            NUMBER;
    l_file              NUMBER;
    l_planck_aeon       usim_spc_process.usim_planck_aeon%TYPE;
    l_from_planck_time  usim_spc_process.usim_planck_time%TYPE;
    l_to_planck_time    usim_spc_process.usim_planck_time%TYPE;
    l_json_log          CLOB;
  BEGIN
    SELECT COUNT(*) INTO l_has_data FROM usim_spc_process;
    IF l_has_data = 0
    THEN
      usim_erl.log_error('usim_creator.create_space_log', 'Could not write log without logging data in USIM_SPC_PROCESS, table is empty.');
      RETURN 0;
    END IF;
    -- get aeon to use if NULL
    SELECT COUNT(*) INTO l_has_data FROM usim_spc_process WHERE usim_planck_aeon = NVL(p_planck_aeon, usim_dbif.get_planck_aeon_seq_current);
    IF l_has_data = 0
    THEN
      -- get max aeon in process, maybe a switch has occured after last processing
      SELECT MAX(usim_planck_aeon) INTO l_planck_aeon FROM usim_spc_process;
    ELSE
      l_planck_aeon := NVL(p_planck_aeon, usim_dbif.get_planck_aeon_seq_current);
    END IF;
    -- check from record
    SELECT COUNT(*) INTO l_has_data FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon AND usim_planck_time = p_from_planck_time;
    IF l_has_data = 0
    THEN
      SELECT MIN(usim_planck_time) INTO l_from_planck_time FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon;
    ELSE
      l_from_planck_time := p_from_planck_time;
    END IF;
    -- check to record
    SELECT COUNT(*) INTO l_has_data FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon AND usim_planck_time = p_to_planck_time;
    IF l_has_data = 0
    THEN
      SELECT MAX(usim_planck_time) INTO l_from_planck_time FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon;
    ELSE
      l_to_planck_time := p_to_planck_time;
    END IF;
    -- write JSON log file
    l_result := usim_creator.get_json_log(l_planck_aeon, l_from_planck_time, l_to_planck_time, l_json_log);
    IF l_result = -1
    THEN
      usim_erl.log_error('usim_creator.create_space_log', 'Could not get json space log for from [' || l_planck_aeon || '], [' || l_from_planck_time || '] or to [' || l_to_planck_time || '].');
      RETURN 0;
    ELSE
      l_file := usim_creator.write_json_file(l_json_log, 'usim_space_log');
    END IF;
    -- write associated JSON structure file
    l_result := usim_creator.create_json_struct(l_planck_aeon, l_from_planck_time, l_to_planck_time);
    IF l_result = 0
    THEN
      usim_erl.log_error('usim_creator.create_space_log', 'Could not create associated structure for from [' || l_planck_aeon || '], [' || l_from_planck_time || '] or to [' || l_to_planck_time || '].');
      RETURN 0;
    END IF;
    RETURN 1;
  END create_space_log
  ;

  FUNCTION create_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    RETURN NUMBER
  IS
  BEGIN
    usim_erl.log_error('usim_creator.create_next_dimension', 'NOT IMPLEMENTED.');
    RETURN 1;
  END create_next_dimension
  ;

  FUNCTION init_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                         , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                         )
    RETURN usim_dimension.usim_id_dim%TYPE
  IS
  BEGIN
    usim_erl.log_error('usim_creator.init_dimension', 'NOT IMPLEMENTED.');
    RETURN NULL;
  END init_dimension
  ;

  FUNCTION init_dim_axis( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
                        , p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE
                        , p_usim_sign   IN usim_rel_mlv_dim.usim_sign%TYPE
                        , p_do_commit   IN BOOLEAN                          DEFAULT TRUE
                        )
    RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
  IS
  BEGIN
    usim_debug.debug_log('usim_creator.init_dim_axis', 'NOT IMPLEMENTED.');
    RETURN NULL;
  END init_dim_axis
  ;

  FUNCTION init_dim_all( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
                       , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
                       , p_do_commit        IN BOOLEAN                              DEFAULT TRUE
                       )
    RETURN NUMBER
  IS
  BEGIN
    usim_debug.debug_log('usim_creator.init_dim_all', 'NOT IMPLEMENTED.');
    RETURN 0;
  END init_dim_all
  ;

  FUNCTION init_zero_dim_nodes( p_usim_id_mlv        IN usim_multiverse.usim_id_mlv%TYPE
                              , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
                              , p_usim_n_dimension   IN usim_dimension.usim_n_dimension%TYPE
                              , p_do_commit          IN BOOLEAN                              DEFAULT TRUE
                              )
    RETURN NUMBER
  IS
  BEGIN
    usim_debug.debug_log('usim_creator.init_zero_dim_nodes', 'NOT IMPLEMENTED.');
    RETURN 0;
  END init_zero_dim_nodes
  ;

  FUNCTION create_new_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                              , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                              , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                              , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                              , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                              , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                              , p_usim_id_spc_parent      IN usim_space.usim_id_spc%TYPE                  DEFAULT NULL
                              , p_do_commit               IN BOOLEAN                                      DEFAULT TRUE
                              )
    RETURN usim_space.usim_id_spc%TYPE
  IS
    -- zero node dim 0 pos 0
    l_usim_id_spc           usim_space.usim_id_spc%TYPE;
    -- used for parent check
    l_usim_id_spc_parent    usim_space.usim_id_spc%TYPE;
    -- dim 1 n1+ pos +0
    l_id_spc0_n1p_1p        usim_space.usim_id_spc%TYPE;
    -- dim 1 n1- pos -0
    l_id_spc0_n1n_1n        usim_space.usim_id_spc%TYPE;
    -- dim 1 n1+ pos +1
    l_id_spc1p_n1p_1p       usim_space.usim_id_spc%TYPE;
    -- dim 1 n1- pos -1
    l_id_spc1n_n1n_1n       usim_space.usim_id_spc%TYPE;
    -- universe id
    l_usim_id_mlv           usim_multiverse.usim_id_mlv%TYPE;
    -- dim axis 0
    l_usim_id_rmd           usim_rel_mlv_dim.usim_id_rmd%TYPE;
    -- pos 0
    l_usim_id_pos           usim_position.usim_id_pos%TYPE;
    -- pos +1
    l_usim_id_pos_1p        usim_position.usim_id_pos%TYPE;
    -- pos -1
    l_usim_id_pos_1n        usim_position.usim_id_pos%TYPE;
    -- dim axis 1+
    l_id_rmd_n1p_1p         usim_rel_mlv_dim.usim_id_rmd%TYPE;
    -- dim axis 1-
    l_id_rmd_n1n_1n         usim_rel_mlv_dim.usim_id_rmd%TYPE;
    -- dummy of dim axis 0 creation
    l_rmd_dummy             usim_rel_mlv_dim.usim_id_rmd%TYPE;
    -- parents array
    l_parents               usim_static.usim_ids_type;
    l_return                NUMBER;
  BEGIN
    -- check base data, must exist
    IF usim_dbif.has_basedata = 0
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Base data not initialized.');
      RETURN NULL;
    END IF;
    -- a parent must be given, if usim_space has already data, assuming an existing base universe seed.
    IF     usim_dbif.has_data_mlv = 1
       AND p_usim_id_spc_parent  IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Parent for new universe missing, as already data in usim_multiverse exist.');
      RETURN NULL;
    END IF;
    -- ignore parent if usim_space is empty
    IF     usim_dbif.has_data_mlv = 0
       AND p_usim_id_spc_parent  IS NOT NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Ignoring parent assignment [' || p_usim_id_spc_parent || '] on empty multiverse.');
      l_usim_id_spc_parent := NULL;
    ELSE
      l_usim_id_spc_parent := p_usim_id_spc_parent;
    END IF;
    -- create universe
    l_usim_id_mlv := usim_dbif.create_universe( p_usim_energy_start_value
                                              , p_usim_planck_time_unit
                                              , p_usim_planck_length_unit
                                              , p_usim_planck_speed_unit
                                              , p_usim_planck_stable
                                              , p_usim_ultimate_border
                                              , FALSE
                                              )
    ;
    -- if universe creation failed rollback everything
    IF l_usim_id_mlv IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create new universe with data energy start [' || p_usim_energy_start_value || '], planck time [' || p_usim_planck_time_unit || '], planck length [' || p_usim_planck_length_unit || '], planck speed [' || p_usim_planck_speed_unit || '], planck stable [' || p_usim_planck_stable || '] and ultimate border rule [' || p_usim_ultimate_border || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- check and create dimension, if necessary
    l_return := usim_dbif.init_dimensions(FALSE);
    IF l_return = 0
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to init dimensions.');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- check and create positions, if necessary
    l_return := usim_dbif.init_positions(FALSE);
    IF l_return = 0
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to init positions.');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- get position 0
    l_usim_id_pos := usim_dbif.get_id_pos(0);
    IF l_usim_id_pos IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to get position 0.');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- create dim axis
    l_return  := usim_dbif.create_dim_axis(l_usim_id_mlv, 0, NULL, l_usim_id_rmd, l_rmd_dummy, FALSE);
    IF l_return = 0
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create dimension axis for dimension 0 universe id [' || l_usim_id_mlv || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- set parent if available
    IF l_usim_id_spc_parent IS NOT NULL
    THEN
      l_parents(1) := l_usim_id_spc_parent;
    END IF;
    -- create basic space node
    l_usim_id_spc := usim_dbif.create_space_node(l_usim_id_rmd, l_usim_id_pos, l_parents, FALSE);
    IF l_usim_id_spc IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node for rmd id [' || l_usim_id_rmd || '], pos id [' || l_usim_id_pos || '] and parent [' || NVL(l_usim_id_spc_parent, 'NONE') || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- create dim axis (+/-) for dimension 1
    l_return := usim_dbif.create_dim_axis(l_usim_id_mlv, 1, l_usim_id_rmd, l_id_rmd_n1p_1p, l_id_rmd_n1n_1n, FALSE);
    IF l_return = 0
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create dimension axis for dimension 1 universe id [' || l_usim_id_mlv || '] and rmd id [' || l_usim_id_rmd || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- create space nodes on dimension 1
    l_parents(1) := l_usim_id_spc;
    -- +0,0,0
    l_id_spc0_n1p_1p  := usim_dbif.create_space_node(l_id_rmd_n1p_1p, l_usim_id_pos, l_parents, FALSE);
    IF l_id_spc0_n1p_1p IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position +0 at dimension 1, n1+ for rmd id [' || l_id_rmd_n1p_1p || '], pos id [' || l_usim_id_pos || '] and parent [' || NVL(l_usim_id_spc_parent, 'NONE') || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- -0,0,0
    l_id_spc0_n1n_1n  := usim_dbif.create_space_node(l_id_rmd_n1n_1n, l_usim_id_pos, l_parents, FALSE);
    IF l_id_spc0_n1p_1p IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position -0 at dimension 1, n1- for rmd id [' || l_id_rmd_n1n_1n || '], pos id [' || l_usim_id_pos || '] and parent [' || NVL(l_usim_id_spc_parent, 'NONE') || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- get positions 1 (+/-)
    l_usim_id_pos_1p := usim_dbif.get_id_pos(1);
    IF l_usim_id_pos_1p IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to get position +1.');
      ROLLBACK;
      RETURN NULL;
    END IF;
    l_usim_id_pos_1n := usim_dbif.get_id_pos(-1);
    IF l_usim_id_pos_1n IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to get position -1.');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- from here on parents have to have the same dim n1 sign
    -- +1,0,0
    l_parents(1) := l_id_spc0_n1p_1p;
    l_id_spc1p_n1p_1p := usim_dbif.create_space_node(l_id_rmd_n1p_1p, l_usim_id_pos_1p, l_parents, FALSE);
    IF l_id_spc1p_n1p_1p IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position +1 at dimension 1, n1+ for rmd id [' || l_id_rmd_n1p_1p || '], pos id [' || l_usim_id_pos_1p || '] and parent [' || NVL(l_parents(1), 'NONE') || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- -1,0,0
    l_parents(1) := l_id_spc0_n1n_1n;
    l_id_spc1n_n1n_1n := usim_dbif.create_space_node(l_id_rmd_n1n_1n, l_usim_id_pos_1n, l_parents, FALSE);
    IF l_id_spc1p_n1p_1p IS NULL
    THEN
      usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position -1 at dimension 1, n1- for rmd id [' || l_id_rmd_n1n_1n || '], pos id [' || l_usim_id_pos_1n || '] and parent [' || NVL(l_parents(1), 'NONE') || '].');
      ROLLBACK;
      RETURN NULL;
    END IF;
    -- now commit if coming so far and do commit is set
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN l_usim_id_spc;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_creator.create_new_universe', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END create_new_universe
  ;

  FUNCTION handle_overflow_dim( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                              , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                              )
    RETURN NUMBER
  IS
    l_dim_parent      usim_space.usim_id_spc%TYPE;
    l_spc_id_pos0p    usim_space.usim_id_spc%TYPE;
    l_spc_id_pos1p    usim_space.usim_id_spc%TYPE;
    l_spc_id_pos0n    usim_space.usim_id_spc%TYPE;
    l_spc_id_pos1n    usim_space.usim_id_spc%TYPE;
    l_id_pos0         usim_position.usim_id_pos%TYPE;
    l_id_pos1p        usim_position.usim_id_pos%TYPE;
    l_id_pos1n        usim_position.usim_id_pos%TYPE;
    l_parents         usim_static.usim_ids_type;
    l_next_dim        usim_dimension.usim_n_dimension%TYPE;
    l_usim_id_mlv     usim_multiverse.usim_id_mlv%TYPE;
    l_usim_id_rmd     usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_usim_id_rmd_p   usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_usim_id_rmd_n   usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_dim_sign        usim_rel_mlv_dim.usim_sign%TYPE;
    l_dim_n1_sign     usim_rel_mlv_dim.usim_n1_sign%TYPE;
    l_result          NUMBER;
    l_classify        NUMBER;
  BEGIN
    l_classify := usim_dbif.is_dim_extendable(p_usim_id_spc, l_dim_parent, l_next_dim);
    IF l_classify = 2
    THEN
      -- get data for create dimension
      l_result := usim_dbif.get_spc_dim_details(l_dim_parent, l_usim_id_mlv, l_usim_id_rmd, l_dim_sign, l_dim_n1_sign);
      IF l_result = 0
      THEN
        usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not fetch data for space id [' || p_usim_id_spc || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      -- create a new dimension on zero pos axis node
      l_result := usim_dbif.create_dim_axis(l_usim_id_mlv, l_next_dim, l_usim_id_rmd, l_usim_id_rmd_p, l_usim_id_rmd_n);
      -- create position 0 and 1 on new dimension
      l_id_pos0      := usim_dbif.get_id_pos(0);
      l_id_pos1p     := usim_dbif.get_id_pos(1);
      l_id_pos1n     := usim_dbif.get_id_pos(-1);
      l_parents(1)   := l_dim_parent;
      l_spc_id_pos0p := usim_dbif.create_space_node(l_usim_id_rmd_p, l_id_pos0, l_parents);
      IF l_spc_id_pos0p IS NULL
      THEN
        usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_p || '], pos [' || l_id_pos0 || '] and parent [' || l_parents(1) || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      l_parents(1)   := l_spc_id_pos0p;
      l_spc_id_pos1p := usim_dbif.create_space_node(l_usim_id_rmd_p, l_id_pos1p, l_parents);
      IF l_spc_id_pos1p IS NULL
      THEN
        usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_p || '], pos [' || l_id_pos1p || '] and parent [' || l_parents(1) || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      l_parents(1)   := l_dim_parent;
      l_spc_id_pos0n := usim_dbif.create_space_node(l_usim_id_rmd_n, l_id_pos0, l_parents);
      IF l_spc_id_pos0n IS NULL
      THEN
        usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_n || '], pos [' || l_id_pos0 || '] and parent [' || l_parents(1) || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      l_parents(1)   := l_spc_id_pos0n;
      l_spc_id_pos1n := usim_dbif.create_space_node(l_usim_id_rmd_n, l_id_pos1n, l_parents);
      IF l_spc_id_pos1n IS NULL
      THEN
        usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_n || '], pos [' || l_id_pos1n || '] and parent [' || l_parents(1) || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      usim_debug.debug_log('usim_creator.handle_overflow_dim', 'Handle new dimension in zero pos for space id [' || p_usim_id_spc || '].');
      RETURN 1;
    ELSIF l_classify = 1
    THEN
      -- connect node to available dimension
      usim_debug.debug_log('usim_creator.handle_overflow_dim', 'Not implemented for space id [' || p_usim_id_spc || '].');
    ELSE
      usim_debug.debug_log('usim_creator.handle_overflow_dim', 'Not implemented for space id [' || p_usim_id_spc || '].');
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_creator.handle_overflow_dim', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END handle_overflow_dim
  ;


  FUNCTION handle_overflow_pos( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                              , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                              )
    RETURN NUMBER
  IS
    l_result    usim_space.usim_id_spc%TYPE;
    l_parent    usim_space.usim_id_spc%TYPE;
    l_parents   usim_static.usim_ids_type;
    l_id_pos    usim_position.usim_id_pos%TYPE;
    l_id_rmd    usim_rel_mlv_dim.usim_id_rmd%TYPE;
    l_is_valid  NUMBER;
    l_return    NUMBER;
  BEGIN
    l_is_valid := usim_dbif.is_pos_extendable(p_usim_id_spc);
    IF l_is_valid = 0
    THEN
      usim_erl.log_error('usim_creator.handle_overflow_pos', 'Used invalid node id [' || p_usim_id_spc || '] no axis zero pos or no position free.');
      RETURN 0;
    END IF;
    IF l_is_valid = 1
    THEN
      -- new position with parent current given node
      l_parent := p_usim_id_spc;
    ELSE
      -- get max pos for zero nodes using their dimension settings
      l_parent := usim_dbif.get_axis_max_pos_parent(p_usim_id_spc);
      IF l_parent IS NULL
      THEN
        usim_erl.log_error('usim_creator.handle_overflow_pos', 'Could not retrieve max pos parent id from space node [' || p_usim_id_spc || '].');
        RETURN 0;
      END IF;
    END IF;
    l_parents(1) := l_parent;
    -- get next position and axis
    l_return := usim_dbif.get_next_pos_on_axis(l_parent, l_id_pos, l_id_rmd);
    IF l_return = 0
    THEN
      usim_erl.log_error('usim_creator.handle_overflow_pos', 'usim_dbif.get_next_pos_on_axis failed for parent [' || l_parent || '].');
      RETURN 0;
    END IF;
    -- create space node with parent identified
    l_result := usim_dbif.create_space_node(l_id_rmd, l_id_pos, l_parents, p_do_commit);
    IF l_result IS NULL
    THEN
      usim_erl.log_error('usim_creator.handle_overflow_pos', 'Failed to create space node for rmd [' || l_id_rmd || '], pos [' || l_id_pos || '] and parent [' || l_parents(1) || '].');
      RETURN 0;
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_creator.handle_overflow_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END handle_overflow_pos
  ;

  FUNCTION handle_overflow_between( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                                  , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                                  )
    RETURN NUMBER
  IS
  BEGIN
    -- where are we
    -- if zero pos
    -- if axis, next dimension only a 1 coordinate for connect is possible
    IF usim_spo.is_axis_pos(p_usim_id_spc) = 1
    THEN

      -- has child next dim with pos 1?
      -- no, then delegate next free low pos inbetween.
      NULL;
    ELSE
      -- positions free lower dimension
      -- positions free higher dimension
      NULL;
    END IF;
    usim_debug.debug_log('usim_creator.handle_overflow_between', 'Not implemented yet.');
    RETURN 0;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_creator.handle_overflow_between', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END handle_overflow_between
  ;


  FUNCTION handle_overflow( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                          , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                          )
    RETURN NUMBER
  IS
    l_escape        NUMBER;
    l_result        NUMBER;
    l_id_spc_parent usim_space.usim_id_spc%TYPE;
  BEGIN
    l_escape := usim_dbif.classify_escape(p_usim_id_spc);

    IF l_escape IN (3, 5)
    THEN
      -- escape position 5 and 3 can be handled together
      l_result := usim_creator.handle_overflow_pos(p_usim_id_spc, p_do_commit);
      IF l_result = 0
      THEN
        usim_erl.log_error('usim_creator.handle_overflow', 'Pos overflow handling error for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Handle pos overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    ELSIF l_escape IN (2, 4)
    THEN
      l_result := usim_creator.handle_overflow_dim(p_usim_id_spc, p_do_commit);
      IF l_result = 0
      THEN
        usim_erl.log_error('usim_creator.handle_overflow', 'Dim overflow handling error for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Handle dim overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    ELSIF l_escape = 1
    THEN
      IF usim_dbif.is_pos_extendable(p_usim_id_spc) = 1
      THEN
        l_result := usim_creator.handle_overflow_pos(p_usim_id_spc, p_do_commit);
      ELSE
        l_result := usim_creator.handle_overflow_dim(p_usim_id_spc, p_do_commit);
      END IF;
      IF l_result = 0
      THEN
        usim_erl.log_error('usim_creator.handle_overflow', 'Pos/dim overflow handling error for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Handle overflow pos/dim for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    -- delegate options
    ELSIF l_escape = 7
    THEN
      l_result := usim_creator.handle_overflow_between(p_usim_id_spc, p_do_commit);
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    ELSIF l_escape = 6
    THEN
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    ELSIF l_escape = 5
    THEN
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    ELSIF l_escape = 0
    THEN
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
    ELSE
      usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] with unknown escape strategy [' || l_escape || '].');
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      -- write error might still work
      usim_erl.log_error('usim_creator.handle_overflow', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END handle_overflow
  ;

END usim_creator;

Package Body USIM_CREATOR kompiliert

SQL> @@../PACKAGES/USIM_PROCESS.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_process
  2  IS
  3    /**A package for processing space nodes. Depends on all available packages including USIM_CREATOR.*/
  4
  5    /**
  6    * Provides a process start node in the queue. The start node is always the base universe seed at position 0 and dimension 0
  7    * without any parent. The process direction is childs. Should be called only once. Will do nothing if processing nodes already
  8    * exist. Will create base data with given parameters, if missing, intialize planck time if not done and create a universe seed, if it
  9    * does not exist using given parameters. Will activate the universe, if not active.
 10    * @param p_max_dimension The maximum dimensions possible for this multiverse. Base data init.
 11    * @param p_usim_abs_max_number The absolute maximum number available for this multiverse. Base data init.
 12    * @param p_usim_overflow_node_seed Defines the overflow behaviour, default 0 means standard overflow behaviour. If set to 1, all new nodes are created with the universe seed at coordinate 0 as the parent. Base data init.
 13    * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used or default if NULL or 0. Universe seed init.
 14    * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value or default if NULL or 0. Universe seed init.
 15    * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value or default if NULL or 0. Universe seed init.
 16    * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value or default if NULL or 0. Universe seed init.
 17    * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct. Universe seed init.
 18    * @param p_usim_ultimate_border The ultimate border rule for this universe. 1 is ultimate border reached, no childs left, 0 is any border at dimensions axis even with childs left. Universe seed init.
 19    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 20    * @return Return 1 if all was successfully processed otherwise 0.
 21    */
 22    FUNCTION place_start_node( p_max_dimension            IN NUMBER                                       DEFAULT 42
 23                             , p_usim_abs_max_number      IN NUMBER                                       DEFAULT 99999999999999999999999999999999999999
 24                             , p_usim_overflow_node_seed  IN NUMBER                                       DEFAULT 0
 25                             , p_usim_energy_start_value  IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
 26                             , p_usim_planck_time_unit    IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
 27                             , p_usim_planck_length_unit  IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
 28                             , p_usim_planck_speed_unit   IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
 29                             , p_usim_planck_stable       IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
 30                             , p_usim_ultimate_border     IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
 31                             , p_do_commit                IN BOOLEAN                                      DEFAULT TRUE
 32                             )
 33      RETURN NUMBER
 34    ;
 35
 36    /**
 37    * Processes a given space node by sending out energy either to child or parent nodes. Handles
 38    * border situation for process direction.
 39    * Will update table USIM_SPC_PROCESS. Using package USIM_MATHS for calculations.
 40    * @param p_usim_id_spc The space node to process. Mandatory.
 41    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 42    * @return Return 1 if all was successfully processed otherwise 0.
 43    */
 44    FUNCTION process_node( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
 45                         , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
 46                         )
 47      RETURN NUMBER
 48    ;
 49
 50    /**
 51    * Processes currently open outputs, sums up the target nodes and updates targets energy. Starts
 52    * then processing target nodes as source nodes. Handles overflows and necessary actions like dimension creation.
 53    * Overflow can result in infinity or in NUMERIC OVERFLOW!!!!
 54    * Updates the planck time. Will write result to table USIM_SPC_PROCESS. Using package USIM_MATHS for calculations.
 55    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 56    * @return Return 1 if all was successfully processed otherwise 0.
 57    */
 58    FUNCTION process_queue(p_do_commit IN BOOLEAN DEFAULT TRUE)
 59      RETURN NUMBER
 60    ;
 61
 62    /**
 63    * Will update the state of all universes in the multiverse. Run after execution usim_process.process_queue.
 64    * @return Return 1 if all was successfully processed otherwise 0.
 65    */
 66    FUNCTION update_universe_states(p_do_commit IN BOOLEAN DEFAULT TRUE)
 67      RETURN NUMBER
 68    ;
 69
 70    /**
 71    * Runs the process queue for the given amount of times or as long as the system is valid. Will update
 72    * state of the current universes.
 73    * @return Return 1 if all was successfully processed otherwise 0.
 74    */
 75    FUNCTION run_samples( p_run_count IN NUMBER
 76                        , p_do_commit IN BOOLEAN DEFAULT TRUE
 77                        )
 78      RETURN NUMBER
 79    ;
 80
 81  END usim_process;
 82  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_process
IS
  /**A package for processing space nodes. Depends on all available packages including USIM_CREATOR.*/

  /**
  * Provides a process start node in the queue. The start node is always the base universe seed at position 0 and dimension 0
  * without any parent. The process direction is childs. Should be called only once. Will do nothing if processing nodes already
  * exist. Will create base data with given parameters, if missing, intialize planck time if not done and create a universe seed, if it
  * does not exist using given parameters. Will activate the universe, if not active.
  * @param p_max_dimension The maximum dimensions possible for this multiverse. Base data init.
  * @param p_usim_abs_max_number The absolute maximum number available for this multiverse. Base data init.
  * @param p_usim_overflow_node_seed Defines the overflow behaviour, default 0 means standard overflow behaviour. If set to 1, all new nodes are created with the universe seed at coordinate 0 as the parent. Base data init.
  * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used or default if NULL or 0. Universe seed init.
  * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value or default if NULL or 0. Universe seed init.
  * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value or default if NULL or 0. Universe seed init.
  * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value or default if NULL or 0. Universe seed init.
  * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct. Universe seed init.
  * @param p_usim_ultimate_border The ultimate border rule for this universe. 1 is ultimate border reached, no childs left, 0 is any border at dimensions axis even with childs left. Universe seed init.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Return 1 if all was successfully processed otherwise 0.
  */
  FUNCTION place_start_node( p_max_dimension            IN NUMBER                                       DEFAULT 42
                           , p_usim_abs_max_number      IN NUMBER                                       DEFAULT 99999999999999999999999999999999999999
                           , p_usim_overflow_node_seed  IN NUMBER                                       DEFAULT 0
                           , p_usim_energy_start_value  IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                           , p_usim_planck_time_unit    IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                           , p_usim_planck_length_unit  IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                           , p_usim_planck_speed_unit   IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                           , p_usim_planck_stable       IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                           , p_usim_ultimate_border     IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                           , p_do_commit                IN BOOLEAN                                      DEFAULT TRUE
                           )
    RETURN NUMBER
  ;

  /**
  * Processes a given space node by sending out energy either to child or parent nodes. Handles
  * border situation for process direction.
  * Will update table USIM_SPC_PROCESS. Using package USIM_MATHS for calculations.
  * @param p_usim_id_spc The space node to process. Mandatory.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Return 1 if all was successfully processed otherwise 0.
  */
  FUNCTION process_node( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                       , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                       )
    RETURN NUMBER
  ;

  /**
  * Processes currently open outputs, sums up the target nodes and updates targets energy. Starts
  * then processing target nodes as source nodes. Handles overflows and necessary actions like dimension creation.
  * Overflow can result in infinity or in NUMERIC OVERFLOW!!!!
  * Updates the planck time. Will write result to table USIM_SPC_PROCESS. Using package USIM_MATHS for calculations.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Return 1 if all was successfully processed otherwise 0.
  */
  FUNCTION process_queue(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  ;

  /**
  * Will update the state of all universes in the multiverse. Run after execution usim_process.process_queue.
  * @return Return 1 if all was successfully processed otherwise 0.
  */
  FUNCTION update_universe_states(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  ;

  /**
  * Runs the process queue for the given amount of times or as long as the system is valid. Will update
  * state of the current universes.
  * @return Return 1 if all was successfully processed otherwise 0.
  */
  FUNCTION run_samples( p_run_count IN NUMBER
                      , p_do_commit IN BOOLEAN DEFAULT TRUE
                      )
    RETURN NUMBER
  ;

END usim_process;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_process
IS
  /**A package for processing space nodes. Depends on all available packages including USIM_CREATOR.*/

  /**
  * Provides a process start node in the queue. The start node is always the base universe seed at position 0 and dimension 0
  * without any parent. The process direction is childs. Should be called only once. Will do nothing if processing nodes already
  * exist. Will create base data with given parameters, if missing, intialize planck time if not done and create a universe seed, if it
  * does not exist using given parameters. Will activate the universe, if not active.
  * @param p_max_dimension The maximum dimensions possible for this multiverse. Base data init.
  * @param p_usim_abs_max_number The absolute maximum number available for this multiverse. Base data init.
  * @param p_usim_overflow_node_seed Defines the overflow behaviour, default 0 means standard overflow behaviour. If set to 1, all new nodes are created with the universe seed at coordinate 0 as the parent. Base data init.
  * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used or default if NULL or 0. Universe seed init.
  * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value or default if NULL or 0. Universe seed init.
  * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value or default if NULL or 0. Universe seed init.
  * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value or default if NULL or 0. Universe seed init.
  * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct. Universe seed init.
  * @param p_usim_ultimate_border The ultimate border rule for this universe. 1 is ultimate border reached, no childs left, 0 is any border at dimensions axis even with childs left. Universe seed init.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Return 1 if all was successfully processed otherwise 0.
  */
  FUNCTION place_start_node( p_max_dimension            IN NUMBER                                       DEFAULT 42
                           , p_usim_abs_max_number      IN NUMBER                                       DEFAULT 99999999999999999999999999999999999999
                           , p_usim_overflow_node_seed  IN NUMBER                                       DEFAULT 0
                           , p_usim_energy_start_value  IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                           , p_usim_planck_time_unit    IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                           , p_usim_planck_length_unit  IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                           , p_usim_planck_speed_unit   IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                           , p_usim_planck_stable       IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                           , p_usim_ultimate_border     IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                           , p_do_commit                IN BOOLEAN                                      DEFAULT TRUE
                           )
    RETURN NUMBER
  ;

  /**
  * Processes a given space node by sending out energy either to child or parent nodes. Handles
  * border situation for process direction.
  * Will update table USIM_SPC_PROCESS. Using package USIM_MATHS for calculations.
  * @param p_usim_id_spc The space node to process. Mandatory.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Return 1 if all was successfully processed otherwise 0.
  */
  FUNCTION process_node( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                       , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                       )
    RETURN NUMBER
  ;

  /**
  * Processes currently open outputs, sums up the target nodes and updates targets energy. Starts
  * then processing target nodes as source nodes. Handles overflows and necessary actions like dimension creation.
  * Overflow can result in infinity or in NUMERIC OVERFLOW!!!!
  * Updates the planck time. Will write result to table USIM_SPC_PROCESS. Using package USIM_MATHS for calculations.
  * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
  * @return Return 1 if all was successfully processed otherwise 0.
  */
  FUNCTION process_queue(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  ;

  /**
  * Will update the state of all universes in the multiverse. Run after execution usim_process.process_queue.
  * @return Return 1 if all was successfully processed otherwise 0.
  */
  FUNCTION update_universe_states(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  ;

  /**
  * Runs the process queue for the given amount of times or as long as the system is valid. Will update
  * state of the current universes.
  * @return Return 1 if all was successfully processed otherwise 0.
  */
  FUNCTION run_samples( p_run_count IN NUMBER
                      , p_do_commit IN BOOLEAN DEFAULT TRUE
                      )
    RETURN NUMBER
  ;

END usim_process;

Package USIM_PROCESS kompiliert

SQL> @@../PACKAGES/USIM_PROCESS.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_process
  2  IS
  3    -- see header for documentation
  4
  5    FUNCTION place_start_node( p_max_dimension            IN NUMBER                                       DEFAULT 42
  6                             , p_usim_abs_max_number      IN NUMBER                                       DEFAULT 99999999999999999999999999999999999999
  7                             , p_usim_overflow_node_seed  IN NUMBER                                       DEFAULT 0
  8                             , p_usim_energy_start_value  IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
  9                             , p_usim_planck_time_unit    IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
 10                             , p_usim_planck_length_unit  IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
 11                             , p_usim_planck_speed_unit   IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
 12                             , p_usim_planck_stable       IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
 13                             , p_usim_ultimate_border     IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
 14                             , p_do_commit                IN BOOLEAN                                      DEFAULT TRUE
 15                             )
 16      RETURN NUMBER
 17    IS
 18      l_source_G      NUMBER;
 19      l_distance      NUMBER;
 20      l_energy        NUMBER;
 21      l_start_value   NUMBER;
 22      l_target_energy NUMBER;
 23      l_resDimG       NUMBER;
 24      l_resR          NUMBER;
 25      l_resEnergy     NUMBER;
 26      l_return        NUMBER;
 27      l_planck_time   NUMBER;
 28      l_planck_aeon   usim_static.usim_id;
 29      l_state         usim_multiverse.usim_universe_status%TYPE;
 30      l_base_id       usim_space.usim_id_spc%TYPE;
 31      l_spr_id        usim_spc_process.usim_id_spr%TYPE;
 32
 33      CURSOR cur_childs(cp_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 34      IS
 35        SELECT chi.usim_id_spc_child
 36             , spcv.usim_energy
 37             , spcv.dim_sign
 38          FROM usim_spc_child chi
 39         INNER JOIN usim_spc_v spcv
 40            ON chi.usim_id_spc_child = spcv.usim_id_spc
 41         WHERE chi.usim_id_spc = cp_usim_id_spc
 42      ;
 43    BEGIN
 44      IF usim_dbif.has_data_spr = 1
 45      THEN
 46        -- can't insert start node if data already exist
 47        usim_erl.log_error('usim_process.place_start_node', 'Process already initialized, no start node allowed.');
 48        RETURN 0;
 49      END IF;
 50      -- prepare base data if needed
 51      IF usim_dbif.has_basedata = 0
 52      THEN
 53        l_return := usim_dbif.init_basedata(p_max_dimension, p_usim_abs_max_number, p_usim_overflow_node_seed);
 54        IF l_return = 0
 55        THEN
 56          usim_erl.log_error('usim_process.place_start_node', 'Could not initialize base data with max dim [' || p_max_dimension || '], max_num [' || p_usim_abs_max_number || '] and overflow rule [' || p_usim_overflow_node_seed || '].');
 57          RETURN 0;
 58        END IF;
 59      END IF;
 60      -- check planck aeon
 61      l_planck_aeon := usim_dbif.get_planck_aeon_seq_current;
 62      IF l_planck_aeon = usim_static.usim_not_available
 63      THEN
 64        -- init planck aeon and time
 65        l_planck_time := usim_dbif.get_planck_time_next;
 66        IF l_planck_time IS NULL
 67        THEN
 68          usim_erl.log_error('usim_process.place_start_node', 'Could not initialize planck time.');
 69          RETURN 0;
 70        END IF;
 71        l_planck_aeon := usim_dbif.get_planck_aeon_seq_current;
 72        IF l_planck_aeon = usim_static.usim_not_available
 73        THEN
 74          usim_erl.log_error('usim_process.place_start_node', 'Could not initialize planck aeon with planck time next.');
 75          RETURN 0;
 76        END IF;
 77      ELSE
 78        -- we should have a planck time if aeon is set
 79        l_planck_time := usim_dbif.get_planck_time_current;
 80        IF l_planck_time IS NULL
 81        THEN
 82          usim_erl.log_error('usim_process.place_start_node', 'Could not get current planck time with planck aeon already set.');
 83          RETURN 0;
 84        END IF;
 85      END IF;
 86      -- check universe
 87      IF usim_dbif.has_data_mlv = 0
 88      THEN
 89        -- create base universe seed
 90        l_base_id := usim_creator.create_new_universe( p_usim_energy_start_value
 91                                                     , p_usim_planck_time_unit
 92                                                     , p_usim_planck_length_unit
 93                                                     , p_usim_planck_speed_unit
 94                                                     , p_usim_planck_stable
 95                                                     , p_usim_ultimate_border
 96                                                     , NULL
 97                                                     , TRUE
 98                                                     )
 99        ;
100        IF l_base_id IS NULL
101        THEN
102          usim_erl.log_error('usim_process.place_start_node', 'Could not create missing base universe energy start [' || p_usim_energy_start_value || '],  planck time [' || p_usim_planck_time_unit || '],  planck length [' || p_usim_planck_length_unit || '], planck speed [' || p_usim_planck_speed_unit || '], planck stable [' || p_usim_planck_stable || '], border rule [' || p_usim_ultimate_border || '] and no parent.');
103          -- rely on rollback of called function
104          RETURN 0;
105        END IF;
106      ELSE
107        -- universe exists, what about nodes?
108        IF usim_dbif.has_data_spc = 0
109        THEN
110          usim_erl.log_error('usim_process.place_start_node', 'Initialization error. Existing universe but no space nodes available.');
111          RETURN 0;
112        END IF;
113        l_base_id := usim_dbif.get_id_spc_base_universe;
114        IF l_base_id IS NULL
115        THEN
116          usim_erl.log_error('usim_process.place_start_node', 'Initialization error. Could not fetch base universe seed.');
117          RETURN 0;
118        END IF;
119      END IF;
120      -- check childs of base universe
121      IF usim_dbif.child_count(l_base_id) != 2
122      THEN
123        -- we expect exactly two childs for base universe seed
124          usim_erl.log_error('usim_process.place_start_node', 'Initialization error. Base universe seed has not the correct amount of childs (2).');
125          RETURN 0;
126      END IF;
127      -- activate seed universe, if not already done
128      l_state := usim_dbif.set_seed_active(FALSE);
129      IF l_state != usim_static.usim_multiverse_status_active
130      THEN
131        ROLLBACK;
132        -- cannot start with this universe
133        usim_erl.log_error('usim_process.place_start_node', 'Universe state error. Current universe cannot be switched to active, space id [' || l_base_id || '] state [' || l_state || '].');
134        RETURN 0;
135      END IF;
136      -- ready to start
137      SELECT usim_energy
138           , usim_energy_start_value
139        INTO l_energy
140           , l_start_value
141        FROM usim_spc_v
142       WHERE usim_id_spc = l_base_id
143      ;
144      IF l_energy IS NULL
145      THEN
146        l_energy := l_start_value;
147      END IF;
148      l_resDimG := usim_dbif.get_dim_G(l_base_id, l_source_G);
149      IF l_resDimG != 1
150      THEN
151        usim_erl.log_error('usim_process.place_start_node', 'Universe setup error. Calculate dimension G for space id [' || l_base_id || '] should not give error or overflow [' || l_resDimG || '].');
152        usim_dbif.set_crashed;
153        RETURN 0;
154      END IF;
155      l_resR := usim_dbif.get_outer_planck_r(l_base_id, l_distance);
156      IF l_resR != 1
157      THEN
158        usim_erl.log_error('usim_process.place_start_node', 'Universe setup error. Calculate radius for space id [' || l_base_id || '] should not give error or overflow [' || l_resR || '].');
159        usim_dbif.set_crashed;
160        RETURN 0;
161      END IF;
162      l_resEnergy := usim_dbif.get_acceleration(l_energy, l_distance, l_source_G, l_target_energy);
163      IF l_resEnergy != 1
164      THEN
165        usim_erl.log_error('usim_process.place_start_node', 'Universe setup error. Calculate energy for base seed space id [' || l_base_id || '] should not give error or overflow [' || l_resEnergy || ']. Energy [' || l_energy || '], distance [' || l_distance || '], G [' || l_source_G || '].');
166        usim_dbif.set_crashed;
167        RETURN 0;
168      END IF;
169      -- process childs
170      FOR rec IN cur_childs(l_base_id)
171      LOOP
172        l_spr_id := usim_dbif.create_process(l_base_id, rec.usim_id_spc_child, l_energy, rec.usim_energy, l_target_energy * rec.dim_sign, FALSE);
173        IF l_spr_id IS NULL
174        THEN
175          ROLLBACK;
176          -- error insert
177          usim_erl.log_error('usim_process.place_start_node', 'Could not insert process record.');
178          usim_dbif.set_crashed;
179          RETURN 0;
180        END IF;
181      END LOOP;
182      -- commit everything if gone well
183      IF p_do_commit
184      THEN
185        COMMIT;
186      END IF;
187      RETURN 1;
188    EXCEPTION
189      WHEN OTHERS THEN
190        ROLLBACK;
191        -- write error might still work
192        usim_erl.log_error('usim_process.place_start_node', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
193        -- try to set all to crashed
194        usim_dbif.set_crashed;
195        -- raise in any case
196        RAISE;
197    END place_start_node
198    ;
199
200    FUNCTION process_node( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
201                         , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
202                         )
203      RETURN NUMBER
204    IS
205      l_source_G      NUMBER;
206      l_distance      NUMBER;
207      l_energy        NUMBER;
208      l_start_value   NUMBER;
209      l_target_energy NUMBER;
210      l_resDimG       NUMBER;
211      l_resR          NUMBER;
212      l_resEnergy     NUMBER;
213      l_is_base       INTEGER;
214      l_result        INTEGER;
215      l_spr_id        usim_spc_process.usim_id_spr%TYPE;
216      l_executed      BOOLEAN;
217
218      CURSOR cur_childs(cp_usim_id_spc IN usim_space.usim_id_spc%TYPE)
219      IS
220        SELECT chi.usim_id_spc_child
221             , spcv.usim_energy
222             , spcv.dim_sign
223          FROM usim_spc_child chi
224         INNER JOIN usim_spc_v spcv
225            ON chi.usim_id_spc_child = spcv.usim_id_spc
226         WHERE chi.usim_id_spc = cp_usim_id_spc
227      ;
228      CURSOR cur_parent(cp_usim_id_spc IN usim_space.usim_id_spc%TYPE)
229      IS
230        SELECT chi.usim_id_spc
231             , spcv.usim_energy
232             , spcv.dim_sign
233          FROM usim_spc_child chi
234         INNER JOIN usim_spc_v spcv
235            ON chi.usim_id_spc = spcv.usim_id_spc
236         WHERE chi.usim_id_spc_child = cp_usim_id_spc
237      ;
238    BEGIN
239      IF usim_dbif.has_data_spc(p_usim_id_spc) = 0
240      THEN
241        usim_erl.log_error('usim_process.process_node', 'Used with invalid space id [' || p_usim_id_spc || '].');
242        RETURN 0;
243      END IF;
244      IF usim_dbif.is_seed_active = 0
245      THEN
246        -- won't operate on universe not active
247        usim_erl.log_error('usim_process.process_node', 'Current universe seed is not active. Node not processed space id [' || p_usim_id_spc || '].');
248        RETURN 0;
249      END IF;
250      -- check border situation
251      l_result := usim_dbif.check_border(p_usim_id_spc, FALSE);
252      IF l_result != 1
253      THEN
254        usim_erl.log_error('usim_process.process_node', 'Check border failed with parameter [' || p_usim_id_spc || '] and result [' || l_result || '].');
255        RETURN 0;
256      END IF;
257      -- operate on node
258      SELECT usim_energy
259           , usim_energy_start_value
260        INTO l_energy
261           , l_start_value
262        FROM usim_spc_v
263       WHERE usim_id_spc = p_usim_id_spc
264      ;
265      l_is_base := usim_dbif.is_universe_base_type(p_usim_id_spc);
266      IF l_is_base = 1
267      THEN
268        IF l_energy IS NULL
269        THEN
270          l_energy := l_start_value;
271        END IF;
272      END IF;
273      l_resDimG := usim_dbif.get_dim_G(p_usim_id_spc, l_source_G);
274      IF l_resDimG != 1
275      THEN
276        IF l_resDimG = 0
277        THEN
278          usim_debug.debug_log('usim_process.process_node', 'Overflow for space id [' || p_usim_id_spc || '] usim_dbif.get_dim_G. Set G to default 1.');
279          l_result   := usim_creator.handle_overflow(p_usim_id_spc, FALSE);
280          IF l_result = 0
281          THEN
282            ROLLBACK;
283            usim_erl.log_error('usim_process.process_node', 'usim_creator.handle_overflow failed for space id [' || p_usim_id_spc || '] usim_dbif.get_dim_G.');
284            usim_dbif.set_crashed;
285            RETURN 0;
286          END IF;
287          -- set to default
288          l_source_G := 1;
289        ELSE
290          usim_erl.log_error('usim_process.process_node', 'Universe setup error. Calculate dimension G for space id [' || p_usim_id_spc || '] should not give error [' || l_resDimG || '].');
291          usim_dbif.set_crashed;
292          RETURN 0;
293        END IF;
294      END IF;
295      l_resR := usim_dbif.get_outer_planck_r(p_usim_id_spc, l_distance);
296      IF l_resR != 1
297      THEN
298        IF l_resR = 0
299        THEN
300          usim_debug.debug_log('usim_process.process_node', 'Overflow for space id [' || p_usim_id_spc || '] usim_dbif.get_outer_planck_r. Set distance to default 1.');
301          l_result   := usim_creator.handle_overflow(p_usim_id_spc, FALSE);
302          IF l_result = 0
303          THEN
304            ROLLBACK;
305            usim_erl.log_error('usim_process.process_node', 'usim_creator.handle_overflow failed for space id [' || p_usim_id_spc || '] usim_dbif.get_outer_planck_r.');
306            usim_dbif.set_crashed;
307            RETURN 0;
308          END IF;
309          -- set to default
310          l_distance := 1;
311        ELSE
312          usim_erl.log_error('usim_process.process_node', 'Universe setup error. Calculate radius for space id [' || p_usim_id_spc || '] should not give error [' || l_resR || '].');
313          usim_dbif.set_crashed;
314          RETURN 0;
315        END IF;
316      END IF;
317      l_resEnergy := usim_dbif.get_acceleration(l_energy, l_distance, l_source_G, l_target_energy);
318      IF l_resEnergy != 1
319      THEN
320        IF l_resEnergy = 0
321        THEN
322          usim_debug.debug_log('usim_process.process_node', 'Overflow for space id [' || p_usim_id_spc || '] usim_dbif.get_acceleration. Set target energy to 0.');
323          l_result        := usim_creator.handle_overflow(p_usim_id_spc, FALSE);
324          IF l_result = 0
325          THEN
326            ROLLBACK;
327            usim_erl.log_error('usim_process.process_node', 'usim_creator.handle_overflow failed for space id [' || p_usim_id_spc || '] usim_dbif.get_acceleration.');
328            usim_dbif.set_crashed;
329            RETURN 0;
330          END IF;
331          l_target_energy := 0;
332        ELSE
333          usim_erl.log_error('usim_process.process_node', 'Universe setup error. Calculate acceleration energy for space id [' || p_usim_id_spc || '] should not give error [' || l_resEnergy || ']. With energy [' || l_energy || '], distance [' || l_distance || '], G [' || l_source_G || '].');
334          usim_dbif.set_crashed;
335          RETURN 0;
336        END IF;
337      END IF;
338      -- process after checks decide direction
339      IF usim_dbif.get_process_spin(p_usim_id_spc) = 1
340      THEN
341        -- childs
342        l_executed := FALSE;
343        FOR rec IN cur_childs(p_usim_id_spc)
344        LOOP
345          l_executed := TRUE;
346          l_spr_id := usim_dbif.create_process( p_usim_id_spc
347                                              , rec.usim_id_spc_child
348                                              , l_energy
349                                              , rec.usim_energy
350                                              , CASE
351                                                  WHEN l_is_base = 1
352                                                  THEN l_target_energy * rec.dim_sign
353                                                  ELSE l_target_energy
354                                                END
355                                              , FALSE
356                                              )
357          ;
358          IF l_spr_id IS NULL
359          THEN
360            ROLLBACK;
361            -- error insert
362            usim_erl.log_error('usim_process.process_node', 'Could not insert process record for space id [' || p_usim_id_spc || '].');
363            usim_dbif.set_crashed;
364            RETURN 0;
365          END IF;
366        END LOOP;
367        IF NOT l_executed
368        THEN
369          usim_erl.log_error('usim_process.process_node', 'ERROR Child cursors had no data. cur_childs(' || p_usim_id_spc || ') process spin 1');
370          usim_dbif.set_crashed;
371          RETURN 0;
372        END IF;
373      ELSIF usim_dbif.get_process_spin(p_usim_id_spc) = -1
374      THEN
375        -- parents
376        l_executed := FALSE;
377        FOR rec IN cur_parent(p_usim_id_spc)
378        LOOP
379          l_executed := TRUE;
380          l_spr_id := usim_dbif.create_process( p_usim_id_spc
381                                              , rec.usim_id_spc
382                                              , l_energy
383                                              , rec.usim_energy
384                                              , CASE
385                                                  WHEN l_is_base = 1
386                                                  THEN l_target_energy * rec.dim_sign
387                                                  ELSE l_target_energy
388                                                END
389                                              , FALSE
390                                              )
391          ;
392          IF l_spr_id IS NULL
393          THEN
394            ROLLBACK;
395            -- error insert
396            usim_erl.log_error('usim_process.process_node', 'Could not insert process record for space id [' || p_usim_id_spc || '].');
397            usim_dbif.set_crashed;
398            RETURN 0;
399          END IF;
400        END LOOP;
401        IF NOT l_executed
402        THEN
403          usim_erl.log_error('usim_process.process_node', 'ERROR Parent cursor had no data. cur_parent(' || p_usim_id_spc || ') process spin -1');
404          usim_dbif.set_crashed;
405          RETURN 0;
406        END IF;
407      ELSE
408        -- invalid space id or process spin
409        ROLLBACK;
410        -- error insert
411        usim_erl.log_error('usim_process.process_node', 'Invalid space id [' || p_usim_id_spc || '] no process direction found.');
412        usim_dbif.set_crashed;
413        RETURN 0;
414      END IF;
415      IF p_do_commit
416      THEN
417        COMMIT;
418      END IF;
419      RETURN 1;
420    EXCEPTION
421      WHEN OTHERS THEN
422        ROLLBACK;
423        -- write error might still work
424        usim_erl.log_error('usim_process.process_node', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
425        -- try to set all to crashed
426        usim_dbif.set_crashed;
427        -- raise in any case
428        RAISE;
429    END process_node
430    ;
431
432    FUNCTION process_queue(p_do_commit IN BOOLEAN DEFAULT TRUE)
433      RETURN NUMBER
434    IS
435      l_energy      NUMBER;
436      l_energy_set  NUMBER;
437      l_result      NUMBER;
438      l_planck_tick NUMBER;
439      l_usim_id_nod usim_node.usim_id_nod%TYPE;
440      l_planck_aeon usim_spc_process.usim_planck_aeon%TYPE;
441      l_planck_time usim_spc_process.usim_planck_time%TYPE;
442      l_cur_aeon    usim_spc_process.usim_planck_aeon%TYPE;
443      l_cur_time    usim_spc_process.usim_planck_time%TYPE;
444      l_usim_id_spr usim_spc_process.usim_id_spr%TYPE;
445      l_executed    BOOLEAN;
446      l_exec_inner  BOOLEAN;
447
448      CURSOR cur_targets
449      IS
450        SELECT usim_id_spc_target
451             , usim_planck_aeon
452             , usim_planck_time
453          FROM usim_spc_process
454         WHERE is_processed = 0
455         GROUP BY usim_id_spc_target
456                , usim_planck_aeon
457                , usim_planck_time
458      ;
459      CURSOR cur_old_targets( cp_planck_aeon IN usim_spc_process.usim_planck_aeon%TYPE
460                            , cp_planck_time IN usim_spc_process.usim_planck_time%TYPE
461                            )
462      IS
463        SELECT usim_id_spc_target
464             , usim_planck_aeon
465             , usim_planck_time
466          FROM usim_spc_process
467         WHERE is_processed      = 0
468           AND usim_planck_aeon  = cp_planck_aeon
469           AND usim_planck_time  = cp_planck_time
470         GROUP BY usim_id_spc_target
471                , usim_planck_aeon
472                , usim_planck_time
473      ;
474      CURSOR cur_target_energies( cp_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
475                                , cp_planck_aeon        IN usim_spc_process.usim_planck_aeon%TYPE
476                                , cp_planck_time        IN usim_spc_process.usim_planck_time%TYPE
477                                )
478      IS
479        SELECT usim_id_spr
480             , usim_energy_output
481             , usim_id_spc_source
482          FROM usim_spc_process
483         WHERE is_processed       = 0
484           AND usim_id_spc_target = cp_usim_id_spc_target
485           AND usim_planck_aeon   = cp_planck_aeon
486           AND usim_planck_time   = cp_planck_time
487      ;
488    BEGIN
489      l_result := usim_dbif.has_unprocessed;
490      IF l_result = 0
491      THEN
492        usim_erl.log_error('usim_process.process_queue', 'ERROR No targets found. Exit process.');
493        usim_dbif.set_crashed;
494        RETURN 0;
495      END IF;
496      l_result := usim_dbif.is_queue_valid;
497      IF l_result != 1
498      THEN
499        usim_erl.log_error('usim_process.process_queue', 'Current process queue is not valid. State [' || l_result || '].');
500        RETURN 0;
501      END IF;
502      -- get aeon and time
503      l_result := usim_dbif.get_unprocessed_planck(l_cur_aeon, l_cur_time);
504      IF l_result != 1
505      THEN
506        usim_erl.log_error('usim_process.process_queue', 'Could not fetch current planck aeon and time. State [' || l_result || '].');
507        RETURN 0;
508      END IF;
509      -- update current targets within current planck time tick
510      l_executed := FALSE;
511      FOR recmain IN cur_targets
512      LOOP
513        l_executed := TRUE;
514        -- check target, if the universe seed state is invalid, do not process it
515        IF usim_dbif.is_seed_active = 1
516        THEN
517          l_usim_id_nod := usim_dbif.get_id_nod(recmain.usim_id_spc_target);
518          IF l_usim_id_nod IS NULL
519          THEN
520            usim_erl.log_error('usim_process.process_queue', 'Could not get node for target id [' || recmain.usim_id_spc_target || '].');
521            usim_dbif.set_crashed;
522            RETURN 0;
523          END IF;
524          IF l_result = 0
525          THEN
526            ROLLBACK;
527            usim_erl.log_error('usim_process.process_queue', 'usim_process.check_border failed. Could not flip direction of space id [' || recmain.usim_id_spc_target || '].');
528            usim_dbif.set_crashed;
529            RETURN 0;
530          END IF;
531          l_energy := NVL(usim_nod.get_energy(l_usim_id_nod), 0);
532          -- sum up energy for every position to be able to identify the process causing overflow
533          l_exec_inner := FALSE;
534          FOR rec IN cur_target_energies(recmain.usim_id_spc_target, recmain.usim_planck_aeon, recmain.usim_planck_time)
535          LOOP
536            l_exec_inner := TRUE;
537            IF usim_dbif.is_overflow_energy_add(rec.usim_energy_output, l_energy) = 1
538            THEN
539              -- overflow energy
540              usim_debug.debug_log('usim_process.process_queue', 'Overflow for target space id [' || recmain.usim_id_spc_target || '] with energy [' || rec.usim_energy_output || '] and current target energy [' || l_energy || ']. Set energy to 0.');
541              -- handle overflow and create a new universe
542              l_result := usim_creator.handle_overflow(recmain.usim_id_spc_target, FALSE);
543              IF l_result = 0
544              THEN
545                ROLLBACK;
546                usim_erl.log_error('usim_process.process_queue', 'usim_creator.handle_overflow failed for space id [' || recmain.usim_id_spc_target || '] usim_dbif.is_overflow_energy_add.');
547                usim_dbif.set_crashed;
548                RETURN 0;
549              END IF;
550              -- set energy to zero and do not add any more energy
551              l_energy := 0;
552              EXIT;
553            ELSE
554              l_energy := l_energy + NVL(rec.usim_energy_output, 0);
555            END IF;
556          END LOOP;
557          IF NOT l_exec_inner
558          THEN
559            usim_erl.log_error('usim_process.process_queue', 'Cursor cur_target_energies has no data paramenters [' || recmain.usim_id_spc_target || '], [' || recmain.usim_planck_aeon || '], [' || recmain.usim_planck_time || '].');
560            usim_dbif.set_crashed;
561            RETURN 0;
562          END IF;
563          -- update energies on target
564          l_energy_set := usim_nod.update_energy(l_energy, l_usim_id_nod, FALSE);
565          IF l_energy_set != l_energy
566          THEN
567            usim_erl.log_error('usim_process.process_queue', 'Database storage issue for target id [' || recmain.usim_id_spc_target || '] and node id [' || l_usim_id_nod || '] as stored energy [' || l_energy_set || '] does not match energy set [' || l_energy || '].');
568            usim_dbif.set_crashed;
569            RETURN 0;
570          END IF;
571        ELSE
572          usim_erl.log_error('usim_process.process_queue', 'No processing of targets as universe seed is not active any longer.');
573          RETURN 0;
574        END IF;
575      END LOOP;
576      IF NOT l_executed
577      THEN
578        usim_erl.log_error('usim_process.process_queue', 'Cursor cur_targets has no data.');
579        usim_dbif.set_crashed;
580        RETURN 0;
581      END IF;
582      -- done all
583      -- change planck tick, next processing step
584      l_planck_tick := usim_dbif.get_planck_time_next;
585      -- get current aeon after update
586      l_planck_aeon := usim_dbif.get_planck_aeon_seq_current;
587      -- create new processes and update old processes
588      l_executed := FALSE;
589      FOR recmain IN cur_old_targets(l_cur_aeon, l_cur_time)
590      LOOP
591        l_executed := TRUE;
592        -- create new process with childs of target
593        l_result := usim_process.process_node(recmain.usim_id_spc_target, FALSE);
594        IF l_result = 0
595        THEN
596          usim_erl.log_error('usim_process.process_queue', 'Unable to process next nodes for target id [' || recmain.usim_id_spc_target || '].');
597          usim_dbif.set_crashed;
598          RETURN 0;
599        END IF;
600        -- now update old processes
601        l_exec_inner := FALSE;
602        FOR rec IN cur_target_energies(recmain.usim_id_spc_target, recmain.usim_planck_aeon, recmain.usim_planck_time)
603        LOOP
604          l_exec_inner := TRUE;
605          IF usim_dbif.is_universe_active(recmain.usim_id_spc_target) = 1
606          THEN
607            l_result := usim_dbif.set_processed(rec.usim_id_spr, 1, FALSE);
608          ELSE
609            -- if universe is invalid, sets process code 2
610            l_result := usim_dbif.set_processed(rec.usim_id_spr, 2, FALSE);
611          END IF;
612          IF l_result = 0
613          THEN
614            usim_erl.log_error('usim_process.process_queue', 'Unable to set processed for process id [' || rec.usim_id_spr || '].');
615            usim_dbif.set_crashed;
616            RETURN 0;
617          END IF;
618          -- flip direction for processed
619          l_result := usim_dbif.flip_process_spin(rec.usim_id_spc_source, FALSE);
620          IF l_result = 0
621          THEN
622            ROLLBACK;
623            usim_erl.log_error('usim_process.process_queue', 'Could not flip direction of space id [' || rec.usim_id_spc_source || '].');
624            usim_dbif.set_crashed;
625            RETURN 0;
626          END IF;
627        END LOOP;
628        IF NOT l_exec_inner
629        THEN
630          usim_erl.log_error('usim_process.process_queue', 'Cursor cur_target_energies in old targets has no data paramenters [' || recmain.usim_id_spc_target || '], [' || recmain.usim_planck_aeon || '], [' || recmain.usim_planck_time || '].');
631          usim_dbif.set_crashed;
632          RETURN 0;
633        END IF;
634        -- handle border
635        l_result := usim_dbif.check_border(recmain.usim_id_spc_target, FALSE);
636        IF l_result != 1
637        THEN
638          usim_erl.log_error('usim_process.process_queue', 'Check border failed with parameter [' || recmain.usim_id_spc_target || '].');
639          usim_dbif.set_crashed;
640          RETURN 0;
641        END IF;
642      END LOOP;
643      IF NOT l_executed
644      THEN
645        usim_erl.log_error('usim_process.process_queue', 'Cursor cur_old_targets has no data for parameters [' || l_cur_aeon || '], [' || l_cur_time || '].');
646        usim_dbif.set_crashed;
647        RETURN 0;
648      END IF;
649      -- everything gone well, commit if defined
650      IF p_do_commit
651      THEN
652        COMMIT;
653      END IF;
654      RETURN 1;
655    EXCEPTION
656      WHEN OTHERS THEN
657        ROLLBACK;
658        -- write error might still work
659        usim_erl.log_error('usim_process.process_queue', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
660        -- try to set all to crashed
661        usim_dbif.set_crashed;
662        -- raise in any case
663        RAISE;
664    END process_queue
665    ;
666
667    FUNCTION update_universe_states(p_do_commit IN BOOLEAN DEFAULT TRUE)
668      RETURN NUMBER
669    IS
670      l_return NUMBER;
671
672      CURSOR cur_universes
673      IS
674        SELECT usim_id_mlv
675          FROM usim_multiverse
676      ;
677    BEGIN
678      FOR rec IN cur_universes
679      LOOP
680        l_return := usim_dbif.set_universe_state(rec.usim_id_mlv, FALSE);
681        IF l_return IS NULL
682        THEN
683          ROLLBACK;
684          usim_erl.log_error('usim_process.update_universe_states', 'Universe setting state error.');
685          usim_dbif.set_crashed;
686          RETURN 0;
687        END IF;
688      END LOOP;
689      IF p_do_commit
690      THEN
691        COMMIT;
692      END IF;
693      RETURN 1;
694    EXCEPTION
695      WHEN OTHERS THEN
696        ROLLBACK;
697        -- write error might still work
698        usim_erl.log_error('usim_process.update_universe_states', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
699        -- try to set all to crashed
700        usim_dbif.set_crashed;
701        -- raise in any case
702        RAISE;
703    END update_universe_states
704    ;
705
706    FUNCTION run_samples( p_run_count IN NUMBER
707                        , p_do_commit IN BOOLEAN DEFAULT TRUE
708                        )
709      RETURN NUMBER
710    IS
711      l_return NUMBER;
712    BEGIN
713      FOR l_idx IN 1..p_run_count
714      LOOP
715        -- check system with every loop
716        IF usim_dbif.is_seed_active != 1
717        THEN
718          ROLLBACK;
719          usim_erl.log_error('usim_process.run_samples', 'Universe seed is not active. Run index: [' || l_idx || '].');
720          usim_dbif.set_crashed;
721          RETURN 0;
722        END IF;
723        IF usim_dbif.is_queue_valid != 1
724        THEN
725          ROLLBACK;
726          usim_erl.log_error('usim_process.run_samples', 'Process queue is not valid [' || usim_dbif.is_queue_valid || ']. Run index: [' || l_idx || '].');
727          usim_dbif.set_crashed;
728          RETURN 0;
729        END IF;
730        -- now process
731        l_return := usim_process.process_queue(p_do_commit);
732        IF l_return = 0
733        THEN
734          ROLLBACK;
735          usim_erl.log_error('usim_process.run_samples', 'Error running process_queue. Run index: [' || l_idx || '].');
736          usim_dbif.set_crashed;
737          RETURN 0;
738        END IF;
739        l_return := usim_process.update_universe_states(p_do_commit);
740        IF l_return = 0
741        THEN
742          ROLLBACK;
743          usim_erl.log_error('usim_process.run_samples', 'Error running update_universe_states. Run index: [' || l_idx || '].');
744          usim_dbif.set_crashed;
745          RETURN 0;
746        END IF;
747        -- commit every successful process
748        IF p_do_commit
749        THEN
750          COMMIT;
751        END IF;
752      END LOOP;
753      RETURN 1;
754    EXCEPTION
755      WHEN OTHERS THEN
756        ROLLBACK;
757        -- write error might still work
758        usim_erl.log_error('usim_process.run_samples', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
759        -- try to set all to crashed
760        usim_dbif.set_crashed;
761        -- raise in any case
762        RAISE;
763    END run_samples
764    ;
765
766  END usim_process;
767  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_process
IS
  -- see header for documentation

  FUNCTION place_start_node( p_max_dimension            IN NUMBER                                       DEFAULT 42
                           , p_usim_abs_max_number      IN NUMBER                                       DEFAULT 99999999999999999999999999999999999999
                           , p_usim_overflow_node_seed  IN NUMBER                                       DEFAULT 0
                           , p_usim_energy_start_value  IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                           , p_usim_planck_time_unit    IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                           , p_usim_planck_length_unit  IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                           , p_usim_planck_speed_unit   IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                           , p_usim_planck_stable       IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                           , p_usim_ultimate_border     IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                           , p_do_commit                IN BOOLEAN                                      DEFAULT TRUE
                           )
    RETURN NUMBER
  IS
    l_source_G      NUMBER;
    l_distance      NUMBER;
    l_energy        NUMBER;
    l_start_value   NUMBER;
    l_target_energy NUMBER;
    l_resDimG       NUMBER;
    l_resR          NUMBER;
    l_resEnergy     NUMBER;
    l_return        NUMBER;
    l_planck_time   NUMBER;
    l_planck_aeon   usim_static.usim_id;
    l_state         usim_multiverse.usim_universe_status%TYPE;
    l_base_id       usim_space.usim_id_spc%TYPE;
    l_spr_id        usim_spc_process.usim_id_spr%TYPE;

    CURSOR cur_childs(cp_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    IS
      SELECT chi.usim_id_spc_child
           , spcv.usim_energy
           , spcv.dim_sign
        FROM usim_spc_child chi
       INNER JOIN usim_spc_v spcv
          ON chi.usim_id_spc_child = spcv.usim_id_spc
       WHERE chi.usim_id_spc = cp_usim_id_spc
    ;
  BEGIN
    IF usim_dbif.has_data_spr = 1
    THEN
      -- can't insert start node if data already exist
      usim_erl.log_error('usim_process.place_start_node', 'Process already initialized, no start node allowed.');
      RETURN 0;
    END IF;
    -- prepare base data if needed
    IF usim_dbif.has_basedata = 0
    THEN
      l_return := usim_dbif.init_basedata(p_max_dimension, p_usim_abs_max_number, p_usim_overflow_node_seed);
      IF l_return = 0
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Could not initialize base data with max dim [' || p_max_dimension || '], max_num [' || p_usim_abs_max_number || '] and overflow rule [' || p_usim_overflow_node_seed || '].');
        RETURN 0;
      END IF;
    END IF;
    -- check planck aeon
    l_planck_aeon := usim_dbif.get_planck_aeon_seq_current;
    IF l_planck_aeon = usim_static.usim_not_available
    THEN
      -- init planck aeon and time
      l_planck_time := usim_dbif.get_planck_time_next;
      IF l_planck_time IS NULL
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Could not initialize planck time.');
        RETURN 0;
      END IF;
      l_planck_aeon := usim_dbif.get_planck_aeon_seq_current;
      IF l_planck_aeon = usim_static.usim_not_available
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Could not initialize planck aeon with planck time next.');
        RETURN 0;
      END IF;
    ELSE
      -- we should have a planck time if aeon is set
      l_planck_time := usim_dbif.get_planck_time_current;
      IF l_planck_time IS NULL
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Could not get current planck time with planck aeon already set.');
        RETURN 0;
      END IF;
    END IF;
    -- check universe
    IF usim_dbif.has_data_mlv = 0
    THEN
      -- create base universe seed
      l_base_id := usim_creator.create_new_universe( p_usim_energy_start_value
                                                   , p_usim_planck_time_unit
                                                   , p_usim_planck_length_unit
                                                   , p_usim_planck_speed_unit
                                                   , p_usim_planck_stable
                                                   , p_usim_ultimate_border
                                                   , NULL
                                                   , TRUE
                                                   )
      ;
      IF l_base_id IS NULL
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Could not create missing base universe energy start [' || p_usim_energy_start_value || '],  planck time [' || p_usim_planck_time_unit || '],  planck length [' || p_usim_planck_length_unit || '], planck speed [' || p_usim_planck_speed_unit || '], planck stable [' || p_usim_planck_stable || '], border rule [' || p_usim_ultimate_border || '] and no parent.');
        -- rely on rollback of called function
        RETURN 0;
      END IF;
    ELSE
      -- universe exists, what about nodes?
      IF usim_dbif.has_data_spc = 0
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Initialization error. Existing universe but no space nodes available.');
        RETURN 0;
      END IF;
      l_base_id := usim_dbif.get_id_spc_base_universe;
      IF l_base_id IS NULL
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Initialization error. Could not fetch base universe seed.');
        RETURN 0;
      END IF;
    END IF;
    -- check childs of base universe
    IF usim_dbif.child_count(l_base_id) != 2
    THEN
      -- we expect exactly two childs for base universe seed
        usim_erl.log_error('usim_process.place_start_node', 'Initialization error. Base universe seed has not the correct amount of childs (2).');
        RETURN 0;
    END IF;
    -- activate seed universe, if not already done
    l_state := usim_dbif.set_seed_active(FALSE);
    IF l_state != usim_static.usim_multiverse_status_active
    THEN
      ROLLBACK;
      -- cannot start with this universe
      usim_erl.log_error('usim_process.place_start_node', 'Universe state error. Current universe cannot be switched to active, space id [' || l_base_id || '] state [' || l_state || '].');
      RETURN 0;
    END IF;
    -- ready to start
    SELECT usim_energy
         , usim_energy_start_value
      INTO l_energy
         , l_start_value
      FROM usim_spc_v
     WHERE usim_id_spc = l_base_id
    ;
    IF l_energy IS NULL
    THEN
      l_energy := l_start_value;
    END IF;
    l_resDimG := usim_dbif.get_dim_G(l_base_id, l_source_G);
    IF l_resDimG != 1
    THEN
      usim_erl.log_error('usim_process.place_start_node', 'Universe setup error. Calculate dimension G for space id [' || l_base_id || '] should not give error or overflow [' || l_resDimG || '].');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    l_resR := usim_dbif.get_outer_planck_r(l_base_id, l_distance);
    IF l_resR != 1
    THEN
      usim_erl.log_error('usim_process.place_start_node', 'Universe setup error. Calculate radius for space id [' || l_base_id || '] should not give error or overflow [' || l_resR || '].');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    l_resEnergy := usim_dbif.get_acceleration(l_energy, l_distance, l_source_G, l_target_energy);
    IF l_resEnergy != 1
    THEN
      usim_erl.log_error('usim_process.place_start_node', 'Universe setup error. Calculate energy for base seed space id [' || l_base_id || '] should not give error or overflow [' || l_resEnergy || ']. Energy [' || l_energy || '], distance [' || l_distance || '], G [' || l_source_G || '].');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    -- process childs
    FOR rec IN cur_childs(l_base_id)
    LOOP
      l_spr_id := usim_dbif.create_process(l_base_id, rec.usim_id_spc_child, l_energy, rec.usim_energy, l_target_energy * rec.dim_sign, FALSE);
      IF l_spr_id IS NULL
      THEN
        ROLLBACK;
        -- error insert
        usim_erl.log_error('usim_process.place_start_node', 'Could not insert process record.');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    END LOOP;
    -- commit everything if gone well
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_process.place_start_node', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END place_start_node
  ;

  FUNCTION process_node( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                       , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                       )
    RETURN NUMBER
  IS
    l_source_G      NUMBER;
    l_distance      NUMBER;
    l_energy        NUMBER;
    l_start_value   NUMBER;
    l_target_energy NUMBER;
    l_resDimG       NUMBER;
    l_resR          NUMBER;
    l_resEnergy     NUMBER;
    l_is_base       INTEGER;
    l_result        INTEGER;
    l_spr_id        usim_spc_process.usim_id_spr%TYPE;
    l_executed      BOOLEAN;

    CURSOR cur_childs(cp_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    IS
      SELECT chi.usim_id_spc_child
           , spcv.usim_energy
           , spcv.dim_sign
        FROM usim_spc_child chi
       INNER JOIN usim_spc_v spcv
          ON chi.usim_id_spc_child = spcv.usim_id_spc
       WHERE chi.usim_id_spc = cp_usim_id_spc
    ;
    CURSOR cur_parent(cp_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    IS
      SELECT chi.usim_id_spc
           , spcv.usim_energy
           , spcv.dim_sign
        FROM usim_spc_child chi
       INNER JOIN usim_spc_v spcv
          ON chi.usim_id_spc = spcv.usim_id_spc
       WHERE chi.usim_id_spc_child = cp_usim_id_spc
    ;
  BEGIN
    IF usim_dbif.has_data_spc(p_usim_id_spc) = 0
    THEN
      usim_erl.log_error('usim_process.process_node', 'Used with invalid space id [' || p_usim_id_spc || '].');
      RETURN 0;
    END IF;
    IF usim_dbif.is_seed_active = 0
    THEN
      -- won't operate on universe not active
      usim_erl.log_error('usim_process.process_node', 'Current universe seed is not active. Node not processed space id [' || p_usim_id_spc || '].');
      RETURN 0;
    END IF;
    -- check border situation
    l_result := usim_dbif.check_border(p_usim_id_spc, FALSE);
    IF l_result != 1
    THEN
      usim_erl.log_error('usim_process.process_node', 'Check border failed with parameter [' || p_usim_id_spc || '] and result [' || l_result || '].');
      RETURN 0;
    END IF;
    -- operate on node
    SELECT usim_energy
         , usim_energy_start_value
      INTO l_energy
         , l_start_value
      FROM usim_spc_v
     WHERE usim_id_spc = p_usim_id_spc
    ;
    l_is_base := usim_dbif.is_universe_base_type(p_usim_id_spc);
    IF l_is_base = 1
    THEN
      IF l_energy IS NULL
      THEN
        l_energy := l_start_value;
      END IF;
    END IF;
    l_resDimG := usim_dbif.get_dim_G(p_usim_id_spc, l_source_G);
    IF l_resDimG != 1
    THEN
      IF l_resDimG = 0
      THEN
        usim_debug.debug_log('usim_process.process_node', 'Overflow for space id [' || p_usim_id_spc || '] usim_dbif.get_dim_G. Set G to default 1.');
        l_result   := usim_creator.handle_overflow(p_usim_id_spc, FALSE);
        IF l_result = 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_process.process_node', 'usim_creator.handle_overflow failed for space id [' || p_usim_id_spc || '] usim_dbif.get_dim_G.');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        -- set to default
        l_source_G := 1;
      ELSE
        usim_erl.log_error('usim_process.process_node', 'Universe setup error. Calculate dimension G for space id [' || p_usim_id_spc || '] should not give error [' || l_resDimG || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    END IF;
    l_resR := usim_dbif.get_outer_planck_r(p_usim_id_spc, l_distance);
    IF l_resR != 1
    THEN
      IF l_resR = 0
      THEN
        usim_debug.debug_log('usim_process.process_node', 'Overflow for space id [' || p_usim_id_spc || '] usim_dbif.get_outer_planck_r. Set distance to default 1.');
        l_result   := usim_creator.handle_overflow(p_usim_id_spc, FALSE);
        IF l_result = 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_process.process_node', 'usim_creator.handle_overflow failed for space id [' || p_usim_id_spc || '] usim_dbif.get_outer_planck_r.');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        -- set to default
        l_distance := 1;
      ELSE
        usim_erl.log_error('usim_process.process_node', 'Universe setup error. Calculate radius for space id [' || p_usim_id_spc || '] should not give error [' || l_resR || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    END IF;
    l_resEnergy := usim_dbif.get_acceleration(l_energy, l_distance, l_source_G, l_target_energy);
    IF l_resEnergy != 1
    THEN
      IF l_resEnergy = 0
      THEN
        usim_debug.debug_log('usim_process.process_node', 'Overflow for space id [' || p_usim_id_spc || '] usim_dbif.get_acceleration. Set target energy to 0.');
        l_result        := usim_creator.handle_overflow(p_usim_id_spc, FALSE);
        IF l_result = 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_process.process_node', 'usim_creator.handle_overflow failed for space id [' || p_usim_id_spc || '] usim_dbif.get_acceleration.');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        l_target_energy := 0;
      ELSE
        usim_erl.log_error('usim_process.process_node', 'Universe setup error. Calculate acceleration energy for space id [' || p_usim_id_spc || '] should not give error [' || l_resEnergy || ']. With energy [' || l_energy || '], distance [' || l_distance || '], G [' || l_source_G || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    END IF;
    -- process after checks decide direction
    IF usim_dbif.get_process_spin(p_usim_id_spc) = 1
    THEN
      -- childs
      l_executed := FALSE;
      FOR rec IN cur_childs(p_usim_id_spc)
      LOOP
        l_executed := TRUE;
        l_spr_id := usim_dbif.create_process( p_usim_id_spc
                                            , rec.usim_id_spc_child
                                            , l_energy
                                            , rec.usim_energy
                                            , CASE
                                                WHEN l_is_base = 1
                                                THEN l_target_energy * rec.dim_sign
                                                ELSE l_target_energy
                                              END
                                            , FALSE
                                            )
        ;
        IF l_spr_id IS NULL
        THEN
          ROLLBACK;
          -- error insert
          usim_erl.log_error('usim_process.process_node', 'Could not insert process record for space id [' || p_usim_id_spc || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
      END LOOP;
      IF NOT l_executed
      THEN
        usim_erl.log_error('usim_process.process_node', 'ERROR Child cursors had no data. cur_childs(' || p_usim_id_spc || ') process spin 1');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    ELSIF usim_dbif.get_process_spin(p_usim_id_spc) = -1
    THEN
      -- parents
      l_executed := FALSE;
      FOR rec IN cur_parent(p_usim_id_spc)
      LOOP
        l_executed := TRUE;
        l_spr_id := usim_dbif.create_process( p_usim_id_spc
                                            , rec.usim_id_spc
                                            , l_energy
                                            , rec.usim_energy
                                            , CASE
                                                WHEN l_is_base = 1
                                                THEN l_target_energy * rec.dim_sign
                                                ELSE l_target_energy
                                              END
                                            , FALSE
                                            )
        ;
        IF l_spr_id IS NULL
        THEN
          ROLLBACK;
          -- error insert
          usim_erl.log_error('usim_process.process_node', 'Could not insert process record for space id [' || p_usim_id_spc || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
      END LOOP;
      IF NOT l_executed
      THEN
        usim_erl.log_error('usim_process.process_node', 'ERROR Parent cursor had no data. cur_parent(' || p_usim_id_spc || ') process spin -1');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    ELSE
      -- invalid space id or process spin
      ROLLBACK;
      -- error insert
      usim_erl.log_error('usim_process.process_node', 'Invalid space id [' || p_usim_id_spc || '] no process direction found.');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_process.process_node', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END process_node
  ;

  FUNCTION process_queue(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  IS
    l_energy      NUMBER;
    l_energy_set  NUMBER;
    l_result      NUMBER;
    l_planck_tick NUMBER;
    l_usim_id_nod usim_node.usim_id_nod%TYPE;
    l_planck_aeon usim_spc_process.usim_planck_aeon%TYPE;
    l_planck_time usim_spc_process.usim_planck_time%TYPE;
    l_cur_aeon    usim_spc_process.usim_planck_aeon%TYPE;
    l_cur_time    usim_spc_process.usim_planck_time%TYPE;
    l_usim_id_spr usim_spc_process.usim_id_spr%TYPE;
    l_executed    BOOLEAN;
    l_exec_inner  BOOLEAN;

    CURSOR cur_targets
    IS
      SELECT usim_id_spc_target
           , usim_planck_aeon
           , usim_planck_time
        FROM usim_spc_process
       WHERE is_processed = 0
       GROUP BY usim_id_spc_target
              , usim_planck_aeon
              , usim_planck_time
    ;
    CURSOR cur_old_targets( cp_planck_aeon IN usim_spc_process.usim_planck_aeon%TYPE
                          , cp_planck_time IN usim_spc_process.usim_planck_time%TYPE
                          )
    IS
      SELECT usim_id_spc_target
           , usim_planck_aeon
           , usim_planck_time
        FROM usim_spc_process
       WHERE is_processed      = 0
         AND usim_planck_aeon  = cp_planck_aeon
         AND usim_planck_time  = cp_planck_time
       GROUP BY usim_id_spc_target
              , usim_planck_aeon
              , usim_planck_time
    ;
    CURSOR cur_target_energies( cp_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
                              , cp_planck_aeon        IN usim_spc_process.usim_planck_aeon%TYPE
                              , cp_planck_time        IN usim_spc_process.usim_planck_time%TYPE
                              )
    IS
      SELECT usim_id_spr
           , usim_energy_output
           , usim_id_spc_source
        FROM usim_spc_process
       WHERE is_processed       = 0
         AND usim_id_spc_target = cp_usim_id_spc_target
         AND usim_planck_aeon   = cp_planck_aeon
         AND usim_planck_time   = cp_planck_time
    ;
  BEGIN
    l_result := usim_dbif.has_unprocessed;
    IF l_result = 0
    THEN
      usim_erl.log_error('usim_process.process_queue', 'ERROR No targets found. Exit process.');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    l_result := usim_dbif.is_queue_valid;
    IF l_result != 1
    THEN
      usim_erl.log_error('usim_process.process_queue', 'Current process queue is not valid. State [' || l_result || '].');
      RETURN 0;
    END IF;
    -- get aeon and time
    l_result := usim_dbif.get_unprocessed_planck(l_cur_aeon, l_cur_time);
    IF l_result != 1
    THEN
      usim_erl.log_error('usim_process.process_queue', 'Could not fetch current planck aeon and time. State [' || l_result || '].');
      RETURN 0;
    END IF;
    -- update current targets within current planck time tick
    l_executed := FALSE;
    FOR recmain IN cur_targets
    LOOP
      l_executed := TRUE;
      -- check target, if the universe seed state is invalid, do not process it
      IF usim_dbif.is_seed_active = 1
      THEN
        l_usim_id_nod := usim_dbif.get_id_nod(recmain.usim_id_spc_target);
        IF l_usim_id_nod IS NULL
        THEN
          usim_erl.log_error('usim_process.process_queue', 'Could not get node for target id [' || recmain.usim_id_spc_target || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        IF l_result = 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_process.process_queue', 'usim_process.check_border failed. Could not flip direction of space id [' || recmain.usim_id_spc_target || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        l_energy := NVL(usim_nod.get_energy(l_usim_id_nod), 0);
        -- sum up energy for every position to be able to identify the process causing overflow
        l_exec_inner := FALSE;
        FOR rec IN cur_target_energies(recmain.usim_id_spc_target, recmain.usim_planck_aeon, recmain.usim_planck_time)
        LOOP
          l_exec_inner := TRUE;
          IF usim_dbif.is_overflow_energy_add(rec.usim_energy_output, l_energy) = 1
          THEN
            -- overflow energy
            usim_debug.debug_log('usim_process.process_queue', 'Overflow for target space id [' || recmain.usim_id_spc_target || '] with energy [' || rec.usim_energy_output || '] and current target energy [' || l_energy || ']. Set energy to 0.');
            -- handle overflow and create a new universe
            l_result := usim_creator.handle_overflow(recmain.usim_id_spc_target, FALSE);
            IF l_result = 0
            THEN
              ROLLBACK;
              usim_erl.log_error('usim_process.process_queue', 'usim_creator.handle_overflow failed for space id [' || recmain.usim_id_spc_target || '] usim_dbif.is_overflow_energy_add.');
              usim_dbif.set_crashed;
              RETURN 0;
            END IF;
            -- set energy to zero and do not add any more energy
            l_energy := 0;
            EXIT;
          ELSE
            l_energy := l_energy + NVL(rec.usim_energy_output, 0);
          END IF;
        END LOOP;
        IF NOT l_exec_inner
        THEN
          usim_erl.log_error('usim_process.process_queue', 'Cursor cur_target_energies has no data paramenters [' || recmain.usim_id_spc_target || '], [' || recmain.usim_planck_aeon || '], [' || recmain.usim_planck_time || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        -- update energies on target
        l_energy_set := usim_nod.update_energy(l_energy, l_usim_id_nod, FALSE);
        IF l_energy_set != l_energy
        THEN
          usim_erl.log_error('usim_process.process_queue', 'Database storage issue for target id [' || recmain.usim_id_spc_target || '] and node id [' || l_usim_id_nod || '] as stored energy [' || l_energy_set || '] does not match energy set [' || l_energy || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
      ELSE
        usim_erl.log_error('usim_process.process_queue', 'No processing of targets as universe seed is not active any longer.');
        RETURN 0;
      END IF;
    END LOOP;
    IF NOT l_executed
    THEN
      usim_erl.log_error('usim_process.process_queue', 'Cursor cur_targets has no data.');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    -- done all
    -- change planck tick, next processing step
    l_planck_tick := usim_dbif.get_planck_time_next;
    -- get current aeon after update
    l_planck_aeon := usim_dbif.get_planck_aeon_seq_current;
    -- create new processes and update old processes
    l_executed := FALSE;
    FOR recmain IN cur_old_targets(l_cur_aeon, l_cur_time)
    LOOP
      l_executed := TRUE;
      -- create new process with childs of target
      l_result := usim_process.process_node(recmain.usim_id_spc_target, FALSE);
      IF l_result = 0
      THEN
        usim_erl.log_error('usim_process.process_queue', 'Unable to process next nodes for target id [' || recmain.usim_id_spc_target || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      -- now update old processes
      l_exec_inner := FALSE;
      FOR rec IN cur_target_energies(recmain.usim_id_spc_target, recmain.usim_planck_aeon, recmain.usim_planck_time)
      LOOP
        l_exec_inner := TRUE;
        IF usim_dbif.is_universe_active(recmain.usim_id_spc_target) = 1
        THEN
          l_result := usim_dbif.set_processed(rec.usim_id_spr, 1, FALSE);
        ELSE
          -- if universe is invalid, sets process code 2
          l_result := usim_dbif.set_processed(rec.usim_id_spr, 2, FALSE);
        END IF;
        IF l_result = 0
        THEN
          usim_erl.log_error('usim_process.process_queue', 'Unable to set processed for process id [' || rec.usim_id_spr || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        -- flip direction for processed
        l_result := usim_dbif.flip_process_spin(rec.usim_id_spc_source, FALSE);
        IF l_result = 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_process.process_queue', 'Could not flip direction of space id [' || rec.usim_id_spc_source || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
      END LOOP;
      IF NOT l_exec_inner
      THEN
        usim_erl.log_error('usim_process.process_queue', 'Cursor cur_target_energies in old targets has no data paramenters [' || recmain.usim_id_spc_target || '], [' || recmain.usim_planck_aeon || '], [' || recmain.usim_planck_time || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      -- handle border
      l_result := usim_dbif.check_border(recmain.usim_id_spc_target, FALSE);
      IF l_result != 1
      THEN
        usim_erl.log_error('usim_process.process_queue', 'Check border failed with parameter [' || recmain.usim_id_spc_target || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    END LOOP;
    IF NOT l_executed
    THEN
      usim_erl.log_error('usim_process.process_queue', 'Cursor cur_old_targets has no data for parameters [' || l_cur_aeon || '], [' || l_cur_time || '].');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    -- everything gone well, commit if defined
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_process.process_queue', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END process_queue
  ;

  FUNCTION update_universe_states(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  IS
    l_return NUMBER;

    CURSOR cur_universes
    IS
      SELECT usim_id_mlv
        FROM usim_multiverse
    ;
  BEGIN
    FOR rec IN cur_universes
    LOOP
      l_return := usim_dbif.set_universe_state(rec.usim_id_mlv, FALSE);
      IF l_return IS NULL
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_process.update_universe_states', 'Universe setting state error.');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    END LOOP;
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_process.update_universe_states', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END update_universe_states
  ;

  FUNCTION run_samples( p_run_count IN NUMBER
                      , p_do_commit IN BOOLEAN DEFAULT TRUE
                      )
    RETURN NUMBER
  IS
    l_return NUMBER;
  BEGIN
    FOR l_idx IN 1..p_run_count
    LOOP
      -- check system with every loop
      IF usim_dbif.is_seed_active != 1
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_process.run_samples', 'Universe seed is not active. Run index: [' || l_idx || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      IF usim_dbif.is_queue_valid != 1
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_process.run_samples', 'Process queue is not valid [' || usim_dbif.is_queue_valid || ']. Run index: [' || l_idx || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      -- now process
      l_return := usim_process.process_queue(p_do_commit);
      IF l_return = 0
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_process.run_samples', 'Error running process_queue. Run index: [' || l_idx || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      l_return := usim_process.update_universe_states(p_do_commit);
      IF l_return = 0
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_process.run_samples', 'Error running update_universe_states. Run index: [' || l_idx || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      -- commit every successful process
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
    END LOOP;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_process.run_samples', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END run_samples
  ;

END usim_process;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_process
IS
  -- see header for documentation

  FUNCTION place_start_node( p_max_dimension            IN NUMBER                                       DEFAULT 42
                           , p_usim_abs_max_number      IN NUMBER                                       DEFAULT 99999999999999999999999999999999999999
                           , p_usim_overflow_node_seed  IN NUMBER                                       DEFAULT 0
                           , p_usim_energy_start_value  IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
                           , p_usim_planck_time_unit    IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
                           , p_usim_planck_length_unit  IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
                           , p_usim_planck_speed_unit   IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
                           , p_usim_planck_stable       IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
                           , p_usim_ultimate_border     IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
                           , p_do_commit                IN BOOLEAN                                      DEFAULT TRUE
                           )
    RETURN NUMBER
  IS
    l_source_G      NUMBER;
    l_distance      NUMBER;
    l_energy        NUMBER;
    l_start_value   NUMBER;
    l_target_energy NUMBER;
    l_resDimG       NUMBER;
    l_resR          NUMBER;
    l_resEnergy     NUMBER;
    l_return        NUMBER;
    l_planck_time   NUMBER;
    l_planck_aeon   usim_static.usim_id;
    l_state         usim_multiverse.usim_universe_status%TYPE;
    l_base_id       usim_space.usim_id_spc%TYPE;
    l_spr_id        usim_spc_process.usim_id_spr%TYPE;

    CURSOR cur_childs(cp_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    IS
      SELECT chi.usim_id_spc_child
           , spcv.usim_energy
           , spcv.dim_sign
        FROM usim_spc_child chi
       INNER JOIN usim_spc_v spcv
          ON chi.usim_id_spc_child = spcv.usim_id_spc
       WHERE chi.usim_id_spc = cp_usim_id_spc
    ;
  BEGIN
    IF usim_dbif.has_data_spr = 1
    THEN
      -- can't insert start node if data already exist
      usim_erl.log_error('usim_process.place_start_node', 'Process already initialized, no start node allowed.');
      RETURN 0;
    END IF;
    -- prepare base data if needed
    IF usim_dbif.has_basedata = 0
    THEN
      l_return := usim_dbif.init_basedata(p_max_dimension, p_usim_abs_max_number, p_usim_overflow_node_seed);
      IF l_return = 0
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Could not initialize base data with max dim [' || p_max_dimension || '], max_num [' || p_usim_abs_max_number || '] and overflow rule [' || p_usim_overflow_node_seed || '].');
        RETURN 0;
      END IF;
    END IF;
    -- check planck aeon
    l_planck_aeon := usim_dbif.get_planck_aeon_seq_current;
    IF l_planck_aeon = usim_static.usim_not_available
    THEN
      -- init planck aeon and time
      l_planck_time := usim_dbif.get_planck_time_next;
      IF l_planck_time IS NULL
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Could not initialize planck time.');
        RETURN 0;
      END IF;
      l_planck_aeon := usim_dbif.get_planck_aeon_seq_current;
      IF l_planck_aeon = usim_static.usim_not_available
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Could not initialize planck aeon with planck time next.');
        RETURN 0;
      END IF;
    ELSE
      -- we should have a planck time if aeon is set
      l_planck_time := usim_dbif.get_planck_time_current;
      IF l_planck_time IS NULL
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Could not get current planck time with planck aeon already set.');
        RETURN 0;
      END IF;
    END IF;
    -- check universe
    IF usim_dbif.has_data_mlv = 0
    THEN
      -- create base universe seed
      l_base_id := usim_creator.create_new_universe( p_usim_energy_start_value
                                                   , p_usim_planck_time_unit
                                                   , p_usim_planck_length_unit
                                                   , p_usim_planck_speed_unit
                                                   , p_usim_planck_stable
                                                   , p_usim_ultimate_border
                                                   , NULL
                                                   , TRUE
                                                   )
      ;
      IF l_base_id IS NULL
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Could not create missing base universe energy start [' || p_usim_energy_start_value || '],  planck time [' || p_usim_planck_time_unit || '],  planck length [' || p_usim_planck_length_unit || '], planck speed [' || p_usim_planck_speed_unit || '], planck stable [' || p_usim_planck_stable || '], border rule [' || p_usim_ultimate_border || '] and no parent.');
        -- rely on rollback of called function
        RETURN 0;
      END IF;
    ELSE
      -- universe exists, what about nodes?
      IF usim_dbif.has_data_spc = 0
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Initialization error. Existing universe but no space nodes available.');
        RETURN 0;
      END IF;
      l_base_id := usim_dbif.get_id_spc_base_universe;
      IF l_base_id IS NULL
      THEN
        usim_erl.log_error('usim_process.place_start_node', 'Initialization error. Could not fetch base universe seed.');
        RETURN 0;
      END IF;
    END IF;
    -- check childs of base universe
    IF usim_dbif.child_count(l_base_id) != 2
    THEN
      -- we expect exactly two childs for base universe seed
        usim_erl.log_error('usim_process.place_start_node', 'Initialization error. Base universe seed has not the correct amount of childs (2).');
        RETURN 0;
    END IF;
    -- activate seed universe, if not already done
    l_state := usim_dbif.set_seed_active(FALSE);
    IF l_state != usim_static.usim_multiverse_status_active
    THEN
      ROLLBACK;
      -- cannot start with this universe
      usim_erl.log_error('usim_process.place_start_node', 'Universe state error. Current universe cannot be switched to active, space id [' || l_base_id || '] state [' || l_state || '].');
      RETURN 0;
    END IF;
    -- ready to start
    SELECT usim_energy
         , usim_energy_start_value
      INTO l_energy
         , l_start_value
      FROM usim_spc_v
     WHERE usim_id_spc = l_base_id
    ;
    IF l_energy IS NULL
    THEN
      l_energy := l_start_value;
    END IF;
    l_resDimG := usim_dbif.get_dim_G(l_base_id, l_source_G);
    IF l_resDimG != 1
    THEN
      usim_erl.log_error('usim_process.place_start_node', 'Universe setup error. Calculate dimension G for space id [' || l_base_id || '] should not give error or overflow [' || l_resDimG || '].');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    l_resR := usim_dbif.get_outer_planck_r(l_base_id, l_distance);
    IF l_resR != 1
    THEN
      usim_erl.log_error('usim_process.place_start_node', 'Universe setup error. Calculate radius for space id [' || l_base_id || '] should not give error or overflow [' || l_resR || '].');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    l_resEnergy := usim_dbif.get_acceleration(l_energy, l_distance, l_source_G, l_target_energy);
    IF l_resEnergy != 1
    THEN
      usim_erl.log_error('usim_process.place_start_node', 'Universe setup error. Calculate energy for base seed space id [' || l_base_id || '] should not give error or overflow [' || l_resEnergy || ']. Energy [' || l_energy || '], distance [' || l_distance || '], G [' || l_source_G || '].');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    -- process childs
    FOR rec IN cur_childs(l_base_id)
    LOOP
      l_spr_id := usim_dbif.create_process(l_base_id, rec.usim_id_spc_child, l_energy, rec.usim_energy, l_target_energy * rec.dim_sign, FALSE);
      IF l_spr_id IS NULL
      THEN
        ROLLBACK;
        -- error insert
        usim_erl.log_error('usim_process.place_start_node', 'Could not insert process record.');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    END LOOP;
    -- commit everything if gone well
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_process.place_start_node', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END place_start_node
  ;

  FUNCTION process_node( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
                       , p_do_commit   IN BOOLEAN                     DEFAULT TRUE
                       )
    RETURN NUMBER
  IS
    l_source_G      NUMBER;
    l_distance      NUMBER;
    l_energy        NUMBER;
    l_start_value   NUMBER;
    l_target_energy NUMBER;
    l_resDimG       NUMBER;
    l_resR          NUMBER;
    l_resEnergy     NUMBER;
    l_is_base       INTEGER;
    l_result        INTEGER;
    l_spr_id        usim_spc_process.usim_id_spr%TYPE;
    l_executed      BOOLEAN;

    CURSOR cur_childs(cp_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    IS
      SELECT chi.usim_id_spc_child
           , spcv.usim_energy
           , spcv.dim_sign
        FROM usim_spc_child chi
       INNER JOIN usim_spc_v spcv
          ON chi.usim_id_spc_child = spcv.usim_id_spc
       WHERE chi.usim_id_spc = cp_usim_id_spc
    ;
    CURSOR cur_parent(cp_usim_id_spc IN usim_space.usim_id_spc%TYPE)
    IS
      SELECT chi.usim_id_spc
           , spcv.usim_energy
           , spcv.dim_sign
        FROM usim_spc_child chi
       INNER JOIN usim_spc_v spcv
          ON chi.usim_id_spc = spcv.usim_id_spc
       WHERE chi.usim_id_spc_child = cp_usim_id_spc
    ;
  BEGIN
    IF usim_dbif.has_data_spc(p_usim_id_spc) = 0
    THEN
      usim_erl.log_error('usim_process.process_node', 'Used with invalid space id [' || p_usim_id_spc || '].');
      RETURN 0;
    END IF;
    IF usim_dbif.is_seed_active = 0
    THEN
      -- won't operate on universe not active
      usim_erl.log_error('usim_process.process_node', 'Current universe seed is not active. Node not processed space id [' || p_usim_id_spc || '].');
      RETURN 0;
    END IF;
    -- check border situation
    l_result := usim_dbif.check_border(p_usim_id_spc, FALSE);
    IF l_result != 1
    THEN
      usim_erl.log_error('usim_process.process_node', 'Check border failed with parameter [' || p_usim_id_spc || '] and result [' || l_result || '].');
      RETURN 0;
    END IF;
    -- operate on node
    SELECT usim_energy
         , usim_energy_start_value
      INTO l_energy
         , l_start_value
      FROM usim_spc_v
     WHERE usim_id_spc = p_usim_id_spc
    ;
    l_is_base := usim_dbif.is_universe_base_type(p_usim_id_spc);
    IF l_is_base = 1
    THEN
      IF l_energy IS NULL
      THEN
        l_energy := l_start_value;
      END IF;
    END IF;
    l_resDimG := usim_dbif.get_dim_G(p_usim_id_spc, l_source_G);
    IF l_resDimG != 1
    THEN
      IF l_resDimG = 0
      THEN
        usim_debug.debug_log('usim_process.process_node', 'Overflow for space id [' || p_usim_id_spc || '] usim_dbif.get_dim_G. Set G to default 1.');
        l_result   := usim_creator.handle_overflow(p_usim_id_spc, FALSE);
        IF l_result = 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_process.process_node', 'usim_creator.handle_overflow failed for space id [' || p_usim_id_spc || '] usim_dbif.get_dim_G.');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        -- set to default
        l_source_G := 1;
      ELSE
        usim_erl.log_error('usim_process.process_node', 'Universe setup error. Calculate dimension G for space id [' || p_usim_id_spc || '] should not give error [' || l_resDimG || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    END IF;
    l_resR := usim_dbif.get_outer_planck_r(p_usim_id_spc, l_distance);
    IF l_resR != 1
    THEN
      IF l_resR = 0
      THEN
        usim_debug.debug_log('usim_process.process_node', 'Overflow for space id [' || p_usim_id_spc || '] usim_dbif.get_outer_planck_r. Set distance to default 1.');
        l_result   := usim_creator.handle_overflow(p_usim_id_spc, FALSE);
        IF l_result = 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_process.process_node', 'usim_creator.handle_overflow failed for space id [' || p_usim_id_spc || '] usim_dbif.get_outer_planck_r.');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        -- set to default
        l_distance := 1;
      ELSE
        usim_erl.log_error('usim_process.process_node', 'Universe setup error. Calculate radius for space id [' || p_usim_id_spc || '] should not give error [' || l_resR || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    END IF;
    l_resEnergy := usim_dbif.get_acceleration(l_energy, l_distance, l_source_G, l_target_energy);
    IF l_resEnergy != 1
    THEN
      IF l_resEnergy = 0
      THEN
        usim_debug.debug_log('usim_process.process_node', 'Overflow for space id [' || p_usim_id_spc || '] usim_dbif.get_acceleration. Set target energy to 0.');
        l_result        := usim_creator.handle_overflow(p_usim_id_spc, FALSE);
        IF l_result = 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_process.process_node', 'usim_creator.handle_overflow failed for space id [' || p_usim_id_spc || '] usim_dbif.get_acceleration.');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        l_target_energy := 0;
      ELSE
        usim_erl.log_error('usim_process.process_node', 'Universe setup error. Calculate acceleration energy for space id [' || p_usim_id_spc || '] should not give error [' || l_resEnergy || ']. With energy [' || l_energy || '], distance [' || l_distance || '], G [' || l_source_G || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    END IF;
    -- process after checks decide direction
    IF usim_dbif.get_process_spin(p_usim_id_spc) = 1
    THEN
      -- childs
      l_executed := FALSE;
      FOR rec IN cur_childs(p_usim_id_spc)
      LOOP
        l_executed := TRUE;
        l_spr_id := usim_dbif.create_process( p_usim_id_spc
                                            , rec.usim_id_spc_child
                                            , l_energy
                                            , rec.usim_energy
                                            , CASE
                                                WHEN l_is_base = 1
                                                THEN l_target_energy * rec.dim_sign
                                                ELSE l_target_energy
                                              END
                                            , FALSE
                                            )
        ;
        IF l_spr_id IS NULL
        THEN
          ROLLBACK;
          -- error insert
          usim_erl.log_error('usim_process.process_node', 'Could not insert process record for space id [' || p_usim_id_spc || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
      END LOOP;
      IF NOT l_executed
      THEN
        usim_erl.log_error('usim_process.process_node', 'ERROR Child cursors had no data. cur_childs(' || p_usim_id_spc || ') process spin 1');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    ELSIF usim_dbif.get_process_spin(p_usim_id_spc) = -1
    THEN
      -- parents
      l_executed := FALSE;
      FOR rec IN cur_parent(p_usim_id_spc)
      LOOP
        l_executed := TRUE;
        l_spr_id := usim_dbif.create_process( p_usim_id_spc
                                            , rec.usim_id_spc
                                            , l_energy
                                            , rec.usim_energy
                                            , CASE
                                                WHEN l_is_base = 1
                                                THEN l_target_energy * rec.dim_sign
                                                ELSE l_target_energy
                                              END
                                            , FALSE
                                            )
        ;
        IF l_spr_id IS NULL
        THEN
          ROLLBACK;
          -- error insert
          usim_erl.log_error('usim_process.process_node', 'Could not insert process record for space id [' || p_usim_id_spc || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
      END LOOP;
      IF NOT l_executed
      THEN
        usim_erl.log_error('usim_process.process_node', 'ERROR Parent cursor had no data. cur_parent(' || p_usim_id_spc || ') process spin -1');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    ELSE
      -- invalid space id or process spin
      ROLLBACK;
      -- error insert
      usim_erl.log_error('usim_process.process_node', 'Invalid space id [' || p_usim_id_spc || '] no process direction found.');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_process.process_node', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END process_node
  ;

  FUNCTION process_queue(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  IS
    l_energy      NUMBER;
    l_energy_set  NUMBER;
    l_result      NUMBER;
    l_planck_tick NUMBER;
    l_usim_id_nod usim_node.usim_id_nod%TYPE;
    l_planck_aeon usim_spc_process.usim_planck_aeon%TYPE;
    l_planck_time usim_spc_process.usim_planck_time%TYPE;
    l_cur_aeon    usim_spc_process.usim_planck_aeon%TYPE;
    l_cur_time    usim_spc_process.usim_planck_time%TYPE;
    l_usim_id_spr usim_spc_process.usim_id_spr%TYPE;
    l_executed    BOOLEAN;
    l_exec_inner  BOOLEAN;

    CURSOR cur_targets
    IS
      SELECT usim_id_spc_target
           , usim_planck_aeon
           , usim_planck_time
        FROM usim_spc_process
       WHERE is_processed = 0
       GROUP BY usim_id_spc_target
              , usim_planck_aeon
              , usim_planck_time
    ;
    CURSOR cur_old_targets( cp_planck_aeon IN usim_spc_process.usim_planck_aeon%TYPE
                          , cp_planck_time IN usim_spc_process.usim_planck_time%TYPE
                          )
    IS
      SELECT usim_id_spc_target
           , usim_planck_aeon
           , usim_planck_time
        FROM usim_spc_process
       WHERE is_processed      = 0
         AND usim_planck_aeon  = cp_planck_aeon
         AND usim_planck_time  = cp_planck_time
       GROUP BY usim_id_spc_target
              , usim_planck_aeon
              , usim_planck_time
    ;
    CURSOR cur_target_energies( cp_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
                              , cp_planck_aeon        IN usim_spc_process.usim_planck_aeon%TYPE
                              , cp_planck_time        IN usim_spc_process.usim_planck_time%TYPE
                              )
    IS
      SELECT usim_id_spr
           , usim_energy_output
           , usim_id_spc_source
        FROM usim_spc_process
       WHERE is_processed       = 0
         AND usim_id_spc_target = cp_usim_id_spc_target
         AND usim_planck_aeon   = cp_planck_aeon
         AND usim_planck_time   = cp_planck_time
    ;
  BEGIN
    l_result := usim_dbif.has_unprocessed;
    IF l_result = 0
    THEN
      usim_erl.log_error('usim_process.process_queue', 'ERROR No targets found. Exit process.');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    l_result := usim_dbif.is_queue_valid;
    IF l_result != 1
    THEN
      usim_erl.log_error('usim_process.process_queue', 'Current process queue is not valid. State [' || l_result || '].');
      RETURN 0;
    END IF;
    -- get aeon and time
    l_result := usim_dbif.get_unprocessed_planck(l_cur_aeon, l_cur_time);
    IF l_result != 1
    THEN
      usim_erl.log_error('usim_process.process_queue', 'Could not fetch current planck aeon and time. State [' || l_result || '].');
      RETURN 0;
    END IF;
    -- update current targets within current planck time tick
    l_executed := FALSE;
    FOR recmain IN cur_targets
    LOOP
      l_executed := TRUE;
      -- check target, if the universe seed state is invalid, do not process it
      IF usim_dbif.is_seed_active = 1
      THEN
        l_usim_id_nod := usim_dbif.get_id_nod(recmain.usim_id_spc_target);
        IF l_usim_id_nod IS NULL
        THEN
          usim_erl.log_error('usim_process.process_queue', 'Could not get node for target id [' || recmain.usim_id_spc_target || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        IF l_result = 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_process.process_queue', 'usim_process.check_border failed. Could not flip direction of space id [' || recmain.usim_id_spc_target || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        l_energy := NVL(usim_nod.get_energy(l_usim_id_nod), 0);
        -- sum up energy for every position to be able to identify the process causing overflow
        l_exec_inner := FALSE;
        FOR rec IN cur_target_energies(recmain.usim_id_spc_target, recmain.usim_planck_aeon, recmain.usim_planck_time)
        LOOP
          l_exec_inner := TRUE;
          IF usim_dbif.is_overflow_energy_add(rec.usim_energy_output, l_energy) = 1
          THEN
            -- overflow energy
            usim_debug.debug_log('usim_process.process_queue', 'Overflow for target space id [' || recmain.usim_id_spc_target || '] with energy [' || rec.usim_energy_output || '] and current target energy [' || l_energy || ']. Set energy to 0.');
            -- handle overflow and create a new universe
            l_result := usim_creator.handle_overflow(recmain.usim_id_spc_target, FALSE);
            IF l_result = 0
            THEN
              ROLLBACK;
              usim_erl.log_error('usim_process.process_queue', 'usim_creator.handle_overflow failed for space id [' || recmain.usim_id_spc_target || '] usim_dbif.is_overflow_energy_add.');
              usim_dbif.set_crashed;
              RETURN 0;
            END IF;
            -- set energy to zero and do not add any more energy
            l_energy := 0;
            EXIT;
          ELSE
            l_energy := l_energy + NVL(rec.usim_energy_output, 0);
          END IF;
        END LOOP;
        IF NOT l_exec_inner
        THEN
          usim_erl.log_error('usim_process.process_queue', 'Cursor cur_target_energies has no data paramenters [' || recmain.usim_id_spc_target || '], [' || recmain.usim_planck_aeon || '], [' || recmain.usim_planck_time || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        -- update energies on target
        l_energy_set := usim_nod.update_energy(l_energy, l_usim_id_nod, FALSE);
        IF l_energy_set != l_energy
        THEN
          usim_erl.log_error('usim_process.process_queue', 'Database storage issue for target id [' || recmain.usim_id_spc_target || '] and node id [' || l_usim_id_nod || '] as stored energy [' || l_energy_set || '] does not match energy set [' || l_energy || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
      ELSE
        usim_erl.log_error('usim_process.process_queue', 'No processing of targets as universe seed is not active any longer.');
        RETURN 0;
      END IF;
    END LOOP;
    IF NOT l_executed
    THEN
      usim_erl.log_error('usim_process.process_queue', 'Cursor cur_targets has no data.');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    -- done all
    -- change planck tick, next processing step
    l_planck_tick := usim_dbif.get_planck_time_next;
    -- get current aeon after update
    l_planck_aeon := usim_dbif.get_planck_aeon_seq_current;
    -- create new processes and update old processes
    l_executed := FALSE;
    FOR recmain IN cur_old_targets(l_cur_aeon, l_cur_time)
    LOOP
      l_executed := TRUE;
      -- create new process with childs of target
      l_result := usim_process.process_node(recmain.usim_id_spc_target, FALSE);
      IF l_result = 0
      THEN
        usim_erl.log_error('usim_process.process_queue', 'Unable to process next nodes for target id [' || recmain.usim_id_spc_target || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      -- now update old processes
      l_exec_inner := FALSE;
      FOR rec IN cur_target_energies(recmain.usim_id_spc_target, recmain.usim_planck_aeon, recmain.usim_planck_time)
      LOOP
        l_exec_inner := TRUE;
        IF usim_dbif.is_universe_active(recmain.usim_id_spc_target) = 1
        THEN
          l_result := usim_dbif.set_processed(rec.usim_id_spr, 1, FALSE);
        ELSE
          -- if universe is invalid, sets process code 2
          l_result := usim_dbif.set_processed(rec.usim_id_spr, 2, FALSE);
        END IF;
        IF l_result = 0
        THEN
          usim_erl.log_error('usim_process.process_queue', 'Unable to set processed for process id [' || rec.usim_id_spr || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
        -- flip direction for processed
        l_result := usim_dbif.flip_process_spin(rec.usim_id_spc_source, FALSE);
        IF l_result = 0
        THEN
          ROLLBACK;
          usim_erl.log_error('usim_process.process_queue', 'Could not flip direction of space id [' || rec.usim_id_spc_source || '].');
          usim_dbif.set_crashed;
          RETURN 0;
        END IF;
      END LOOP;
      IF NOT l_exec_inner
      THEN
        usim_erl.log_error('usim_process.process_queue', 'Cursor cur_target_energies in old targets has no data paramenters [' || recmain.usim_id_spc_target || '], [' || recmain.usim_planck_aeon || '], [' || recmain.usim_planck_time || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      -- handle border
      l_result := usim_dbif.check_border(recmain.usim_id_spc_target, FALSE);
      IF l_result != 1
      THEN
        usim_erl.log_error('usim_process.process_queue', 'Check border failed with parameter [' || recmain.usim_id_spc_target || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    END LOOP;
    IF NOT l_executed
    THEN
      usim_erl.log_error('usim_process.process_queue', 'Cursor cur_old_targets has no data for parameters [' || l_cur_aeon || '], [' || l_cur_time || '].');
      usim_dbif.set_crashed;
      RETURN 0;
    END IF;
    -- everything gone well, commit if defined
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_process.process_queue', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END process_queue
  ;

  FUNCTION update_universe_states(p_do_commit IN BOOLEAN DEFAULT TRUE)
    RETURN NUMBER
  IS
    l_return NUMBER;

    CURSOR cur_universes
    IS
      SELECT usim_id_mlv
        FROM usim_multiverse
    ;
  BEGIN
    FOR rec IN cur_universes
    LOOP
      l_return := usim_dbif.set_universe_state(rec.usim_id_mlv, FALSE);
      IF l_return IS NULL
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_process.update_universe_states', 'Universe setting state error.');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
    END LOOP;
    IF p_do_commit
    THEN
      COMMIT;
    END IF;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_process.update_universe_states', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END update_universe_states
  ;

  FUNCTION run_samples( p_run_count IN NUMBER
                      , p_do_commit IN BOOLEAN DEFAULT TRUE
                      )
    RETURN NUMBER
  IS
    l_return NUMBER;
  BEGIN
    FOR l_idx IN 1..p_run_count
    LOOP
      -- check system with every loop
      IF usim_dbif.is_seed_active != 1
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_process.run_samples', 'Universe seed is not active. Run index: [' || l_idx || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      IF usim_dbif.is_queue_valid != 1
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_process.run_samples', 'Process queue is not valid [' || usim_dbif.is_queue_valid || ']. Run index: [' || l_idx || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      -- now process
      l_return := usim_process.process_queue(p_do_commit);
      IF l_return = 0
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_process.run_samples', 'Error running process_queue. Run index: [' || l_idx || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      l_return := usim_process.update_universe_states(p_do_commit);
      IF l_return = 0
      THEN
        ROLLBACK;
        usim_erl.log_error('usim_process.run_samples', 'Error running update_universe_states. Run index: [' || l_idx || '].');
        usim_dbif.set_crashed;
        RETURN 0;
      END IF;
      -- commit every successful process
      IF p_do_commit
      THEN
        COMMIT;
      END IF;
    END LOOP;
    RETURN 1;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      -- write error might still work
      usim_erl.log_error('usim_process.run_samples', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
      -- try to set all to crashed
      usim_dbif.set_crashed;
      -- raise in any case
      RAISE;
  END run_samples
  ;

END usim_process;

Package Body USIM_PROCESS kompiliert

SQL> --== processing packages end ==--
SQL> -- build test model
SQL> @@USIM_TEST_MODEL.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> --== sequences start ==--
SQL> -- USIM_TEST_SUMMARY (tsu) sequence
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../SEQUENCES/USIM_TSU_ID_SEQ.sql'
  4           ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_TSU_ID_SEQ still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TSU_ID_SEQ'
  8     AND object_type = 'SEQUENCE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_TSU_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_TSU_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TSU_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../SEQUENCES/USIM_TSU_ID_SEQ.sql'
         ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_TSU_ID_SEQ still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TSU_ID_SEQ'
   AND object_type = 'SEQUENCE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_TSU_ID_SEQ.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_TEST_SUMMARY (tsu) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_tsu_id_seq
  2    MINVALUE 1
  3    INCREMENT BY 1
  4    START WITH 1
  5    CACHE 20
  6    NOORDER
  7    NOCYCLE
  8    NOKEEP
  9    NOSCALE
 10    GLOBAL
 11  ;
alt:CREATE SEQUENCE &USIM_SCHEMA..usim_tsu_id_seq
  MINVALUE 1
  INCREMENT BY 1
  START WITH 1
  CACHE 20
  NOORDER
  NOCYCLE
  NOKEEP
  NOSCALE
  GLOBAL

neu:CREATE SEQUENCE USIM_TEST.usim_tsu_id_seq
  MINVALUE 1
  INCREMENT BY 1
  START WITH 1
  CACHE 20
  NOORDER
  NOCYCLE
  NOKEEP
  NOSCALE
  GLOBAL

Sequence USIM_TEST.USIM_TSU_ID_SEQ erstellt.

SQL> --== sequences end ==--
SQL>
SQL> --== test tables start ==--
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_TEST_SUMMARY_TBL.sql'
  4           ELSE '../UTIL/../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_TEST_SUMMARY still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TEST_SUMMARY'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_TEST_SUMMARY_TBL.sql'
         ELSE '../UTIL/../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_TEST_SUMMARY still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TEST_SUMMARY'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_TEST_SUMMARY_TBL.sql'
         ELSE '../UTIL/../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_TEST_SUMMARY still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TEST_SUMMARY'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------------------------
../TABLES/USIM_TEST_SUMMARY_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_TEST_SUMMARY (tsu)
SQL> CREATE TABLE &USIM_SCHEMA..usim_test_summary
  2    ( usim_id_tsu         NUMBER          NOT NULL ENABLE
  3    , usim_test_object    VARCHAR2(128)   NOT NULL ENABLE
  4    , usim_tests_success  NUMBER
  5    , usim_tests_failed   NUMBER
  6    )
  7  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_test_summary
  ( usim_id_tsu         NUMBER          NOT NULL ENABLE
  , usim_test_object    VARCHAR2(128)   NOT NULL ENABLE
  , usim_tests_success  NUMBER
  , usim_tests_failed   NUMBER
  )

neu:CREATE TABLE USIM_TEST.usim_test_summary
  ( usim_id_tsu         NUMBER          NOT NULL ENABLE
  , usim_test_object    VARCHAR2(128)   NOT NULL ENABLE
  , usim_tests_success  NUMBER
  , usim_tests_failed   NUMBER
  )

Table USIM_TEST.USIM_TEST_SUMMARY erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_test_summary IS 'Table to contain test summary of tests executed. Will use the alias tsu.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_test_summary IS 'Table to contain test summary of tests executed. Will use the alias tsu.'
neu:COMMENT ON TABLE USIM_TEST.usim_test_summary IS 'Table to contain test summary of tests executed. Will use the alias tsu.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_id_tsu IS 'Unique id of an executed test.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_id_tsu IS 'Unique id of an executed test.'
neu:COMMENT ON COLUMN USIM_TEST.usim_test_summary.usim_id_tsu IS 'Unique id of an executed test.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_test_object IS 'Description of the test executed.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_test_object IS 'Description of the test executed.'
neu:COMMENT ON COLUMN USIM_TEST.usim_test_summary.usim_test_object IS 'Description of the test executed.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_tests_success IS 'Amount of successful executed tests for the test object.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_tests_success IS 'Amount of successful executed tests for the test object.'
neu:COMMENT ON COLUMN USIM_TEST.usim_test_summary.usim_tests_success IS 'Amount of successful executed tests for the test object.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_tests_failed IS 'Amount of failed executed tests for the test object.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_tests_failed IS 'Amount of failed executed tests for the test object.'
neu:COMMENT ON COLUMN USIM_TEST.usim_test_summary.usim_tests_failed IS 'Amount of failed executed tests for the test object.'

Comment erstellt.

SQL>
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_test_summary
  2    ADD CONSTRAINT usim_tsu_pk
  3    PRIMARY KEY (usim_id_tsu)
  4    ENABLE
  5  ;
alt:ALTER TABLE &USIM_SCHEMA..usim_test_summary
  ADD CONSTRAINT usim_tsu_pk
  PRIMARY KEY (usim_id_tsu)
  ENABLE

neu:ALTER TABLE USIM_TEST.usim_test_summary
  ADD CONSTRAINT usim_tsu_pk
  PRIMARY KEY (usim_id_tsu)
  ENABLE

Table USIM_TEST.USIM_TEST_SUMMARY geändert.

SQL>
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_tsu_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_test_summary
  3      FOR EACH ROW
  4      BEGIN
  5        -- always set this values on insert, do not care about input
  6        :NEW.usim_id_tsu := usim_tsu_id_seq.NEXTVAL;
  7      END;
  8  /
alt:CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_tsu_ins_trg
  BEFORE INSERT ON &USIM_SCHEMA..usim_test_summary
    FOR EACH ROW
    BEGIN
      -- always set this values on insert, do not care about input
      :NEW.usim_id_tsu := usim_tsu_id_seq.NEXTVAL;
    END;

neu:CREATE OR REPLACE TRIGGER USIM_TEST.usim_tsu_ins_trg
  BEFORE INSERT ON USIM_TEST.usim_test_summary
    FOR EACH ROW
    BEGIN
      -- always set this values on insert, do not care about input
      :NEW.usim_id_tsu := usim_tsu_id_seq.NEXTVAL;
    END;

Trigger USIM_TSU_INS_TRG kompiliert

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_tsu_ins_trg ENABLE;
alt:ALTER TRIGGER &USIM_SCHEMA..usim_tsu_ins_trg ENABLE
neu:ALTER TRIGGER USIM_TEST.usim_tsu_ins_trg ENABLE

Trigger USIM_TEST.USIM_TSU_INS_TRG geändert.

SQL> -- USIM_TEST_ERRORS (ter)
SQL> SELECT CASE
  2           WHEN COUNT(*) = 0
  3           THEN '../TABLES/USIM_TEST_ERRORS_TBL.sql'
  4           ELSE '../UTIL/../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_TEST_ERRORS still exists."'
  5         END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TEST_ERRORS'
  8     AND object_type = 'TABLE'
  9     AND owner       = '&USIM_SCHEMA'
 10  ;
alt:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_TEST_ERRORS_TBL.sql'
         ELSE '../UTIL/../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_TEST_ERRORS still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TEST_ERRORS'
   AND object_type = 'TABLE'
   AND owner       = '&USIM_SCHEMA'

neu:SELECT CASE
         WHEN COUNT(*) = 0
         THEN '../TABLES/USIM_TEST_ERRORS_TBL.sql'
         ELSE '../UTIL/../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_TEST_ERRORS still exists."'
       END AS SCRIPTFILE
  FROM all_objects
 WHERE object_name = 'USIM_TEST_ERRORS'
   AND object_type = 'TABLE'
   AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------------
../TABLES/USIM_TEST_ERRORS_TBL.sql

1 Zeile ausgewählt.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- USIM_TEST_ERRORS (ter)
SQL> CREATE TABLE &USIM_SCHEMA..usim_test_errors
  2    ( usim_id_tsu       NUMBER                                NOT NULL ENABLE
  3    , usim_timestamp    TIMESTAMP       DEFAULT SYSTIMESTAMP  NOT NULL ENABLE
  4    , usim_error_msg    VARCHAR2(4000)                        NOT NULL ENABLE
  5    )
  6  ;
alt:CREATE TABLE &USIM_SCHEMA..usim_test_errors
  ( usim_id_tsu       NUMBER                                NOT NULL ENABLE
  , usim_timestamp    TIMESTAMP       DEFAULT SYSTIMESTAMP  NOT NULL ENABLE
  , usim_error_msg    VARCHAR2(4000)                        NOT NULL ENABLE
  )

neu:CREATE TABLE USIM_TEST.usim_test_errors
  ( usim_id_tsu       NUMBER                                NOT NULL ENABLE
  , usim_timestamp    TIMESTAMP       DEFAULT SYSTIMESTAMP  NOT NULL ENABLE
  , usim_error_msg    VARCHAR2(4000)                        NOT NULL ENABLE
  )

Table USIM_TEST.USIM_TEST_ERRORS erstellt.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_test_errors IS 'Contains errors that occured in executed tests. Will use the alias ter.';
alt:COMMENT ON TABLE &USIM_SCHEMA..usim_test_errors IS 'Contains errors that occured in executed tests. Will use the alias ter.'
neu:COMMENT ON TABLE USIM_TEST.usim_test_errors IS 'Contains errors that occured in executed tests. Will use the alias ter.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_errors.usim_id_tsu IS 'The related id in usim_test_summary. No FK used, only controlled by application.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_test_errors.usim_id_tsu IS 'The related id in usim_test_summary. No FK used, only controlled by application.'
neu:COMMENT ON COLUMN USIM_TEST.usim_test_errors.usim_id_tsu IS 'The related id in usim_test_summary. No FK used, only controlled by application.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_errors.usim_timestamp IS 'The time stamp of the error in a test.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_test_errors.usim_timestamp IS 'The time stamp of the error in a test.'
neu:COMMENT ON COLUMN USIM_TEST.usim_test_errors.usim_timestamp IS 'The time stamp of the error in a test.'

Comment erstellt.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_errors.usim_error_msg IS 'The error message of the test.';
alt:COMMENT ON COLUMN &USIM_SCHEMA..usim_test_errors.usim_error_msg IS 'The error message of the test.'
neu:COMMENT ON COLUMN USIM_TEST.usim_test_errors.usim_error_msg IS 'The error message of the test.'

Comment erstellt.

SQL> -- test package
SQL> @@../PACKAGES/USIM_TEST.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_test
  2  IS
  3    /** Package for test support.
  4    * No checks are done, parameters must be valid.
  5    */
  6
  7    /**
  8    * Initialize a new test.
  9    * @param p_usim_test_object The name of the test object.
 10    * @return The id of the initialized test.
 11    */
 12    FUNCTION init_test(p_usim_test_object IN usim_test_summary.usim_test_object%TYPE)
 13      RETURN NUMBER
 14    ;
 15
 16    /**
 17    * Logs an error message that occured in a test for a given test object.
 18    * @param p_usim_id_tsu The id of the test object in usim_test_summary.
 19    * @param p_usim_error_msg The error message to log in usim_test_errors.
 20    */
 21    PROCEDURE log_error( p_usim_id_tsu    IN usim_test_errors.usim_id_tsu%TYPE
 22                       , p_usim_error_msg IN usim_test_errors.usim_error_msg%TYPE
 23                       )
 24    ;
 25
 26    /**
 27    * Persists the test results after testing.
 28    * @param p_usim_id_tsu The id of the test object in usim_test_summary.
 29    * @param p_usim_success The amount of successful tests.
 30    * @param p_usim_failed The amount of failed tests.
 31    */
 32    PROCEDURE write_test_results( p_usim_id_tsu   IN usim_test_summary.usim_id_tsu%TYPE
 33                                , p_usim_success  IN NUMBER
 34                                , p_usim_failed   IN NUMBER
 35                                )
 36    ;
 37  END usim_test;
 38  /
alt:CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_test
IS
  /** Package for test support.
  * No checks are done, parameters must be valid.
  */

  /**
  * Initialize a new test.
  * @param p_usim_test_object The name of the test object.
  * @return The id of the initialized test.
  */
  FUNCTION init_test(p_usim_test_object IN usim_test_summary.usim_test_object%TYPE)
    RETURN NUMBER
  ;

  /**
  * Logs an error message that occured in a test for a given test object.
  * @param p_usim_id_tsu The id of the test object in usim_test_summary.
  * @param p_usim_error_msg The error message to log in usim_test_errors.
  */
  PROCEDURE log_error( p_usim_id_tsu    IN usim_test_errors.usim_id_tsu%TYPE
                     , p_usim_error_msg IN usim_test_errors.usim_error_msg%TYPE
                     )
  ;

  /**
  * Persists the test results after testing.
  * @param p_usim_id_tsu The id of the test object in usim_test_summary.
  * @param p_usim_success The amount of successful tests.
  * @param p_usim_failed The amount of failed tests.
  */
  PROCEDURE write_test_results( p_usim_id_tsu   IN usim_test_summary.usim_id_tsu%TYPE
                              , p_usim_success  IN NUMBER
                              , p_usim_failed   IN NUMBER
                              )
  ;
END usim_test;

neu:CREATE OR REPLACE PACKAGE USIM_TEST.usim_test
IS
  /** Package for test support.
  * No checks are done, parameters must be valid.
  */

  /**
  * Initialize a new test.
  * @param p_usim_test_object The name of the test object.
  * @return The id of the initialized test.
  */
  FUNCTION init_test(p_usim_test_object IN usim_test_summary.usim_test_object%TYPE)
    RETURN NUMBER
  ;

  /**
  * Logs an error message that occured in a test for a given test object.
  * @param p_usim_id_tsu The id of the test object in usim_test_summary.
  * @param p_usim_error_msg The error message to log in usim_test_errors.
  */
  PROCEDURE log_error( p_usim_id_tsu    IN usim_test_errors.usim_id_tsu%TYPE
                     , p_usim_error_msg IN usim_test_errors.usim_error_msg%TYPE
                     )
  ;

  /**
  * Persists the test results after testing.
  * @param p_usim_id_tsu The id of the test object in usim_test_summary.
  * @param p_usim_success The amount of successful tests.
  * @param p_usim_failed The amount of failed tests.
  */
  PROCEDURE write_test_results( p_usim_id_tsu   IN usim_test_summary.usim_id_tsu%TYPE
                              , p_usim_success  IN NUMBER
                              , p_usim_failed   IN NUMBER
                              )
  ;
END usim_test;

Package USIM_TEST kompiliert

SQL> @@../PACKAGES/USIM_TEST.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_test
  2  IS
  3    -- see header for description
  4    FUNCTION init_test(p_usim_test_object IN usim_test_summary.usim_test_object%TYPE)
  5      RETURN NUMBER
  6    IS
  7      PRAGMA AUTONOMOUS_TRANSACTION;
  8      l_result NUMBER;
  9    BEGIN
 10      INSERT INTO usim_test_summary (usim_test_object) VALUES (p_usim_test_object) RETURNING usim_id_tsu INTO l_result;
 11      COMMIT;
 12      RETURN l_result;
 13    END init_test
 14    ;
 15
 16    PROCEDURE log_error( p_usim_id_tsu    IN usim_test_errors.usim_id_tsu%TYPE
 17                       , p_usim_error_msg IN usim_test_errors.usim_error_msg%TYPE
 18                       )
 19    IS
 20      PRAGMA AUTONOMOUS_TRANSACTION;
 21    BEGIN
 22      INSERT INTO usim_test_errors
 23        ( usim_id_tsu
 24        , usim_error_msg
 25        )
 26        VALUES
 27        ( p_usim_id_tsu
 28        , p_usim_error_msg
 29        )
 30      ;
 31      COMMIT;
 32    END log_error
 33    ;
 34
 35    PROCEDURE write_test_results( p_usim_id_tsu   IN usim_test_summary.usim_id_tsu%TYPE
 36                                , p_usim_success  IN NUMBER
 37                                , p_usim_failed   IN NUMBER
 38                                )
 39    IS
 40    BEGIN
 41      UPDATE usim_test_summary
 42         SET usim_tests_success = p_usim_success
 43           , usim_tests_failed  = p_usim_failed
 44       WHERE usim_id_tsu = p_usim_id_tsu
 45      ;
 46      COMMIT;
 47    END write_test_results
 48    ;
 49
 50  END usim_test;
 51  /
alt:CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_test
IS
  -- see header for description
  FUNCTION init_test(p_usim_test_object IN usim_test_summary.usim_test_object%TYPE)
    RETURN NUMBER
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    l_result NUMBER;
  BEGIN
    INSERT INTO usim_test_summary (usim_test_object) VALUES (p_usim_test_object) RETURNING usim_id_tsu INTO l_result;
    COMMIT;
    RETURN l_result;
  END init_test
  ;

  PROCEDURE log_error( p_usim_id_tsu    IN usim_test_errors.usim_id_tsu%TYPE
                     , p_usim_error_msg IN usim_test_errors.usim_error_msg%TYPE
                     )
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO usim_test_errors
      ( usim_id_tsu
      , usim_error_msg
      )
      VALUES
      ( p_usim_id_tsu
      , p_usim_error_msg
      )
    ;
    COMMIT;
  END log_error
  ;

  PROCEDURE write_test_results( p_usim_id_tsu   IN usim_test_summary.usim_id_tsu%TYPE
                              , p_usim_success  IN NUMBER
                              , p_usim_failed   IN NUMBER
                              )
  IS
  BEGIN
    UPDATE usim_test_summary
       SET usim_tests_success = p_usim_success
         , usim_tests_failed  = p_usim_failed
     WHERE usim_id_tsu = p_usim_id_tsu
    ;
    COMMIT;
  END write_test_results
  ;

END usim_test;

neu:CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_test
IS
  -- see header for description
  FUNCTION init_test(p_usim_test_object IN usim_test_summary.usim_test_object%TYPE)
    RETURN NUMBER
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    l_result NUMBER;
  BEGIN
    INSERT INTO usim_test_summary (usim_test_object) VALUES (p_usim_test_object) RETURNING usim_id_tsu INTO l_result;
    COMMIT;
    RETURN l_result;
  END init_test
  ;

  PROCEDURE log_error( p_usim_id_tsu    IN usim_test_errors.usim_id_tsu%TYPE
                     , p_usim_error_msg IN usim_test_errors.usim_error_msg%TYPE
                     )
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO usim_test_errors
      ( usim_id_tsu
      , usim_error_msg
      )
      VALUES
      ( p_usim_id_tsu
      , p_usim_error_msg
      )
    ;
    COMMIT;
  END log_error
  ;

  PROCEDURE write_test_results( p_usim_id_tsu   IN usim_test_summary.usim_id_tsu%TYPE
                              , p_usim_success  IN NUMBER
                              , p_usim_failed   IN NUMBER
                              )
  IS
  BEGIN
    UPDATE usim_test_summary
       SET usim_tests_success = p_usim_success
         , usim_tests_failed  = p_usim_failed
     WHERE usim_id_tsu = p_usim_id_tsu
    ;
    COMMIT;
  END write_test_results
  ;

END usim_test;

Package Body USIM_TEST kompiliert

SQL> --== test tables end ==--
SQL>
SQL>
SQL> --== packages with debug code overrides start ==--
SQL> -- you may add any packages with debug code to override the standard packages here
SQL> --== packages with debug code overrides end ==--
SQL> -- check state of database
SQL> @@../UTIL/VERIFY_SYSTEM.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 Zeile ausgewählt.

SQL> -- check state of database
SQL> SET FEEDBACK OFF
SQL> SELECT CASE
  2          WHEN COUNT(*) > 0
  3          THEN 'ERROR Database has invalid objects'
  4          ELSE 'SUCCESS All database objects are valid'
  5        END AS info
  6    FROM all_objects
  7   WHERE status != 'VALID'
  8     AND owner   = '&USIM_SCHEMA'
  9  ;
alt:SELECT CASE
        WHEN COUNT(*) > 0
        THEN 'ERROR Database has invalid objects'
        ELSE 'SUCCESS All database objects are valid'
      END AS info
  FROM all_objects
 WHERE status != 'VALID'
   AND owner   = '&USIM_SCHEMA'

neu:SELECT CASE
        WHEN COUNT(*) > 0
        THEN 'ERROR Database has invalid objects'
        ELSE 'SUCCESS All database objects are valid'
      END AS info
  FROM all_objects
 WHERE status != 'VALID'
   AND owner   = 'USIM_TEST'

INFO
--------------------------------------
SUCCESS All database objects are valid
SQL> -- group details if any
SQL> SELECT object_type
  2       , COUNT(*) AS invalid_objects
  3    FROM all_objects
  4   WHERE status != 'VALID'
  5     AND owner   = '&USIM_SCHEMA'
  6   GROUP BY object_type
  7  ;
alt:SELECT object_type
     , COUNT(*) AS invalid_objects
  FROM all_objects
 WHERE status != 'VALID'
   AND owner   = '&USIM_SCHEMA'
 GROUP BY object_type

neu:SELECT object_type
     , COUNT(*) AS invalid_objects
  FROM all_objects
 WHERE status != 'VALID'
   AND owner   = 'USIM_TEST'
 GROUP BY object_type
SQL> -- details if any
SQL> SELECT object_name
  2       , object_type
  3       , status
  4    FROM all_objects
  5   WHERE status != 'VALID'
  6     AND owner   = '&USIM_SCHEMA'
  7   ORDER BY object_type
  8          , object_name
  9  ;
alt:SELECT object_name
     , object_type
     , status
  FROM all_objects
 WHERE status != 'VALID'
   AND owner   = '&USIM_SCHEMA'
 ORDER BY object_type
        , object_name

neu:SELECT object_name
     , object_type
     , status
  FROM all_objects
 WHERE status != 'VALID'
   AND owner   = 'USIM_TEST'
 ORDER BY object_type
        , object_name
SQL> SELECT trigger_name AS not_enabled_trigger
  2       , table_name
  3    FROM all_triggers
  4   WHERE status != 'ENABLED'
  5     AND owner   = '&USIM_SCHEMA'
  6  ;
alt:SELECT trigger_name AS not_enabled_trigger
     , table_name
  FROM all_triggers
 WHERE status != 'ENABLED'
   AND owner   = '&USIM_SCHEMA'

neu:SELECT trigger_name AS not_enabled_trigger
     , table_name
  FROM all_triggers
 WHERE status != 'ENABLED'
   AND owner   = 'USIM_TEST'
SQL> SET FEEDBACK ON
SQL> -- run tests
SQL> @@../TESTING/USIM_TESTS.sql
SQL> SET FEEDBACK OFF
SQL> SELECT 'Execute tests on USIM model.' AS info FROM dual;

INFO
----------------------------
Execute tests on USIM model.
SQL> -- do not keep old results
SQL> DELETE usim_test_errors;
SQL> DELETE usim_test_summary;
SQL> COMMIT;
SQL> @@TEST_USIM_STATIC.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(4000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_STATIC';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12  BEGIN
 13    l_test_id := usim_test.init_test(l_test_object);
 14    l_test_section := 'PACKAGE Variables';
 15    l_run_id := '001';
 16    IF usim_static.usim_max_childs_per_dimension != 1
 17    THEN
 18      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_max_childs_per_dimension NOT 1';
 19      usim_test.log_error(l_test_id, l_fail_message);
 20      l_tests_failed := l_tests_failed + 1;
 21    ELSE
 22      l_tests_success := l_tests_success + 1;
 23    END IF;
 24    l_run_id := '002';
 25    IF usim_static.usim_max_seeds != 1
 26    THEN
 27      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_max_seeds NOT 1';
 28      usim_test.log_error(l_test_id, l_fail_message);
 29      l_tests_failed := l_tests_failed + 1;
 30    ELSE
 31      l_tests_success := l_tests_success + 1;
 32    END IF;
 33    l_run_id := '003';
 34    IF usim_static.usim_planck_time_seq_name != 'USIM_PLANCK_TIME_SEQ'
 35    THEN
 36      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_planck_time_seq_name NOT USIM_PLANCK_TIME_SEQ';
 37      usim_test.log_error(l_test_id, l_fail_message);
 38      l_tests_failed := l_tests_failed + 1;
 39    ELSE
 40      l_tests_success := l_tests_success + 1;
 41    END IF;
 42    l_run_id := '004';
 43    IF usim_static.usim_planck_aeon_seq_name != 'USIM_PLANCK_AEON_SEQ'
 44    THEN
 45      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_planck_aeon_seq_name NOT USIM_PLANCK_AEON_SEQ';
 46      usim_test.log_error(l_test_id, l_fail_message);
 47      l_tests_failed := l_tests_failed + 1;
 48    ELSE
 49      l_tests_success := l_tests_success + 1;
 50    END IF;
 51    l_run_id := '005';
 52    IF usim_static.usim_not_available != 'N/A'
 53    THEN
 54      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_not_available NOT "N/A"';
 55      usim_test.log_error(l_test_id, l_fail_message);
 56      l_tests_failed := l_tests_failed + 1;
 57    ELSE
 58      l_tests_success := l_tests_success + 1;
 59    END IF;
 60    l_run_id := '006';
 61    IF usim_static.usim_status_success != 1
 62    THEN
 63      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_status_success NOT 1';
 64      usim_test.log_error(l_test_id, l_fail_message);
 65      l_tests_failed := l_tests_failed + 1;
 66    ELSE
 67      l_tests_success := l_tests_success + 1;
 68    END IF;
 69    l_run_id := '007';
 70    IF usim_static.usim_status_error != -1
 71    THEN
 72      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_status_error NOT -1';
 73      usim_test.log_error(l_test_id, l_fail_message);
 74      l_tests_failed := l_tests_failed + 1;
 75    ELSE
 76      l_tests_success := l_tests_success + 1;
 77    END IF;
 78    l_run_id := '008';
 79    IF usim_static.usim_status_warning != 0
 80    THEN
 81      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_status_warning NOT 0';
 82      usim_test.log_error(l_test_id, l_fail_message);
 83      l_tests_failed := l_tests_failed + 1;
 84    ELSE
 85      l_tests_success := l_tests_success + 1;
 86    END IF;
 87    l_run_id := '009';
 88    IF usim_static.PI != ACOS(-1)
 89    THEN
 90      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': PI NOT ACOS(-1)';
 91      usim_test.log_error(l_test_id, l_fail_message);
 92      l_tests_failed := l_tests_failed + 1;
 93    ELSE
 94      l_tests_success := l_tests_success + 1;
 95    END IF;
 96    l_run_id := '010';
 97    IF usim_static.PI_DOUBLE != ACOS(-1) * 2
 98    THEN
 99      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': PI_DOUBLE NOT ACOS(-1) * 2';
100      usim_test.log_error(l_test_id, l_fail_message);
101      l_tests_failed := l_tests_failed + 1;
102    ELSE
103      l_tests_success := l_tests_success + 1;
104    END IF;
105    l_run_id := '011';
106    IF usim_static.PI_QUARTER != ACOS(-1) / 4
107    THEN
108      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': PI_QUARTER NOT ACOS(-1) / 4';
109      usim_test.log_error(l_test_id, l_fail_message);
110      l_tests_failed := l_tests_failed + 1;
111    ELSE
112      l_tests_success := l_tests_success + 1;
113    END IF;
114    l_run_id := '012';
115    IF usim_static.usim_multiverse_status_active != 1
116    THEN
117      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_multiverse_status_active NOT 1';
118      usim_test.log_error(l_test_id, l_fail_message);
119      l_tests_failed := l_tests_failed + 1;
120    ELSE
121      l_tests_success := l_tests_success + 1;
122    END IF;
123    l_run_id := '013';
124    IF usim_static.usim_multiverse_status_inactive != 0
125    THEN
126      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_multiverse_status_inactive NOT 0';
127      usim_test.log_error(l_test_id, l_fail_message);
128      l_tests_failed := l_tests_failed + 1;
129    ELSE
130      l_tests_success := l_tests_success + 1;
131    END IF;
132    l_run_id := '014';
133    IF usim_static.usim_multiverse_status_dead != -1
134    THEN
135      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_multiverse_status_dead NOT -1';
136      usim_test.log_error(l_test_id, l_fail_message);
137      l_tests_failed := l_tests_failed + 1;
138    ELSE
139      l_tests_success := l_tests_success + 1;
140    END IF;
141    l_run_id := '015';
142    IF usim_static.usim_multiverse_status_crashed != -2
143    THEN
144      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_multiverse_status_crashed NOT -2';
145      usim_test.log_error(l_test_id, l_fail_message);
146      l_tests_failed := l_tests_failed + 1;
147    ELSE
148      l_tests_success := l_tests_success + 1;
149    END IF;
150
151    l_test_section := 'NON SQL Functions';
152    l_run_id := '016';
153    IF usim_static.get_bool_str(TRUE) != 'TRUE'
154    THEN
155      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_bool_str(TRUE) NOT "TRUE"';
156      usim_test.log_error(l_test_id, l_fail_message);
157      l_tests_failed := l_tests_failed + 1;
158    ELSE
159      l_tests_success := l_tests_success + 1;
160    END IF;
161    l_run_id := '017';
162    IF usim_static.get_bool_str(1 = 1) != 'TRUE'
163    THEN
164      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_bool_str(1 = 1) NOT "TRUE"';
165      usim_test.log_error(l_test_id, l_fail_message);
166      l_tests_failed := l_tests_failed + 1;
167    ELSE
168      l_tests_success := l_tests_success + 1;
169    END IF;
170    l_run_id := '018';
171    IF usim_static.get_bool_str(FALSE) != 'FALSE'
172    THEN
173      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_bool_str(FALSE) NOT "FALSE"';
174      usim_test.log_error(l_test_id, l_fail_message);
175      l_tests_failed := l_tests_failed + 1;
176    ELSE
177      l_tests_success := l_tests_success + 1;
178    END IF;
179    l_run_id := '019';
180    IF usim_static.get_bool_str(1 = 2) != 'FALSE'
181    THEN
182      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_bool_str(1 = 2) NOT "FALSE"';
183      usim_test.log_error(l_test_id, l_fail_message);
184      l_tests_failed := l_tests_failed + 1;
185    ELSE
186      l_tests_success := l_tests_success + 1;
187    END IF;
188
189    l_test_section := 'SQL Functions';
190    l_run_id := '020';
191    SELECT usim_static.get_max_childs_per_dimension INTO l_sql_number_result FROM dual;
192    IF l_sql_number_result != usim_static.usim_max_childs_per_dimension
193    THEN
194      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_max_childs_per_dimension NOT usim_max_childs_per_dimension';
195      usim_test.log_error(l_test_id, l_fail_message);
196      l_tests_failed := l_tests_failed + 1;
197    ELSE
198      l_tests_success := l_tests_success + 1;
199    END IF;
200    l_run_id := '021';
201    SELECT usim_static.get_max_seeds INTO l_sql_number_result FROM dual;
202    IF l_sql_number_result != usim_static.usim_max_seeds
203    THEN
204      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_max_seeds FROM dual NOT usim_max_seeds';
205      usim_test.log_error(l_test_id, l_fail_message);
206      l_tests_failed := l_tests_failed + 1;
207    ELSE
208      l_tests_success := l_tests_success + 1;
209    END IF;
210    l_run_id := '022';
211    SELECT usim_static.get_pi INTO l_sql_number_result FROM dual;
212    IF l_sql_number_result != usim_static.PI
213    THEN
214      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_pi FROM dual NOT PI';
215      usim_test.log_error(l_test_id, l_fail_message);
216      l_tests_failed := l_tests_failed + 1;
217    ELSE
218      l_tests_success := l_tests_success + 1;
219    END IF;
220    l_run_id := '023';
221    SELECT usim_static.get_pi_double INTO l_sql_number_result FROM dual;
222    IF l_sql_number_result != usim_static.PI_DOUBLE
223    THEN
224      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_pi_double FROM dual NOT PI_DOUBLE';
225      usim_test.log_error(l_test_id, l_fail_message);
226      l_tests_failed := l_tests_failed + 1;
227    ELSE
228      l_tests_success := l_tests_success + 1;
229    END IF;
230    l_run_id := '024';
231    SELECT usim_static.get_pi_quarter INTO l_sql_number_result FROM dual;
232    IF l_sql_number_result != usim_static.PI_QUARTER
233    THEN
234      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_pi_quarter FROM dual NOT PI_QUARTER';
235      usim_test.log_error(l_test_id, l_fail_message);
236      l_tests_failed := l_tests_failed + 1;
237    ELSE
238      l_tests_success := l_tests_success + 1;
239    END IF;
240    l_run_id := '025';
241    SELECT usim_static.get_planck_time_seq_name INTO l_sql_char_result FROM dual;
242    IF l_sql_char_result != usim_static.usim_planck_time_seq_name
243    THEN
244      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_planck_time_seq_name FROM dual NOT usim_planck_time_seq_name';
245      usim_test.log_error(l_test_id, l_fail_message);
246      l_tests_failed := l_tests_failed + 1;
247    ELSE
248      l_tests_success := l_tests_success + 1;
249    END IF;
250    l_run_id := '026';
251    SELECT usim_static.get_planck_aeon_seq_name INTO l_sql_char_result FROM dual;
252    IF l_sql_char_result != usim_static.usim_planck_aeon_seq_name
253    THEN
254      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_planck_aeon_seq_name NOT usim_planck_aeon_seq_name';
255      usim_test.log_error(l_test_id, l_fail_message);
256      l_tests_failed := l_tests_failed + 1;
257    ELSE
258      l_tests_success := l_tests_success + 1;
259    END IF;
260    l_run_id := '027';
261    SELECT usim_static.get_not_available INTO l_sql_char_result FROM dual;
262    IF l_sql_char_result != usim_static.usim_not_available
263    THEN
264      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_not_available NOT usim_not_available';
265      usim_test.log_error(l_test_id, l_fail_message);
266      l_tests_failed := l_tests_failed + 1;
267    ELSE
268      l_tests_success := l_tests_success + 1;
269    END IF;
270    l_run_id := '028';
271    SELECT usim_static.get_debug_success INTO l_sql_number_result FROM dual;
272    IF l_sql_number_result != usim_static.usim_status_success
273    THEN
274      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_debug_success FROM dual NOT usim_status_success';
275      usim_test.log_error(l_test_id, l_fail_message);
276      l_tests_failed := l_tests_failed + 1;
277    ELSE
278      l_tests_success := l_tests_success + 1;
279    END IF;
280    l_run_id := '029';
281    SELECT usim_static.get_debug_error INTO l_sql_number_result FROM dual;
282    IF l_sql_number_result != usim_static.usim_status_error
283    THEN
284      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_debug_error FROM dual NOT usim_status_error';
285      usim_test.log_error(l_test_id, l_fail_message);
286      l_tests_failed := l_tests_failed + 1;
287    ELSE
288      l_tests_success := l_tests_success + 1;
289    END IF;
290    l_run_id := '030';
291    SELECT usim_static.get_debug_warning INTO l_sql_number_result FROM dual;
292    IF l_sql_number_result != usim_static.usim_status_warning
293    THEN
294      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_debug_warning FROM dual NOT usim_status_warning';
295      usim_test.log_error(l_test_id, l_fail_message);
296      l_tests_failed := l_tests_failed + 1;
297    ELSE
298      l_tests_success := l_tests_success + 1;
299    END IF;
300    l_run_id := '031';
301    SELECT usim_static.get_multiverse_active INTO l_sql_number_result FROM dual;
302    IF l_sql_number_result != usim_static.usim_multiverse_status_active
303    THEN
304      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_multiverse_active FROM dual NOT usim_multiverse_status_active';
305      usim_test.log_error(l_test_id, l_fail_message);
306      l_tests_failed := l_tests_failed + 1;
307    ELSE
308      l_tests_success := l_tests_success + 1;
309    END IF;
310    l_run_id := '032';
311    SELECT usim_static.get_multiverse_inactive INTO l_sql_number_result FROM dual;
312    IF l_sql_number_result != usim_static.usim_multiverse_status_inactive
313    THEN
314      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_multiverse_inactive FROM dual NOT usim_multiverse_status_inactive';
315      usim_test.log_error(l_test_id, l_fail_message);
316      l_tests_failed := l_tests_failed + 1;
317    ELSE
318      l_tests_success := l_tests_success + 1;
319    END IF;
320    l_run_id := '033';
321    SELECT usim_static.get_multiverse_dead INTO l_sql_number_result FROM dual;
322    IF l_sql_number_result != usim_static.usim_multiverse_status_dead
323    THEN
324      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_multiverse_dead FROM dual NOT usim_multiverse_status_dead';
325      usim_test.log_error(l_test_id, l_fail_message);
326      l_tests_failed := l_tests_failed + 1;
327    ELSE
328      l_tests_success := l_tests_success + 1;
329    END IF;
330    l_run_id := '034';
331    SELECT usim_static.get_multiverse_crashed INTO l_sql_number_result FROM dual;
332    IF l_sql_number_result != usim_static.usim_multiverse_status_crashed
333    THEN
334      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT get_multiverse_crashed FROM dual NOT usim_multiverse_status_crashed';
335      usim_test.log_error(l_test_id, l_fail_message);
336      l_tests_failed := l_tests_failed + 1;
337    ELSE
338      l_tests_success := l_tests_success + 1;
339    END IF;
340
341    l_test_section := 'Status Functions';
342    l_run_id := '035';
343    IF usim_static.get_multiverse_status(usim_static.usim_multiverse_status_active) != 'ACTIVE'
344    THEN
345      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_multiverse_status(usim_static.usim_multiverse_status_active) NOT "ACTIVE"';
346      usim_test.log_error(l_test_id, l_fail_message);
347      l_tests_failed := l_tests_failed + 1;
348    ELSE
349      l_tests_success := l_tests_success + 1;
350    END IF;
351    l_run_id := '036';
352    IF usim_static.get_multiverse_status(usim_static.usim_multiverse_status_inactive) != 'INACTIVE'
353    THEN
354      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_multiverse_status(usim_static.usim_multiverse_status_inactive) NOT "INACTIVE"';
355      usim_test.log_error(l_test_id, l_fail_message);
356      l_tests_failed := l_tests_failed + 1;
357    ELSE
358      l_tests_success := l_tests_success + 1;
359    END IF;
360    l_run_id := '037';
361    IF usim_static.get_multiverse_status(usim_static.usim_multiverse_status_dead) != 'DEAD'
362    THEN
363      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_multiverse_status(usim_static.usim_multiverse_status_dead) NOT "DEAD"';
364      usim_test.log_error(l_test_id, l_fail_message);
365      l_tests_failed := l_tests_failed + 1;
366    ELSE
367      l_tests_success := l_tests_success + 1;
368    END IF;
369    l_run_id := '038';
370    IF usim_static.get_multiverse_status(usim_static.usim_multiverse_status_crashed) != 'CRASHED'
371    THEN
372      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_multiverse_status(usim_static.usim_multiverse_status_crashed) NOT "CRASHED"';
373      usim_test.log_error(l_test_id, l_fail_message);
374      l_tests_failed := l_tests_failed + 1;
375    ELSE
376      l_tests_success := l_tests_success + 1;
377    END IF;
378    l_run_id := '039';
379    IF usim_static.get_multiverse_status(-10) != 'UNKNOWN'
380    THEN
381      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_multiverse_status(-10) NOT "UNKNOWN"';
382      usim_test.log_error(l_test_id, l_fail_message);
383      l_tests_failed := l_tests_failed + 1;
384    ELSE
385      l_tests_success := l_tests_success + 1;
386    END IF;
387    l_run_id := '040';
388    IF usim_static.get_debug_status(usim_static.usim_status_success) != 'SUCCESS'
389    THEN
390      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_debug_status(usim_static.usim_status_success) NOT "SUCCESS"';
391      usim_test.log_error(l_test_id, l_fail_message);
392      l_tests_failed := l_tests_failed + 1;
393    ELSE
394      l_tests_success := l_tests_success + 1;
395    END IF;
396    l_run_id := '041';
397    IF usim_static.get_debug_status(usim_static.usim_status_error) != 'ERROR'
398    THEN
399      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_debug_status(usim_static.usim_status_error) NOT "ERROR"';
400      usim_test.log_error(l_test_id, l_fail_message);
401      l_tests_failed := l_tests_failed + 1;
402    ELSE
403      l_tests_success := l_tests_success + 1;
404    END IF;
405    l_run_id := '042';
406    IF usim_static.get_debug_status(usim_static.usim_status_warning) != 'WARNING'
407    THEN
408      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_debug_status(usim_static.usim_status_error) NOT "WARNING"';
409      usim_test.log_error(l_test_id, l_fail_message);
410      l_tests_failed := l_tests_failed + 1;
411    ELSE
412      l_tests_success := l_tests_success + 1;
413    END IF;
414    l_run_id := '043';
415    IF usim_static.get_debug_status(10) != 'UNKNOWN'
416    THEN
417      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_debug_status(10) NOT "UNKNOWN"';
418      usim_test.log_error(l_test_id, l_fail_message);
419      l_tests_failed := l_tests_failed + 1;
420    ELSE
421      l_tests_success := l_tests_success + 1;
422    END IF;
423    l_run_id := '044';
424    IF usim_static.get_debug_status(-10) != 'UNKNOWN'
425    THEN
426      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_debug_status(-10) NOT "UNKNOWN"';
427      usim_test.log_error(l_test_id, l_fail_message);
428      l_tests_failed := l_tests_failed + 1;
429    ELSE
430      l_tests_success := l_tests_success + 1;
431    END IF;
432
433    l_test_section := 'Big PK Functions';
434    l_run_id := '045';
435    IF LENGTH(usim_static.get_big_pk(1)) != 55
436    THEN
437      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': LENGTH(usim_static.get_big_pk(1)) NOT 55';
438      usim_test.log_error(l_test_id, l_fail_message);
439      l_tests_failed := l_tests_failed + 1;
440    ELSE
441      l_tests_success := l_tests_success + 1;
442    END IF;
443    l_run_id := '046';
444    SELECT LENGTH(usim_static.get_big_pk(1)) INTO l_sql_number_result FROM dual;
445    IF l_sql_number_result != 55
446    THEN
447      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': SELECT LENGTH(usim_static.get_big_pk(1)) FROM dual NOT 55';
448      usim_test.log_error(l_test_id, l_fail_message);
449      l_tests_failed := l_tests_failed + 1;
450    ELSE
451      l_tests_success := l_tests_success + 1;
452    END IF;
453    l_run_id := '047';
454    IF TO_NUMBER(SUBSTR(usim_static.get_big_pk(1), -38)) != 1
455    THEN
456      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': TO_NUMBER(SUBSTR(usim_static.get_big_pk(1), -38)) NOT 1';
457      usim_test.log_error(l_test_id, l_fail_message);
458      l_tests_failed := l_tests_failed + 1;
459    ELSE
460      l_tests_success := l_tests_success + 1;
461    END IF;
462    l_run_id := '048';
463    IF TRUNC(usim_static.get_big_pk_date(usim_static.get_big_pk(1))) != TRUNC(SYSDATE)
464    THEN
465      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': TRUNC(usim_static.get_big_pk_date(usim_static.get_big_pk(1))) NOT TRUNC(SYSDATE)';
466      usim_test.log_error(l_test_id, l_fail_message);
467      l_tests_failed := l_tests_failed + 1;
468    ELSE
469      l_tests_success := l_tests_success + 1;
470    END IF;
471    l_run_id := '049';
472    IF usim_static.get_big_pk_number(usim_static.get_big_pk(1)) != 1
473    THEN
474      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ':  usim_static.get_big_pk_number(usim_static.get_big_pk(1)) NOT 1';
475      usim_test.log_error(l_test_id, l_fail_message);
476      l_tests_failed := l_tests_failed + 1;
477    ELSE
478      l_tests_success := l_tests_success + 1;
479    END IF;
480
481    l_test_section := 'get_next_number function';
482    l_run_id := '050';
483    IF usim_static.get_next_number(NULL, NULL) != 1
484    THEN
485      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_next_number(NULL, NULL) NOT 1';
486      usim_test.log_error(l_test_id, l_fail_message);
487      l_tests_failed := l_tests_failed + 1;
488    ELSE
489      l_tests_success := l_tests_success + 1;
490    END IF;
491    l_run_id := '051';
492    IF usim_static.get_next_number(0, NULL) != 1
493    THEN
494      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_next_number(0, NULL) NOT 1';
495      usim_test.log_error(l_test_id, l_fail_message);
496      l_tests_failed := l_tests_failed + 1;
497    ELSE
498      l_tests_success := l_tests_success + 1;
499    END IF;
500    l_run_id := '052';
501    IF usim_static.get_next_number(0, 0) != 1
502    THEN
503      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_next_number(0, 0) NOT 1';
504      usim_test.log_error(l_test_id, l_fail_message);
505      l_tests_failed := l_tests_failed + 1;
506    ELSE
507      l_tests_success := l_tests_success + 1;
508    END IF;
509    l_run_id := '053';
510    IF usim_static.get_next_number(NULL, -1) != -1
511    THEN
512      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_next_number(NULL, -1) NOT -1';
513      usim_test.log_error(l_test_id, l_fail_message);
514      l_tests_failed := l_tests_failed + 1;
515    ELSE
516      l_tests_success := l_tests_success + 1;
517    END IF;
518    l_run_id := '054';
519    IF usim_static.get_next_number(0, -1) != -1
520    THEN
521      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_next_number(0, -1) NOT -1';
522      usim_test.log_error(l_test_id, l_fail_message);
523      l_tests_failed := l_tests_failed + 1;
524    ELSE
525      l_tests_success := l_tests_success + 1;
526    END IF;
527    l_run_id := '055';
528    IF usim_static.get_next_number(0, 1) != 1
529    THEN
530      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_next_number(0, 1) NOT 1';
531      usim_test.log_error(l_test_id, l_fail_message);
532      l_tests_failed := l_tests_failed + 1;
533    ELSE
534      l_tests_success := l_tests_success + 1;
535    END IF;
536    l_run_id := '056';
537    IF usim_static.get_next_number(0, 22) != 1
538    THEN
539      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_next_number(0, 22) NOT 1';
540      usim_test.log_error(l_test_id, l_fail_message);
541      l_tests_failed := l_tests_failed + 1;
542    ELSE
543      l_tests_success := l_tests_success + 1;
544    END IF;
545    l_run_id := '057';
546    IF usim_static.get_next_number(0, -22) != -1
547    THEN
548      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_next_number(0, -22) NOT -1';
549      usim_test.log_error(l_test_id, l_fail_message);
550      l_tests_failed := l_tests_failed + 1;
551    ELSE
552      l_tests_success := l_tests_success + 1;
553    END IF;
554    l_run_id := '058';
555    IF usim_static.get_next_number(3, 1) != 4
556    THEN
557      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_next_number(3, 1) NOT 4';
558      usim_test.log_error(l_test_id, l_fail_message);
559      l_tests_failed := l_tests_failed + 1;
560    ELSE
561      l_tests_success := l_tests_success + 1;
562    END IF;
563    l_run_id := '059';
564    IF usim_static.get_next_number(3, -1) != 4
565    THEN
566      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_next_number(3, -1) NOT 4';
567      usim_test.log_error(l_test_id, l_fail_message);
568      l_tests_failed := l_tests_failed + 1;
569    ELSE
570      l_tests_success := l_tests_success + 1;
571    END IF;
572    l_run_id := '060';
573    IF usim_static.get_next_number(-3, -1) != -4
574    THEN
575      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_next_number(-3, -1) NOT -4';
576      usim_test.log_error(l_test_id, l_fail_message);
577      l_tests_failed := l_tests_failed + 1;
578    ELSE
579      l_tests_success := l_tests_success + 1;
580    END IF;
581    l_run_id := '061';
582    IF usim_static.get_next_number(-3, 1) != -4
583    THEN
584      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_next_number(-3, 1) NOT -4';
585      usim_test.log_error(l_test_id, l_fail_message);
586      l_tests_failed := l_tests_failed + 1;
587    ELSE
588      l_tests_success := l_tests_success + 1;
589    END IF;
590
591    -- write test results
592    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
593  EXCEPTION
594    WHEN OTHERS THEN
595      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
596      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
597  END;
598  /
SQL> @@TEST_USIM_MATHS.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(4000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_MATHS';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12  BEGIN
 13    l_test_id := usim_test.init_test(l_test_object);
 14    l_test_section := 'Planck functions NULL or 0 values';
 15    l_run_id := '001';
 16    IF usim_maths.init_planck_time(NULL, 1) != 1
 17    THEN
 18      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_speed with NULL value (first) NOT 1';
 19      usim_test.log_error(l_test_id, l_fail_message);
 20      l_tests_failed := l_tests_failed + 1;
 21    ELSE
 22      l_tests_success := l_tests_success + 1;
 23    END IF;
 24    l_run_id := '002';
 25    IF usim_maths.init_planck_speed(1, NULL) != 1
 26    THEN
 27      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_speed with NULL value (second) NOT 1';
 28      usim_test.log_error(l_test_id, l_fail_message);
 29      l_tests_failed := l_tests_failed + 1;
 30    ELSE
 31      l_tests_success := l_tests_success + 1;
 32    END IF;
 33    l_run_id := '003';
 34    IF usim_maths.init_planck_speed(NULL, NULL) != 1
 35    THEN
 36      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_speed with NULL values NOT 1';
 37      usim_test.log_error(l_test_id, l_fail_message);
 38      l_tests_failed := l_tests_failed + 1;
 39    ELSE
 40      l_tests_success := l_tests_success + 1;
 41    END IF;
 42    l_run_id := '004';
 43    IF usim_maths.init_planck_speed(0, 1) != 1
 44    THEN
 45      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_speed with 0 value (first) NOT 1';
 46      usim_test.log_error(l_test_id, l_fail_message);
 47      l_tests_failed := l_tests_failed + 1;
 48    ELSE
 49      l_tests_success := l_tests_success + 1;
 50    END IF;
 51    l_run_id := '005';
 52    IF usim_maths.init_planck_speed(1, 0) != 1
 53    THEN
 54      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_speed with 0 value (second) NOT 1';
 55      usim_test.log_error(l_test_id, l_fail_message);
 56      l_tests_failed := l_tests_failed + 1;
 57    ELSE
 58      l_tests_success := l_tests_success + 1;
 59    END IF;
 60    l_run_id := '006';
 61    IF usim_maths.init_planck_speed(0, 0) != 1
 62    THEN
 63      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_speed with 0 values NOT 1';
 64      usim_test.log_error(l_test_id, l_fail_message);
 65      l_tests_failed := l_tests_failed + 1;
 66    ELSE
 67      l_tests_success := l_tests_success + 1;
 68    END IF;
 69    l_run_id := '007';
 70    IF usim_maths.init_planck_time(NULL, 1) != 1
 71    THEN
 72      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_time with NULL value (first) NOT 1';
 73      usim_test.log_error(l_test_id, l_fail_message);
 74      l_tests_failed := l_tests_failed + 1;
 75    ELSE
 76      l_tests_success := l_tests_success + 1;
 77    END IF;
 78    l_run_id := '008';
 79    IF usim_maths.init_planck_time(1, NULL) != 1
 80    THEN
 81      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_time with NULL value (second) NOT 1';
 82      usim_test.log_error(l_test_id, l_fail_message);
 83      l_tests_failed := l_tests_failed + 1;
 84    ELSE
 85      l_tests_success := l_tests_success + 1;
 86    END IF;
 87    l_run_id := '009';
 88    IF usim_maths.init_planck_time(NULL, NULL) != 1
 89    THEN
 90      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_time with NULL values NOT 1';
 91      usim_test.log_error(l_test_id, l_fail_message);
 92      l_tests_failed := l_tests_failed + 1;
 93    ELSE
 94      l_tests_success := l_tests_success + 1;
 95    END IF;
 96    l_run_id := '010';
 97    IF usim_maths.init_planck_time(0, 1) != 1
 98    THEN
 99      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_time with 0 value (first) NOT 1';
100      usim_test.log_error(l_test_id, l_fail_message);
101      l_tests_failed := l_tests_failed + 1;
102    ELSE
103      l_tests_success := l_tests_success + 1;
104    END IF;
105    l_run_id := '011';
106    IF usim_maths.init_planck_time(1, 0) != 1
107    THEN
108      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_time with 0 value (second) NOT 1';
109      usim_test.log_error(l_test_id, l_fail_message);
110      l_tests_failed := l_tests_failed + 1;
111    ELSE
112      l_tests_success := l_tests_success + 1;
113    END IF;
114    l_run_id := '012';
115    IF usim_maths.init_planck_time(0, 0) != 1
116    THEN
117      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_time with 0 values NOT 1';
118      usim_test.log_error(l_test_id, l_fail_message);
119      l_tests_failed := l_tests_failed + 1;
120    ELSE
121      l_tests_success := l_tests_success + 1;
122    END IF;
123    l_run_id := '013';
124    IF usim_maths.init_planck_length(NULL, 1) != 1
125    THEN
126      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_length with NULL value (first) NOT 1';
127      usim_test.log_error(l_test_id, l_fail_message);
128      l_tests_failed := l_tests_failed + 1;
129    ELSE
130      l_tests_success := l_tests_success + 1;
131    END IF;
132    l_run_id := '014';
133    IF usim_maths.init_planck_length(1, NULL) != 1
134    THEN
135      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_length with NULL value (second) NOT 1';
136      usim_test.log_error(l_test_id, l_fail_message);
137      l_tests_failed := l_tests_failed + 1;
138    ELSE
139      l_tests_success := l_tests_success + 1;
140    END IF;
141    l_run_id := '015';
142    IF usim_maths.init_planck_length(NULL, NULL) != 1
143    THEN
144      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_length with NULL values NOT 1';
145      usim_test.log_error(l_test_id, l_fail_message);
146      l_tests_failed := l_tests_failed + 1;
147    ELSE
148      l_tests_success := l_tests_success + 1;
149    END IF;
150    l_run_id := '016';
151    IF usim_maths.init_planck_length(0, 1) != 1
152    THEN
153      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_length with 0 value (first) NOT 1';
154      usim_test.log_error(l_test_id, l_fail_message);
155      l_tests_failed := l_tests_failed + 1;
156    ELSE
157      l_tests_success := l_tests_success + 1;
158    END IF;
159    l_run_id := '017';
160    IF usim_maths.init_planck_length(1, 0) != 1
161    THEN
162      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_length with 0 value (second) NOT 1';
163      usim_test.log_error(l_test_id, l_fail_message);
164      l_tests_failed := l_tests_failed + 1;
165    ELSE
166      l_tests_success := l_tests_success + 1;
167    END IF;
168    l_run_id := '018';
169    IF usim_maths.init_planck_length(0, 0) != 1
170    THEN
171      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_length with 0 values NOT 1';
172      usim_test.log_error(l_test_id, l_fail_message);
173      l_tests_failed := l_tests_failed + 1;
174    ELSE
175      l_tests_success := l_tests_success + 1;
176    END IF;
177    l_run_id := '019';
178    IF usim_maths.apply_planck(NULL, 1) != 0
179    THEN
180      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': apply_planck with NULL value (first) NOT 0';
181      usim_test.log_error(l_test_id, l_fail_message);
182      l_tests_failed := l_tests_failed + 1;
183    ELSE
184      l_tests_success := l_tests_success + 1;
185    END IF;
186    l_run_id := '020';
187    IF usim_maths.apply_planck(1, NULL) != 0
188    THEN
189      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': apply_planck with NULL value (second) NOT 0';
190      usim_test.log_error(l_test_id, l_fail_message);
191      l_tests_failed := l_tests_failed + 1;
192    ELSE
193      l_tests_success := l_tests_success + 1;
194    END IF;
195    l_run_id := '021';
196    IF usim_maths.apply_planck(NULL, NULL) != 0
197    THEN
198      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': apply_planck with NULL values NOT 0';
199      usim_test.log_error(l_test_id, l_fail_message);
200      l_tests_failed := l_tests_failed + 1;
201    ELSE
202      l_tests_success := l_tests_success + 1;
203    END IF;
204    l_run_id := '022';
205    IF usim_maths.apply_planck(0, 1) != 0
206    THEN
207      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': apply_planck with 0 value (first) NOT 0';
208      usim_test.log_error(l_test_id, l_fail_message);
209      l_tests_failed := l_tests_failed + 1;
210    ELSE
211      l_tests_success := l_tests_success + 1;
212    END IF;
213    l_run_id := '023';
214    IF usim_maths.apply_planck(1, 0) != 0
215    THEN
216      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': apply_planck with 0 value (second) NOT 0';
217      usim_test.log_error(l_test_id, l_fail_message);
218      l_tests_failed := l_tests_failed + 1;
219    ELSE
220      l_tests_success := l_tests_success + 1;
221    END IF;
222    l_run_id := '024';
223    IF usim_maths.apply_planck(0, 0) != 0
224    THEN
225      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': apply_planck with 0 values NOT 0';
226      usim_test.log_error(l_test_id, l_fail_message);
227      l_tests_failed := l_tests_failed + 1;
228    ELSE
229      l_tests_success := l_tests_success + 1;
230    END IF;
231
232    l_test_section := 'Planck functions results';
233    l_run_id := '025';
234    IF usim_maths.init_planck_speed(1, 1) != 1
235    THEN
236      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_speed with 1,1 NOT 1';
237      usim_test.log_error(l_test_id, l_fail_message);
238      l_tests_failed := l_tests_failed + 1;
239    ELSE
240      l_tests_success := l_tests_success + 1;
241    END IF;
242    l_run_id := '026';
243    IF usim_maths.init_planck_speed(2, 1) != (2/1)
244    THEN
245      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_speed with 2,1 NOT 2/1';
246      usim_test.log_error(l_test_id, l_fail_message);
247      l_tests_failed := l_tests_failed + 1;
248    ELSE
249      l_tests_success := l_tests_success + 1;
250    END IF;
251    l_run_id := '027';
252    IF usim_maths.init_planck_speed(1, 2) != (1/2)
253    THEN
254      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_speed with 1,2 NOT 1/2';
255      usim_test.log_error(l_test_id, l_fail_message);
256      l_tests_failed := l_tests_failed + 1;
257    ELSE
258      l_tests_success := l_tests_success + 1;
259    END IF;
260    l_run_id := '028';
261    IF usim_maths.init_planck_time(1, 1) != 1
262    THEN
263      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_time with 1,1 NOT 1';
264      usim_test.log_error(l_test_id, l_fail_message);
265      l_tests_failed := l_tests_failed + 1;
266    ELSE
267      l_tests_success := l_tests_success + 1;
268    END IF;
269    l_run_id := '029';
270    IF usim_maths.init_planck_time(2, 1) != (2/1)
271    THEN
272      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_time with 2,1 NOT 2/1';
273      usim_test.log_error(l_test_id, l_fail_message);
274      l_tests_failed := l_tests_failed + 1;
275    ELSE
276      l_tests_success := l_tests_success + 1;
277    END IF;
278    l_run_id := '030';
279    IF usim_maths.init_planck_time(1, 2) != (1/2)
280    THEN
281      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_time with 1,2 NOT 1/2';
282      usim_test.log_error(l_test_id, l_fail_message);
283      l_tests_failed := l_tests_failed + 1;
284    ELSE
285      l_tests_success := l_tests_success + 1;
286    END IF;
287    l_run_id := '031';
288    IF usim_maths.init_planck_length(1, 1) != 1
289    THEN
290      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_length with 1,1 NOT 1';
291      usim_test.log_error(l_test_id, l_fail_message);
292      l_tests_failed := l_tests_failed + 1;
293    ELSE
294      l_tests_success := l_tests_success + 1;
295    END IF;
296    l_run_id := '032';
297    IF usim_maths.init_planck_length(2, 1) != (2 * 1)
298    THEN
299      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_length with 2,1 NOT 2 * 1';
300      usim_test.log_error(l_test_id, l_fail_message);
301      l_tests_failed := l_tests_failed + 1;
302    ELSE
303      l_tests_success := l_tests_success + 1;
304    END IF;
305    l_run_id := '033';
306    IF usim_maths.init_planck_length(2, 3) != (2 * 3)
307    THEN
308      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_planck_length with 2,3 NOT 2 * 3';
309      usim_test.log_error(l_test_id, l_fail_message);
310      l_tests_failed := l_tests_failed + 1;
311    ELSE
312      l_tests_success := l_tests_success + 1;
313    END IF;
314    l_run_id := '034';
315    IF usim_maths.apply_planck(1, 1) != 1
316    THEN
317      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': apply_planck with 1,1 NOT 1';
318      usim_test.log_error(l_test_id, l_fail_message);
319      l_tests_failed := l_tests_failed + 1;
320    ELSE
321      l_tests_success := l_tests_success + 1;
322    END IF;
323    l_run_id := '035';
324    IF usim_maths.apply_planck(2, 1) != (2 * 1)
325    THEN
326      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': apply_planck with 2,1 NOT 2 * 1';
327      usim_test.log_error(l_test_id, l_fail_message);
328      l_tests_failed := l_tests_failed + 1;
329    ELSE
330      l_tests_success := l_tests_success + 1;
331    END IF;
332    l_run_id := '036';
333    IF usim_maths.apply_planck(2, 3) != (2 * 3)
334    THEN
335      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': apply_planck with 2,3 NOT 2 * 3';
336      usim_test.log_error(l_test_id, l_fail_message);
337      l_tests_failed := l_tests_failed + 1;
338    ELSE
339      l_tests_success := l_tests_success + 1;
340    END IF;
341
342    -- write test results
343    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
344  EXCEPTION
345    WHEN OTHERS THEN
346      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
347      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
348  END;
349  /
SQL> @@TEST_USIM_DEBUG.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(4000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_DEBUG';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_debug_id          usim_debug_log.usim_id_dlg%TYPE;
 11    l_debug_object      usim_debug_log.usim_log_object%TYPE := 'TEST_USIM_DEBUG';
 12    l_debug_content     usim_debug_log.usim_log_content%TYPE;
 13    l_test_id           NUMBER;
 14  BEGIN
 15    l_test_id := usim_test.init_test(l_test_object);
 16    l_test_section := 'Debug Status';
 17    DELETE usim_debug_log;
 18    COMMIT;
 19    l_run_id := '001';
 20    usim_debug.set_debug_on;
 21    IF NOT usim_debug.is_debug_on
 22    THEN
 23      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': Debug on and usim_debug.is_debug_on NOT TRUE';
 24      usim_test.log_error(l_test_id, l_fail_message);
 25      l_tests_failed := l_tests_failed + 1;
 26    ELSE
 27      l_tests_success := l_tests_success + 1;
 28    END IF;
 29    l_run_id := '002';
 30    SELECT usim_debug.is_debug INTO l_sql_char_result FROM dual;
 31    IF l_sql_char_result != 'TRUE'
 32    THEN
 33      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': Debug on and SELECT usim_debug.is_debug NOT "TRUE"';
 34      usim_test.log_error(l_test_id, l_fail_message);
 35      l_tests_failed := l_tests_failed + 1;
 36    ELSE
 37      l_tests_success := l_tests_success + 1;
 38    END IF;
 39    l_run_id := '003';
 40    usim_debug.set_debug_off;
 41    IF usim_debug.is_debug_on
 42    THEN
 43      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': Debug off and usim_debug.is_debug_on NOT FALSE';
 44      usim_test.log_error(l_test_id, l_fail_message);
 45      l_tests_failed := l_tests_failed + 1;
 46    ELSE
 47      l_tests_success := l_tests_success + 1;
 48    END IF;
 49    l_run_id := '004';
 50    SELECT usim_debug.is_debug INTO l_sql_char_result FROM dual;
 51    IF l_sql_char_result != 'FALSE'
 52    THEN
 53      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': Debug off and SELECT usim_debug.is_debug NOT "FALSE"';
 54      usim_test.log_error(l_test_id, l_fail_message);
 55      l_tests_failed := l_tests_failed + 1;
 56    ELSE
 57      l_tests_success := l_tests_success + 1;
 58    END IF;
 59
 60    l_test_section := 'Debug Action';
 61    l_run_id := '005';
 62    IF NVL(usim_debug.start_debug, -1) != -1
 63    THEN
 64      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': Debug off and usim_debug.start_debug IS NOT NULL';
 65      usim_test.log_error(l_test_id, l_fail_message);
 66      l_tests_failed := l_tests_failed + 1;
 67    ELSE
 68      l_tests_success := l_tests_success + 1;
 69    END IF;
 70    l_run_id := '006';
 71    usim_debug.set_debug_on;
 72    l_debug_id      := usim_debug.start_debug;
 73    IF NVL(l_debug_id, -1) != usim_dlg_id_seq.CURRVAL
 74    THEN
 75      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': Debug on and usim_debug.start_debug IS NOT usim_dlg_id_seq.CURRVAL';
 76      usim_test.log_error(l_test_id, l_fail_message);
 77      l_tests_failed := l_tests_failed + 1;
 78    ELSE
 79      l_tests_success := l_tests_success + 1;
 80    END IF;
 81    l_run_id := '007';
 82    l_debug_content := 'Test: l_debug_id[' || l_debug_id || ']';
 83    usim_debug.debug_log(l_debug_id, usim_static.usim_status_success, l_debug_object, l_debug_content);
 84    SELECT COUNT(*) INTO l_sql_number_result FROM usim_debug_log WHERE usim_log_object = l_debug_object;
 85    IF l_sql_number_result != 1
 86    THEN
 87      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': No debug message written.';
 88      usim_test.log_error(l_test_id, l_fail_message);
 89      l_tests_failed := l_tests_failed + 1;
 90    ELSE
 91      l_tests_success := l_tests_success + 1;
 92    END IF;
 93    l_run_id := '008';
 94    SELECT TRIM(usim_log_content) INTO l_sql_char_result FROM usim_debug_log WHERE usim_log_object = l_debug_object;
 95    IF l_sql_char_result != l_debug_content
 96    THEN
 97      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': No debug content does not match expected content.';
 98      usim_test.log_error(l_test_id, l_fail_message);
 99      l_tests_failed := l_tests_failed + 1;
100    ELSE
101      l_tests_success := l_tests_success + 1;
102    END IF;
103    -- basic state
104    usim_debug.set_debug_off;
105    DELETE usim_debug_log;
106    COMMIT;
107
108    -- write test results
109    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
110  EXCEPTION
111    WHEN OTHERS THEN
112      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
113      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
114  END;
115  /
SQL> @@TEST_USIM_BASEDATA.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(4000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_BASE_DATA table';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12  BEGIN
 13    l_test_id := usim_test.init_test(l_test_object);
 14    l_test_section := 'Table constraints';
 15    -- insert record
 16    l_run_id := '001';
 17    DELETE usim_basedata;
 18    COMMIT;
 19    BEGIN
 20      INSERT INTO usim_basedata (usim_id_bda) VALUES (2) RETURNING usim_id_bda INTO l_sql_number_result;
 21      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert 2 for id should not work.';
 22      usim_test.log_error(l_test_id, l_fail_message);
 23      l_tests_failed := l_tests_failed + 1;
 24    EXCEPTION
 25      WHEN OTHERS THEN
 26        IF INSTR(SQLERRM, 'USIM_ID_BDA_CHK') > 0
 27        THEN
 28          l_tests_success := l_tests_success + 1;
 29        ELSE
 30          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 31          usim_test.log_error(l_test_id, l_fail_message);
 32          l_tests_failed := l_tests_failed + 1;
 33        END IF;
 34    END;
 35    ROLLBACK;
 36    l_run_id := '002';
 37    BEGIN
 38      INSERT INTO usim_basedata (usim_overflow_node_seed) VALUES (2) RETURNING usim_id_bda INTO l_sql_number_result;
 39      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert 2 for usim_overflow_node_seed should not work.';
 40      usim_test.log_error(l_test_id, l_fail_message);
 41      l_tests_failed := l_tests_failed + 1;
 42    EXCEPTION
 43      WHEN OTHERS THEN
 44        IF INSTR(SQLERRM, 'USIM_OVR_BDA_CHK') > 0
 45        THEN
 46          l_tests_success := l_tests_success + 1;
 47        ELSE
 48          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 49          usim_test.log_error(l_test_id, l_fail_message);
 50          l_tests_failed := l_tests_failed + 1;
 51        END IF;
 52    END;
 53    ROLLBACK;
 54    l_run_id := '003';
 55    BEGIN
 56      INSERT INTO usim_basedata (usim_max_dimension) VALUES (-2) RETURNING usim_max_dimension INTO l_sql_number_result;
 57      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert -2 for usim_max_dimension should not work.';
 58      usim_test.log_error(l_test_id, l_fail_message);
 59      l_tests_failed := l_tests_failed + 1;
 60    EXCEPTION
 61      WHEN OTHERS THEN
 62        IF INSTR(SQLERRM, 'USIM_DIM_BDA_CHK') > 0
 63        THEN
 64          l_tests_success := l_tests_success + 1;
 65        ELSE
 66          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 67          usim_test.log_error(l_test_id, l_fail_message);
 68          l_tests_failed := l_tests_failed + 1;
 69        END IF;
 70    END;
 71    ROLLBACK;
 72    l_run_id := '004';
 73    BEGIN
 74      INSERT INTO usim_basedata (usim_abs_max_number) VALUES (-2) RETURNING usim_abs_max_number INTO l_sql_number_result;
 75      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert -2 for usim_abs_max_number should not work.';
 76      usim_test.log_error(l_test_id, l_fail_message);
 77      l_tests_failed := l_tests_failed + 1;
 78    EXCEPTION
 79      WHEN OTHERS THEN
 80        IF INSTR(SQLERRM, 'USIM_MAXN_BDA_CHK') > 0
 81        THEN
 82          l_tests_success := l_tests_success + 1;
 83        ELSE
 84          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 85          usim_test.log_error(l_test_id, l_fail_message);
 86          l_tests_failed := l_tests_failed + 1;
 87        END IF;
 88    END;
 89    ROLLBACK;
 90    l_test_section := 'Column defaults, insert trigger';
 91    l_run_id := '005';
 92    BEGIN
 93      INSERT INTO usim_basedata (usim_id_bda) VALUES (NULL) RETURNING usim_id_bda INTO l_sql_number_result;
 94      IF l_sql_number_result = 1
 95      THEN
 96        l_tests_success := l_tests_success + 1;
 97      ELSE
 98        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert NULL for usim_id_bda NOT 1.';
 99        usim_test.log_error(l_test_id, l_fail_message);
100        l_tests_failed := l_tests_failed + 1;
101      END IF;
102    EXCEPTION
103      WHEN OTHERS THEN
104        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
105        usim_test.log_error(l_test_id, l_fail_message);
106        l_tests_failed := l_tests_failed + 1;
107    END;
108    ROLLBACK;
109    l_run_id := '006';
110    BEGIN
111      INSERT INTO usim_basedata (usim_planck_time_seq_last) VALUES (1) RETURNING usim_planck_time_seq_last INTO l_sql_number_result;
112      IF l_sql_number_result = -1
113      THEN
114        l_tests_success := l_tests_success + 1;
115      ELSE
116        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert 1 for usim_planck_time_seq_last NOT -1.';
117        usim_test.log_error(l_test_id, l_fail_message);
118        l_tests_failed := l_tests_failed + 1;
119      END IF;
120    EXCEPTION
121      WHEN OTHERS THEN
122        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
123        usim_test.log_error(l_test_id, l_fail_message);
124        l_tests_failed := l_tests_failed + 1;
125    END;
126    ROLLBACK;
127    l_run_id := '007';
128    BEGIN
129      INSERT INTO usim_basedata (usim_planck_time_seq_curr) VALUES (1) RETURNING usim_planck_time_seq_curr INTO l_sql_number_result;
130      IF l_sql_number_result = -1
131      THEN
132        l_tests_success := l_tests_success + 1;
133      ELSE
134        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert 1 for usim_planck_time_seq_curr NOT -1.';
135        usim_test.log_error(l_test_id, l_fail_message);
136        l_tests_failed := l_tests_failed + 1;
137      END IF;
138    EXCEPTION
139      WHEN OTHERS THEN
140        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
141        usim_test.log_error(l_test_id, l_fail_message);
142        l_tests_failed := l_tests_failed + 1;
143    END;
144    ROLLBACK;
145    l_run_id := '008';
146    BEGIN
147      INSERT INTO usim_basedata (usim_planck_aeon_seq_last) VALUES ('BLA') RETURNING usim_planck_aeon_seq_last INTO l_sql_char_result;
148      IF TRIM(l_sql_char_result) = usim_static.usim_not_available
149      THEN
150        l_tests_success := l_tests_success + 1;
151      ELSE
152        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] insert BLA for usim_planck_aeon_seq_last NOT ' || usim_static.usim_not_available;
153        usim_test.log_error(l_test_id, l_fail_message);
154        l_tests_failed := l_tests_failed + 1;
155      END IF;
156    EXCEPTION
157      WHEN OTHERS THEN
158        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
159        usim_test.log_error(l_test_id, l_fail_message);
160        l_tests_failed := l_tests_failed + 1;
161    END;
162    ROLLBACK;
163    l_run_id := '009';
164    BEGIN
165      INSERT INTO usim_basedata (usim_planck_aeon_seq_curr) VALUES ('BLA') RETURNING usim_planck_aeon_seq_curr INTO l_sql_char_result;
166      IF TRIM(l_sql_char_result) = usim_static.usim_not_available
167      THEN
168        l_tests_success := l_tests_success + 1;
169      ELSE
170        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] insert BLA for usim_planck_aeon_seq_curr NOT ' || usim_static.usim_not_available;
171        usim_test.log_error(l_test_id, l_fail_message);
172        l_tests_failed := l_tests_failed + 1;
173      END IF;
174    EXCEPTION
175      WHEN OTHERS THEN
176        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
177        usim_test.log_error(l_test_id, l_fail_message);
178        l_tests_failed := l_tests_failed + 1;
179    END;
180    ROLLBACK;
181    l_run_id := '010';
182    BEGIN
183      INSERT INTO usim_basedata (usim_created) VALUES (TRUNC(SYSDATE-10)) RETURNING usim_created INTO l_sql_date_result;
184      IF l_sql_date_result != TRUNC(SYSDATE-10)
185      THEN
186        l_tests_success := l_tests_success + 1;
187      ELSE
188        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || TO_CHAR(l_sql_date_result, 'DD.MM.YYYY HH24:MI:SS') || '] usim_created should not be writable.';
189        usim_test.log_error(l_test_id, l_fail_message);
190        l_tests_failed := l_tests_failed + 1;
191      END IF;
192    EXCEPTION
193      WHEN OTHERS THEN
194        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
195        usim_test.log_error(l_test_id, l_fail_message);
196        l_tests_failed := l_tests_failed + 1;
197    END;
198    ROLLBACK;
199    l_run_id := '011';
200    BEGIN
201      INSERT INTO usim_basedata (usim_updated) VALUES (TRUNC(SYSDATE-10)) RETURNING usim_updated INTO l_sql_date_result;
202      IF l_sql_date_result != TRUNC(SYSDATE-10)
203      THEN
204        l_tests_success := l_tests_success + 1;
205      ELSE
206        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || TO_CHAR(l_sql_date_result, 'DD.MM.YYYY HH24:MI:SS') || '] usim_updated should not be writable.';
207        usim_test.log_error(l_test_id, l_fail_message);
208        l_tests_failed := l_tests_failed + 1;
209      END IF;
210    EXCEPTION
211      WHEN OTHERS THEN
212        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
213        usim_test.log_error(l_test_id, l_fail_message);
214        l_tests_failed := l_tests_failed + 1;
215    END;
216    ROLLBACK;
217    l_run_id := '012';
218    BEGIN
219      INSERT INTO usim_basedata (usim_created_by) VALUES ('BLA') RETURNING usim_created_by INTO l_sql_char_result;
220      IF TRIM(l_sql_char_result) != 'BLA'
221      THEN
222        l_tests_success := l_tests_success + 1;
223      ELSE
224        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] usim_created_by should not be writable.';
225        usim_test.log_error(l_test_id, l_fail_message);
226        l_tests_failed := l_tests_failed + 1;
227      END IF;
228    EXCEPTION
229      WHEN OTHERS THEN
230        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
231        usim_test.log_error(l_test_id, l_fail_message);
232        l_tests_failed := l_tests_failed + 1;
233    END;
234    ROLLBACK;
235    l_run_id := '013';
236    BEGIN
237      INSERT INTO usim_basedata (usim_updated_by) VALUES ('BLA') RETURNING usim_created_by INTO l_sql_char_result;
238      IF TRIM(l_sql_char_result) != 'BLA'
239      THEN
240        l_tests_success := l_tests_success + 1;
241      ELSE
242        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] usim_updated_by should not be writable.';
243        usim_test.log_error(l_test_id, l_fail_message);
244        l_tests_failed := l_tests_failed + 1;
245      END IF;
246    EXCEPTION
247      WHEN OTHERS THEN
248        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
249        usim_test.log_error(l_test_id, l_fail_message);
250        l_tests_failed := l_tests_failed + 1;
251    END;
252    ROLLBACK;
253
254
255    l_test_section := 'Update trigger no update allowed';
256    -- insert default record
257    l_run_id := '014';
258    INSERT INTO usim_basedata (usim_updated_by) VALUES ('BLA');
259    COMMIT;
260    BEGIN
261      UPDATE usim_basedata
262         SET usim_planck_time_seq_last = 1
263      RETURNING usim_planck_time_seq_last INTO l_sql_number_result;
264      IF l_sql_number_result != 1
265      THEN
266        l_tests_success := l_tests_success + 1;
267      ELSE
268        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] usim_planck_time_seq_last update not allowed.';
269        usim_test.log_error(l_test_id, l_fail_message);
270        l_tests_failed := l_tests_failed + 1;
271      END IF;
272    EXCEPTION
273      WHEN OTHERS THEN
274        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
275        usim_test.log_error(l_test_id, l_fail_message);
276        l_tests_failed := l_tests_failed + 1;
277    END;
278    ROLLBACK;
279    l_run_id := '015';
280    BEGIN
281      UPDATE usim_basedata
282         SET usim_planck_aeon_seq_last = 'BLA'
283      RETURNING usim_planck_aeon_seq_last INTO l_sql_char_result;
284      IF TRIM(l_sql_char_result) != 'BLA'
285      THEN
286        l_tests_success := l_tests_success + 1;
287      ELSE
288        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] usim_planck_aeon_seq_last update not allowed.';
289        usim_test.log_error(l_test_id, l_fail_message);
290        l_tests_failed := l_tests_failed + 1;
291      END IF;
292    EXCEPTION
293      WHEN OTHERS THEN
294        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
295        usim_test.log_error(l_test_id, l_fail_message);
296        l_tests_failed := l_tests_failed + 1;
297    END;
298    ROLLBACK;
299    l_run_id := '016';
300    BEGIN
301      UPDATE usim_basedata
302         SET usim_overflow_node_seed = -1
303      RETURNING usim_overflow_node_seed INTO l_sql_number_result;
304      IF l_sql_number_result != -1
305      THEN
306        l_tests_success := l_tests_success + 1;
307      ELSE
308        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] usim_overflow_node_seed update not allowed.';
309        usim_test.log_error(l_test_id, l_fail_message);
310        l_tests_failed := l_tests_failed + 1;
311      END IF;
312    EXCEPTION
313      WHEN OTHERS THEN
314        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
315        usim_test.log_error(l_test_id, l_fail_message);
316        l_tests_failed := l_tests_failed + 1;
317    END;
318    ROLLBACK;
319    l_run_id := '017';
320    BEGIN
321      UPDATE usim_basedata
322         SET usim_max_dimension = 99
323      RETURNING usim_max_dimension INTO l_sql_number_result;
324      IF l_sql_number_result != 99
325      THEN
326        l_tests_success := l_tests_success + 1;
327      ELSE
328        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] usim_max_dimension update not allowed.';
329        usim_test.log_error(l_test_id, l_fail_message);
330        l_tests_failed := l_tests_failed + 1;
331      END IF;
332    EXCEPTION
333      WHEN OTHERS THEN
334        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
335        usim_test.log_error(l_test_id, l_fail_message);
336        l_tests_failed := l_tests_failed + 1;
337    END;
338    ROLLBACK;
339    l_run_id := '018';
340    BEGIN
341      UPDATE usim_basedata
342         SET usim_abs_max_number = 999
343      RETURNING usim_abs_max_number INTO l_sql_number_result;
344      IF l_sql_number_result != 999
345      THEN
346        l_tests_success := l_tests_success + 1;
347      ELSE
348        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] usim_abs_max_number update not allowed.';
349        usim_test.log_error(l_test_id, l_fail_message);
350        l_tests_failed := l_tests_failed + 1;
351      END IF;
352    EXCEPTION
353      WHEN OTHERS THEN
354        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
355        usim_test.log_error(l_test_id, l_fail_message);
356        l_tests_failed := l_tests_failed + 1;
357    END;
358    ROLLBACK;
359    l_run_id := '019';
360    BEGIN
361      UPDATE usim_basedata
362         SET usim_created = TRUNC(SYSDATE+10)
363      RETURNING usim_created INTO l_sql_date_result;
364      IF l_sql_date_result != TRUNC(SYSDATE+10)
365      THEN
366        l_tests_success := l_tests_success + 1;
367      ELSE
368        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || TO_CHAR(l_sql_date_result, 'DD.MM.YYYY HH24:MI:SS') || '] usim_created update not allowed.';
369        usim_test.log_error(l_test_id, l_fail_message);
370        l_tests_failed := l_tests_failed + 1;
371      END IF;
372    EXCEPTION
373      WHEN OTHERS THEN
374        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
375        usim_test.log_error(l_test_id, l_fail_message);
376        l_tests_failed := l_tests_failed + 1;
377    END;
378    ROLLBACK;
379    l_run_id := '020';
380    BEGIN
381      UPDATE usim_basedata
382         SET usim_updated = TRUNC(SYSDATE+10)
383      RETURNING usim_updated INTO l_sql_date_result;
384      IF l_sql_date_result != TRUNC(SYSDATE+10)
385      THEN
386        l_tests_success := l_tests_success + 1;
387      ELSE
388        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || TO_CHAR(l_sql_date_result, 'DD.MM.YYYY HH24:MI:SS') || '] usim_updated update not allowed.';
389        usim_test.log_error(l_test_id, l_fail_message);
390        l_tests_failed := l_tests_failed + 1;
391      END IF;
392    EXCEPTION
393      WHEN OTHERS THEN
394        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
395        usim_test.log_error(l_test_id, l_fail_message);
396        l_tests_failed := l_tests_failed + 1;
397    END;
398    ROLLBACK;
399    l_run_id := '021';
400    BEGIN
401      UPDATE usim_basedata
402         SET usim_updated_by = 'BLA'
403      RETURNING usim_updated_by INTO l_sql_char_result;
404      IF TRIM(l_sql_char_result) != 'BLA'
405      THEN
406        l_tests_success := l_tests_success + 1;
407      ELSE
408        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] usim_updated_by update only for schema or OS user allowed.';
409        usim_test.log_error(l_test_id, l_fail_message);
410        l_tests_failed := l_tests_failed + 1;
411      END IF;
412    EXCEPTION
413      WHEN OTHERS THEN
414        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
415        usim_test.log_error(l_test_id, l_fail_message);
416        l_tests_failed := l_tests_failed + 1;
417    END;
418    ROLLBACK;
419
420    l_test_section := 'Update trigger update sequence currval';
421    l_run_id := '022';
422    BEGIN
423      UPDATE usim_basedata
424         SET usim_planck_time_seq_curr = 1
425      RETURNING usim_planck_time_seq_curr INTO l_sql_number_result;
426      IF l_sql_number_result = 1
427      THEN
428        l_tests_success := l_tests_success + 1;
429      ELSE
430        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] usim_planck_time_seq_curr should be writable.';
431        usim_test.log_error(l_test_id, l_fail_message);
432        l_tests_failed := l_tests_failed + 1;
433      END IF;
434    EXCEPTION
435      WHEN OTHERS THEN
436        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
437        usim_test.log_error(l_test_id, l_fail_message);
438        l_tests_failed := l_tests_failed + 1;
439    END;
440    l_run_id := '023';
441    BEGIN
442      UPDATE usim_basedata
443         SET usim_planck_time_seq_curr = 2
444      RETURNING usim_planck_time_seq_curr INTO l_sql_number_result;
445      IF l_sql_number_result = 2
446      THEN
447        l_tests_success := l_tests_success + 1;
448      ELSE
449        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] usim_planck_time_seq_curr should be writable.';
450        usim_test.log_error(l_test_id, l_fail_message);
451        l_tests_failed := l_tests_failed + 1;
452      END IF;
453    EXCEPTION
454      WHEN OTHERS THEN
455        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
456        usim_test.log_error(l_test_id, l_fail_message);
457        l_tests_failed := l_tests_failed + 1;
458    END;
459    l_run_id := '024';
460    BEGIN
461      SELECT usim_planck_time_seq_last INTO l_sql_number_result FROM usim_basedata;
462      IF l_sql_number_result = 1
463      THEN
464        l_tests_success := l_tests_success + 1;
465      ELSE
466        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] usim_planck_time_seq_last not set to last curr.';
467        usim_test.log_error(l_test_id, l_fail_message);
468        l_tests_failed := l_tests_failed + 1;
469      END IF;
470    EXCEPTION
471      WHEN OTHERS THEN
472        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
473        usim_test.log_error(l_test_id, l_fail_message);
474        l_tests_failed := l_tests_failed + 1;
475    END;
476    ROLLBACK;
477    l_run_id := '025';
478    BEGIN
479      UPDATE usim_basedata
480         SET usim_planck_aeon_seq_curr = 'BLA'
481      RETURNING usim_planck_aeon_seq_curr INTO l_sql_char_result;
482      IF TRIM(l_sql_char_result) = 'BLA'
483      THEN
484        l_tests_success := l_tests_success + 1;
485      ELSE
486        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] usim_planck_aeon_seq_curr should be writable.';
487        usim_test.log_error(l_test_id, l_fail_message);
488        l_tests_failed := l_tests_failed + 1;
489      END IF;
490    EXCEPTION
491      WHEN OTHERS THEN
492        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
493        usim_test.log_error(l_test_id, l_fail_message);
494        l_tests_failed := l_tests_failed + 1;
495    END;
496    l_run_id := '026';
497    BEGIN
498      UPDATE usim_basedata
499         SET usim_planck_aeon_seq_curr = 'BLUBB'
500      RETURNING usim_planck_aeon_seq_curr INTO l_sql_char_result;
501      IF TRIM(l_sql_char_result) = 'BLUBB'
502      THEN
503        l_tests_success := l_tests_success + 1;
504      ELSE
505        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] usim_planck_aeon_seq_curr should be writable.';
506        usim_test.log_error(l_test_id, l_fail_message);
507        l_tests_failed := l_tests_failed + 1;
508      END IF;
509    EXCEPTION
510      WHEN OTHERS THEN
511        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
512        usim_test.log_error(l_test_id, l_fail_message);
513        l_tests_failed := l_tests_failed + 1;
514    END;
515    l_run_id := '027';
516    BEGIN
517      SELECT usim_planck_aeon_seq_last INTO l_sql_char_result FROM usim_basedata;
518      IF TRIM(l_sql_char_result) = 'BLA'
519      THEN
520        l_tests_success := l_tests_success + 1;
521      ELSE
522        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] usim_planck_aeon_seq_last not set to last curr.';
523        usim_test.log_error(l_test_id, l_fail_message);
524        l_tests_failed := l_tests_failed + 1;
525      END IF;
526    EXCEPTION
527      WHEN OTHERS THEN
528        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
529        usim_test.log_error(l_test_id, l_fail_message);
530        l_tests_failed := l_tests_failed + 1;
531    END;
532    ROLLBACK;
533
534    -- reset table
535    DELETE usim_basedata;
536    COMMIT;
537    -- write test results
538    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
539  EXCEPTION
540    WHEN OTHERS THEN
541      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
542      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
543  END;
544  /
SQL> @@TEST_USIM_BASE.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(32000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_BASE';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12  BEGIN
 13    l_test_id := usim_test.init_test(l_test_object);
 14    l_test_section := 'Base data not initialized';
 15    l_run_id := '001';
 16    DELETE usim_basedata;
 17    COMMIT;
 18    -- functions
 19    IF usim_base.has_basedata = 1
 20    THEN
 21      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': data deleted should not have base data.';
 22      usim_test.log_error(l_test_id, l_fail_message);
 23      l_tests_failed := l_tests_failed + 1;
 24    ELSE
 25      l_tests_success := l_tests_success + 1;
 26    END IF;
 27    l_run_id := '002';
 28    IF usim_base.get_max_dimension IS NOT NULL
 29    THEN
 30      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || usim_base.get_max_dimension || '] get_max_dimension should be NULL.';
 31      usim_test.log_error(l_test_id, l_fail_message);
 32      l_tests_failed := l_tests_failed + 1;
 33    ELSE
 34      l_tests_success := l_tests_success + 1;
 35    END IF;
 36    l_run_id := '003';
 37    IF usim_base.get_abs_max_number IS NOT NULL
 38    THEN
 39      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || usim_base.get_abs_max_number || '] get_abs_max_number should be NULL.';
 40      usim_test.log_error(l_test_id, l_fail_message);
 41      l_tests_failed := l_tests_failed + 1;
 42    ELSE
 43      l_tests_success := l_tests_success + 1;
 44    END IF;
 45    l_run_id := '004';
 46    IF NOT usim_base.planck_time_seq_exists
 47    THEN
 48      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': planck time sequence should exist independent from base data.';
 49      usim_test.log_error(l_test_id, l_fail_message);
 50      l_tests_failed := l_tests_failed + 1;
 51    ELSE
 52      l_tests_success := l_tests_success + 1;
 53    END IF;
 54    l_run_id := '005';
 55    IF usim_base.get_planck_time_current IS NOT NULL
 56    THEN
 57      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || usim_base.get_planck_time_current || '] get_planck_time_current should be NULL.';
 58      usim_test.log_error(l_test_id, l_fail_message);
 59      l_tests_failed := l_tests_failed + 1;
 60    ELSE
 61      l_tests_success := l_tests_success + 1;
 62    END IF;
 63    l_run_id := '006';
 64    IF usim_base.get_planck_time_last IS NOT NULL
 65    THEN
 66      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || usim_base.get_planck_time_last || '] get_planck_time_last should be NULL.';
 67      usim_test.log_error(l_test_id, l_fail_message);
 68      l_tests_failed := l_tests_failed + 1;
 69    ELSE
 70      l_tests_success := l_tests_success + 1;
 71    END IF;
 72    l_run_id := '007';
 73    l_sql_number_result := usim_base.get_planck_time_next;
 74    IF l_sql_number_result IS NOT NULL
 75    THEN
 76      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] get_planck_time_next should be NULL.';
 77      usim_test.log_error(l_test_id, l_fail_message);
 78      l_tests_failed := l_tests_failed + 1;
 79    ELSE
 80      l_tests_success := l_tests_success + 1;
 81    END IF;
 82    l_run_id := '008';
 83    IF NOT usim_base.planck_aeon_seq_exists
 84    THEN
 85      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': planck aeon sequence should exist independent from base data.';
 86      usim_test.log_error(l_test_id, l_fail_message);
 87      l_tests_failed := l_tests_failed + 1;
 88    ELSE
 89      l_tests_success := l_tests_success + 1;
 90    END IF;
 91    l_run_id := '009';
 92    IF usim_base.get_planck_aeon_seq_current IS NOT NULL
 93    THEN
 94      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || usim_base.get_planck_aeon_seq_current || '] get_planck_aeon_seq_current should be NULL.';
 95      usim_test.log_error(l_test_id, l_fail_message);
 96      l_tests_failed := l_tests_failed + 1;
 97    ELSE
 98      l_tests_success := l_tests_success + 1;
 99    END IF;
100    l_run_id := '010';
101    IF usim_base.get_planck_aeon_seq_last IS NOT NULL
102    THEN
103      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || usim_base.get_planck_aeon_seq_last || '] get_planck_aeon_seq_last should be NULL.';
104      usim_test.log_error(l_test_id, l_fail_message);
105      l_tests_failed := l_tests_failed + 1;
106    ELSE
107      l_tests_success := l_tests_success + 1;
108    END IF;
109    l_run_id := '011';
110    l_sql_char_result := usim_base.get_planck_aeon_seq_next;
111    IF l_sql_char_result IS NOT NULL
112    THEN
113      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] get_planck_aeon_seq_next should be NULL.';
114      usim_test.log_error(l_test_id, l_fail_message);
115      l_tests_failed := l_tests_failed + 1;
116    ELSE
117      l_tests_success := l_tests_success + 1;
118    END IF;
119    l_run_id := '012';
120    IF usim_base.get_overflow_node_seed IS NOT NULL
121    THEN
122      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || usim_base.get_overflow_node_seed || '] get_overflow_node_seed should be NULL.';
123      usim_test.log_error(l_test_id, l_fail_message);
124      l_tests_failed := l_tests_failed + 1;
125    ELSE
126      l_tests_success := l_tests_success + 1;
127    END IF;
128
129    l_test_section := 'Initialize base data';
130    -- make sure no data exist
131    l_run_id := '013';
132    DELETE usim_basedata;
133    COMMIT;
134    -- defaults
135    usim_base.init_basedata;
136    IF usim_base.has_basedata = 0
137    THEN
138      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not create a record.';
139      usim_test.log_error(l_test_id, l_fail_message);
140      l_tests_failed := l_tests_failed + 1;
141    ELSE
142      l_tests_success := l_tests_success + 1;
143    END IF;
144    l_run_id := '014';
145    IF usim_base.get_max_dimension != 42
146    THEN
147      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not set default max dimension.';
148      usim_test.log_error(l_test_id, l_fail_message);
149      l_tests_failed := l_tests_failed + 1;
150    ELSE
151      l_tests_success := l_tests_success + 1;
152    END IF;
153    l_run_id := '015';
154    IF usim_base.get_abs_max_number != 99999999999999999999999999999999999999
155    THEN
156      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not set default absolute max number.';
157      usim_test.log_error(l_test_id, l_fail_message);
158      l_tests_failed := l_tests_failed + 1;
159    ELSE
160      l_tests_success := l_tests_success + 1;
161    END IF;
162    l_run_id := '016';
163    IF usim_base.get_overflow_node_seed != 0
164    THEN
165      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not set default overflow behavior.';
166      usim_test.log_error(l_test_id, l_fail_message);
167      l_tests_failed := l_tests_failed + 1;
168    ELSE
169      l_tests_success := l_tests_success + 1;
170    END IF;
171    -- defaults, if explicite NULL
172    l_run_id := '017';
173    DELETE usim_basedata;
174    COMMIT;
175    usim_base.init_basedata(NULL, NULL, NULL);
176    IF usim_base.has_basedata = 0
177    THEN
178      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not create a record.';
179      usim_test.log_error(l_test_id, l_fail_message);
180      l_tests_failed := l_tests_failed + 1;
181    ELSE
182      l_tests_success := l_tests_success + 1;
183    END IF;
184    l_run_id := '018';
185    IF usim_base.get_max_dimension != 42
186    THEN
187      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not set default max dimension.';
188      usim_test.log_error(l_test_id, l_fail_message);
189      l_tests_failed := l_tests_failed + 1;
190    ELSE
191      l_tests_success := l_tests_success + 1;
192    END IF;
193    l_run_id := '019';
194    IF usim_base.get_abs_max_number != 99999999999999999999999999999999999999
195    THEN
196      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not set default absolute max number.';
197      usim_test.log_error(l_test_id, l_fail_message);
198      l_tests_failed := l_tests_failed + 1;
199    ELSE
200      l_tests_success := l_tests_success + 1;
201    END IF;
202    l_run_id := '020';
203    IF usim_base.get_overflow_node_seed != 0
204    THEN
205      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not set default overflow behavior.';
206      usim_test.log_error(l_test_id, l_fail_message);
207      l_tests_failed := l_tests_failed + 1;
208    ELSE
209      l_tests_success := l_tests_success + 1;
210    END IF;
211    -- breaking constraints input -> defaults
212    l_run_id := '021';
213    DELETE usim_basedata;
214    COMMIT;
215    usim_base.init_basedata(-1, -1, 10);
216    IF usim_base.has_basedata = 0
217    THEN
218      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not create a record.';
219      usim_test.log_error(l_test_id, l_fail_message);
220      l_tests_failed := l_tests_failed + 1;
221    ELSE
222      l_tests_success := l_tests_success + 1;
223    END IF;
224    l_run_id := '022';
225    IF usim_base.get_max_dimension != 42
226    THEN
227      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not set default max dimension.';
228      usim_test.log_error(l_test_id, l_fail_message);
229      l_tests_failed := l_tests_failed + 1;
230    ELSE
231      l_tests_success := l_tests_success + 1;
232    END IF;
233    l_run_id := '023';
234    IF usim_base.get_abs_max_number != 99999999999999999999999999999999999999
235    THEN
236      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not set default absolute max number.';
237      usim_test.log_error(l_test_id, l_fail_message);
238      l_tests_failed := l_tests_failed + 1;
239    ELSE
240      l_tests_success := l_tests_success + 1;
241    END IF;
242    l_run_id := '024';
243    IF usim_base.get_overflow_node_seed != 0
244    THEN
245      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not set default overflow behavior.';
246      usim_test.log_error(l_test_id, l_fail_message);
247      l_tests_failed := l_tests_failed + 1;
248    ELSE
249      l_tests_success := l_tests_success + 1;
250    END IF;
251    -- insert valid data
252    l_run_id := '025';
253    DELETE usim_basedata;
254    COMMIT;
255    usim_base.init_basedata(11, 9999, 1);
256    IF usim_base.has_basedata = 0
257    THEN
258      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not create a record.';
259      usim_test.log_error(l_test_id, l_fail_message);
260      l_tests_failed := l_tests_failed + 1;
261    ELSE
262      l_tests_success := l_tests_success + 1;
263    END IF;
264    l_run_id := '026';
265    IF usim_base.get_max_dimension != 11
266    THEN
267      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not set max dimension to 11.';
268      usim_test.log_error(l_test_id, l_fail_message);
269      l_tests_failed := l_tests_failed + 1;
270    ELSE
271      l_tests_success := l_tests_success + 1;
272    END IF;
273    l_run_id := '027';
274    IF usim_base.get_abs_max_number != 9999
275    THEN
276      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not set absolute max number to 9999.';
277      usim_test.log_error(l_test_id, l_fail_message);
278      l_tests_failed := l_tests_failed + 1;
279    ELSE
280      l_tests_success := l_tests_success + 1;
281    END IF;
282    l_run_id := '028';
283    IF usim_base.get_overflow_node_seed != 1
284    THEN
285      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': init_basedata did not set overflow behavior to 1.';
286      usim_test.log_error(l_test_id, l_fail_message);
287      l_tests_failed := l_tests_failed + 1;
288    ELSE
289      l_tests_success := l_tests_success + 1;
290    END IF;
291
292    -- cleanup
293    DELETE usim_basedata;
294    COMMIT;
295    -- write test results
296    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
297  EXCEPTION
298    WHEN OTHERS THEN
299      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
300      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
301  END;
302  /
SQL> @@TEST_USIM_MULTIVERSE.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(32000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_MULTIVERSE table';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12  BEGIN
 13    l_test_id := usim_test.init_test(l_test_object);
 14    l_test_section := 'Table insert requirements';
 15    l_run_id := '001';
 16    -- setup
 17    DELETE usim_basedata;
 18    DELETE usim_multiverse;
 19    COMMIT;
 20    BEGIN
 21      INSERT INTO usim_multiverse (usim_universe_status) VALUES (0) RETURNING usim_universe_status INTO l_sql_number_result;
 22      -- input should be impossible with no base data
 23      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert with no base data should not work.';
 24      usim_test.log_error(l_test_id, l_fail_message);
 25      l_tests_failed := l_tests_failed + 1;
 26    EXCEPTION
 27      WHEN OTHERS THEN
 28        IF SQLCODE = -20000
 29        THEN
 30          l_tests_success := l_tests_success + 1;
 31        ELSE
 32          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 33          usim_test.log_error(l_test_id, l_fail_message);
 34          l_tests_failed := l_tests_failed + 1;
 35        END IF;
 36    END;
 37    ROLLBACK;
 38    l_test_section := 'Table trigger calculated columns';
 39    l_run_id := '002';
 40    usim_base.init_basedata;
 41    BEGIN
 42      INSERT INTO usim_multiverse (usim_universe_status) VALUES (2) RETURNING usim_universe_status INTO l_sql_number_result;
 43      IF l_sql_number_result = 0
 44      THEN
 45        l_tests_success := l_tests_success + 1;
 46      ELSE
 47        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert for usim_universe_status NOT 0.';
 48        usim_test.log_error(l_test_id, l_fail_message);
 49        l_tests_failed := l_tests_failed + 1;
 50      END IF;
 51    EXCEPTION
 52      WHEN OTHERS THEN
 53        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 54        usim_test.log_error(l_test_id, l_fail_message);
 55        l_tests_failed := l_tests_failed + 1;
 56    END;
 57    l_run_id := '003';
 58    BEGIN
 59      UPDATE usim_multiverse SET usim_universe_status = 2 RETURNING usim_universe_status INTO l_sql_number_result;
 60      IF l_sql_number_result = 0
 61      THEN
 62        l_tests_success := l_tests_success + 1;
 63      ELSE
 64        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update 2 for usim_universe_status NOT 0.';
 65      usim_test.log_error(l_test_id, l_fail_message);
 66      l_tests_failed := l_tests_failed + 1;
 67  END IF;
 68    EXCEPTION
 69      WHEN OTHERS THEN
 70        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 71        usim_test.log_error(l_test_id, l_fail_message);
 72        l_tests_failed := l_tests_failed + 1;
 73    END;
 74    ROLLBACK;
 75    l_run_id := '004';
 76    BEGIN
 77      INSERT INTO usim_multiverse (usim_planck_time) VALUES (2) RETURNING usim_planck_time INTO l_sql_number_result;
 78      IF l_sql_number_result = usim_base.get_planck_time_current
 79      THEN
 80        l_tests_success := l_tests_success + 1;
 81      ELSE
 82        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert 2 for usim_planck_time NOT ' || usim_base.get_planck_time_current;
 83        usim_test.log_error(l_test_id, l_fail_message);
 84        l_tests_failed := l_tests_failed + 1;
 85      END IF;
 86    EXCEPTION
 87      WHEN OTHERS THEN
 88        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 89        usim_test.log_error(l_test_id, l_fail_message);
 90        l_tests_failed := l_tests_failed + 1;
 91    END;
 92    ROLLBACK;
 93    l_run_id := '005';
 94    BEGIN
 95      INSERT INTO usim_multiverse (usim_planck_aeon) VALUES ('2') RETURNING usim_planck_aeon INTO l_sql_char_result;
 96      IF TRIM(l_sql_char_result) = usim_base.get_planck_aeon_seq_current
 97      THEN
 98        l_tests_success := l_tests_success + 1;
 99      ELSE
100        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] insert 2 for usim_planck_aeon NOT ' || usim_base.get_planck_aeon_seq_current;
101        usim_test.log_error(l_test_id, l_fail_message);
102        l_tests_failed := l_tests_failed + 1;
103      END IF;
104    EXCEPTION
105      WHEN OTHERS THEN
106        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
107        usim_test.log_error(l_test_id, l_fail_message);
108        l_tests_failed := l_tests_failed + 1;
109    END;
110    ROLLBACK;
111
112    l_test_section := 'Table constraints';
113    l_run_id := '006';
114    BEGIN
115      INSERT INTO usim_multiverse (usim_planck_stable) VALUES (2) RETURNING usim_planck_stable INTO l_sql_number_result;
116      -- input should be prevented by constraint
117      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert 2 on usim_planck_stable should not work.';
118      usim_test.log_error(l_test_id, l_fail_message);
119      l_tests_failed := l_tests_failed + 1;
120    EXCEPTION
121      WHEN OTHERS THEN
122        IF INSTR(SQLERRM, 'USIM_MLV_PLANCK_CHK') > 0
123        THEN
124          l_tests_success := l_tests_success + 1;
125        ELSE
126          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
127          usim_test.log_error(l_test_id, l_fail_message);
128          l_tests_failed := l_tests_failed + 1;
129        END IF;
130    END;
131    ROLLBACK;
132    l_run_id := '007';
133    BEGIN
134      INSERT INTO usim_multiverse (usim_is_base_universe) VALUES (2) RETURNING usim_is_base_universe INTO l_sql_number_result;
135      -- input should be prevented by constraint
136      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert 2 on usim_is_base_universe should not work.';
137      usim_test.log_error(l_test_id, l_fail_message);
138      l_tests_failed := l_tests_failed + 1;
139    EXCEPTION
140      WHEN OTHERS THEN
141        IF INSTR(SQLERRM, 'USIM_MLV_BASE_CHK') > 0
142        THEN
143          l_tests_success := l_tests_success + 1;
144        ELSE
145          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
146          usim_test.log_error(l_test_id, l_fail_message);
147          l_tests_failed := l_tests_failed + 1;
148        END IF;
149    END;
150    ROLLBACK;
151    l_run_id := '008';
152    BEGIN
153      INSERT INTO usim_multiverse (usim_ultimate_border) VALUES (2) RETURNING usim_ultimate_border INTO l_sql_number_result;
154      -- input should be prevented by constraint
155      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] insert 2 on usim_ultimate_border should not work.';
156      usim_test.log_error(l_test_id, l_fail_message);
157      l_tests_failed := l_tests_failed + 1;
158    EXCEPTION
159      WHEN OTHERS THEN
160        IF INSTR(SQLERRM, 'USIM_BORDER_MLV_CHK') > 0
161        THEN
162          l_tests_success := l_tests_success + 1;
163        ELSE
164          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
165          usim_test.log_error(l_test_id, l_fail_message);
166          l_tests_failed := l_tests_failed + 1;
167        END IF;
168    END;
169    ROLLBACK;
170
171    l_test_section := 'Table update trigger';
172    l_run_id := '009';
173    -- setup
174    INSERT INTO usim_multiverse (usim_planck_stable) VALUES (1);
175    COMMIT;
176    BEGIN
177      UPDATE usim_multiverse SET usim_energy_start_value = 10 RETURNING usim_energy_start_value INTO l_sql_number_result;
178      IF l_sql_number_result != 10
179      THEN
180        l_tests_success := l_tests_success + 1;
181      ELSE
182        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update 10 on usim_energy_start_value should not work.';
183        usim_test.log_error(l_test_id, l_fail_message);
184        l_tests_failed := l_tests_failed + 1;
185      END IF;
186    EXCEPTION
187      WHEN OTHERS THEN
188        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
189        usim_test.log_error(l_test_id, l_fail_message);
190        l_tests_failed := l_tests_failed + 1;
191    END;
192    ROLLBACK;
193    l_run_id := '010';
194    BEGIN
195      UPDATE usim_multiverse SET usim_is_base_universe = 1 RETURNING usim_is_base_universe INTO l_sql_number_result;
196      IF l_sql_number_result = 0
197      THEN
198        l_tests_success := l_tests_success + 1;
199      ELSE
200        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update 1 on usim_is_base_universe should not work.';
201        usim_test.log_error(l_test_id, l_fail_message);
202        l_tests_failed := l_tests_failed + 1;
203      END IF;
204    EXCEPTION
205      WHEN OTHERS THEN
206        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
207        usim_test.log_error(l_test_id, l_fail_message);
208        l_tests_failed := l_tests_failed + 1;
209    END;
210    l_run_id := '011';
211    BEGIN
212      UPDATE usim_multiverse SET usim_ultimate_border = 0 RETURNING usim_ultimate_border INTO l_sql_number_result;
213      IF l_sql_number_result = 1
214      THEN
215        l_tests_success := l_tests_success + 1;
216      ELSE
217        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update 0 on usim_ultimate_border should not work.';
218        usim_test.log_error(l_test_id, l_fail_message);
219        l_tests_failed := l_tests_failed + 1;
220      END IF;
221    EXCEPTION
222      WHEN OTHERS THEN
223        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
224        usim_test.log_error(l_test_id, l_fail_message);
225        l_tests_failed := l_tests_failed + 1;
226    END;
227    ROLLBACK;
228    l_run_id := '012';
229    BEGIN
230      UPDATE usim_multiverse SET usim_planck_stable = 0 RETURNING usim_planck_stable INTO l_sql_number_result;
231      IF l_sql_number_result = 1
232      THEN
233        l_tests_success := l_tests_success + 1;
234      ELSE
235        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update 0 on usim_planck_stable should not work.';
236        usim_test.log_error(l_test_id, l_fail_message);
237        l_tests_failed := l_tests_failed + 1;
238      END IF;
239    EXCEPTION
240      WHEN OTHERS THEN
241        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
242        usim_test.log_error(l_test_id, l_fail_message);
243        l_tests_failed := l_tests_failed + 1;
244    END;
245    ROLLBACK;
246
247    l_test_section := 'Table planck stable update';
248    l_run_id := '013';
249    BEGIN
250      UPDATE usim_multiverse SET usim_planck_stable = 0 RETURNING usim_planck_stable INTO l_sql_number_result;
251      IF l_sql_number_result = 1
252      THEN
253        l_tests_success := l_tests_success + 1;
254      ELSE
255        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update of usim_planck_time_unit should not work.';
256        usim_test.log_error(l_test_id, l_fail_message);
257        l_tests_failed := l_tests_failed + 1;
258      END IF;
259    EXCEPTION
260      WHEN OTHERS THEN
261        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
262        usim_test.log_error(l_test_id, l_fail_message);
263        l_tests_failed := l_tests_failed + 1;
264    END;
265    ROLLBACK;
266
267    l_test_section := 'Table update trigger planck stable';
268    l_run_id := '014';
269    BEGIN
270      UPDATE usim_multiverse SET usim_planck_time_unit = 0 RETURNING usim_planck_time_unit INTO l_sql_number_result;
271      IF l_sql_number_result = 1
272      THEN
273        l_tests_success := l_tests_success + 1;
274      ELSE
275        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update of usim_planck_time_unit should not work.';
276        usim_test.log_error(l_test_id, l_fail_message);
277        l_tests_failed := l_tests_failed + 1;
278      END IF;
279    EXCEPTION
280      WHEN OTHERS THEN
281        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
282        usim_test.log_error(l_test_id, l_fail_message);
283        l_tests_failed := l_tests_failed + 1;
284    END;
285    ROLLBACK;
286    l_run_id := '015';
287    BEGIN
288      UPDATE usim_multiverse SET usim_planck_speed_unit = 0 RETURNING usim_planck_speed_unit INTO l_sql_number_result;
289      IF l_sql_number_result = 1
290      THEN
291        l_tests_success := l_tests_success + 1;
292      ELSE
293        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update of usim_planck_speed_unit should not work.';
294        usim_test.log_error(l_test_id, l_fail_message);
295        l_tests_failed := l_tests_failed + 1;
296      END IF;
297    EXCEPTION
298      WHEN OTHERS THEN
299        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
300        usim_test.log_error(l_test_id, l_fail_message);
301        l_tests_failed := l_tests_failed + 1;
302    END;
303    ROLLBACK;
304    l_run_id := '016';
305    BEGIN
306      UPDATE usim_multiverse SET usim_planck_length_unit = 0 RETURNING usim_planck_length_unit INTO l_sql_number_result;
307      IF l_sql_number_result = 1
308      THEN
309        l_tests_success := l_tests_success + 1;
310      ELSE
311        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update of usim_planck_length_unit should not work.';
312        usim_test.log_error(l_test_id, l_fail_message);
313        l_tests_failed := l_tests_failed + 1;
314      END IF;
315    EXCEPTION
316      WHEN OTHERS THEN
317        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
318        usim_test.log_error(l_test_id, l_fail_message);
319        l_tests_failed := l_tests_failed + 1;
320    END;
321    ROLLBACK;
322    l_run_id := '017';
323    BEGIN
324      UPDATE usim_multiverse SET usim_planck_time_unit = 2 RETURNING usim_planck_time_unit INTO l_sql_number_result;
325      IF l_sql_number_result = 1
326      THEN
327        l_tests_success := l_tests_success + 1;
328      ELSE
329        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update of usim_planck_time_unit should not work.';
330        usim_test.log_error(l_test_id, l_fail_message);
331        l_tests_failed := l_tests_failed + 1;
332      END IF;
333    EXCEPTION
334      WHEN OTHERS THEN
335        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
336        usim_test.log_error(l_test_id, l_fail_message);
337        l_tests_failed := l_tests_failed + 1;
338    END;
339    ROLLBACK;
340    l_run_id := '018';
341    BEGIN
342      UPDATE usim_multiverse SET usim_planck_speed_unit = 2 RETURNING usim_planck_speed_unit INTO l_sql_number_result;
343      IF l_sql_number_result = 1
344      THEN
345        l_tests_success := l_tests_success + 1;
346      ELSE
347        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update of usim_planck_speed_unit should not work.';
348        usim_test.log_error(l_test_id, l_fail_message);
349        l_tests_failed := l_tests_failed + 1;
350      END IF;
351    EXCEPTION
352      WHEN OTHERS THEN
353        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
354        usim_test.log_error(l_test_id, l_fail_message);
355        l_tests_failed := l_tests_failed + 1;
356    END;
357    ROLLBACK;
358    l_run_id := '019';
359    BEGIN
360      UPDATE usim_multiverse SET usim_planck_length_unit = 2 RETURNING usim_planck_length_unit INTO l_sql_number_result;
361      IF l_sql_number_result = 1
362      THEN
363        l_tests_success := l_tests_success + 1;
364      ELSE
365        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update of usim_planck_length_unit should not work.';
366        usim_test.log_error(l_test_id, l_fail_message);
367        l_tests_failed := l_tests_failed + 1;
368      END IF;
369    EXCEPTION
370      WHEN OTHERS THEN
371        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
372        usim_test.log_error(l_test_id, l_fail_message);
373        l_tests_failed := l_tests_failed + 1;
374    END;
375    ROLLBACK;
376
377    l_run_id := '020';
378    -- setup planck stable 0
379    DELETE usim_multiverse;
380    INSERT INTO usim_multiverse (usim_planck_stable) VALUES (0);
381    COMMIT;
382    BEGIN
383      UPDATE usim_multiverse SET usim_planck_time_unit = 2 RETURNING usim_planck_time_unit INTO l_sql_number_result;
384      IF l_sql_number_result = 2
385      THEN
386        l_tests_success := l_tests_success + 1;
387      ELSE
388        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update of usim_planck_time_unit NOT 2.';
389        usim_test.log_error(l_test_id, l_fail_message);
390        l_tests_failed := l_tests_failed + 1;
391      END IF;
392    EXCEPTION
393      WHEN OTHERS THEN
394        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
395        usim_test.log_error(l_test_id, l_fail_message);
396        l_tests_failed := l_tests_failed + 1;
397    END;
398    ROLLBACK;
399    l_run_id := '021';
400    BEGIN
401      UPDATE usim_multiverse SET usim_planck_speed_unit = 2 RETURNING usim_planck_speed_unit INTO l_sql_number_result;
402      IF l_sql_number_result = 2
403      THEN
404        l_tests_success := l_tests_success + 1;
405      ELSE
406        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update of usim_planck_speed_unit NOT 2.';
407        usim_test.log_error(l_test_id, l_fail_message);
408        l_tests_failed := l_tests_failed + 1;
409      END IF;
410    EXCEPTION
411      WHEN OTHERS THEN
412        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
413        usim_test.log_error(l_test_id, l_fail_message);
414        l_tests_failed := l_tests_failed + 1;
415    END;
416    ROLLBACK;
417    l_run_id := '022';
418    BEGIN
419      UPDATE usim_multiverse SET usim_planck_length_unit = 2 RETURNING usim_planck_length_unit INTO l_sql_number_result;
420      IF l_sql_number_result = 2
421      THEN
422        l_tests_success := l_tests_success + 1;
423      ELSE
424        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update of usim_planck_length_unit NOT 2.';
425        usim_test.log_error(l_test_id, l_fail_message);
426        l_tests_failed := l_tests_failed + 1;
427      END IF;
428    EXCEPTION
429      WHEN OTHERS THEN
430        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
431        usim_test.log_error(l_test_id, l_fail_message);
432        l_tests_failed := l_tests_failed + 1;
433    END;
434    ROLLBACK;
435
436    -- cleanup
437    DELETE usim_basedata;
438    DELETE usim_multiverse;
439    COMMIT;
440    -- write test results
441    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
442  EXCEPTION
443    WHEN OTHERS THEN
444      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
445      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
446  END;
447  /
SQL> @@TEST_USIM_MLV.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(32000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_MLV';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_usim_id_mlv       usim_multiverse.usim_id_mlv%TYPE;
 12    l_test_id           NUMBER;
 13  BEGIN
 14    l_test_id := usim_test.init_test(l_test_object);
 15    l_test_section := 'No universe available';
 16    l_run_id := '001';
 17    -- setup
 18    DELETE usim_basedata;
 19    DELETE usim_multiverse;
 20    COMMIT;
 21    usim_base.init_basedata;
 22    IF usim_mlv.has_data = 1
 23    THEN
 24      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': no universe should exist after delete.';
 25      usim_test.log_error(l_test_id, l_fail_message);
 26      l_tests_failed := l_tests_failed + 1;
 27    ELSE
 28      l_tests_success := l_tests_success + 1;
 29    END IF;
 30    l_test_section := 'First universe available';
 31    l_run_id := '002';
 32    l_usim_id_mlv := usim_mlv.insert_universe;
 33    IF usim_mlv.has_data = 0
 34    THEN
 35      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': insert failed, no universe usim_mlv.has_data NOT 1.';
 36      usim_test.log_error(l_test_id, l_fail_message);
 37      l_tests_failed := l_tests_failed + 1;
 38    ELSE
 39      l_tests_success := l_tests_success + 1;
 40    END IF;
 41    l_test_section := 'Check insert values';
 42    l_run_id := '003';
 43    SELECT usim_energy_start_value INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
 44    IF l_sql_number_result != 1
 45    THEN
 46      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default usim_energy_start_value NOT 1.';
 47      usim_test.log_error(l_test_id, l_fail_message);
 48      l_tests_failed := l_tests_failed + 1;
 49    ELSE
 50      l_tests_success := l_tests_success + 1;
 51    END IF;
 52    l_run_id := '004';
 53    SELECT usim_planck_time_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
 54    IF l_sql_number_result != 1
 55    THEN
 56      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default usim_planck_time_unit NOT 1.';
 57      usim_test.log_error(l_test_id, l_fail_message);
 58      l_tests_failed := l_tests_failed + 1;
 59    ELSE
 60      l_tests_success := l_tests_success + 1;
 61    END IF;
 62    l_run_id := '005';
 63    SELECT usim_planck_length_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
 64    IF l_sql_number_result != 1
 65    THEN
 66      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default usim_planck_length_unit NOT 1.';
 67      usim_test.log_error(l_test_id, l_fail_message);
 68      l_tests_failed := l_tests_failed + 1;
 69    ELSE
 70      l_tests_success := l_tests_success + 1;
 71    END IF;
 72    l_run_id := '006';
 73    SELECT usim_planck_speed_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
 74    IF l_sql_number_result != 1
 75    THEN
 76      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default p_usim_planck_speed_unit NOT 1.';
 77      usim_test.log_error(l_test_id, l_fail_message);
 78      l_tests_failed := l_tests_failed + 1;
 79    ELSE
 80      l_tests_success := l_tests_success + 1;
 81    END IF;
 82    l_run_id := '007';
 83    SELECT usim_planck_stable INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
 84    IF l_sql_number_result != 1
 85    THEN
 86      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default usim_planck_stable NOT 1.';
 87      usim_test.log_error(l_test_id, l_fail_message);
 88      l_tests_failed := l_tests_failed + 1;
 89    ELSE
 90      l_tests_success := l_tests_success + 1;
 91    END IF;
 92    l_run_id := '008';
 93    SELECT usim_ultimate_border INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
 94    IF l_sql_number_result != 1
 95    THEN
 96      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default usim_ultimate_border NOT 1.';
 97      usim_test.log_error(l_test_id, l_fail_message);
 98      l_tests_failed := l_tests_failed + 1;
 99    ELSE
100      l_tests_success := l_tests_success + 1;
101    END IF;
102    l_run_id := '009';
103    SELECT usim_is_base_universe INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
104    IF l_sql_number_result != 1
105    THEN
106      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': first insert usim_is_base_universe NOT 1.';
107      usim_test.log_error(l_test_id, l_fail_message);
108      l_tests_failed := l_tests_failed + 1;
109    ELSE
110      l_tests_success := l_tests_success + 1;
111    END IF;
112    l_run_id := '010';
113    SELECT usim_universe_status INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
114    IF l_sql_number_result != usim_static.usim_multiverse_status_inactive
115    THEN
116      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default usim_universe_status[' || l_sql_number_result || '] NOT usim_static.usim_multiverse_status_inactive[' || usim_static.usim_multiverse_status_inactive || '].';
117      usim_test.log_error(l_test_id, l_fail_message);
118      l_tests_failed := l_tests_failed + 1;
119    ELSE
120      l_tests_success := l_tests_success + 1;
121    END IF;
122    l_test_section := 'Second universe available defaults by using 0';
123    l_run_id := '011';
124    l_usim_id_mlv := usim_mlv.insert_universe(0, 0, 0, 0, 1, NULL);
125    SELECT usim_energy_start_value INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
126    IF l_sql_number_result != 1
127    THEN
128      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default usim_energy_start_value NOT 1.';
129      usim_test.log_error(l_test_id, l_fail_message);
130      l_tests_failed := l_tests_failed + 1;
131    ELSE
132      l_tests_success := l_tests_success + 1;
133    END IF;
134    l_run_id := '012';
135    SELECT usim_planck_time_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
136    IF l_sql_number_result != 1
137    THEN
138      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default usim_planck_time_unit NOT 1.';
139      usim_test.log_error(l_test_id, l_fail_message);
140      l_tests_failed := l_tests_failed + 1;
141    ELSE
142      l_tests_success := l_tests_success + 1;
143    END IF;
144    l_run_id := '013';
145    SELECT usim_planck_length_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
146    IF l_sql_number_result != 1
147    THEN
148      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default usim_planck_length_unit NOT 1.';
149      usim_test.log_error(l_test_id, l_fail_message);
150      l_tests_failed := l_tests_failed + 1;
151    ELSE
152      l_tests_success := l_tests_success + 1;
153    END IF;
154    l_run_id := '014';
155    SELECT usim_planck_speed_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
156    IF l_sql_number_result != 1
157    THEN
158      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default p_usim_planck_speed_unit NOT 1.';
159      usim_test.log_error(l_test_id, l_fail_message);
160      l_tests_failed := l_tests_failed + 1;
161    ELSE
162      l_tests_success := l_tests_success + 1;
163    END IF;
164    l_run_id := '015';
165    SELECT usim_planck_stable INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
166    IF l_sql_number_result != 1
167    THEN
168      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default usim_planck_stable NOT 1.';
169      usim_test.log_error(l_test_id, l_fail_message);
170      l_tests_failed := l_tests_failed + 1;
171    ELSE
172      l_tests_success := l_tests_success + 1;
173    END IF;
174    l_run_id := '016';
175    SELECT usim_ultimate_border INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
176    IF l_sql_number_result != 1
177    THEN
178      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default usim_ultimate_border NOT 1.';
179      usim_test.log_error(l_test_id, l_fail_message);
180      l_tests_failed := l_tests_failed + 1;
181    ELSE
182      l_tests_success := l_tests_success + 1;
183    END IF;
184    l_run_id := '017';
185    SELECT usim_is_base_universe INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
186    IF l_sql_number_result != 0
187    THEN
188      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': second insert usim_is_base_universe NOT 0.';
189      usim_test.log_error(l_test_id, l_fail_message);
190      l_tests_failed := l_tests_failed + 1;
191    ELSE
192      l_tests_success := l_tests_success + 1;
193    END IF;
194    l_run_id := '018';
195    SELECT usim_universe_status INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
196    IF l_sql_number_result != usim_static.usim_multiverse_status_inactive
197    THEN
198      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': default usim_universe_status[' || l_sql_number_result || '] NOT usim_static.usim_multiverse_status_inactive[' || usim_static.usim_multiverse_status_inactive || '].';
199      usim_test.log_error(l_test_id, l_fail_message);
200      l_tests_failed := l_tests_failed + 1;
201    ELSE
202      l_tests_success := l_tests_success + 1;
203    END IF;
204    l_test_section := 'Universe exists and p_do_commit';
205    l_run_id := '019';
206    IF usim_mlv.has_data(l_usim_id_mlv) != 1
207    THEN
208      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_mlv.universe_exists[' || l_usim_id_mlv || '] NOT 1.';
209      usim_test.log_error(l_test_id, l_fail_message);
210      l_tests_failed := l_tests_failed + 1;
211    ELSE
212      l_tests_success := l_tests_success + 1;
213    END IF;
214    l_run_id := '020';
215    l_usim_id_mlv := usim_mlv.insert_universe(0, 0, 0, 0, 1, NULL, FALSE);
216    IF usim_mlv.has_data(l_usim_id_mlv) != 1
217    THEN
218      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_mlv.universe_exists[' || l_usim_id_mlv || '] NOT 1.';
219      usim_test.log_error(l_test_id, l_fail_message);
220      l_tests_failed := l_tests_failed + 1;
221    ELSE
222      l_tests_success := l_tests_success + 1;
223    END IF;
224    l_run_id := '021';
225    ROLLBACK;
226    IF usim_mlv.has_data(l_usim_id_mlv) != 0
227    THEN
228      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_mlv.universe_exists[' || l_usim_id_mlv || '] NOT 0.';
229      usim_test.log_error(l_test_id, l_fail_message);
230      l_tests_failed := l_tests_failed + 1;
231    ELSE
232      l_tests_success := l_tests_success + 1;
233    END IF;
234    l_test_section := 'Third universe available by using negative values';
235    l_run_id := '022';
236    l_usim_id_mlv := usim_mlv.insert_universe(-1, -1, -1, -1, -1, 0);
237    SELECT usim_energy_start_value INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
238    IF l_sql_number_result != 1
239    THEN
240      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': insert usim_energy_start_value NOT 1.';
241      usim_test.log_error(l_test_id, l_fail_message);
242      l_tests_failed := l_tests_failed + 1;
243    ELSE
244      l_tests_success := l_tests_success + 1;
245    END IF;
246    l_run_id := '023';
247    SELECT usim_planck_time_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
248    IF l_sql_number_result != 1
249    THEN
250      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': insert usim_planck_time_unit NOT 1.';
251      usim_test.log_error(l_test_id, l_fail_message);
252      l_tests_failed := l_tests_failed + 1;
253    ELSE
254      l_tests_success := l_tests_success + 1;
255    END IF;
256    l_run_id := '024';
257    SELECT usim_planck_length_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
258    IF l_sql_number_result != 1
259    THEN
260      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': insert usim_planck_length_unit NOT 1.';
261      usim_test.log_error(l_test_id, l_fail_message);
262      l_tests_failed := l_tests_failed + 1;
263    ELSE
264      l_tests_success := l_tests_success + 1;
265    END IF;
266    l_run_id := '025';
267    SELECT usim_planck_speed_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
268    IF l_sql_number_result != 1
269    THEN
270      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': insert usim_planck_speed_unit NOT 1.';
271      usim_test.log_error(l_test_id, l_fail_message);
272      l_tests_failed := l_tests_failed + 1;
273    ELSE
274      l_tests_success := l_tests_success + 1;
275    END IF;
276    l_run_id := '026';
277    SELECT usim_planck_stable INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
278    IF l_sql_number_result != 1
279    THEN
280      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': insert usim_planck_stable NOT 1.';
281      usim_test.log_error(l_test_id, l_fail_message);
282      l_tests_failed := l_tests_failed + 1;
283    ELSE
284      l_tests_success := l_tests_success + 1;
285    END IF;
286    l_run_id := '027';
287    SELECT usim_ultimate_border INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
288    IF l_sql_number_result != 0
289    THEN
290      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': insert usim_ultimate_border NOT 0.';
291      usim_test.log_error(l_test_id, l_fail_message);
292      l_tests_failed := l_tests_failed + 1;
293    ELSE
294      l_tests_success := l_tests_success + 1;
295    END IF;
296
297    l_test_section := 'Fourth universe available by using not default values';
298    l_run_id := '028';
299    l_usim_id_mlv := usim_mlv.insert_universe(100, 2, 3, 4, 1, 1);
300    SELECT usim_energy_start_value INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
301    IF l_sql_number_result != 100
302    THEN
303      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': insert usim_energy_start_value NOT 100.';
304      usim_test.log_error(l_test_id, l_fail_message);
305      l_tests_failed := l_tests_failed + 1;
306    ELSE
307      l_tests_success := l_tests_success + 1;
308    END IF;
309    l_run_id := '029';
310    SELECT usim_planck_time_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
311    IF l_sql_number_result != 2
312    THEN
313      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': insert usim_planck_time_unit NOT 2.';
314      usim_test.log_error(l_test_id, l_fail_message);
315      l_tests_failed := l_tests_failed + 1;
316    ELSE
317      l_tests_success := l_tests_success + 1;
318    END IF;
319    l_run_id := '030';
320    SELECT usim_planck_length_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
321    IF l_sql_number_result != 3
322    THEN
323      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': insert usim_planck_length_unit NOT 3.';
324      usim_test.log_error(l_test_id, l_fail_message);
325      l_tests_failed := l_tests_failed + 1;
326    ELSE
327      l_tests_success := l_tests_success + 1;
328    END IF;
329    l_run_id := '031';
330    SELECT usim_planck_speed_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
331    IF l_sql_number_result != 4
332    THEN
333      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': insert usim_planck_speed_unit NOT 4.';
334      usim_test.log_error(l_test_id, l_fail_message);
335      l_tests_failed := l_tests_failed + 1;
336    ELSE
337      l_tests_success := l_tests_success + 1;
338    END IF;
339
340    l_test_section := 'Fifth universe check state';
341    l_run_id := '032';
342    l_usim_id_mlv := usim_mlv.insert_universe;
343    l_sql_number_result := usim_mlv.update_state(l_usim_id_mlv, usim_static.usim_multiverse_status_active);
344    SELECT usim_universe_status INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
345    IF l_sql_number_result != usim_static.usim_multiverse_status_active
346    THEN
347      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_universe_status [' || l_sql_number_result || '] after update NOT active [' || usim_static.usim_multiverse_status_active || '].';
348      usim_test.log_error(l_test_id, l_fail_message);
349      l_tests_failed := l_tests_failed + 1;
350    ELSE
351      l_tests_success := l_tests_success + 1;
352    END IF;
353    l_run_id := '033';
354    l_sql_number_result := usim_mlv.update_state(l_usim_id_mlv, usim_static.usim_multiverse_status_dead);
355    SELECT usim_universe_status INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
356    IF l_sql_number_result != usim_static.usim_multiverse_status_dead
357    THEN
358      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_universe_status [' || l_sql_number_result || '] after update NULL NOT dead [' || usim_static.usim_multiverse_status_dead || '].';
359      usim_test.log_error(l_test_id, l_fail_message);
360      l_tests_failed := l_tests_failed + 1;
361    ELSE
362      l_tests_success := l_tests_success + 1;
363    END IF;
364    l_run_id := '034';
365    l_sql_number_result := usim_mlv.update_state(l_usim_id_mlv, usim_static.usim_multiverse_status_crashed);
366    SELECT usim_universe_status INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
367    IF l_sql_number_result != usim_static.usim_multiverse_status_crashed
368    THEN
369      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_universe_status [' || l_sql_number_result || '] after update only positive energy NOT crashed [' || usim_static.usim_multiverse_status_crashed || '].';
370      usim_test.log_error(l_test_id, l_fail_message);
371      l_tests_failed := l_tests_failed + 1;
372    ELSE
373      l_tests_success := l_tests_success + 1;
374    END IF;
375
376    l_test_section := 'Planck units update and planck stable 1';
377    l_run_id := '035';
378    l_usim_id_mlv := usim_mlv.insert_universe(p_usim_planck_stable => 1);
379    SELECT usim_mlv.get_planck_stable(l_usim_id_mlv) INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
380    IF l_sql_number_result != 1
381    THEN
382      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_planck_stable [' || l_sql_number_result || '] NOT 1.';
383      usim_test.log_error(l_test_id, l_fail_message);
384      l_tests_failed := l_tests_failed + 1;
385    ELSE
386      l_tests_success := l_tests_success + 1;
387    END IF;
388    l_run_id := '036';
389    SELECT usim_mlv.get_planck_stable('NO_VALID_ID') INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
390    IF l_sql_number_result != -1
391    THEN
392      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_planck_stable with invalid id [' || l_sql_number_result || '] NOT -1.';
393      usim_test.log_error(l_test_id, l_fail_message);
394      l_tests_failed := l_tests_failed + 1;
395    ELSE
396      l_tests_success := l_tests_success + 1;
397    END IF;
398    l_run_id := '037';
399    l_sql_number_result := usim_mlv.update_planck_unit_time_speed(l_usim_id_mlv, 1, 1);
400    IF l_sql_number_result != 0
401    THEN
402      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update [' || l_sql_number_result || '] of planck units with planck stable 1 should not work.';
403      usim_test.log_error(l_test_id, l_fail_message);
404      l_tests_failed := l_tests_failed + 1;
405    ELSE
406      l_tests_success := l_tests_success + 1;
407    END IF;
408    l_run_id := '038';
409    l_sql_number_result := usim_mlv.update_planck_unit_time_length(l_usim_id_mlv, 1, 1);
410    IF l_sql_number_result != 0
411    THEN
412      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update [' || l_sql_number_result || '] of planck units with planck stable 1 should not work.';
413      usim_test.log_error(l_test_id, l_fail_message);
414      l_tests_failed := l_tests_failed + 1;
415    ELSE
416      l_tests_success := l_tests_success + 1;
417    END IF;
418    l_run_id := '039';
419    l_sql_number_result := usim_mlv.update_planck_unit_speed_length(l_usim_id_mlv, 1, 1);
420    IF l_sql_number_result != 0
421    THEN
422      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update [' || l_sql_number_result || '] of planck units with planck stable 1 should not work.';
423      usim_test.log_error(l_test_id, l_fail_message);
424      l_tests_failed := l_tests_failed + 1;
425    ELSE
426      l_tests_success := l_tests_success + 1;
427    END IF;
428
429    l_test_section := 'Planck units update and planck stable 0';
430    l_run_id := '040';
431    l_usim_id_mlv := usim_mlv.insert_universe(p_usim_planck_stable => 0);
432    SELECT usim_mlv.get_planck_stable(l_usim_id_mlv) INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
433    IF l_sql_number_result != 0
434    THEN
435      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_planck_stable [' || l_sql_number_result || '] NOT 0.';
436      usim_test.log_error(l_test_id, l_fail_message);
437      l_tests_failed := l_tests_failed + 1;
438    ELSE
439      l_tests_success := l_tests_success + 1;
440    END IF;
441    l_run_id := '041';
442    l_sql_number_result := usim_mlv.update_planck_unit_time_speed(l_usim_id_mlv, 2, 2);
443    IF l_sql_number_result != 1
444    THEN
445      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update [' || l_sql_number_result || '] of planck units with planck stable 0 should work.';
446      usim_test.log_error(l_test_id, l_fail_message);
447      l_tests_failed := l_tests_failed + 1;
448    ELSE
449      l_tests_success := l_tests_success + 1;
450    END IF;
451    l_run_id := '042';
452    SELECT usim_planck_time_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
453    IF l_sql_number_result != 2
454    THEN
455      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update usim_planck_time_unit [' || l_sql_number_result || '] NOT 2.';
456      usim_test.log_error(l_test_id, l_fail_message);
457      l_tests_failed := l_tests_failed + 1;
458    ELSE
459      l_tests_success := l_tests_success + 1;
460    END IF;
461    l_run_id := '043';
462    SELECT usim_planck_speed_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
463    IF l_sql_number_result != 2
464    THEN
465      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update usim_planck_speed_unit [' || l_sql_number_result || '] NOT 2.';
466      usim_test.log_error(l_test_id, l_fail_message);
467      l_tests_failed := l_tests_failed + 1;
468    ELSE
469      l_tests_success := l_tests_success + 1;
470    END IF;
471    l_run_id := '044';
472    SELECT usim_planck_length_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
473    IF l_sql_number_result != 4
474    THEN
475      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update usim_planck_length_unit [' || l_sql_number_result || '] NOT 2.';
476      usim_test.log_error(l_test_id, l_fail_message);
477      l_tests_failed := l_tests_failed + 1;
478    ELSE
479      l_tests_success := l_tests_success + 1;
480    END IF;
481    l_run_id := '045';
482    l_sql_number_result := usim_mlv.update_planck_unit_time_length(l_usim_id_mlv, 3, 9);
483    SELECT usim_planck_time_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
484    IF l_sql_number_result != 3
485    THEN
486      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update usim_planck_time_unit [' || l_sql_number_result || '] NOT 3.';
487      usim_test.log_error(l_test_id, l_fail_message);
488      l_tests_failed := l_tests_failed + 1;
489    ELSE
490      l_tests_success := l_tests_success + 1;
491    END IF;
492    l_run_id := '046';
493    SELECT usim_planck_length_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
494    IF l_sql_number_result != 9
495    THEN
496      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update usim_planck_length_unit [' || l_sql_number_result || '] NOT 9.';
497      usim_test.log_error(l_test_id, l_fail_message);
498      l_tests_failed := l_tests_failed + 1;
499    ELSE
500      l_tests_success := l_tests_success + 1;
501    END IF;
502    l_run_id := '047';
503    SELECT usim_planck_speed_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
504    IF l_sql_number_result != 3
505    THEN
506      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update usim_planck_speed_unit [' || l_sql_number_result || '] NOT 3.';
507      usim_test.log_error(l_test_id, l_fail_message);
508      l_tests_failed := l_tests_failed + 1;
509    ELSE
510      l_tests_success := l_tests_success + 1;
511    END IF;
512    l_run_id := '048';
513    l_sql_number_result := usim_mlv.update_planck_unit_speed_length(l_usim_id_mlv, 2, 4);
514    SELECT usim_planck_speed_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
515    IF l_sql_number_result != 2
516    THEN
517      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update usim_planck_speed_unit [' || l_sql_number_result || '] NOT 2.';
518      usim_test.log_error(l_test_id, l_fail_message);
519      l_tests_failed := l_tests_failed + 1;
520    ELSE
521      l_tests_success := l_tests_success + 1;
522    END IF;
523    l_run_id := '049';
524    SELECT usim_planck_length_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
525    IF l_sql_number_result != 4
526    THEN
527      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update usim_planck_length_unit [' || l_sql_number_result || '] NOT 4.';
528      usim_test.log_error(l_test_id, l_fail_message);
529      l_tests_failed := l_tests_failed + 1;
530    ELSE
531      l_tests_success := l_tests_success + 1;
532    END IF;
533    l_run_id := '050';
534    SELECT usim_planck_time_unit INTO l_sql_number_result FROM usim_multiverse WHERE usim_id_mlv = l_usim_id_mlv;
535    IF l_sql_number_result != 2
536    THEN
537      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': update usim_planck_time_unit [' || l_sql_number_result || '] NOT 2.';
538      usim_test.log_error(l_test_id, l_fail_message);
539      l_tests_failed := l_tests_failed + 1;
540    ELSE
541      l_tests_success := l_tests_success + 1;
542    END IF;
543
544    l_test_section := 'Check base universe';
545    l_run_id := '051';
546    DELETE usim_multiverse;
547    COMMIT;
548    IF usim_mlv.is_base('NOT EXISTS') IS NOT NULL
549    THEN
550      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': is_base for empty table should be NULL.';
551      usim_test.log_error(l_test_id, l_fail_message);
552      l_tests_failed := l_tests_failed + 1;
553    ELSE
554      l_tests_success := l_tests_success + 1;
555    END IF;
556    l_run_id := '052';
557    l_usim_id_mlv := usim_mlv.insert_universe;
558    IF usim_mlv.is_base(l_usim_id_mlv) != 1
559    THEN
560      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': is_base for first universe should be 1.';
561      usim_test.log_error(l_test_id, l_fail_message);
562      l_tests_failed := l_tests_failed + 1;
563    ELSE
564      l_tests_success := l_tests_success + 1;
565    END IF;
566    l_run_id := '053';
567    l_usim_id_mlv := usim_mlv.insert_universe;
568    IF usim_mlv.is_base(l_usim_id_mlv) != 0
569    THEN
570      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': is_base for second universe should be 0.';
571      usim_test.log_error(l_test_id, l_fail_message);
572      l_tests_failed := l_tests_failed + 1;
573    ELSE
574      l_tests_success := l_tests_success + 1;
575    END IF;
576
577    -- cleanup
578    DELETE usim_basedata;
579    DELETE usim_multiverse;
580    COMMIT;
581    -- write test results
582    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
583  EXCEPTION
584    WHEN OTHERS THEN
585      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
586      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
587  END;
588  /
SQL> @@TEST_USIM_DIMENSION.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(4000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_DIMENSION table';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12    l_usim_id_dim       usim_dimension.usim_id_dim%TYPE;
 13  BEGIN
 14    l_test_id := usim_test.init_test(l_test_object);
 15    l_test_section := 'Table constraints';
 16    l_run_id := '001';
 17    -- setup
 18    DELETE usim_basedata;
 19    DELETE usim_dimension;
 20    COMMIT;
 21    usim_base.init_basedata;
 22    BEGIN
 23      INSERT INTO usim_dimension (usim_n_dimension) VALUES (-1) RETURNING usim_id_dim INTO l_usim_id_dim;
 24      -- input should be prevented by constraint
 25      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_usim_id_dim || '] negative dimension insert should not be possible.';
 26      usim_test.log_error(l_test_id, l_fail_message);
 27      l_tests_failed := l_tests_failed + 1;
 28    EXCEPTION
 29      WHEN OTHERS THEN
 30        IF INSTR(SQLERRM, 'USIM_DIM_DIMENSION_CHK') > 0
 31        THEN
 32          l_tests_success := l_tests_success + 1;
 33        ELSE
 34          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 35          usim_test.log_error(l_test_id, l_fail_message);
 36          l_tests_failed := l_tests_failed + 1;
 37        END IF;
 38    END;
 39    ROLLBACK;
 40    l_run_id := '002';
 41    BEGIN
 42      INSERT INTO usim_dimension (usim_n_dimension) VALUES (0) RETURNING usim_id_dim INTO l_usim_id_dim;
 43      INSERT INTO usim_dimension (usim_n_dimension) VALUES (0) RETURNING usim_id_dim INTO l_usim_id_dim;
 44      -- input should be prevented by constraint
 45      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] duplicate dimension insert should not be possible.';
 46      usim_test.log_error(l_test_id, l_fail_message);
 47      l_tests_failed := l_tests_failed + 1;
 48    EXCEPTION
 49      WHEN OTHERS THEN
 50        IF INSTR(SQLERRM, 'USIM_DIM_UK') > 0
 51        THEN
 52          l_tests_success := l_tests_success + 1;
 53        ELSE
 54          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 55          usim_test.log_error(l_test_id, l_fail_message);
 56          l_tests_failed := l_tests_failed + 1;
 57        END IF;
 58    END;
 59    ROLLBACK;
 60
 61    l_test_section := 'Table insert trigger';
 62    l_run_id := '003';
 63    BEGIN
 64      INSERT INTO usim_dimension (usim_n_dimension) VALUES (99) RETURNING usim_id_dim INTO l_usim_id_dim;
 65      -- input should be prevented by trigger
 66      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': dimension over max insert should not be possible.';
 67      usim_test.log_error(l_test_id, l_fail_message);
 68      l_tests_failed := l_tests_failed + 1;
 69    EXCEPTION
 70      WHEN OTHERS THEN
 71        IF SQLCODE = -20000
 72        THEN
 73          l_tests_success := l_tests_success + 1;
 74        ELSE
 75          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 76          usim_test.log_error(l_test_id, l_fail_message);
 77          l_tests_failed := l_tests_failed + 1;
 78        END IF;
 79    END;
 80    ROLLBACK;
 81    l_test_section := 'Table update trigger';
 82    l_run_id := '004';
 83    BEGIN
 84      INSERT INTO usim_dimension (usim_n_dimension) VALUES (0) RETURNING usim_id_dim INTO l_usim_id_dim;
 85      UPDATE usim_dimension SET usim_n_dimension = 1 WHERE usim_id_dim = l_usim_id_dim;
 86      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_usim_id_dim || '] should not be updateable.';
 87      usim_test.log_error(l_test_id, l_fail_message);
 88      l_tests_failed := l_tests_failed + 1;
 89    EXCEPTION
 90      WHEN OTHERS THEN
 91        IF SQLCODE = -20001
 92        THEN
 93          l_tests_success := l_tests_success + 1;
 94        ELSE
 95          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 96          usim_test.log_error(l_test_id, l_fail_message);
 97          l_tests_failed := l_tests_failed + 1;
 98        END IF;
 99    END;
100    ROLLBACK;
101    l_run_id := '005';
102    BEGIN
103      INSERT INTO usim_dimension (usim_id_dim, usim_n_dimension) VALUES ('BLA', 0) RETURNING usim_id_dim INTO l_usim_id_dim;
104      IF l_usim_id_dim != 'BLA'
105      THEN
106        l_tests_success := l_tests_success + 1;
107      ELSE
108        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] insert usim_id_dim BLA should not be possible.';
109        usim_test.log_error(l_test_id, l_fail_message);
110        l_tests_failed := l_tests_failed + 1;
111      END IF;
112    EXCEPTION
113      WHEN OTHERS THEN
114        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
115        usim_test.log_error(l_test_id, l_fail_message);
116        l_tests_failed := l_tests_failed + 1;
117    END;
118    ROLLBACK;
119
120    -- cleanup
121    DELETE usim_basedata;
122    DELETE usim_multiverse;
123    DELETE usim_dimension;
124    COMMIT;
125    -- write test results
126    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
127  EXCEPTION
128    WHEN OTHERS THEN
129      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
130      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
131  END;
132  /
SQL> @@TEST_USIM_DIM.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(4000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_DIM';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12    l_usim_id_dim       usim_dimension.usim_id_dim%TYPE;
 13  BEGIN
 14    l_test_id := usim_test.init_test(l_test_object);
 15    l_test_section := 'Check functions no data';
 16    l_run_id := '001';
 17    -- setup
 18    DELETE usim_basedata;
 19    DELETE usim_dimension;
 20    COMMIT;
 21    usim_base.init_basedata(2); -- limit to 2 dimensions for tests
 22    IF usim_dim.has_data != 0
 23    THEN
 24      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_dim.has_data should not have any data.';
 25      usim_test.log_error(l_test_id, l_fail_message);
 26      l_tests_failed := l_tests_failed + 1;
 27    ELSE
 28      l_tests_success := l_tests_success + 1;
 29    END IF;
 30    l_run_id := '002';
 31    IF usim_dim.has_data('NO_VALID_ID') != 0
 32    THEN
 33      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_dim.has_data(NO_VALID_ID) should not have any data for the given id.';
 34      usim_test.log_error(l_test_id, l_fail_message);
 35      l_tests_failed := l_tests_failed + 1;
 36    ELSE
 37      l_tests_success := l_tests_success + 1;
 38    END IF;
 39    l_run_id := '003';
 40    IF usim_dim.get_max_dimension != -1
 41    THEN
 42      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_dim.get_max_dimension should not have any max data.';
 43      usim_test.log_error(l_test_id, l_fail_message);
 44      l_tests_failed := l_tests_failed + 1;
 45    ELSE
 46      l_tests_success := l_tests_success + 1;
 47    END IF;
 48    l_run_id := '004';
 49    IF usim_dim.get_dimension('NO_VALID_ID') != -1
 50    THEN
 51      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_dim.get_dimension should not have any data for the given id.';
 52      usim_test.log_error(l_test_id, l_fail_message);
 53      l_tests_failed := l_tests_failed + 1;
 54    ELSE
 55      l_tests_success := l_tests_success + 1;
 56    END IF;
 57
 58    l_test_section := 'Insert first dimension and checks';
 59    l_run_id := '005';
 60    l_usim_id_dim := usim_dim.insert_dimension(0);
 61    l_sql_number_result := usim_dim.get_dimension(l_usim_id_dim);
 62    IF l_sql_number_result != 0
 63    THEN
 64      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': first dimension [' || l_sql_number_result || '] should be 0.';
 65      usim_test.log_error(l_test_id, l_fail_message);
 66      l_tests_failed := l_tests_failed + 1;
 67    ELSE
 68      l_tests_success := l_tests_success + 1;
 69    END IF;
 70    l_run_id := '006';
 71    IF usim_dim.has_data(l_usim_id_dim) != 1
 72    THEN
 73      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': dimension id [' || l_usim_id_dim || '] should exist.';
 74      usim_test.log_error(l_test_id, l_fail_message);
 75      l_tests_failed := l_tests_failed + 1;
 76    ELSE
 77      l_tests_success := l_tests_success + 1;
 78    END IF;
 79    l_run_id := '007';
 80    l_sql_number_result := usim_dim.get_max_dimension;
 81    IF l_sql_number_result != 0
 82    THEN
 83      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': first max dimension [' || l_sql_number_result || '] should be 0.';
 84      usim_test.log_error(l_test_id, l_fail_message);
 85      l_tests_failed := l_tests_failed + 1;
 86    ELSE
 87      l_tests_success := l_tests_success + 1;
 88    END IF;
 89    l_run_id := '008';
 90    IF usim_dim.has_data != 1
 91    THEN
 92      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_dim.has_data should have data.';
 93      usim_test.log_error(l_test_id, l_fail_message);
 94      l_tests_failed := l_tests_failed + 1;
 95    ELSE
 96      l_tests_success := l_tests_success + 1;
 97    END IF;
 98
 99    l_test_section := 'Insert second dimension and checks';
100    l_run_id := '009';
101    l_usim_id_dim := usim_dim.insert_dimension(1);
102    l_sql_number_result := usim_dim.get_dimension(l_usim_id_dim);
103    IF l_sql_number_result != 1
104    THEN
105      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': second dimension [' || l_sql_number_result || '] should be 1.';
106      usim_test.log_error(l_test_id, l_fail_message);
107      l_tests_failed := l_tests_failed + 1;
108    ELSE
109      l_tests_success := l_tests_success + 1;
110    END IF;
111
112    l_test_section := 'Insert third dimension and checks';
113    l_run_id := '010';
114    l_usim_id_dim := usim_dim.insert_dimension(2);
115    l_sql_number_result := usim_dim.get_dimension(l_usim_id_dim);
116    IF l_sql_number_result != 2
117    THEN
118      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': third dimension [' || l_sql_number_result || '] should be 2.';
119      usim_test.log_error(l_test_id, l_fail_message);
120      l_tests_failed := l_tests_failed + 1;
121    ELSE
122      l_tests_success := l_tests_success + 1;
123    END IF;
124
125    l_test_section := 'Insert dimension checks';
126    l_run_id := '011';
127    l_sql_number_result := usim_dim.has_data(usim_base.get_max_dimension);
128    IF l_sql_number_result != 1
129    THEN
130      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': dimension_exists [' || l_sql_number_result || '] wrong for max dimension.';
131      usim_test.log_error(l_test_id, l_fail_message);
132      l_tests_failed := l_tests_failed + 1;
133    ELSE
134      l_tests_success := l_tests_success + 1;
135    END IF;
136    l_run_id := '012';
137    l_usim_id_dim := usim_dim.get_id_dim(usim_base.get_max_dimension);
138    IF l_usim_id_dim IS NULL
139    THEN
140      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_id_dim wrong for max dimension[' || l_usim_id_dim || '].';
141      usim_test.log_error(l_test_id, l_fail_message);
142      l_tests_failed := l_tests_failed + 1;
143    ELSE
144      l_tests_success := l_tests_success + 1;
145    END IF;
146
147    l_test_section := 'Insert dimension do commit check';
148    l_run_id := '013';
149    DELETE usim_dimension;
150    COMMIT;
151    l_usim_id_dim := usim_dim.insert_dimension(0, FALSE);
152    l_sql_number_result := usim_dim.get_dimension(l_usim_id_dim);
153    IF l_sql_number_result != 0
154    THEN
155      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': first dimension [' || l_sql_number_result || '] should be 0.';
156      usim_test.log_error(l_test_id, l_fail_message);
157      l_tests_failed := l_tests_failed + 1;
158    ELSE
159      l_tests_success := l_tests_success + 1;
160    END IF;
161    l_run_id := '014';
162    ROLLBACK;
163    l_sql_number_result := usim_dim.get_dimension(l_usim_id_dim);
164    IF l_sql_number_result != -1
165    THEN
166      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': dimension [' || l_sql_number_result || '] should not exist after rollback.';
167      usim_test.log_error(l_test_id, l_fail_message);
168      l_tests_failed := l_tests_failed + 1;
169    ELSE
170      l_tests_success := l_tests_success + 1;
171    END IF;
172
173    l_test_section := 'Get ID';
174    l_run_id := '015';
175    DELETE usim_dimension;
176    COMMIT;
177    l_usim_id_dim := usim_dim.insert_dimension(0);
178    l_sql_number_result := usim_dim.get_dimension(l_usim_id_dim);
179    IF l_sql_number_result != 0
180    THEN
181      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': first dimension [' || l_sql_number_result || '] should be 0.';
182      usim_test.log_error(l_test_id, l_fail_message);
183      l_tests_failed := l_tests_failed + 1;
184    ELSE
185      l_tests_success := l_tests_success + 1;
186    END IF;
187    l_run_id := '016';
188    l_sql_char_result := usim_dim.get_id_dim(0);
189    IF TRIM(l_sql_char_result) != l_usim_id_dim
190    THEN
191      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_id_dim(0) [' || l_sql_char_result || '] should return [' || l_usim_id_dim || '].';
192      usim_test.log_error(l_test_id, l_fail_message);
193      l_tests_failed := l_tests_failed + 1;
194    ELSE
195      l_tests_success := l_tests_success + 1;
196    END IF;
197    l_run_id := '017';
198    l_usim_id_dim := usim_dim.insert_dimension(1);
199    l_sql_number_result := usim_dim.get_dimension(l_usim_id_dim);
200    IF l_sql_number_result != 1
201    THEN
202      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': second dimension [' || l_sql_number_result || '] should be 1.';
203      usim_test.log_error(l_test_id, l_fail_message);
204      l_tests_failed := l_tests_failed + 1;
205    ELSE
206      l_tests_success := l_tests_success + 1;
207    END IF;
208    l_run_id := '018';
209    l_sql_char_result := usim_dim.get_id_dim(1);
210    IF TRIM(l_sql_char_result) != l_usim_id_dim
211    THEN
212      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_id_dim(1) [' || l_sql_char_result || '] should return [' || l_usim_id_dim || '].';
213      usim_test.log_error(l_test_id, l_fail_message);
214      l_tests_failed := l_tests_failed + 1;
215    ELSE
216      l_tests_success := l_tests_success + 1;
217    END IF;
218
219    -- cleanup
220    DELETE usim_basedata;
221    DELETE usim_dimension;
222    COMMIT;
223    -- write test results
224    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
225  EXCEPTION
226    WHEN OTHERS THEN
227      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
228      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
229  END;
230  /
SQL> @@TEST_USIM_POSITION.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(4000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_POSITION table';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12    l_usim_id_pos       usim_position.usim_id_pos%TYPE;
 13  BEGIN
 14    l_test_id := usim_test.init_test(l_test_object);
 15    l_test_section := 'Table constraints';
 16    l_run_id := '001';
 17    -- setup
 18    DELETE usim_basedata;
 19    DELETE usim_position;
 20    COMMIT;
 21    usim_base.init_basedata(p_usim_abs_max_number => 2);
 22    BEGIN
 23      -- same value twice
 24      INSERT INTO usim_position (usim_coordinate) VALUES (0);
 25      INSERT INTO usim_position (usim_coordinate) VALUES (0);
 26      -- input should be prevented by constraint
 27      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] inserting same position 0 twice should not be possible.';
 28      usim_test.log_error(l_test_id, l_fail_message);
 29      l_tests_failed := l_tests_failed + 1;
 30    EXCEPTION
 31      WHEN OTHERS THEN
 32        IF INSTR(SQLERRM, 'USIM_POS_UK') > 0
 33        THEN
 34          l_tests_success := l_tests_success + 1;
 35        ELSE
 36          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 37          usim_test.log_error(l_test_id, l_fail_message);
 38          l_tests_failed := l_tests_failed + 1;
 39        END IF;
 40    END;
 41    ROLLBACK;
 42
 43    l_test_section := 'Table insert trigger';
 44    l_run_id := '002';
 45    BEGIN
 46      INSERT INTO usim_position (usim_id_pos, usim_coordinate) VALUES ('BLA', 0) RETURNING usim_id_pos INTO l_usim_id_pos;
 47      -- check input value
 48      IF TRIM(l_usim_id_pos) != 'BLA'
 49      THEN
 50        l_tests_success := l_tests_success + 1;
 51      ELSE
 52        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_usim_id_pos || '] id should not be definable on insert.';
 53        usim_test.log_error(l_test_id, l_fail_message);
 54        l_tests_failed := l_tests_failed + 1;
 55      END IF;
 56    EXCEPTION
 57      WHEN OTHERS THEN
 58        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 59        usim_test.log_error(l_test_id, l_fail_message);
 60        l_tests_failed := l_tests_failed + 1;
 61    END;
 62    ROLLBACK;
 63    l_test_section := 'Table update trigger';
 64    l_run_id := '003';
 65    BEGIN
 66      INSERT INTO usim_position (usim_coordinate) VALUES (0) RETURNING usim_id_pos INTO l_usim_id_pos;
 67      UPDATE usim_position SET usim_id_pos = 'BLA', usim_coordinate = 1 WHERE usim_id_pos = l_usim_id_pos;
 68      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] update should not be possible.';
 69      usim_test.log_error(l_test_id, l_fail_message);
 70      l_tests_failed := l_tests_failed + 1;
 71    EXCEPTION
 72      WHEN OTHERS THEN
 73        IF SQLCODE = -20001
 74        THEN
 75          l_tests_success := l_tests_success + 1;
 76        ELSE
 77          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 78          usim_test.log_error(l_test_id, l_fail_message);
 79          l_tests_failed := l_tests_failed + 1;
 80        END IF;
 81    END;
 82    ROLLBACK;
 83
 84    -- cleanup
 85    DELETE usim_basedata;
 86    DELETE usim_position;
 87    COMMIT;
 88    -- write test results
 89    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
 90  EXCEPTION
 91    WHEN OTHERS THEN
 92      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
 93      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
 94  END;
 95  /
SQL> @@TEST_USIM_POS.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(4000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_POS';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12    l_usim_id_pos       usim_position.usim_id_pos%TYPE;
 13    l_usim_coordinate   usim_position.usim_coordinate%TYPE;
 14    l_sign              NUMBER;
 15  BEGIN
 16    l_test_id := usim_test.init_test(l_test_object);
 17    l_test_section := 'Check functions no data';
 18    l_run_id := '001';
 19    -- setup
 20    DELETE usim_basedata;
 21    DELETE usim_position;
 22    COMMIT;
 23    usim_base.init_basedata;
 24    IF usim_pos.has_data != 0
 25    THEN
 26      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_pos.has_data should not find data.';
 27      usim_test.log_error(l_test_id, l_fail_message);
 28      l_tests_failed := l_tests_failed + 1;
 29    ELSE
 30      l_tests_success := l_tests_success + 1;
 31    END IF;
 32    l_run_id := '002';
 33    IF usim_pos.has_data(0) != 0
 34    THEN
 35      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_pos.has_data(0, 0) should not find data.';
 36      usim_test.log_error(l_test_id, l_fail_message);
 37      l_tests_failed := l_tests_failed + 1;
 38    ELSE
 39      l_tests_success := l_tests_success + 1;
 40    END IF;
 41    l_run_id := '003';
 42    IF usim_pos.get_max_coordinate(1) IS NOT NULL
 43    THEN
 44      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_pos.get_max_coordinate(1) should not find data.';
 45      usim_test.log_error(l_test_id, l_fail_message);
 46      l_tests_failed := l_tests_failed + 1;
 47    ELSE
 48      l_tests_success := l_tests_success + 1;
 49    END IF;
 50    l_run_id := '004';
 51    IF usim_pos.get_max_coordinate(-1) IS NOT NULL
 52    THEN
 53      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_pos.get_max_coordinate(-1) should not find data.';
 54      usim_test.log_error(l_test_id, l_fail_message);
 55      l_tests_failed := l_tests_failed + 1;
 56    ELSE
 57      l_tests_success := l_tests_success + 1;
 58    END IF;
 59    l_run_id := '005';
 60    IF usim_pos.has_data('NO_VALID_ID') != 0
 61    THEN
 62      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_pos.has_data(NO_VALID_ID) should not find data.';
 63      usim_test.log_error(l_test_id, l_fail_message);
 64      l_tests_failed := l_tests_failed + 1;
 65    ELSE
 66      l_tests_success := l_tests_success + 1;
 67    END IF;
 68    l_run_id := '006';
 69    l_usim_coordinate := usim_pos.get_coordinate('NO_VALID_ID');
 70    IF l_usim_coordinate IS NOT NULL
 71    THEN
 72      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_pos.get_coordinate(NO_VALID_ID) should not find data[' || l_usim_coordinate || '].';
 73      usim_test.log_error(l_test_id, l_fail_message);
 74      l_tests_failed := l_tests_failed + 1;
 75    ELSE
 76      l_tests_success := l_tests_success + 1;
 77    END IF;
 78    l_run_id := '007';
 79    l_usim_id_pos := usim_pos.get_id_pos(0);
 80    IF l_usim_id_pos IS NOT NULL
 81    THEN
 82      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_pos.get_id_pos(0) should not find data[' || l_usim_id_pos || '].';
 83      usim_test.log_error(l_test_id, l_fail_message);
 84      l_tests_failed := l_tests_failed + 1;
 85    ELSE
 86      l_tests_success := l_tests_success + 1;
 87    END IF;
 88
 89    l_test_section := 'Basic inserts and do commit check';
 90    l_run_id := '008';
 91    l_usim_id_pos := usim_pos.insert_position(0, FALSE);
 92    IF usim_pos.has_data != 1
 93    THEN
 94      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_pos.insert_next_position should insert data.';
 95      usim_test.log_error(l_test_id, l_fail_message);
 96      l_tests_failed := l_tests_failed + 1;
 97    ELSE
 98      l_tests_success := l_tests_success + 1;
 99    END IF;
100    l_run_id := '009';
101    l_usim_coordinate := usim_pos.get_coordinate(l_usim_id_pos);
102    IF l_usim_coordinate != 0
103    THEN
104      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': first insert[' || l_usim_coordinate || '] should create coordinate 0.';
105      usim_test.log_error(l_test_id, l_fail_message);
106      l_tests_failed := l_tests_failed + 1;
107    ELSE
108      l_tests_success := l_tests_success + 1;
109    END IF;
110    l_run_id := '010';
111    ROLLBACK;
112    IF usim_pos.has_data != 0
113    THEN
114      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': after rollback of first insert usim_position should not have data.';
115      usim_test.log_error(l_test_id, l_fail_message);
116      l_tests_failed := l_tests_failed + 1;
117    ELSE
118      l_tests_success := l_tests_success + 1;
119    END IF;
120    l_run_id := '011';
121    l_usim_coordinate := usim_pos.get_coordinate(l_usim_id_pos);
122    IF l_usim_coordinate IS NOT NULL
123    THEN
124      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': rollback after first insert[' || l_usim_coordinate || '] should not find coordinate.';
125      usim_test.log_error(l_test_id, l_fail_message);
126      l_tests_failed := l_tests_failed + 1;
127    ELSE
128      l_tests_success := l_tests_success + 1;
129    END IF;
130    l_run_id := '012';
131    l_usim_id_pos     := usim_pos.insert_position(0);
132    l_usim_coordinate := usim_pos.get_coordinate(l_usim_id_pos);
133    l_sign            := usim_pos.get_coord_sign(l_usim_id_pos);
134    IF    l_usim_coordinate != 0
135       OR l_sign            != 0
136    THEN
137      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': first insert[' || l_usim_coordinate || '] should find coordinate 0 with sign 0.';
138      usim_test.log_error(l_test_id, l_fail_message);
139      l_tests_failed := l_tests_failed + 1;
140    ELSE
141      l_tests_success := l_tests_success + 1;
142    END IF;
143
144    l_test_section := 'Check functions with data';
145    l_run_id := '013';
146    DELETE usim_position;
147    COMMIT;
148    l_usim_id_pos     := usim_pos.insert_position(0);
149    l_usim_id_pos     := usim_pos.insert_position(1);
150    l_usim_id_pos     := usim_pos.insert_position(-1);
151    l_usim_coordinate := usim_pos.get_coordinate(l_usim_id_pos);
152    l_sign            := usim_pos.get_coord_sign(l_usim_id_pos);
153    IF    l_usim_coordinate != -1
154    THEN
155      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': first negative coordinate [' || l_usim_coordinate || '] should be -1.';
156      usim_test.log_error(l_test_id, l_fail_message);
157      l_tests_failed := l_tests_failed + 1;
158    ELSE
159      l_tests_success := l_tests_success + 1;
160    END IF;
161    l_run_id := '014';
162    IF usim_pos.has_data(l_usim_id_pos) != 1
163    THEN
164      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': coordinate id [' || l_usim_id_pos || '] should exist.';
165      usim_test.log_error(l_test_id, l_fail_message);
166      l_tests_failed := l_tests_failed + 1;
167    ELSE
168      l_tests_success := l_tests_success + 1;
169    END IF;
170    l_run_id := '015';
171    l_sql_char_result := usim_pos.get_id_pos(-2);
172    IF l_sql_char_result IS NOT NULL
173    THEN
174      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': coordinate -2 should not exist.';
175      usim_test.log_error(l_test_id, l_fail_message);
176      l_tests_failed := l_tests_failed + 1;
177    ELSE
178      l_tests_success := l_tests_success + 1;
179    END IF;
180    l_run_id := '016';
181    l_sql_char_result := usim_pos.get_id_pos(-1);
182    IF l_sql_char_result != l_usim_id_pos
183    THEN
184      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': coordinate -0 [' || l_sql_char_result || '] should have id [' || l_usim_id_pos || '].';
185      usim_test.log_error(l_test_id, l_fail_message);
186      l_tests_failed := l_tests_failed + 1;
187    ELSE
188      l_tests_success := l_tests_success + 1;
189    END IF;
190    l_run_id := '017';
191    IF usim_pos.has_data(0) != 1
192    THEN
193      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': coordinate 0, sign 0, should exist.';
194      usim_test.log_error(l_test_id, l_fail_message);
195      l_tests_failed := l_tests_failed + 1;
196    ELSE
197      l_tests_success := l_tests_success + 1;
198    END IF;
199    l_run_id := '018';
200    IF usim_pos.has_data(1) != 1
201    THEN
202      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': coordinate 0, sign 1, should exist.';
203      usim_test.log_error(l_test_id, l_fail_message);
204      l_tests_failed := l_tests_failed + 1;
205    ELSE
206      l_tests_success := l_tests_success + 1;
207    END IF;
208
209    l_test_section := 'Insert given coordinate';
210    l_run_id := '019';
211    l_usim_coordinate := usim_pos.get_max_coordinate(1) + 1;
212    l_usim_id_pos     := usim_pos.insert_position(l_usim_coordinate);
213    IF l_usim_id_pos IS NULL
214    THEN
215      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': inserting coordinate (max +1) should work.';
216      usim_test.log_error(l_test_id, l_fail_message);
217      l_tests_failed := l_tests_failed + 1;
218    ELSE
219      l_tests_success := l_tests_success + 1;
220    END IF;
221    l_run_id := '020';
222    l_sql_char_result := usim_pos.insert_position(l_usim_coordinate);
223    IF l_usim_id_pos != TRIM(l_sql_char_result)
224    THEN
225      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': inserting existing coordinate should return the correct coodinate.';
226      usim_test.log_error(l_test_id, l_fail_message);
227      l_tests_failed := l_tests_failed + 1;
228    ELSE
229      l_tests_success := l_tests_success + 1;
230    END IF;
231    l_run_id := '021';
232    -- create start situation
233    DELETE usim_position;
234    COMMIT;
235    l_usim_id_pos := usim_pos.insert_position(0);
236    IF l_usim_id_pos IS NULL
237    THEN
238      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': inserting coordinate 0,0 should work.';
239      usim_test.log_error(l_test_id, l_fail_message);
240      l_tests_failed := l_tests_failed + 1;
241    ELSE
242      l_tests_success := l_tests_success + 1;
243    END IF;
244    l_run_id := '022';
245    l_usim_id_pos := usim_pos.insert_position(1);
246    IF l_usim_id_pos IS NULL
247    THEN
248      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': inserting next coordinate 0,1 should work.';
249      usim_test.log_error(l_test_id, l_fail_message);
250      l_tests_failed := l_tests_failed + 1;
251    ELSE
252      l_tests_success := l_tests_success + 1;
253    END IF;
254    l_run_id := '023';
255    l_usim_id_pos := usim_pos.insert_position(-1);
256    IF l_usim_id_pos IS NULL
257    THEN
258      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': inserting next coordinate 0,-1 should work.';
259      usim_test.log_error(l_test_id, l_fail_message);
260      l_tests_failed := l_tests_failed + 1;
261    ELSE
262      l_tests_success := l_tests_success + 1;
263    END IF;
264
265    -- cleanup
266    DELETE usim_basedata;
267    DELETE usim_position;
268    COMMIT;
269    -- write test results
270    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
271  EXCEPTION
272    WHEN OTHERS THEN
273      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
274      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
275  END;
276  /
SQL> @@TEST_USIM_NODE.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(4000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_NODE table';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12    l_usim_id_nod       usim_node.usim_id_nod%TYPE;
 13  BEGIN
 14    l_test_id := usim_test.init_test(l_test_object);
 15    l_test_section := 'Table insert trigger';
 16    l_run_id := '001';
 17    -- setup
 18    DELETE usim_basedata;
 19    DELETE usim_node;
 20    COMMIT;
 21    usim_base.init_basedata;
 22    BEGIN
 23      INSERT INTO usim_node (usim_id_nod, usim_energy) VALUES ('BLA', 1000) RETURNING usim_id_nod INTO l_usim_id_nod;
 24      -- check input value
 25      IF TRIM(l_usim_id_nod) != 'BLA'
 26      THEN
 27        l_tests_success := l_tests_success + 1;
 28      ELSE
 29        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_usim_id_nod || '] setting id on insert should not be possible.';
 30        usim_test.log_error(l_test_id, l_fail_message);
 31        l_tests_failed := l_tests_failed + 1;
 32      END IF;
 33    EXCEPTION
 34      WHEN OTHERS THEN
 35        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 36        usim_test.log_error(l_test_id, l_fail_message);
 37        l_tests_failed := l_tests_failed + 1;
 38    END;
 39    l_run_id := '002';
 40    BEGIN
 41      SELECT usim_energy INTO l_sql_number_result FROM usim_node WHERE usim_id_nod = l_usim_id_nod;
 42      -- check input value
 43      IF l_sql_number_result IS NULL
 44      THEN
 45        l_tests_success := l_tests_success + 1;
 46      ELSE
 47        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] setting energy on insert should not be possible.';
 48        usim_test.log_error(l_test_id, l_fail_message);
 49        l_tests_failed := l_tests_failed + 1;
 50      END IF;
 51    EXCEPTION
 52      WHEN OTHERS THEN
 53        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 54        usim_test.log_error(l_test_id, l_fail_message);
 55        l_tests_failed := l_tests_failed + 1;
 56    END;
 57    ROLLBACK;
 58
 59    l_test_section := 'Table update trigger';
 60    l_run_id := '003';
 61    BEGIN
 62      INSERT INTO usim_node (usim_energy) VALUES (NULL) RETURNING usim_id_nod INTO l_usim_id_nod;
 63      UPDATE usim_node SET usim_id_nod = 'BLA' WHERE usim_id_nod = l_usim_id_nod RETURNING usim_id_nod INTO l_sql_char_result;
 64      -- check input value
 65      IF TRIM(l_sql_char_result) != 'BLA'
 66      THEN
 67        l_tests_success := l_tests_success + 1;
 68      ELSE
 69        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] setting id on update should not be possible.';
 70        usim_test.log_error(l_test_id, l_fail_message);
 71        l_tests_failed := l_tests_failed + 1;
 72      END IF;
 73    EXCEPTION
 74      WHEN OTHERS THEN
 75        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 76        usim_test.log_error(l_test_id, l_fail_message);
 77        l_tests_failed := l_tests_failed + 1;
 78    END;
 79    l_run_id := '004';
 80    BEGIN
 81      UPDATE usim_node SET usim_energy = 1000 WHERE usim_id_nod = l_usim_id_nod RETURNING usim_energy INTO l_sql_number_result;
 82      -- check input value
 83      IF l_sql_number_result = 1000
 84      THEN
 85        l_tests_success := l_tests_success + 1;
 86      ELSE
 87        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_number_result || '] setting energy on update should be possible.';
 88        usim_test.log_error(l_test_id, l_fail_message);
 89        l_tests_failed := l_tests_failed + 1;
 90      END IF;
 91    EXCEPTION
 92      WHEN OTHERS THEN
 93        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 94        usim_test.log_error(l_test_id, l_fail_message);
 95        l_tests_failed := l_tests_failed + 1;
 96    END;
 97
 98    -- cleanup
 99    DELETE usim_basedata;
100    DELETE usim_node;
101    COMMIT;
102    -- write test results
103    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
104  EXCEPTION
105    WHEN OTHERS THEN
106      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
107      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
108  END;
109  /
SQL> @@TEST_USIM_NOD.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(4000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_NOD';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12    l_usim_id_nod       usim_node.usim_id_nod%TYPE;
 13  BEGIN
 14    l_test_id := usim_test.init_test(l_test_object);
 15    l_test_section := 'Functions no data';
 16    l_run_id := '001';
 17    -- setup
 18    DELETE usim_basedata;
 19    DELETE usim_node;
 20    COMMIT;
 21    usim_base.init_basedata;
 22
 23    IF usim_nod.has_data = 1
 24    THEN
 25      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': has_data should not report data on empty table.';
 26      usim_test.log_error(l_test_id, l_fail_message);
 27      l_tests_failed := l_tests_failed + 1;
 28    ELSE
 29      l_tests_success := l_tests_success + 1;
 30    END IF;
 31    l_run_id := '002';
 32    IF usim_nod.has_data('BLA') = 1
 33    THEN
 34      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': has_data should not report data on empty table for not existing id BLA.';
 35      usim_test.log_error(l_test_id, l_fail_message);
 36      l_tests_failed := l_tests_failed + 1;
 37    ELSE
 38      l_tests_success := l_tests_success + 1;
 39    END IF;
 40    l_run_id := '003';
 41    IF usim_nod.get_energy('BLA') IS NOT NULL
 42    THEN
 43      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': get_energy should not report data on empty table for not existing id BLA.';
 44      usim_test.log_error(l_test_id, l_fail_message);
 45      l_tests_failed := l_tests_failed + 1;
 46    ELSE
 47      l_tests_success := l_tests_success + 1;
 48    END IF;
 49
 50    l_test_section := 'Functions insert do commit FALSE';
 51    l_run_id := '004';
 52    l_usim_id_nod := usim_nod.insert_node(FALSE);
 53    IF l_usim_id_nod IS NULL
 54    THEN
 55      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_id_nod should not be NULL after insert.';
 56      usim_test.log_error(l_test_id, l_fail_message);
 57      l_tests_failed := l_tests_failed + 1;
 58    ELSE
 59      l_tests_success := l_tests_success + 1;
 60    END IF;
 61    l_run_id := '005';
 62    l_sql_number_result := usim_nod.get_energy(l_usim_id_nod);
 63    IF l_sql_number_result IS NOT NULL
 64    THEN
 65      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_energy should be NULL after insert.';
 66      usim_test.log_error(l_test_id, l_fail_message);
 67      l_tests_failed := l_tests_failed + 1;
 68    ELSE
 69      l_tests_success := l_tests_success + 1;
 70    END IF;
 71    l_run_id := '006';
 72    IF usim_nod.has_data = 0
 73    THEN
 74      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': has_data should report data after insert.';
 75      usim_test.log_error(l_test_id, l_fail_message);
 76      l_tests_failed := l_tests_failed + 1;
 77    ELSE
 78      l_tests_success := l_tests_success + 1;
 79    END IF;
 80    l_run_id := '007';
 81    IF usim_nod.has_data(l_usim_id_nod) = 0
 82    THEN
 83      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': has_data[' || l_usim_id_nod || '] should report data for id after insert.';
 84      usim_test.log_error(l_test_id, l_fail_message);
 85      l_tests_failed := l_tests_failed + 1;
 86    ELSE
 87      l_tests_success := l_tests_success + 1;
 88    END IF;
 89    l_run_id := '008';
 90    ROLLBACK;
 91    IF usim_nod.has_data = 1
 92    THEN
 93      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': has_data should not report data after rollback.';
 94      usim_test.log_error(l_test_id, l_fail_message);
 95      l_tests_failed := l_tests_failed + 1;
 96    ELSE
 97      l_tests_success := l_tests_success + 1;
 98    END IF;
 99    l_run_id := '009';
100    IF usim_nod.has_data(l_usim_id_nod) = 1
101    THEN
102      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': has_data[' || l_usim_id_nod || '] should not report data for id after rollback.';
103      usim_test.log_error(l_test_id, l_fail_message);
104      l_tests_failed := l_tests_failed + 1;
105    ELSE
106      l_tests_success := l_tests_success + 1;
107    END IF;
108
109    l_test_section := 'Functions update do commit FALSE';
110    l_run_id := '010';
111    l_usim_id_nod := usim_nod.insert_node(FALSE);
112    l_sql_number_result := usim_nod.update_energy(10, l_usim_id_nod, FALSE);
113    IF l_sql_number_result != 10
114    THEN
115      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_energy [' || l_sql_number_result || '] should be 10 after update for [' || l_usim_id_nod || '].';
116      usim_test.log_error(l_test_id, l_fail_message);
117      l_tests_failed := l_tests_failed + 1;
118    ELSE
119      l_tests_success := l_tests_success + 1;
120    END IF;
121    l_run_id := '011';
122    l_sql_number_result := usim_nod.update_energy(usim_base.get_abs_max_number, l_usim_id_nod, FALSE);
123    IF l_sql_number_result != usim_base.get_abs_max_number
124    THEN
125      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_energy [' || l_sql_number_result || '] should be max after correct max update for [' || l_usim_id_nod || '].';
126      usim_test.log_error(l_test_id, l_fail_message);
127      l_tests_failed := l_tests_failed + 1;
128    ELSE
129      l_tests_success := l_tests_success + 1;
130    END IF;
131    ROLLBACK;
132
133    l_test_section := 'Functions add do commit FALSE';
134    l_run_id := '011';
135    l_usim_id_nod := usim_nod.insert_node(FALSE);
136    l_sql_number_result := usim_nod.add_energy(10, l_usim_id_nod, FALSE);
137    IF l_sql_number_result != 10
138    THEN
139      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_energy [' || l_sql_number_result || '] should be 10 after add for [' || l_usim_id_nod || '].';
140      usim_test.log_error(l_test_id, l_fail_message);
141      l_tests_failed := l_tests_failed + 1;
142    ELSE
143      l_tests_success := l_tests_success + 1;
144    END IF;
145    ROLLBACK;
146
147    l_test_section := 'Functions add negative energy do commit FALSE';
148    l_run_id := '012';
149    l_usim_id_nod := usim_nod.insert_node(FALSE);
150    l_sql_number_result := usim_nod.add_energy(-10, l_usim_id_nod, FALSE);
151    IF l_sql_number_result != -10
152    THEN
153      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_energy [' || l_sql_number_result || '] should be -10 after add for [' || l_usim_id_nod || '].';
154      usim_test.log_error(l_test_id, l_fail_message);
155      l_tests_failed := l_tests_failed + 1;
156    ELSE
157      l_tests_success := l_tests_success + 1;
158    END IF;
159    l_run_id := '013';
160    ROLLBACK;
161    IF usim_nod.has_data = 1
162    THEN
163      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': has_data should not report data after rollback.';
164      usim_test.log_error(l_test_id, l_fail_message);
165      l_tests_failed := l_tests_failed + 1;
166    ELSE
167      l_tests_success := l_tests_success + 1;
168    END IF;
169    l_run_id := '014';
170    IF usim_nod.has_data(l_usim_id_nod) = 1
171    THEN
172      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': has_data[' || l_usim_id_nod || '] should not report data for id after rollback.';
173      usim_test.log_error(l_test_id, l_fail_message);
174      l_tests_failed := l_tests_failed + 1;
175    ELSE
176      l_tests_success := l_tests_success + 1;
177    END IF;
178
179    l_test_section := 'Functions insert, update, add do commit TRUE';
180    l_run_id := '015';
181    l_usim_id_nod := usim_nod.insert_node;
182    IF usim_nod.has_data = 0
183    THEN
184      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': has_data should have data after insert.';
185      usim_test.log_error(l_test_id, l_fail_message);
186      l_tests_failed := l_tests_failed + 1;
187    ELSE
188      l_tests_success := l_tests_success + 1;
189    END IF;
190    l_run_id := '016';
191    IF usim_nod.has_data(l_usim_id_nod) = 0
192    THEN
193      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': has_data[' || l_usim_id_nod || '] should have data for id after insert.';
194      usim_test.log_error(l_test_id, l_fail_message);
195      l_tests_failed := l_tests_failed + 1;
196    ELSE
197      l_tests_success := l_tests_success + 1;
198    END IF;
199    ROLLBACK;
200    l_run_id := '017';
201    IF usim_nod.has_data = 0
202    THEN
203      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': has_data should have data after insert with commit and rollback.';
204      usim_test.log_error(l_test_id, l_fail_message);
205      l_tests_failed := l_tests_failed + 1;
206    ELSE
207      l_tests_success := l_tests_success + 1;
208    END IF;
209    l_run_id := '018';
210    IF usim_nod.has_data(l_usim_id_nod) = 0
211    THEN
212      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': has_data[' || l_usim_id_nod || '] should have data for id after insert with commit and rollback.';
213      usim_test.log_error(l_test_id, l_fail_message);
214      l_tests_failed := l_tests_failed + 1;
215    ELSE
216      l_tests_success := l_tests_success + 1;
217    END IF;
218    l_run_id := '019';
219    l_sql_number_result := usim_nod.add_energy(10, l_usim_id_nod);
220    IF l_sql_number_result != 10
221    THEN
222      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_energy [' || l_sql_number_result || '] should be 10 after add for [' || l_usim_id_nod || '].';
223      usim_test.log_error(l_test_id, l_fail_message);
224      l_tests_failed := l_tests_failed + 1;
225    ELSE
226      l_tests_success := l_tests_success + 1;
227    END IF;
228    ROLLBACK;
229    l_run_id := '020';
230    IF l_sql_number_result != 10
231    THEN
232      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_energy [' || l_sql_number_result || '] should be still 10 after rollback of add with commit for [' || l_usim_id_nod || '].';
233      usim_test.log_error(l_test_id, l_fail_message);
234      l_tests_failed := l_tests_failed + 1;
235    ELSE
236      l_tests_success := l_tests_success + 1;
237    END IF;
238    l_run_id := '021';
239    l_sql_number_result := usim_nod.update_energy(20, l_usim_id_nod);
240    IF l_sql_number_result != 20
241    THEN
242      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_energy [' || l_sql_number_result || '] should be 20 after update for [' || l_usim_id_nod || '].';
243      usim_test.log_error(l_test_id, l_fail_message);
244      l_tests_failed := l_tests_failed + 1;
245    ELSE
246      l_tests_success := l_tests_success + 1;
247    END IF;
248    ROLLBACK;
249    l_run_id := '022';
250    IF l_sql_number_result != 20
251    THEN
252      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': usim_energy [' || l_sql_number_result || '] should still be 20 after update with commit for [' || l_usim_id_nod || '].';
253      usim_test.log_error(l_test_id, l_fail_message);
254      l_tests_failed := l_tests_failed + 1;
255    ELSE
256      l_tests_success := l_tests_success + 1;
257    END IF;
258
259    -- cleanup
260    DELETE usim_basedata;
261    DELETE usim_node;
262    COMMIT;
263    -- write test results
264    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
265  EXCEPTION
266    WHEN OTHERS THEN
267      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
268      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
269  END;
270  /
SQL> @@TEST_USIM_REL_MLV_DIM.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(4000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_REL_MLV_DIM table';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12    l_usim_id_mlv       usim_multiverse.usim_id_mlv%TYPE;
 13    l_usim_id_dim       usim_dimension.usim_id_dim%TYPE;
 14    l_usim_id_rmd       usim_rel_mlv_dim.usim_id_rmd%TYPE;
 15  BEGIN
 16    l_test_id := usim_test.init_test(l_test_object);
 17    l_test_section := 'Table constraints';
 18    l_run_id := '001';
 19    -- setup
 20    DELETE usim_basedata;
 21    DELETE usim_multiverse;
 22    DELETE usim_dimension;
 23    DELETE usim_rel_mlv_dim;
 24    COMMIT;
 25    usim_base.init_basedata;
 26    l_usim_id_mlv := usim_mlv.insert_universe;
 27    l_usim_id_dim := usim_dim.insert_dimension(0);
 28    BEGIN
 29      INSERT INTO usim_rel_mlv_dim (usim_id_mlv, usim_id_dim, usim_sign) VALUES (l_usim_id_mlv, l_usim_id_dim, 0);
 30      INSERT INTO usim_rel_mlv_dim (usim_id_mlv, usim_id_dim, usim_sign) VALUES (l_usim_id_mlv, l_usim_id_dim, 0);
 31      -- input should be prevented by constraint
 32      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': duplicates insert should not be possible';
 33      usim_test.log_error(l_test_id, l_fail_message);
 34      l_tests_failed := l_tests_failed + 1;
 35    EXCEPTION
 36      WHEN OTHERS THEN
 37        IF INSTR(SQLERRM, 'USIM_RMD_UK') > 0
 38        THEN
 39          l_tests_success := l_tests_success + 1;
 40        ELSE
 41          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 42          usim_test.log_error(l_test_id, l_fail_message);
 43          l_tests_failed := l_tests_failed + 1;
 44        END IF;
 45    END;
 46    ROLLBACK;
 47    l_run_id := '002';
 48    BEGIN
 49      INSERT INTO usim_rel_mlv_dim (usim_id_mlv, usim_id_dim, usim_sign) VALUES ('BLA', l_usim_id_dim, 0);
 50      -- input should be prevented by constraint
 51      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': not existing universe insert should not be possible';
 52      usim_test.log_error(l_test_id, l_fail_message);
 53      l_tests_failed := l_tests_failed + 1;
 54    EXCEPTION
 55      WHEN OTHERS THEN
 56        IF INSTR(SQLERRM, 'USIM_RMD_MLV_FK') > 0
 57        THEN
 58          l_tests_success := l_tests_success + 1;
 59        ELSE
 60          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 61          usim_test.log_error(l_test_id, l_fail_message);
 62          l_tests_failed := l_tests_failed + 1;
 63        END IF;
 64    END;
 65    ROLLBACK;
 66    l_run_id := '003';
 67    BEGIN
 68      INSERT INTO usim_rel_mlv_dim (usim_id_mlv, usim_id_dim, usim_sign) VALUES (l_usim_id_mlv, 'BLA', 1);
 69      -- input should be prevented by constraint
 70      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': not existing dimension insert should not be possible';
 71      usim_test.log_error(l_test_id, l_fail_message);
 72      l_tests_failed := l_tests_failed + 1;
 73    EXCEPTION
 74      WHEN OTHERS THEN
 75        IF INSTR(SQLERRM, 'USIM_RMD_DIM_FK') > 0
 76        THEN
 77          l_tests_success := l_tests_success + 1;
 78        ELSE
 79          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
 80          usim_test.log_error(l_test_id, l_fail_message);
 81          l_tests_failed := l_tests_failed + 1;
 82        END IF;
 83    END;
 84    ROLLBACK;
 85
 86    l_test_section := 'Table insert trigger';
 87    l_run_id := '004';
 88    BEGIN
 89      INSERT INTO usim_rel_mlv_dim (usim_id_rmd, usim_id_mlv, usim_id_dim, usim_sign) VALUES ('BLA', l_usim_id_mlv, l_usim_id_dim, 0) RETURNING usim_id_rmd INTO l_usim_id_rmd;
 90      -- check input value
 91      IF TRIM(l_usim_id_rmd) != 'BLA'
 92      THEN
 93        l_tests_success := l_tests_success + 1;
 94      ELSE
 95        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_usim_id_rmd || '] insert of a given rmd id should not be possible.';
 96        usim_test.log_error(l_test_id, l_fail_message);
 97        l_tests_failed := l_tests_failed + 1;
 98      END IF;
 99    EXCEPTION
100      WHEN OTHERS THEN
101        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
102        usim_test.log_error(l_test_id, l_fail_message);
103        l_tests_failed := l_tests_failed + 1;
104    END;
105    ROLLBACK;
106
107    l_test_section := 'Table update trigger';
108    l_run_id := '005';
109    BEGIN
110      INSERT INTO usim_rel_mlv_dim (usim_id_mlv, usim_id_dim, usim_sign) VALUES (l_usim_id_mlv, l_usim_id_dim, 0) RETURNING usim_id_rmd INTO l_usim_id_rmd;
111      UPDATE usim_rel_mlv_dim
112         SET usim_id_rmd = 'BLA'
113           , usim_id_mlv = 'BLA'
114           , usim_id_dim = 'BLA'
115       WHERE usim_id_rmd = l_usim_id_rmd
116      ;
117      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_usim_id_rmd || '] update of a rmd id should not be possible.';
118      usim_test.log_error(l_test_id, l_fail_message);
119      l_tests_failed := l_tests_failed + 1;
120    EXCEPTION
121      WHEN OTHERS THEN
122        IF SQLCODE = -20001
123        THEN
124          l_tests_success := l_tests_success + 1;
125        ELSE
126          l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
127          usim_test.log_error(l_test_id, l_fail_message);
128          l_tests_failed := l_tests_failed + 1;
129        END IF;
130    END;
131    l_run_id := '006';
132    BEGIN
133      SELECT usim_id_dim INTO l_sql_char_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = l_usim_id_rmd;
134      -- check input value
135      IF TRIM(l_sql_char_result) != 'BLA'
136      THEN
137        l_tests_success := l_tests_success + 1;
138      ELSE
139        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] update of a dimension id should not be possible.';
140        usim_test.log_error(l_test_id, l_fail_message);
141        l_tests_failed := l_tests_failed + 1;
142      END IF;
143    EXCEPTION
144      WHEN OTHERS THEN
145        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
146        usim_test.log_error(l_test_id, l_fail_message);
147        l_tests_failed := l_tests_failed + 1;
148    END;
149    l_run_id := '007';
150    BEGIN
151      SELECT usim_id_mlv INTO l_sql_char_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = l_usim_id_rmd;
152      -- check input value
153      IF TRIM(l_sql_char_result) != 'BLA'
154      THEN
155        l_tests_success := l_tests_success + 1;
156      ELSE
157        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_sql_char_result || '] update of a multiverse id should not be possible.';
158        usim_test.log_error(l_test_id, l_fail_message);
159        l_tests_failed := l_tests_failed + 1;
160      END IF;
161    EXCEPTION
162      WHEN OTHERS THEN
163        l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': unexpected error ' || SQLCODE || ': ' || SQLERRM;
164        usim_test.log_error(l_test_id, l_fail_message);
165        l_tests_failed := l_tests_failed + 1;
166    END;
167    ROLLBACK;
168
169    -- cleanup
170    DELETE usim_basedata;
171    DELETE usim_multiverse;
172    DELETE usim_dimension;
173    DELETE usim_rel_mlv_dim;
174    COMMIT;
175    -- write test results
176    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
177  EXCEPTION
178    WHEN OTHERS THEN
179      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
180      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
181  END;
182  /
SQL> @@TEST_USIM_RMD.sql
SQL> DECLARE
  2    l_tests_success     INTEGER := 0;
  3    l_tests_failed      INTEGER := 0;
  4    l_fail_message      VARCHAR2(4000);
  5    l_run_id            VARCHAR2(10);
  6    l_test_section      VARCHAR2(100);
  7    l_test_object       VARCHAR2(128) := 'USIM_RMD';
  8    l_sql_number_result NUMBER;
  9    l_sql_char_result   VARCHAR2(32000);
 10    l_sql_date_result   DATE;
 11    l_test_id           NUMBER;
 12    l_usim_id_mlv       usim_multiverse.usim_id_mlv%TYPE;
 13    l_usim_id_dim       usim_dimension.usim_id_dim%TYPE;
 14    l_usim_id_rmd       usim_rel_mlv_dim.usim_id_rmd%TYPE;
 15  BEGIN
 16    l_test_id := usim_test.init_test(l_test_object);
 17    l_test_section := 'Functions no data';
 18    l_run_id := '001';
 19    -- setup
 20    DELETE usim_basedata;
 21    DELETE usim_multiverse;
 22    DELETE usim_dimension;
 23    DELETE usim_rel_mlv_dim;
 24    COMMIT;
 25    usim_base.init_basedata;
 26    l_usim_id_mlv := usim_mlv.insert_universe;
 27    l_usim_id_dim := usim_dim.insert_dimension(0);
 28    IF usim_rmd.has_data = 1
 29    THEN
 30      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should not have data with empty table.';
 31      usim_test.log_error(l_test_id, l_fail_message);
 32      l_tests_failed := l_tests_failed + 1;
 33    ELSE
 34      l_tests_success := l_tests_success + 1;
 35    END IF;
 36    l_run_id := '002';
 37    IF usim_rmd.has_data('BLA') = 1
 38    THEN
 39      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should not have not existing relation id data with empty table.';
 40      usim_test.log_error(l_test_id, l_fail_message);
 41      l_tests_failed := l_tests_failed + 1;
 42    ELSE
 43      l_tests_success := l_tests_success + 1;
 44    END IF;
 45    l_run_id := '003';
 46    IF usim_rmd.has_data(l_usim_id_mlv, l_usim_id_dim, 0, NULL) = 1
 47    THEN
 48      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should not have universe/dimension data with empty table.';
 49      usim_test.log_error(l_test_id, l_fail_message);
 50      l_tests_failed := l_tests_failed + 1;
 51    ELSE
 52      l_tests_success := l_tests_success + 1;
 53    END IF;
 54    l_run_id := '004';
 55    IF usim_rmd.has_data(l_usim_id_mlv, 0, 0, NULL) = 1
 56    THEN
 57      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should not have universe/n dimension data with empty table.';
 58      usim_test.log_error(l_test_id, l_fail_message);
 59      l_tests_failed := l_tests_failed + 1;
 60    ELSE
 61      l_tests_success := l_tests_success + 1;
 62    END IF;
 63    l_run_id := '005';
 64    l_usim_id_rmd := usim_rmd.get_id_rmd(l_usim_id_mlv, l_usim_id_dim, 0, NULL);
 65    IF l_usim_id_rmd IS NOT NULL
 66    THEN
 67      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_usim_id_rmd || '] should not get id for universe/dimension with empty table.';
 68      usim_test.log_error(l_test_id, l_fail_message);
 69      l_tests_failed := l_tests_failed + 1;
 70    ELSE
 71      l_tests_success := l_tests_success + 1;
 72    END IF;
 73    l_run_id := '006';
 74    l_usim_id_rmd := usim_rmd.get_id_rmd(l_usim_id_mlv, 0, 0, NULL);
 75    IF l_usim_id_rmd IS NOT NULL
 76    THEN
 77      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': [' || l_usim_id_rmd || '] should not get id for universe/n dimension with empty table.';
 78      usim_test.log_error(l_test_id, l_fail_message);
 79      l_tests_failed := l_tests_failed + 1;
 80    ELSE
 81      l_tests_success := l_tests_success + 1;
 82    END IF;
 83
 84    l_test_section := 'Insert functions do commit';
 85    l_run_id := '007';
 86    l_usim_id_rmd := usim_rmd.insert_rmd(l_usim_id_mlv, l_usim_id_dim, 0, NULL, FALSE);
 87    IF usim_rmd.has_data(l_usim_id_rmd) = 0
 88    THEN
 89      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should have existing relation id data.';
 90      usim_test.log_error(l_test_id, l_fail_message);
 91      l_tests_failed := l_tests_failed + 1;
 92    ELSE
 93      l_tests_success := l_tests_success + 1;
 94    END IF;
 95    ROLLBACK;
 96    l_run_id := '008';
 97    IF usim_rmd.has_data(l_usim_id_rmd) = 1
 98    THEN
 99      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should not have existing relation id data after rollback.';
100      usim_test.log_error(l_test_id, l_fail_message);
101      l_tests_failed := l_tests_failed + 1;
102    ELSE
103      l_tests_success := l_tests_success + 1;
104    END IF;
105
106    l_test_section := 'Functions with data';
107    l_run_id := '009';
108    l_usim_id_rmd := usim_rmd.insert_rmd(l_usim_id_mlv, l_usim_id_dim, 0, NULL);
109    IF usim_rmd.has_data(l_usim_id_rmd) = 0
110    THEN
111      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should have existing relation id data.';
112      usim_test.log_error(l_test_id, l_fail_message);
113      l_tests_failed := l_tests_failed + 1;
114    ELSE
115      l_tests_success := l_tests_success + 1;
116    END IF;
117    l_run_id := '010';
118    IF usim_rmd.has_data(l_usim_id_mlv, l_usim_id_dim, 0, NULL) = 0
119    THEN
120      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should have data for universe and dimension id.';
121      usim_test.log_error(l_test_id, l_fail_message);
122      l_tests_failed := l_tests_failed + 1;
123    ELSE
124      l_tests_success := l_tests_success + 1;
125    END IF;
126    l_run_id := '011';
127    IF usim_rmd.has_data = 0
128    THEN
129      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should have at least some data.';
130      usim_test.log_error(l_test_id, l_fail_message);
131      l_tests_failed := l_tests_failed + 1;
132    ELSE
133      l_tests_success := l_tests_success + 1;
134    END IF;
135    l_run_id := '012';
136    IF usim_rmd.has_data(l_usim_id_mlv, usim_dim.get_dimension(l_usim_id_dim), 0, NULL) = 0
137    THEN
138      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should have data for dimension.';
139      usim_test.log_error(l_test_id, l_fail_message);
140      l_tests_failed := l_tests_failed + 1;
141    ELSE
142      l_tests_success := l_tests_success + 1;
143    END IF;
144    l_run_id := '013';
145    l_sql_char_result := usim_rmd.get_id_rmd(l_usim_id_mlv, l_usim_id_dim, 0, NULL);
146    IF TRIM(l_sql_char_result) != l_usim_id_rmd
147    THEN
148      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should have data for universe and dimension id.';
149      usim_test.log_error(l_test_id, l_fail_message);
150      l_tests_failed := l_tests_failed + 1;
151    ELSE
152      l_tests_success := l_tests_success + 1;
153    END IF;
154    l_run_id := '014';
155    l_sql_char_result := usim_rmd.get_id_rmd(l_usim_id_mlv, usim_dim.get_dimension(l_usim_id_dim), 0, NULL);
156    IF TRIM(l_sql_char_result) != l_usim_id_rmd
157    THEN
158      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should have data for universe id and dimension.';
159      usim_test.log_error(l_test_id, l_fail_message);
160      l_tests_failed := l_tests_failed + 1;
161    ELSE
162      l_tests_success := l_tests_success + 1;
163    END IF;
164    l_run_id := '015';
165    l_sql_char_result := usim_rmd.insert_rmd(l_usim_id_mlv, usim_dim.get_dimension(l_usim_id_dim), 0, NULL);
166    IF TRIM(l_sql_char_result) != l_usim_id_rmd
167    THEN
168      l_fail_message := l_test_object || ' - ' || l_test_section || ' - ' || l_run_id || ': should return existing id for universe id and dimension.';
169      usim_test.log_error(l_test_id, l_fail_message);
170      l_tests_failed := l_tests_failed + 1;
171    ELSE
172      l_tests_success := l_tests_success + 1;
173    END IF;
174
175    -- cleanup
176    DELETE usim_basedata;
177    DELETE usim_multiverse;
178    DELETE usim_dimension;
179    DELETE usim_rel_mlv_dim;
180    COMMIT;
181    -- write test results
182    usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
183  EXCEPTION
184    WHEN OTHERS THEN
185      usim_test.log_error(l_test_id, SUBSTR('Test section failed unexpected: [' || l_test_section || '] tests done: ' || TO_CHAR(NVL(l_tests_success, 0) + NVL(l_tests_failed, 0)) || ' last runs id ' || l_run_id || ' ora: ' || SQLERRM, 1, 4000));
186      usim_test.write_test_results(l_test_id, l_tests_success, l_tests_failed);
187  END;
188  /
SQL> SET FEEDBACK ON
SQL> -- test summary
SQL> @@../UTIL/TEST_SUMMARY.sql
SQL> SET FEEDBACK OFF
SQL> SELECT CASE
  2           WHEN usim_tests_failed = 0
  3           THEN 'SUCCESS'
  4           ELSE 'FAILED'
  5         END AS status
  6       , usim_tests_success
  7       , usim_tests_failed
  8       , usim_test_object
  9    FROM usim_test_summary
 10  ;

STATUS  USIM_TESTS_SUCCESS USIM_TESTS_FAILED USIM_TEST_OBJECT
------- ------------------ ----------------- --------------------------------------------------------------------------------------------------------------------------------
SUCCESS                 61                 0 USIM_STATIC
SUCCESS                 36                 0 USIM_MATHS
SUCCESS                  8                 0 USIM_DEBUG
SUCCESS                 27                 0 USIM_BASE_DATA table
SUCCESS                 28                 0 USIM_BASE
SUCCESS                 22                 0 USIM_MULTIVERSE table
SUCCESS                 53                 0 USIM_MLV
SUCCESS                  5                 0 USIM_DIMENSION table
SUCCESS                 18                 0 USIM_DIM
SUCCESS                  3                 0 USIM_POSITION table
SUCCESS                 23                 0 USIM_POS
SUCCESS                  4                 0 USIM_NODE table
SUCCESS                 23                 0 USIM_NOD
SUCCESS                  7                 0 USIM_REL_MLV_DIM table
SUCCESS                 15                 0 USIM_RMD
SQL> -- Test errors if any
SQL> SELECT ter.usim_timestamp
  2       , tsu.usim_test_object
  3       , ter.usim_error_msg
  4    FROM usim_test_errors ter
  5    LEFT OUTER JOIN usim_test_summary tsu
  6      ON ter.usim_id_tsu = tsu.usim_id_tsu
  7   ORDER BY ter.usim_timestamp
  8  ;
SQL> SET FEEDBACK ON
SQL> -- setup some basic data
SQL> @@../UTIL/BASIC_TEST_DATA_SETUP.sql
SQL> DECLARE
  2    -- n1p: n1=1, n1n n=-1, 1p=1/dim 1 sign 1, 1n=-1/dim 1 sign -1
  3    l_id_mlv1         usim_multiverse.usim_id_mlv%TYPE;
  4    l_id_mlv2         usim_multiverse.usim_id_mlv%TYPE;
  5    l_id_rmd0         usim_rel_mlv_dim.usim_id_rmd%TYPE;
  6    l_id_rmd_n1p_1p   usim_rel_mlv_dim.usim_id_rmd%TYPE;
  7    l_id_rmd_n1n_1n   usim_rel_mlv_dim.usim_id_rmd%TYPE;
  8    l_id_rmd_n1p_2p   usim_rel_mlv_dim.usim_id_rmd%TYPE;
  9    l_id_rmd_n1p_2n   usim_rel_mlv_dim.usim_id_rmd%TYPE;
 10    l_id_rmd_n1n_2p   usim_rel_mlv_dim.usim_id_rmd%TYPE;
 11    l_id_rmd_n1n_2n   usim_rel_mlv_dim.usim_id_rmd%TYPE;
 12    l_id_rmd_n1p_3p   usim_rel_mlv_dim.usim_id_rmd%TYPE;
 13    l_id_rmd_n1p_3n   usim_rel_mlv_dim.usim_id_rmd%TYPE;
 14    l_id_rmd_n1n_3p   usim_rel_mlv_dim.usim_id_rmd%TYPE;
 15    l_id_rmd_n1n_3n   usim_rel_mlv_dim.usim_id_rmd%TYPE;
 16    l_id_pos0         usim_position.usim_id_pos%TYPE;
 17    l_id_pos1p        usim_position.usim_id_pos%TYPE;
 18    l_id_pos1n        usim_position.usim_id_pos%TYPE;
 19    l_id_pos2p        usim_position.usim_id_pos%TYPE;
 20    l_id_pos2n        usim_position.usim_id_pos%TYPE;
 21    l_id_spc0         usim_space.usim_id_spc%TYPE;
 22    -- dim 1 pos 0
 23    l_id_spc0_n1p_1p  usim_space.usim_id_spc%TYPE;
 24    l_id_spc0_n1n_1n  usim_space.usim_id_spc%TYPE;
 25    -- dim 1 pos 1
 26    l_id_spc1p_n1p_1p usim_space.usim_id_spc%TYPE;
 27    l_id_spc1n_n1n_1n usim_space.usim_id_spc%TYPE;
 28    -- dim 1 pos 2
 29    l_id_spc2p_n1p_1p usim_space.usim_id_spc%TYPE;
 30    l_id_spc2n_n1n_1n usim_space.usim_id_spc%TYPE;
 31    -- dim 2 pos 0
 32    l_id_spc0p_n1p_2p usim_space.usim_id_spc%TYPE;
 33    l_id_spc0n_n1p_2n usim_space.usim_id_spc%TYPE;
 34    l_id_spc0p_n1n_2p usim_space.usim_id_spc%TYPE;
 35    l_id_spc0n_n1n_2n usim_space.usim_id_spc%TYPE;
 36    -- dim 2 pos 1
 37    l_id_spc1p_n1p_2p usim_space.usim_id_spc%TYPE;
 38    l_id_spc1n_n1p_2n usim_space.usim_id_spc%TYPE;
 39    l_id_spc1p_n1n_2p usim_space.usim_id_spc%TYPE;
 40    l_id_spc1n_n1n_2n usim_space.usim_id_spc%TYPE;
 41    -- dim 2 pos 2
 42    l_id_spc2p_n1p_2p usim_space.usim_id_spc%TYPE;
 43    l_id_spc2n_n1p_2n usim_space.usim_id_spc%TYPE;
 44    l_id_spc2p_n1n_2p usim_space.usim_id_spc%TYPE;
 45    l_id_spc2n_n1n_2n usim_space.usim_id_spc%TYPE;
 46    -- inbetween nodes
 47    -- 1,1 in dim 1,2
 48    l_id_spc1p1p_n1p_1p2p usim_space.usim_id_spc%TYPE;
 49    -- -1,1 in dim -1,2
 50    l_id_spc1n1p_n1n_1n2p usim_space.usim_id_spc%TYPE;
 51    -- 1, -1
 52    l_id_spc1p1n_n1p_1p2n usim_space.usim_id_spc%TYPE;
 53    -- -1, -1
 54    l_id_spc1n1n_n1n_1n2n usim_space.usim_id_spc%TYPE;
 55
 56    l_seq             NUMBER;
 57    l_return          NUMBER;
 58    l_usim_id_mlv     usim_multiverse.usim_id_mlv%TYPE;
 59    l_usim_id_spc     usim_space.usim_id_spc%TYPE;
 60    l_seq_aeon        usim_static.usim_id;
 61    l_parents         usim_static.usim_ids_type;
 62    l_universe_state  usim_multiverse.usim_universe_status%TYPE;
 63  BEGIN
 64    usim_erl.purge_log;
 65    usim_debug.purge_log;
 66    usim_debug.set_debug_on;
 67
 68  /*
 69    l_return := usim_dbif.init_basedata(3, 10);
 70    usim_erl.log_error('basic_test_data_setup', 'Init base data with max dimension 3 and max number 10.');
 71
 72    -- init planck time
 73    l_seq := usim_dbif.get_planck_time_next;
 74    usim_erl.log_error('basic_test_data_setup', 'Init planck tick [' || l_seq || '].');
 75    l_seq_aeon := usim_dbif.get_planck_aeon_seq_current;
 76    usim_erl.log_error('basic_test_data_setup', 'Current planck aeon [' || l_seq_aeon || '] after update tick.');
 77    -- base universe
 78    l_return    := usim_dbif.init_dimensions;
 79    l_return    := usim_dbif.init_positions;
 80    l_id_mlv1   := usim_dbif.create_universe;
 81    l_id_pos0   := usim_dbif.get_id_pos(0);
 82    l_id_pos1p  := usim_dbif.get_id_pos(1);
 83    l_id_pos1n  := usim_dbif.get_id_pos(-1);
 84    l_id_pos2p  := usim_dbif.get_id_pos(2);
 85    l_id_pos2n  := usim_dbif.get_id_pos(-2);
 86    -- dim axis 0
 87    l_return  := usim_dbif.create_dim_axis(l_id_mlv1, 0, NULL, l_id_rmd0, l_id_rmd_n1p_1p);
 88    l_id_spc0 := usim_dbif.create_space_node(l_id_rmd0, l_id_pos0, l_parents);
 89    -- dim axis 1 (+/-)
 90    l_return := usim_dbif.create_dim_axis(l_id_mlv1, 1, l_id_rmd0, l_id_rmd_n1p_1p, l_id_rmd_n1n_1n);
 91    l_parents(1) := l_id_spc0;
 92    -- +0,0,0
 93    l_id_spc0_n1p_1p  := usim_dbif.create_space_node(l_id_rmd_n1p_1p, l_id_pos0, l_parents);
 94    -- -0,0,0
 95    l_id_spc0_n1n_1n  := usim_dbif.create_space_node(l_id_rmd_n1n_1n, l_id_pos0, l_parents);
 96
 97    -- from here on parents have to have the same dim n1 sign
 98    -- do positive axis n1p_n1
 99    l_parents(1) := l_id_spc0_n1p_1p;
100    -- 1,0,0
101    l_id_spc1p_n1p_1p := usim_dbif.create_space_node(l_id_rmd_n1p_1p, l_id_pos1p, l_parents);
102    l_parents(1) := l_id_spc1p_n1p_1p;
103    -- 2,0,0
104    l_id_spc2p_n1p_1p := usim_dbif.create_space_node(l_id_rmd_n1p_1p, l_id_pos2p, l_parents);
105
106    -- do negative axis n1n_n1
107    l_parents(1) := l_id_spc0_n1n_1n;
108    -- -1,0,0
109    l_id_spc1n_n1n_1n := usim_dbif.create_space_node(l_id_rmd_n1n_1n, l_id_pos1n, l_parents);
110    l_parents(1) := l_id_spc1n_n1n_1n;
111    -- -2,0,0
112    l_id_spc2n_n1n_1n := usim_dbif.create_space_node(l_id_rmd_n1n_1n, l_id_pos2n, l_parents);
113
114    -- dim axis n1p_n2 (+/-)
115    l_return := usim_dbif.create_dim_axis(l_id_mlv1, 2, l_id_rmd_n1p_1p, l_id_rmd_n1p_2p, l_id_rmd_n1p_2n);
116    -- dim axis n1n_n2 (+/-)
117    l_return := usim_dbif.create_dim_axis(l_id_mlv1, 2, l_id_rmd_n1n_1n, l_id_rmd_n1n_2p, l_id_rmd_n1n_2n);
118
119    -- do axis n1p_n2p
120    -- +0,+0,0 n1p_n2p
121    l_parents(1) := l_id_spc0_n1p_1p;
122    l_id_spc0p_n1p_2p := usim_dbif.create_space_node(l_id_rmd_n1p_2p, l_id_pos0, l_parents);
123    -- +0,+1,0 n1p_n2p
124    l_parents(1) := l_id_spc0p_n1p_2p;
125    l_id_spc1p_n1p_2p := usim_dbif.create_space_node(l_id_rmd_n1p_2p, l_id_pos1p, l_parents);
126    -- +0,+2,0 n1p_n2p
127    l_parents(1) := l_id_spc1p_n1p_2p;
128    l_id_spc2p_n1p_2p := usim_dbif.create_space_node(l_id_rmd_n1p_2p, l_id_pos2p, l_parents);
129
130    -- do axis n1p_n2n
131    -- +0,-0,0 n1p_n2n
132    l_parents(1) := l_id_spc0_n1p_1p;
133    l_id_spc0n_n1p_2n := usim_dbif.create_space_node(l_id_rmd_n1p_2n, l_id_pos0, l_parents);
134    -- +0,-1,0 n1p_n2n
135    l_parents(1) := l_id_spc0n_n1p_2n;
136    l_id_spc1n_n1p_2n := usim_dbif.create_space_node(l_id_rmd_n1p_2n, l_id_pos1n, l_parents);
137    -- +0,-2,0 n1p_n2n
138    l_parents(1) := l_id_spc1n_n1p_2n;
139    l_id_spc2n_n1p_2n := usim_dbif.create_space_node(l_id_rmd_n1p_2n, l_id_pos2n, l_parents);
140
141    -- do axis n1n_n2p
142    -- -0,+0,0 n1n_n2p
143    l_parents(1) := l_id_spc0_n1n_1n;
144    l_id_spc0p_n1n_2p := usim_dbif.create_space_node(l_id_rmd_n1n_2p, l_id_pos0, l_parents);
145    -- -0,+1,0 n1n_n2p
146    l_parents(1) := l_id_spc0p_n1n_2p;
147    l_id_spc1p_n1n_2p := usim_dbif.create_space_node(l_id_rmd_n1n_2p, l_id_pos1p, l_parents);
148    -- -0,+2,0 n1n_n2p
149    l_parents(1) := l_id_spc1p_n1n_2p;
150    l_id_spc2p_n1n_2p := usim_dbif.create_space_node(l_id_rmd_n1n_2p, l_id_pos2p, l_parents);
151
152    -- do axis n1n_n2n
153    -- -0,-0,0 n1n_n2n
154    l_parents(1) := l_id_spc0_n1n_1n;
155    l_id_spc0n_n1n_2n := usim_dbif.create_space_node(l_id_rmd_n1n_2n, l_id_pos0, l_parents);
156    -- -0,-1,0 n1n_n2n
157    l_parents(1) := l_id_spc0n_n1n_2n;
158    l_id_spc1n_n1n_2n := usim_dbif.create_space_node(l_id_rmd_n1n_2n, l_id_pos1n, l_parents);
159    -- -0,-2,0 n1n_n2n
160    l_parents(1) := l_id_spc1n_n1n_2n;
161    l_id_spc2n_n1n_2n := usim_dbif.create_space_node(l_id_rmd_n1n_2n, l_id_pos2n, l_parents);
162
163    -- inbetween nodes two ways to construct, higher dimension with related value or lower dimension with related value
164    -- 1,1,0 n1p
165    l_parents(1) := l_id_spc1p_n1p_1p;
166    l_parents(2) := l_id_spc1p_n1p_2p;
167    l_id_spc1p1p_n1p_1p2p := usim_dbif.create_space_node(l_id_rmd_n1p_2p, l_id_pos1p, l_parents);
168    -- 1,-1,0 n1p
169    l_parents(1) := l_id_spc1p_n1p_1p;
170    l_parents(2) := l_id_spc1n_n1p_2n;
171    l_id_spc1p1n_n1p_1p2n := usim_dbif.create_space_node(l_id_rmd_n1p_2p, l_id_pos1p, l_parents);
172    -- -1,1,0 n1n
173    l_parents(1) := l_id_spc1n_n1n_1n;
174    l_parents(2) := l_id_spc1n_n1n_2n;
175    l_id_spc1n1p_n1n_1n2p := usim_dbif.create_space_node(l_id_rmd_n1n_2n, l_id_pos1n, l_parents);
176    -- -1,-1,0 n1n
177    l_parents(1) := l_id_spc1n_n1n_1n;
178    l_parents(2) := l_id_spc1p_n1n_2p;
179    l_id_spc1n1n_n1n_1n2n := usim_dbif.create_space_node(l_id_rmd_n1n_2n, l_id_pos1n, l_parents);
180
181  --  l_universe_state := usim_dbif.set_universe_state(l_id_mlv1, usim_static.usim_multiverse_status_active,);
182  */
183    -- test processing
184    l_return := usim_process.place_start_node(3, 10);
185    IF l_return = 1
186    THEN
187      usim_debug.debug_log('basic_test_data_setup', 'Init place start node with max dimension 3 and max number 10.');
188      l_return := usim_process.run_samples(1000);
189      IF l_return = 1
190      THEN
191        usim_debug.debug_log('basic_test_data_setup', 'Samples run exit without error.');
192      ELSE
193        usim_debug.debug_log('basic_test_data_setup', 'Error running samples.');
194      END IF;
195    ELSE
196      usim_debug.debug_log('basic_test_data_setup', 'Failed to init place start node with max dimension 3 and max number 10.');
197    END IF;
198
199    -- get variables for this run
200    l_usim_id_spc := usim_dbif.get_id_spc_base_universe;
201    l_usim_id_mlv := usim_dbif.get_id_mlv(l_usim_id_spc);
202    l_seq_aeon    := usim_dbif.get_planck_aeon_seq_current;
203    l_seq         := usim_dbif.get_planck_time_current;
204    -- provide json output, if website is running, may throw errors on file open
205    l_return := usim_creator.create_space_log(l_seq_aeon, 1, l_seq);
206  EXCEPTION
207    WHEN OTHERS THEN
208      usim_debug.debug_log('basic_test_data_setup', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
209  END;
210  /
PL/SQL-Prozedur erfolgreich abgeschlossen.
SQL> -- list error and debug messages
SQL> SELECT usim_timestamp, SUBSTR(usim_err_object, 1, 50) AS usim_err_object, usim_err_info FROM usim_error_log ORDER BY usim_timestamp, usim_tick;

0 Zeilen ausgewählt.

SQL> SELECT usim_timestamp, SUBSTR(usim_log_object, 1, 50) AS usim_log_object, usim_log_content FROM usim_debug_log ORDER BY usim_timestamp, ROWID;

USIM_TIMESTAMP                USIM_LOG_OBJECT                                    USIM_LOG_CONTENT
----------------------------- -------------------------------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
20.05.2024 04:20:54.222847000 basic_test_data_setup                              Init place start node with max dimension 3 and max number 10.
20.05.2024 04:20:55.873866000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [4.713134765625] and current target energy [7.4111328125]. Set energy to 0.
20.05.2024 04:20:56.280107000 usim_creator.handle_overflow_dim                   Handle new dimension in zero pos for space id [2024052004205403700000000000000000000000000000000000002].
20.05.2024 04:20:56.280580000 usim_creator.handle_overflow                       [23] Handle dim overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [4].
20.05.2024 04:20:56.291291000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-4.713134765625] and current target energy [-7.4111328125]. Set energy to 0.
20.05.2024 04:20:56.316200000 usim_creator.handle_overflow_dim                   Handle new dimension in zero pos for space id [2024052004205410800000000000000000000000000000000000003].
20.05.2024 04:20:56.316320000 usim_creator.handle_overflow                       [23] Handle dim overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [4].
20.05.2024 04:20:56.476140000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [2.3565673828125] and current target energy [9.42626953125]. Set energy to 0.
20.05.2024 04:20:56.489015000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:20:56.489426000 usim_creator.handle_overflow                       [30] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:20:56.491051000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-2.3565673828125] and current target energy [-9.42626953125]. Set energy to 0.
20.05.2024 04:20:56.495027000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:20:56.495316000 usim_creator.handle_overflow                       [30] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:20:56.948770000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.4941419661045074462890625] and current target energy [8.9504684507846832275390625]. Set energy to 0.
20.05.2024 04:20:57.039165000 usim_creator.handle_overflow_dim                   Handle new dimension in zero pos for space id [2024052004205403700000000000000000000000000000000000002].
20.05.2024 04:20:57.046734000 usim_creator.handle_overflow                       [37] Handle dim overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [4].
20.05.2024 04:20:57.054818000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.4941419661045074462890625] and current target energy [-8.9504684507846832275390625]. Set energy to 0.
20.05.2024 04:20:57.169290000 usim_creator.handle_overflow_dim                   Handle new dimension in zero pos for space id [2024052004205410800000000000000000000000000000000000003].
20.05.2024 04:20:57.169771000 usim_creator.handle_overflow                       [37] Handle dim overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [4].
20.05.2024 04:20:57.919843000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [1.444719441351480782032012939453125] and current target energy [9.29599237628281116485595703125]. Set energy to 0.
20.05.2024 04:20:57.959677000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:20:57.969125000 usim_creator.handle_overflow                       [44] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:20:57.982000000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [1.444719441351480782032012939453125] and current target energy [9.29599237628281116485595703125]. Set energy to 0.
20.05.2024 04:20:57.992739000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:20:57.993031000 usim_creator.handle_overflow                       [44] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:20:57.994627000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-1.444719441351480782032012939453125] and current target energy [-9.29599237628281116485595703125]. Set energy to 0.
20.05.2024 04:20:58.005660000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:20:58.005950000 usim_creator.handle_overflow                       [44] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:20:58.018290000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-1.444719441351480782032012939453125] and current target energy [-9.29599237628281116485595703125]. Set energy to 0.
20.05.2024 04:20:58.043584000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:20:58.045055000 usim_creator.handle_overflow                       [44] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:20:58.297225000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [4.78262897559943667147308588027954101563] and current target energy [8.2540455265916534699499607086181640625]. Set energy to 0.
20.05.2024 04:20:58.308588000 usim_creator.handle_overflow                       [47] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:20:58.311010000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-4.78262897559943667147308588027954101563] and current target energy [-8.2540455265916534699499607086181640625]. Set energy to 0.
20.05.2024 04:20:58.317215000 usim_creator.handle_overflow                       [47] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:20:58.654119000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [2.30278562910118722584229544736444950104] and current target energy [9.56525795119887334294617176055908203125]. Set energy to 0.
20.05.2024 04:20:58.664462000 usim_creator.handle_overflow                       [50] Handle pos overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [3].
20.05.2024 04:20:58.667133000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-2.30278562910118722584229544736444950104] and current target energy [-9.56525795119887334294617176055908203125]. Set energy to 0.
20.05.2024 04:20:58.674558000 usim_creator.handle_overflow                       [50] Handle pos overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [3].
20.05.2024 04:20:58.994019000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [2.21093753633587519757952577492687851191] and current target energy [8.13246675645448391378522501327097415924]. Set energy to 0.
20.05.2024 04:20:59.026789000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:20:59.043047000 usim_creator.handle_overflow                       [52] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:20:59.051433000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [2.21093753633587519757952577492687851191] and current target energy [8.13246675645448391378522501327097415924]. Set energy to 0.
20.05.2024 04:20:59.066752000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:20:59.086055000 usim_creator.handle_overflow                       [52] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:20:59.103776000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-2.21093753633587519757952577492687851191] and current target energy [-8.13246675645448391378522501327097415924]. Set energy to 0.
20.05.2024 04:20:59.122536000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:20:59.137352000 usim_creator.handle_overflow                       [52] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:20:59.158647000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-2.21093753633587519757952577492687851191] and current target energy [-8.13246675645448391378522501327097415924]. Set energy to 0.
20.05.2024 04:20:59.167225000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:20:59.167520000 usim_creator.handle_overflow                       [52] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:20:59.467615000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.47143377129631509891982688031930592843] and current target energy [9.3491851375610229846202514636388514191]. Set energy to 0.
20.05.2024 04:20:59.485077000 usim_creator.handle_overflow                       [56] Handle pos overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [5].
20.05.2024 04:20:59.487032000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.47143377129631509891982688031930592843] and current target energy [9.3491851375610229846202514636388514191]. Set energy to 0.
20.05.2024 04:20:59.498764000 usim_creator.handle_overflow                       [56] Handle pos overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [5].
20.05.2024 04:20:59.500674000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.47143377129631509891982688031930592843] and current target energy [-9.3491851375610229846202514636388514191]. Set energy to 0.
20.05.2024 04:20:59.509326000 usim_creator.handle_overflow                       [56] Handle pos overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [5].
20.05.2024 04:20:59.511044000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.47143377129631509891982688031930592843] and current target energy [-9.3491851375610229846202514636388514191]. Set energy to 0.
20.05.2024 04:20:59.522419000 usim_creator.handle_overflow                       [56] Handle pos overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [5].
20.05.2024 04:20:59.671562000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.47483397958455249754546045881653526522] and current target energy [9.11251364965282713466454556083817806213]. Set energy to 0.
20.05.2024 04:20:59.675703000 usim_creator.handle_overflow                       [59] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:20:59.677426000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.47483397958455249754546045881653526522] and current target energy [-9.11251364965282713466454556083817806213]. Set energy to 0.
20.05.2024 04:20:59.681500000 usim_creator.handle_overflow                       [59] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:20:59.831223000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.48383104378045119691809441975216543597] and current target energy [9.71160858816757956504805981978734052973]. Set energy to 0.
20.05.2024 04:20:59.842044000 usim_creator.handle_overflow                       [63] Handle pos overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [3].
20.05.2024 04:20:59.844298000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.48383104378045119691809441975216543597] and current target energy [9.71160858816757956504805981978734052973]. Set energy to 0.
20.05.2024 04:20:59.850340000 usim_creator.handle_overflow                       [63] Handle pos overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [3].
20.05.2024 04:20:59.852185000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.48383104378045119691809441975216543597] and current target energy [-9.71160858816757956504805981978734052973]. Set energy to 0.
20.05.2024 04:20:59.858016000 usim_creator.handle_overflow                       [63] Handle pos overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [3].
20.05.2024 04:20:59.859892000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.48383104378045119691809441975216543597] and current target energy [-9.71160858816757956504805981978734052973]. Set energy to 0.
20.05.2024 04:20:59.869885000 usim_creator.handle_overflow                       [63] Handle pos overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [3].
20.05.2024 04:21:00.534800000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.3414914625736268592386748704616138855] and current target energy [9.51925160809420366689455315738549651999]. Set energy to 0.
20.05.2024 04:21:00.547646000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:00.549209000 usim_creator.handle_overflow                       [70] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:00.553761000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.3414914625736268592386748704616138855] and current target energy [-9.51925160809420366689455315738549651999]. Set energy to 0.
20.05.2024 04:21:00.561026000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:00.561727000 usim_creator.handle_overflow                       [70] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:00.750393000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.43077087229590885602427726898483736157] and current target energy [8.79535602557618696250267153324204470344]. Set energy to 0.
20.05.2024 04:21:00.760875000 usim_creator.handle_overflow                       [73] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:00.766185000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.43077087229590885602427726898483736157] and current target energy [-8.79535602557618696250267153324204470344]. Set energy to 0.
20.05.2024 04:21:00.771750000 usim_creator.handle_overflow                       [73] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:01.251366000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [1.32459761190071819014463964503231665061] and current target energy [9.72308348918363542409710907593934944626]. Set energy to 0.
20.05.2024 04:21:01.264096000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:01.268764000 usim_creator.handle_overflow                       [78] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:01.282560000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [1.32459761190071819014463964503231665061] and current target energy [9.72308348918363542409710907593934944626]. Set energy to 0.
20.05.2024 04:21:01.303841000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:01.304992000 usim_creator.handle_overflow                       [78] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:01.306974000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-1.32459761190071819014463964503231665061] and current target energy [-9.72308348918363542409710907593934944626]. Set energy to 0.
20.05.2024 04:21:01.322867000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:01.324219000 usim_creator.handle_overflow                       [78] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:01.343760000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-1.32459761190071819014463964503231665061] and current target energy [-9.72308348918363542409710907593934944626]. Set energy to 0.
20.05.2024 04:21:01.356281000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:01.357372000 usim_creator.handle_overflow                       [78] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:01.734392000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [3.00389195065549014449212787788690927625] and current target energy [8.682982925147253718477349740923227771]. Set energy to 0.
20.05.2024 04:21:01.753809000 usim_creator.handle_overflow                       [81] Handle pos overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [3].
20.05.2024 04:21:01.756801000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-3.00389195065549014449212787788690927625] and current target energy [-8.682982925147253718477349740923227771]. Set energy to 0.
20.05.2024 04:21:01.775338000 usim_creator.handle_overflow                       [81] Handle pos overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [3].
20.05.2024 04:21:02.479160000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.85539220097759943032959896851012874837] and current target energy [6.00778390131098028898425575577381855249]. Set energy to 0.
20.05.2024 04:21:02.513616000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:02.519100000 usim_creator.handle_overflow                       [88] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:02.538798000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.85539220097759943032959896851012874837] and current target energy [-6.00778390131098028898425575577381855249]. Set energy to 0.
20.05.2024 04:21:02.554959000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:02.570713000 usim_creator.handle_overflow                       [88] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:02.591665000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.85539220097759943032959896851012874837] and current target energy [6.90569471520637087486095505041909958969]. Set energy to 0.
20.05.2024 04:21:02.616374000 usim_creator.handle_overflow                       [88] Handle pos overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [5].
20.05.2024 04:21:02.626056000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.85539220097759943032959896851012874837] and current target energy [6.90569471520637087486095505041909958969]. Set energy to 0.
20.05.2024 04:21:02.651220000 usim_creator.handle_overflow                       [88] Handle pos overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [5].
20.05.2024 04:21:02.669092000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.85539220097759943032959896851012874837] and current target energy [-6.90569471520637087486095505041909958969]. Set energy to 0.
20.05.2024 04:21:02.696239000 usim_creator.handle_overflow                       [88] Handle pos overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [5].
20.05.2024 04:21:02.710268000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.85539220097759943032959896851012874837] and current target energy [-6.90569471520637087486095505041909958969]. Set energy to 0.
20.05.2024 04:21:02.745861000 usim_creator.handle_overflow                       [88] Handle pos overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [5].
20.05.2024 04:21:03.233220000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [2.47333999090793370403948912094569740407] and current target energy [8.15115999102441770625093802031845672657]. Set energy to 0.
20.05.2024 04:21:03.241574000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:03.241942000 usim_creator.handle_overflow                       [92] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:03.243872000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [2.47333999090793370403948912094569740407] and current target energy [8.15115999102441770625093802031845672657]. Set energy to 0.
20.05.2024 04:21:03.272942000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:03.273994000 usim_creator.handle_overflow                       [92] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:03.279893000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-2.47333999090793370403948912094569740407] and current target energy [-8.15115999102441770625093802031845672657]. Set energy to 0.
20.05.2024 04:21:03.289323000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:03.291970000 usim_creator.handle_overflow                       [92] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:03.297973000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-2.47333999090793370403948912094569740407] and current target energy [-8.15115999102441770625093802031845672657]. Set energy to 0.
20.05.2024 04:21:03.335444000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:03.348864000 usim_creator.handle_overflow                       [92] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:03.946998000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.23360571491999858301957336451881050589] and current target energy [9.89335996363173481615795648378278961629]. Set energy to 0.
20.05.2024 04:21:03.959911000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:03.960975000 usim_creator.handle_overflow                       [97] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:21:03.962995000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.23360571491999858301957336451881050589] and current target energy [9.89335996363173481615795648378278961629]. Set energy to 0.
20.05.2024 04:21:03.969823000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:03.970145000 usim_creator.handle_overflow                       [97] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:21:03.974204000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.23360571491999858301957336451881050589] and current target energy [-9.89335996363173481615795648378278961629]. Set energy to 0.
20.05.2024 04:21:04.001330000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:04.010619000 usim_creator.handle_overflow                       [97] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:21:04.027077000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.23360571491999858301957336451881050589] and current target energy [-9.89335996363173481615795648378278961629]. Set energy to 0.
20.05.2024 04:21:04.054538000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:04.055831000 usim_creator.handle_overflow                       [97] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:21:04.640456000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [3.23821500166499628042638008186187757797] and current target energy [9.86884571935998866415658691615048404714]. Set energy to 0.
20.05.2024 04:21:04.689914000 usim_creator.handle_overflow                       [101] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:04.697475000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-3.23821500166499628042638008186187757797] and current target energy [-9.86884571935998866415658691615048404714]. Set energy to 0.
20.05.2024 04:21:04.704548000 usim_creator.handle_overflow                       [101] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:05.216076000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.50740224268752273343714466145929096094] and current target energy [7.26877403006408096548533740246063014078]. Set energy to 0.
20.05.2024 04:21:05.223980000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:05.224271000 usim_creator.handle_overflow                       [108] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:05.226136000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.50740224268752273343714466145929096094] and current target energy [-7.26877403006408096548533740246063014078]. Set energy to 0.
20.05.2024 04:21:05.238926000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:05.239235000 usim_creator.handle_overflow                       [108] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:05.570681000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.59116548803316050097258166032675623106] and current target energy [7.15341987991702433926456488320946895236]. Set energy to 0.
20.05.2024 04:21:05.595658000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:05.608438000 usim_creator.handle_overflow                       [112] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:05.617345000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.59116548803316050097258166032675623106] and current target energy [7.15341987991702433926456488320946895236]. Set energy to 0.
20.05.2024 04:21:05.632776000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:05.633956000 usim_creator.handle_overflow                       [112] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:05.650216000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.59116548803316050097258166032675623106] and current target energy [-7.15341987991702433926456488320946895236]. Set energy to 0.
20.05.2024 04:21:05.668496000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:05.669255000 usim_creator.handle_overflow                       [112] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:05.684341000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.59116548803316050097258166032675623106] and current target energy [-7.15341987991702433926456488320946895236]. Set energy to 0.
20.05.2024 04:21:05.690176000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:05.690412000 usim_creator.handle_overflow                       [112] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:05.692956000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.59116548803316050097258166032675623106] and current target energy [8.08373193055852809219090560630011206505]. Set energy to 0.
20.05.2024 04:21:05.705917000 usim_creator.handle_overflow                       [112] Handle pos overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [5].
20.05.2024 04:21:05.710750000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.59116548803316050097258166032675623106] and current target energy [8.08373193055852809219090560630011206505]. Set energy to 0.
20.05.2024 04:21:05.720511000 usim_creator.handle_overflow                       [112] Handle pos overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [5].
20.05.2024 04:21:05.723331000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.59116548803316050097258166032675623106] and current target energy [-8.08373193055852809219090560630011206505]. Set energy to 0.
20.05.2024 04:21:05.737359000 usim_creator.handle_overflow                       [112] Handle pos overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [5].
20.05.2024 04:21:05.741840000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.59116548803316050097258166032675623106] and current target energy [-8.08373193055852809219090560630011206505]. Set energy to 0.
20.05.2024 04:21:05.760661000 usim_creator.handle_overflow                       [112] Handle pos overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [5].
20.05.2024 04:21:05.831050000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [1.79558274401658025048629083016337811553] and current target energy [9.01480448537504546687428932291858192187]. Set energy to 0.
20.05.2024 04:21:05.839082000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:05.839755000 usim_creator.handle_overflow                       [113] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:21:05.844998000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-1.79558274401658025048629083016337811553] and current target energy [-9.01480448537504546687428932291858192187]. Set energy to 0.
20.05.2024 04:21:05.852015000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:05.852760000 usim_creator.handle_overflow                       [113] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:21:06.204513000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.3848738264251695716626354850830776526475] and current target energy [9.93688834226882295573976143849777837698]. Set energy to 0.
20.05.2024 04:21:06.231100000 usim_creator.handle_overflow                       [117] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:06.240892000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.3848738264251695716626354850830776526475] and current target energy [-9.93688834226882295573976143849777837698]. Set energy to 0.
20.05.2024 04:21:06.254023000 usim_creator.handle_overflow                       [117] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:07.580190000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [3.32723419329273179816225766385033558001] and current target energy [8.93393341780938726685818839734457570202]. Set energy to 0.
20.05.2024 04:21:07.592398000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:07.593035000 usim_creator.handle_overflow                       [128] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:07.597709000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-3.32723419329273179816225766385033558001] and current target energy [-8.93393341780938726685818839734457570202]. Set energy to 0.
20.05.2024 04:21:07.605338000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:07.606090000 usim_creator.handle_overflow                       [128] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:07.691872000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.79549884219306275963201160582046469589] and current target energy [8.74082129923334312943593377777160695728]. Set energy to 0.
20.05.2024 04:21:07.699901000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:07.700627000 usim_creator.handle_overflow                       [129] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:21:07.709417000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.79549884219306275963201160582046469589] and current target energy [8.74082129923334312943593377777160695728]. Set energy to 0.
20.05.2024 04:21:07.716017000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:07.716319000 usim_creator.handle_overflow                       [129] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:21:07.721136000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.79549884219306275963201160582046469589] and current target energy [-8.74082129923334312943593377777160695728]. Set energy to 0.
20.05.2024 04:21:07.752551000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:07.756985000 usim_creator.handle_overflow                       [129] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:21:07.769791000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.79549884219306275963201160582046469589] and current target energy [-8.74082129923334312943593377777160695728]. Set energy to 0.
20.05.2024 04:21:07.786822000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:07.787548000 usim_creator.handle_overflow                       [129] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:21:07.960016000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [4.06450579328421733123799975716588832397] and current target energy [6.92584972749618750752269934235869559795]. Set energy to 0.
20.05.2024 04:21:07.980074000 usim_creator.handle_overflow                       [130] Handle pos overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [3].
20.05.2024 04:21:08.006847000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-4.06450579328421733123799975716588832397] and current target energy [-6.92584972749618750752269934235869559795]. Set energy to 0.
20.05.2024 04:21:08.040056000 usim_creator.handle_overflow                       [130] Handle pos overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [3].
20.05.2024 04:21:08.404553000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.88945658054614159070833616831997723783] and current target energy [7.18199536877225103852804642328185878354]. Set energy to 0.
20.05.2024 04:21:08.419352000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:08.420566000 usim_creator.handle_overflow                       [132] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:08.435911000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.88945658054614159070833616831997723783] and current target energy [7.18199536877225103852804642328185878354]. Set energy to 0.
20.05.2024 04:21:08.456041000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:08.461575000 usim_creator.handle_overflow                       [132] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:08.463667000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.88945658054614159070833616831997723783] and current target energy [-7.18199536877225103852804642328185878354]. Set energy to 0.
20.05.2024 04:21:08.472770000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:08.473072000 usim_creator.handle_overflow                       [132] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:08.474897000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.88945658054614159070833616831997723783] and current target energy [-7.18199536877225103852804642328185878354]. Set energy to 0.
20.05.2024 04:21:08.486912000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:08.487974000 usim_creator.handle_overflow                       [132] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:08.650413000 usim_process.process_queue                         Overflow for target space id [2024052004205701200000000000000000000000000000000000015] with energy [1.19450160972387102766674564862318059775] and current target energy [9.35021759374038632205600787926667425271]. Set energy to 0.
20.05.2024 04:21:08.663200000 usim_creator.handle_overflow                       [133] Not implemented. Handle overflow for [2024052004205701200000000000000000000000000000000000015] escape strategy [0].
20.05.2024 04:21:08.680563000 usim_process.process_queue                         Overflow for target space id [2024052004205702800000000000000000000000000000000000017] with energy [1.19450160972387102766674564862318059775] and current target energy [9.35021759374038632205600787926667425271]. Set energy to 0.
20.05.2024 04:21:08.703545000 usim_creator.handle_overflow                       [133] Not implemented. Handle overflow for [2024052004205702800000000000000000000000000000000000017] escape strategy [0].
20.05.2024 04:21:08.713321000 usim_process.process_queue                         Overflow for target space id [2024052004205711900000000000000000000000000000000000019] with energy [-1.19450160972387102766674564862318059775] and current target energy [-9.35021759374038632205600787926667425271]. Set energy to 0.
20.05.2024 04:21:08.724986000 usim_creator.handle_overflow                       [133] Not implemented. Handle overflow for [2024052004205711900000000000000000000000000000000000019] escape strategy [0].
20.05.2024 04:21:08.732618000 usim_process.process_queue                         Overflow for target space id [2024052004205716200000000000000000000000000000000000021] with energy [-1.19450160972387102766674564862318059775] and current target energy [-9.35021759374038632205600787926667425271]. Set energy to 0.
20.05.2024 04:21:08.749677000 usim_creator.handle_overflow                       [133] Not implemented. Handle overflow for [2024052004205716200000000000000000000000000000000000021] escape strategy [0].
20.05.2024 04:21:08.986563000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [3.9769811869151794609731679627429327809] and current target energy [8.12901158656843466247599951433177664794]. Set energy to 0.
20.05.2024 04:21:09.002449000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:09.003439000 usim_creator.handle_overflow                       [135] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:21:09.005400000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-3.9769811869151794609731679627429327809] and current target energy [-8.12901158656843466247599951433177664794]. Set energy to 0.
20.05.2024 04:21:09.012180000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:09.012470000 usim_creator.handle_overflow                       [135] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:21:09.176528000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.86182072568267698838542021039997154729] and current target energy [7.9539623738303589219463359254858655618]. Set energy to 0.
20.05.2024 04:21:09.224301000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:09.225383000 usim_creator.handle_overflow                       [136] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:09.249886000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.86182072568267698838542021039997154729] and current target energy [-7.9539623738303589219463359254858655618]. Set energy to 0.
20.05.2024 04:21:09.268088000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:09.268998000 usim_creator.handle_overflow                       [136] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:09.298853000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.86182072568267698838542021039997154729] and current target energy [9.556012877790968221333965188985444782]. Set energy to 0.
20.05.2024 04:21:09.321042000 usim_creator.handle_overflow                       [136] Handle pos overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [5].
20.05.2024 04:21:09.339170000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.86182072568267698838542021039997154729] and current target energy [9.556012877790968221333965188985444782]. Set energy to 0.
20.05.2024 04:21:09.370494000 usim_creator.handle_overflow                       [136] Handle pos overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [5].
20.05.2024 04:21:09.383334000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.86182072568267698838542021039997154729] and current target energy [-9.556012877790968221333965188985444782]. Set energy to 0.
20.05.2024 04:21:09.420153000 usim_creator.handle_overflow                       [136] Handle pos overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [5].
20.05.2024 04:21:09.429747000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.86182072568267698838542021039997154729] and current target energy [-9.556012877790968221333965188985444782]. Set energy to 0.
20.05.2024 04:21:09.451264000 usim_creator.handle_overflow                       [136] Handle pos overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [5].
20.05.2024 04:21:09.881887000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [1.45618163022393079327008349107900539893] and current target energy [9.72364145136535397677084042079994309458]. Set energy to 0.
20.05.2024 04:21:09.897386000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:09.898902000 usim_creator.handle_overflow                       [140] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:09.923698000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [1.45618163022393079327008349107900539893] and current target energy [9.72364145136535397677084042079994309458]. Set energy to 0.
20.05.2024 04:21:09.943940000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:09.961133000 usim_creator.handle_overflow                       [140] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:09.970317000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-1.45618163022393079327008349107900539893] and current target energy [-9.72364145136535397677084042079994309458]. Set energy to 0.
20.05.2024 04:21:09.993983000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:09.994378000 usim_creator.handle_overflow                       [140] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:10.007688000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-1.45618163022393079327008349107900539893] and current target energy [-9.72364145136535397677084042079994309458]. Set energy to 0.
20.05.2024 04:21:10.021511000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:10.024158000 usim_creator.handle_overflow                       [140] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:10.285424000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.6319228258648141149788536325830672409063] and current target energy [9.72364145136535397677084042079994309457]. Set energy to 0.
20.05.2024 04:21:10.298242000 usim_creator.handle_overflow                       [143] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:10.301082000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.6319228258648141149788536325830672409063] and current target energy [-9.72364145136535397677084042079994309457]. Set energy to 0.
20.05.2024 04:21:10.308244000 usim_creator.handle_overflow                       [143] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:10.500201000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [1.45618163022393079327008349107900539893] and current target energy [9.64522035787837405925139352142696738642]. Set energy to 0.
20.05.2024 04:21:10.509542000 usim_creator.handle_overflow                       [146] Handle pos overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [3].
20.05.2024 04:21:10.514434000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [1.45618163022393079327008349107900539893] and current target energy [9.64522035787837405925139352142696738642]. Set energy to 0.
20.05.2024 04:21:10.522696000 usim_creator.handle_overflow                       [146] Handle pos overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [3].
20.05.2024 04:21:10.527051000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-1.45618163022393079327008349107900539893] and current target energy [-9.64522035787837405925139352142696738642]. Set energy to 0.
20.05.2024 04:21:10.535804000 usim_creator.handle_overflow                       [146] Handle pos overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [3].
20.05.2024 04:21:10.540620000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-1.45618163022393079327008349107900539893] and current target energy [-9.64522035787837405925139352142696738642]. Set energy to 0.
20.05.2024 04:21:10.549527000 usim_creator.handle_overflow                       [146] Handle pos overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [3].
20.05.2024 04:21:11.257640000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.22131390849772798531027714729242123482] and current target energy [7.67256083271797462229574126953745509808]. Set energy to 0.
20.05.2024 04:21:11.268586000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:11.271862000 usim_creator.handle_overflow                       [152] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:11.274264000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.22131390849772798531027714729242123482] and current target energy [-7.67256083271797462229574126953745509808]. Set energy to 0.
20.05.2024 04:21:11.287589000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:11.287894000 usim_creator.handle_overflow                       [152] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:11.306188000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.22131390849772798531027714729242123482] and current target energy [6.27083778833918216692718411326453081408]. Set energy to 0.
20.05.2024 04:21:11.343613000 usim_creator.handle_overflow                       [152] Handle pos overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [5].
20.05.2024 04:21:11.356567000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.22131390849772798531027714729242123482] and current target energy [6.27083778833918216692718411326453081408]. Set energy to 0.
20.05.2024 04:21:11.390073000 usim_creator.handle_overflow                       [152] Handle pos overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [5].
20.05.2024 04:21:11.413701000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.22131390849772798531027714729242123482] and current target energy [-6.27083778833918216692718411326453081408]. Set energy to 0.
20.05.2024 04:21:11.440844000 usim_creator.handle_overflow                       [152] Handle pos overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [5].
20.05.2024 04:21:11.454153000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.22131390849772798531027714729242123482] and current target energy [-6.27083778833918216692718411326453081408]. Set energy to 0.
20.05.2024 04:21:11.481466000 usim_creator.handle_overflow                       [152] Handle pos overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [5].
20.05.2024 04:21:11.666220000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.72323768003558200641917892274285488015] and current target energy [8.44262781699545597062055429458484246963]. Set energy to 0.
20.05.2024 04:21:11.687790000 usim_creator.handle_overflow                       [153] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:11.703011000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.72323768003558200641917892274285488015] and current target energy [-8.44262781699545597062055429458484246963]. Set energy to 0.
20.05.2024 04:21:11.723210000 usim_creator.handle_overflow                       [153] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:11.905198000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [4.76330238578236883652116486922243306137] and current target energy [6.21496418937365642362940923380230737836]. Set energy to 0.
20.05.2024 04:21:11.931859000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:11.933185000 usim_creator.handle_overflow                       [154] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:21:11.947452000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-4.76330238578236883652116486922243306137] and current target energy [-6.21496418937365642362940923380230737836]. Set energy to 0.
20.05.2024 04:21:11.964897000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:11.969254000 usim_creator.handle_overflow                       [154] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:21:12.434307000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [.74304193707943256707257642864023002652] and current target energy [9.52660477156473767304232973844486612273]. Set energy to 0.
20.05.2024 04:21:12.453211000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:12.454624000 usim_creator.handle_overflow                       [157] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:21:12.474152000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-.74304193707943256707257642864023002652] and current target energy [-9.52660477156473767304232973844486612273]. Set energy to 0.
20.05.2024 04:21:12.496990000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:12.499028000 usim_creator.handle_overflow                       [157] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:21:12.985576000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.08725240366139453390660797150950355123] and current target energy [9.09239687366167533093390975452579536701]. Set energy to 0.
20.05.2024 04:21:12.996169000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:12.996470000 usim_creator.handle_overflow                       [161] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:21:12.998404000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.08725240366139453390660797150950355123] and current target energy [9.09239687366167533093390975452579536701]. Set energy to 0.
20.05.2024 04:21:13.028605000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:13.029872000 usim_creator.handle_overflow                       [161] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:21:13.050291000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.08725240366139453390660797150950355123] and current target energy [-9.09239687366167533093390975452579536701]. Set energy to 0.
20.05.2024 04:21:13.078864000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:13.086934000 usim_creator.handle_overflow                       [161] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:21:13.089455000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.08725240366139453390660797150950355123] and current target energy [-9.09239687366167533093390975452579536701]. Set energy to 0.
20.05.2024 04:21:13.108412000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:13.116217000 usim_creator.handle_overflow                       [161] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:21:13.608134000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [2.34076377197446900846615010507604650533] and current target energy [8.73761409332106919829045777008661833432]. Set energy to 0.
20.05.2024 04:21:13.623269000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:13.627007000 usim_creator.handle_overflow                       [164] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:13.637069000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [2.34076377197446900846615010507604650533] and current target energy [8.73761409332106919829045777008661833432]. Set energy to 0.
20.05.2024 04:21:13.645327000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:13.646127000 usim_creator.handle_overflow                       [164] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:13.651101000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-2.34076377197446900846615010507604650533] and current target energy [-8.73761409332106919829045777008661833432]. Set energy to 0.
20.05.2024 04:21:13.659564000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:13.661729000 usim_creator.handle_overflow                       [164] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:13.665231000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-2.34076377197446900846615010507604650533] and current target energy [-8.73761409332106919829045777008661833432]. Set energy to 0.
20.05.2024 04:21:13.673182000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:13.673932000 usim_creator.handle_overflow                       [164] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:14.053712000 usim_process.process_queue                         Overflow for target space id [2024052004205948300000000000000000000000000000000000024] with energy [.6070125195902782677024843074910340077163] and current target energy [9.65829781562728910237056008521212322466]. Set energy to 0.
20.05.2024 04:21:14.069968000 usim_creator.handle_overflow                       [168] Not implemented. Handle overflow for [2024052004205948300000000000000000000000000000000000024] escape strategy [0].
20.05.2024 04:21:14.085172000 usim_process.process_queue                         Overflow for target space id [2024052004205949500000000000000000000000000000000000025] with energy [.6070125195902782677024843074910340077163] and current target energy [9.65829781562728910237056008521212322466]. Set energy to 0.
20.05.2024 04:21:14.101614000 usim_creator.handle_overflow                       [168] Not implemented. Handle overflow for [2024052004205949500000000000000000000000000000000000025] escape strategy [0].
20.05.2024 04:21:14.109584000 usim_process.process_queue                         Overflow for target space id [2024052004205950700000000000000000000000000000000000026] with energy [-.6070125195902782677024843074910340077163] and current target energy [-9.65829781562728910237056008521212322466]. Set energy to 0.
20.05.2024 04:21:14.127514000 usim_creator.handle_overflow                       [168] Not implemented. Handle overflow for [2024052004205950700000000000000000000000000000000000026] escape strategy [0].
20.05.2024 04:21:14.141529000 usim_process.process_queue                         Overflow for target space id [2024052004205952100000000000000000000000000000000000027] with energy [-.6070125195902782677024843074910340077163] and current target energy [-9.65829781562728910237056008521212322466]. Set energy to 0.
20.05.2024 04:21:14.157353000 usim_creator.handle_overflow                       [168] Not implemented. Handle overflow for [2024052004205952100000000000000000000000000000000000027] escape strategy [0].
20.05.2024 04:21:14.716832000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.8464864293359217197247247443800043437625] and current target energy [9.38779750850190824971226871829197511735]. Set energy to 0.
20.05.2024 04:21:14.754339000 usim_creator.handle_overflow                       [171] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:14.760961000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.8464864293359217197247247443800043437625] and current target energy [-9.38779750850190824971226871829197511735]. Set energy to 0.
20.05.2024 04:21:14.782552000 usim_creator.handle_overflow                       [171] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:14.798088000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.89058067799428319588893643517939474298] and current target energy [7.43809599521661224676451860517472466778]. Set energy to 0.
20.05.2024 04:21:14.813738000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:14.814994000 usim_creator.handle_overflow                       [171] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:21:14.822272000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.89058067799428319588893643517939474298] and current target energy [-7.43809599521661224676451860517472466778]. Set energy to 0.
20.05.2024 04:21:14.839649000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:14.839978000 usim_creator.handle_overflow                       [171] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:21:15.055256000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [4.07959123212174075492646280169200499958] and current target energy [6.24089480265816777595328720965365596584]. Set energy to 0.
20.05.2024 04:21:15.064460000 usim_creator.handle_overflow                       [173] Handle pos overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [3].
20.05.2024 04:21:15.069963000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-4.07959123212174075492646280169200499958] and current target energy [-6.24089480265816777595328720965365596584]. Set energy to 0.
20.05.2024 04:21:15.079188000 usim_creator.handle_overflow                       [173] Handle pos overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [3].
20.05.2024 04:21:15.547897000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [3.35735296753881984792530137085689767076] and current target energy [9.78116135598856639177787287035878948596]. Set energy to 0.
20.05.2024 04:21:15.587305000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:15.595155000 usim_creator.handle_overflow                       [176] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:15.616181000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-3.35735296753881984792530137085689767076] and current target energy [-9.78116135598856639177787287035878948596]. Set energy to 0.
20.05.2024 04:21:15.643742000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:15.645060000 usim_creator.handle_overflow                       [176] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:15.663722000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.35735296753881984792530137085689767076] and current target energy [6.7718914346873737577977979550400347501]. Set energy to 0.
20.05.2024 04:21:15.701940000 usim_creator.handle_overflow                       [176] Handle pos overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [5].
20.05.2024 04:21:15.717588000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.35735296753881984792530137085689767076] and current target energy [6.7718914346873737577977979550400347501]. Set energy to 0.
20.05.2024 04:21:15.748030000 usim_creator.handle_overflow                       [176] Handle pos overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [5].
20.05.2024 04:21:15.759963000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.35735296753881984792530137085689767076] and current target energy [-6.7718914346873737577977979550400347501]. Set energy to 0.
20.05.2024 04:21:15.798486000 usim_creator.handle_overflow                       [176] Handle pos overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [5].
20.05.2024 04:21:15.821487000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.35735296753881984792530137085689767076] and current target energy [-6.7718914346873737577977979550400347501]. Set energy to 0.
20.05.2024 04:21:15.845797000 usim_creator.handle_overflow                       [176] Handle pos overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [5].
20.05.2024 04:21:16.046254000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.15274561266069040344076500654150960076] and current target energy [8.86745154773833009929136774825530494228]. Set energy to 0.
20.05.2024 04:21:16.066041000 usim_creator.handle_overflow                       [177] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:16.071868000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.15274561266069040344076500654150960076] and current target energy [-8.86745154773833009929136774825530494228]. Set energy to 0.
20.05.2024 04:21:16.078993000 usim_creator.handle_overflow                       [177] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:16.245671000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [1.67944023046467439534663005696444329603] and current target energy [9.68157077359961554853134573208303062443]. Set energy to 0.
20.05.2024 04:21:16.258812000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:16.259335000 usim_creator.handle_overflow                       [178] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:21:16.267501000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [1.67944023046467439534663005696444329603] and current target energy [9.68157077359961554853134573208303062443]. Set energy to 0.
20.05.2024 04:21:16.279406000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:16.280935000 usim_creator.handle_overflow                       [178] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:21:16.290043000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-1.67944023046467439534663005696444329603] and current target energy [-9.68157077359961554853134573208303062443]. Set energy to 0.
20.05.2024 04:21:16.302437000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:16.303898000 usim_creator.handle_overflow                       [178] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:21:16.309330000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-1.67944023046467439534663005696444329603] and current target energy [-9.68157077359961554853134573208303062443]. Set energy to 0.
20.05.2024 04:21:16.320617000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:16.321075000 usim_creator.handle_overflow                       [178] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:21:16.554890000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [1.93373081163122512627928595819716083097] and current target energy [9.12093135465797920812886787637753902798]. Set energy to 0.
20.05.2024 04:21:16.583203000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:16.596939000 usim_creator.handle_overflow                       [180] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:16.607373000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [1.93373081163122512627928595819716083097] and current target energy [9.12093135465797920812886787637753902798]. Set energy to 0.
20.05.2024 04:21:16.627880000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:16.639462000 usim_creator.handle_overflow                       [180] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:16.646933000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-1.93373081163122512627928595819716083097] and current target energy [-9.12093135465797920812886787637753902798]. Set energy to 0.
20.05.2024 04:21:16.663804000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:16.664849000 usim_creator.handle_overflow                       [180] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:16.674812000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-1.93373081163122512627928595819716083097] and current target energy [-9.12093135465797920812886787637753902798]. Set energy to 0.
20.05.2024 04:21:16.689715000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:16.691171000 usim_creator.handle_overflow                       [180] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:16.967919000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.006677145554005840698930837564683700287288] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:16.983455000 usim_process.process_node                          Overflow for space id [2024052004211570000000000000000000000000000000000000058] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:17.005844000 usim_creator.handle_overflow                       [182] Handle pos overflow for [2024052004211570000000000000000000000000000000000000058] escape strategy [3].
20.05.2024 04:21:17.032927000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.006677145554005840698930837564683700287288] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:17.038915000 usim_process.process_node                          Overflow for space id [2024052004211574500000000000000000000000000000000000059] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:17.062647000 usim_creator.handle_overflow                       [182] Handle pos overflow for [2024052004211574500000000000000000000000000000000000059] escape strategy [3].
20.05.2024 04:21:17.087625000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.006677145554005840698930837564683700287288] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:17.089745000 usim_process.process_node                          Overflow for space id [2024052004211579500000000000000000000000000000000000060] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:17.118330000 usim_creator.handle_overflow                       [182] Handle pos overflow for [2024052004211579500000000000000000000000000000000000060] escape strategy [3].
20.05.2024 04:21:17.139193000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.006677145554005840698930837564683700287288] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:17.140435000 usim_process.process_node                          Overflow for space id [2024052004211584300000000000000000000000000000000000061] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:17.168004000 usim_creator.handle_overflow                       [182] Handle pos overflow for [2024052004211584300000000000000000000000000000000000061] escape strategy [3].
20.05.2024 04:21:17.234711000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [2.67723174607989237042049121361037828098] and current target energy [8.15918246424348150985292560338400999916]. Set energy to 0.
20.05.2024 04:21:17.244432000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:17.245130000 usim_creator.handle_overflow                       [182] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:21:17.250524000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-2.67723174607989237042049121361037828098] and current target energy [-8.15918246424348150985292560338400999916]. Set energy to 0.
20.05.2024 04:21:17.258476000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:17.259182000 usim_creator.handle_overflow                       [182] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:21:18.671951000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.002263574532047011687199006929919931561725] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:18.672791000 usim_process.process_node                          Overflow for space id [2024052004211700300000000000000000000000000000000000062] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:18.682136000 usim_creator.handle_overflow                       [193] Handle pos overflow for [2024052004211700300000000000000000000000000000000000062] escape strategy [3].
20.05.2024 04:21:18.694179000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.002263574532047011687199006929919931561725] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:18.694874000 usim_process.process_node                          Overflow for space id [2024052004211706000000000000000000000000000000000000063] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:18.708325000 usim_creator.handle_overflow                       [193] Handle pos overflow for [2024052004211706000000000000000000000000000000000000063] escape strategy [3].
20.05.2024 04:21:18.716505000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.002263574532047011687199006929919931561725] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:18.717072000 usim_process.process_node                          Overflow for space id [2024052004211711600000000000000000000000000000000000064] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:18.745400000 usim_creator.handle_overflow                       [193] Handle pos overflow for [2024052004211711600000000000000000000000000000000000064] escape strategy [3].
20.05.2024 04:21:18.761923000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.002263574532047011687199006929919931561725] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:18.762140000 usim_process.process_node                          Overflow for space id [2024052004211716600000000000000000000000000000000000065] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:18.781793000 usim_creator.handle_overflow                       [193] Handle pos overflow for [2024052004211716600000000000000000000000000000000000065] escape strategy [3].
20.05.2024 04:21:18.867467000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.801789221446858904063967775701698679375] and current target energy [9.58881564780308394807894986031385072177]. Set energy to 0.
20.05.2024 04:21:18.903895000 usim_creator.handle_overflow                       [193] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:18.912958000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.801789221446858904063967775701698679375] and current target energy [-9.58881564780308394807894986031385072177]. Set energy to 0.
20.05.2024 04:21:18.930784000 usim_creator.handle_overflow                       [193] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:18.933023000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [2.07385998928104554167696694709860968692] and current target energy [9.5161807322193954473384009779649442007]. Set energy to 0.
20.05.2024 04:21:18.944229000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:18.944537000 usim_creator.handle_overflow                       [193] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:21:18.948894000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [2.07385998928104554167696694709860968692] and current target energy [9.5161807322193954473384009779649442007]. Set energy to 0.
20.05.2024 04:21:18.963669000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:18.974362000 usim_creator.handle_overflow                       [193] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:21:18.990283000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-2.07385998928104554167696694709860968692] and current target energy [-9.5161807322193954473384009779649442007]. Set energy to 0.
20.05.2024 04:21:19.005666000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:19.008787000 usim_creator.handle_overflow                       [193] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:21:19.020192000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-2.07385998928104554167696694709860968692] and current target energy [-9.5161807322193954473384009779649442007]. Set energy to 0.
20.05.2024 04:21:19.040606000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:19.041816000 usim_creator.handle_overflow                       [193] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:21:19.888769000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [2.17116641350771105666289380004188909754] and current target energy [8.72946222498592885141958462541710407415]. Set energy to 0.
20.05.2024 04:21:19.915174000 usim_creator.handle_overflow                       [197] Handle pos overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [3].
20.05.2024 04:21:19.917979000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [2.17116641350771105666289380004188909754] and current target energy [8.72946222498592885141958462541710407415]. Set energy to 0.
20.05.2024 04:21:19.944474000 usim_creator.handle_overflow                       [197] Handle pos overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [3].
20.05.2024 04:21:19.964831000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-2.17116641350771105666289380004188909754] and current target energy [-8.72946222498592885141958462541710407415]. Set energy to 0.
20.05.2024 04:21:19.988551000 usim_creator.handle_overflow                       [197] Handle pos overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [3].
20.05.2024 04:21:19.992178000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-2.17116641350771105666289380004188909754] and current target energy [-8.72946222498592885141958462541710407415]. Set energy to 0.
20.05.2024 04:21:20.009935000 usim_creator.handle_overflow                       [197] Handle pos overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [3].
20.05.2024 04:21:20.329553000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [3.28066048459356858385553105069348804124] and current target energy [9.99820338161849473175018986878015403041]. Set energy to 0.
20.05.2024 04:21:20.337981000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:20.338515000 usim_creator.handle_overflow                       [199] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:21:20.342371000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-3.28066048459356858385553105069348804124] and current target energy [-9.99820338161849473175018986878015403041]. Set energy to 0.
20.05.2024 04:21:20.351148000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:20.351963000 usim_creator.handle_overflow                       [199] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:21:20.428403000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [3.87877273235600323522943336787216930413] and current target energy [9.28747977891741998181841488311879493691]. Set energy to 0.
20.05.2024 04:21:20.437646000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:20.438415000 usim_creator.handle_overflow                       [200] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:20.444600000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-3.87877273235600323522943336787216930413] and current target energy [-9.28747977891741998181841488311879493691]. Set energy to 0.
20.05.2024 04:21:20.452357000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:20.453949000 usim_creator.handle_overflow                       [200] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:20.456063000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.87877273235600323522943336787216930413] and current target energy [6.2276111505065929590993185883698822796]. Set energy to 0.
20.05.2024 04:21:20.464846000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:20.465256000 usim_creator.handle_overflow                       [200] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:20.466386000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.87877273235600323522943336787216930413] and current target energy [6.2276111505065929590993185883698822796]. Set energy to 0.
20.05.2024 04:21:20.474085000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:20.474848000 usim_creator.handle_overflow                       [200] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:20.478216000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.87877273235600323522943336787216930413] and current target energy [-6.2276111505065929590993185883698822796]. Set energy to 0.
20.05.2024 04:21:20.486904000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:20.488171000 usim_creator.handle_overflow                       [200] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:20.492552000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.87877273235600323522943336787216930413] and current target energy [-6.2276111505065929590993185883698822796]. Set energy to 0.
20.05.2024 04:21:20.499655000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:20.499939000 usim_creator.handle_overflow                       [200] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:20.503622000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.87877273235600323522943336787216930413] and current target energy [6.414313771574871232511742205613589435]. Set energy to 0.
20.05.2024 04:21:20.518093000 usim_creator.handle_overflow                       [200] Handle pos overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [5].
20.05.2024 04:21:20.522407000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.87877273235600323522943336787216930413] and current target energy [6.414313771574871232511742205613589435]. Set energy to 0.
20.05.2024 04:21:20.536309000 usim_creator.handle_overflow                       [200] Handle pos overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [5].
20.05.2024 04:21:20.539445000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.87877273235600323522943336787216930413] and current target energy [-6.414313771574871232511742205613589435]. Set energy to 0.
20.05.2024 04:21:20.555659000 usim_creator.handle_overflow                       [200] Handle pos overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [5].
20.05.2024 04:21:20.560681000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.87877273235600323522943336787216930413] and current target energy [-6.414313771574871232511742205613589435]. Set energy to 0.
20.05.2024 04:21:20.573926000 usim_creator.handle_overflow                       [200] Handle pos overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [5].
20.05.2024 04:21:20.957369000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.006828449778368765561640863305201508913688] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:20.958083000 usim_process.process_node                          Overflow for space id [2024052004211700300000000000000000000000000000000000062] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:20.966283000 usim_creator.handle_overflow                       [205] Not implemented. Handle overflow for [2024052004211700300000000000000000000000000000000000062] escape strategy [0].
20.05.2024 04:21:20.972354000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.006828449778368765561640863305201508913688] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:20.973019000 usim_process.process_node                          Overflow for space id [2024052004211706000000000000000000000000000000000000063] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:20.981473000 usim_creator.handle_overflow                       [205] Not implemented. Handle overflow for [2024052004211706000000000000000000000000000000000000063] escape strategy [0].
20.05.2024 04:21:20.987273000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.006828449778368765561640863305201508913688] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:20.987997000 usim_process.process_node                          Overflow for space id [2024052004211711600000000000000000000000000000000000064] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:20.995262000 usim_creator.handle_overflow                       [205] Not implemented. Handle overflow for [2024052004211711600000000000000000000000000000000000064] escape strategy [0].
20.05.2024 04:21:21.000592000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.006828449778368765561640863305201508913688] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:21.001280000 usim_process.process_node                          Overflow for space id [2024052004211716600000000000000000000000000000000000065] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:21.011222000 usim_creator.handle_overflow                       [205] Not implemented. Handle overflow for [2024052004211716600000000000000000000000000000000000065] escape strategy [0].
20.05.2024 04:21:21.038508000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.05588852871345034562839554165903339168] and current target energy [8.2235541148538013825135821666361335667]. Set energy to 0.
20.05.2024 04:21:21.053896000 usim_creator.handle_overflow                       [205] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:21.073296000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.05588852871345034562839554165903339168] and current target energy [-8.2235541148538013825135821666361335667]. Set energy to 0.
20.05.2024 04:21:21.089899000 usim_creator.handle_overflow                       [205] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:21.297398000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [4.31563075651892057757185929882893367331] and current target energy [6.56132096918713716771106210138697608247]. Set energy to 0.
20.05.2024 04:21:21.317772000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:21.318967000 usim_creator.handle_overflow                       [206] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:21:21.346379000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-4.31563075651892057757185929882893367331] and current target energy [-6.56132096918713716771106210138697608247]. Set energy to 0.
20.05.2024 04:21:21.372366000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:21.378305000 usim_creator.handle_overflow                       [206] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:21:21.879944000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.006828449778368765561640863305201508913688] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:21.881444000 usim_process.process_node                          Overflow for space id [2024052004211700300000000000000000000000000000000000062] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:21.902974000 usim_creator.handle_overflow                       [209] Not implemented. Handle overflow for [2024052004211700300000000000000000000000000000000000062] escape strategy [0].
20.05.2024 04:21:21.914568000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.006828449778368765561640863305201508913688] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:21.915731000 usim_process.process_node                          Overflow for space id [2024052004211706000000000000000000000000000000000000063] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:21.933074000 usim_creator.handle_overflow                       [209] Not implemented. Handle overflow for [2024052004211706000000000000000000000000000000000000063] escape strategy [0].
20.05.2024 04:21:21.944427000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.006828449778368765561640863305201508913688] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:21.947191000 usim_process.process_node                          Overflow for space id [2024052004211711600000000000000000000000000000000000064] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:21.970475000 usim_creator.handle_overflow                       [209] Not implemented. Handle overflow for [2024052004211711600000000000000000000000000000000000064] escape strategy [0].
20.05.2024 04:21:21.986952000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.006828449778368765561640863305201508913688] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:21.994890000 usim_process.process_node                          Overflow for space id [2024052004211716600000000000000000000000000000000000065] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:22.025900000 usim_creator.handle_overflow                       [209] Not implemented. Handle overflow for [2024052004211716600000000000000000000000000000000000065] escape strategy [0].
20.05.2024 04:21:22.297763000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [.65954156925161240248247544480406249009] and current target energy [9.93192010167133970797139493351999985076]. Set energy to 0.
20.05.2024 04:21:22.320753000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:22.324088000 usim_creator.handle_overflow                       [210] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:21:22.328183000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [.65954156925161240248247544480406249009] and current target energy [9.93192010167133970797139493351999985076]. Set energy to 0.
20.05.2024 04:21:22.340227000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:22.340526000 usim_creator.handle_overflow                       [210] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:21:22.343751000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-.65954156925161240248247544480406249009] and current target energy [-9.93192010167133970797139493351999985076]. Set energy to 0.
20.05.2024 04:21:22.361582000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:22.362968000 usim_creator.handle_overflow                       [210] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:21:22.381907000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-.65954156925161240248247544480406249009] and current target energy [-9.93192010167133970797139493351999985076]. Set energy to 0.
20.05.2024 04:21:22.411180000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:22.420110000 usim_creator.handle_overflow                       [210] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:21:22.714619000 usim_process.process_queue                         Overflow for target space id [2024052004205701200000000000000000000000000000000000015] with energy [.97565944732657684807240784212186243997] and current target energy [9.86620155450284247814828448516915585124]. Set energy to 0.
20.05.2024 04:21:22.724841000 usim_creator.handle_overflow                       [211] Not implemented. Handle overflow for [2024052004205701200000000000000000000000000000000000015] escape strategy [0].
20.05.2024 04:21:22.726802000 usim_process.process_queue                         Overflow for target space id [2024052004205702800000000000000000000000000000000000017] with energy [.97565944732657684807240784212186243997] and current target energy [9.86620155450284247814828448516915585124]. Set energy to 0.
20.05.2024 04:21:22.743744000 usim_creator.handle_overflow                       [211] Not implemented. Handle overflow for [2024052004205702800000000000000000000000000000000000017] escape strategy [0].
20.05.2024 04:21:22.753114000 usim_process.process_queue                         Overflow for target space id [2024052004205711900000000000000000000000000000000000019] with energy [-.97565944732657684807240784212186243997] and current target energy [-9.86620155450284247814828448516915585124]. Set energy to 0.
20.05.2024 04:21:22.764446000 usim_creator.handle_overflow                       [211] Not implemented. Handle overflow for [2024052004205711900000000000000000000000000000000000019] escape strategy [0].
20.05.2024 04:21:22.773005000 usim_process.process_queue                         Overflow for target space id [2024052004205716200000000000000000000000000000000000021] with energy [-.97565944732657684807240784212186243997] and current target energy [-9.86620155450284247814828448516915585124]. Set energy to 0.
20.05.2024 04:21:22.779145000 usim_creator.handle_overflow                       [211] Not implemented. Handle overflow for [2024052004205716200000000000000000000000000000000000021] escape strategy [0].
20.05.2024 04:21:23.204092000 usim_process.process_queue                         Overflow for target space id [2024052004210261400000000000000000000000000000000000034] with energy [.9563774723437507744115724822362286770138] and current target energy [9.74340283035833633243447222825113912179]. Set energy to 0.
20.05.2024 04:21:23.211410000 usim_creator.handle_overflow                       [213] Not implemented. Handle overflow for [2024052004210261400000000000000000000000000000000000034] escape strategy [0].
20.05.2024 04:21:23.215082000 usim_process.process_queue                         Overflow for target space id [2024052004210264800000000000000000000000000000000000035] with energy [.9563774723437507744115724822362286770138] and current target energy [9.74340283035833633243447222825113912179]. Set energy to 0.
20.05.2024 04:21:23.219519000 usim_creator.handle_overflow                       [213] Not implemented. Handle overflow for [2024052004210264800000000000000000000000000000000000035] escape strategy [0].
20.05.2024 04:21:23.223956000 usim_process.process_queue                         Overflow for target space id [2024052004210269400000000000000000000000000000000000036] with energy [-.9563774723437507744115724822362286770138] and current target energy [-9.74340283035833633243447222825113912179]. Set energy to 0.
20.05.2024 04:21:23.231174000 usim_creator.handle_overflow                       [213] Not implemented. Handle overflow for [2024052004210269400000000000000000000000000000000000036] escape strategy [0].
20.05.2024 04:21:23.235066000 usim_process.process_queue                         Overflow for target space id [2024052004210273800000000000000000000000000000000000037] with energy [-.9563774723437507744115724822362286770138] and current target energy [-9.74340283035833633243447222825113912179]. Set energy to 0.
20.05.2024 04:21:23.241747000 usim_creator.handle_overflow                       [213] Not implemented. Handle overflow for [2024052004210273800000000000000000000000000000000000037] escape strategy [0].
20.05.2024 04:21:23.243909000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [4.53298931774010534638601258045261172602] and current target energy [9.22730738420644951507903746992812222067]. Set energy to 0.
20.05.2024 04:21:23.249314000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:23.249595000 usim_creator.handle_overflow                       [213] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:21:23.252067000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-4.53298931774010534638601258045261172602] and current target energy [-9.22730738420644951507903746992812222067]. Set energy to 0.
20.05.2024 04:21:23.262038000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:23.262679000 usim_creator.handle_overflow                       [213] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:21:23.617714000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.79307361482828918229478123913175020846] and current target energy [6.8500529486789472436063063329924184289]. Set energy to 0.
20.05.2024 04:21:23.660375000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:23.662058000 usim_creator.handle_overflow                       [216] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:23.682783000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.79307361482828918229478123913175020846] and current target energy [-6.8500529486789472436063063329924184289]. Set energy to 0.
20.05.2024 04:21:23.697484000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:23.698481000 usim_creator.handle_overflow                       [216] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:23.714886000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.79307361482828918229478123913175020846] and current target energy [9.02932469660303254903555692812845180638]. Set energy to 0.
20.05.2024 04:21:23.728097000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:23.744045000 usim_creator.handle_overflow                       [216] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:23.756218000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.79307361482828918229478123913175020846] and current target energy [9.02932469660303254903555692812845180638]. Set energy to 0.
20.05.2024 04:21:23.771032000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:23.772362000 usim_creator.handle_overflow                       [216] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:23.777742000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.79307361482828918229478123913175020846] and current target energy [-9.02932469660303254903555692812845180638]. Set energy to 0.
20.05.2024 04:21:23.788021000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:23.788342000 usim_creator.handle_overflow                       [216] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:23.791129000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.79307361482828918229478123913175020846] and current target energy [-9.02932469660303254903555692812845180638]. Set energy to 0.
20.05.2024 04:21:23.820153000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:23.825988000 usim_creator.handle_overflow                       [216] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:23.843261000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.79307361482828918229478123913175020846] and current target energy [7.9909951866277760581555944084261293184]. Set energy to 0.
20.05.2024 04:21:23.863329000 usim_creator.handle_overflow                       [216] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:21:23.874392000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.79307361482828918229478123913175020846] and current target energy [7.9909951866277760581555944084261293184]. Set energy to 0.
20.05.2024 04:21:23.892883000 usim_creator.handle_overflow                       [216] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:21:23.902935000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.79307361482828918229478123913175020846] and current target energy [-7.9909951866277760581555944084261293184]. Set energy to 0.
20.05.2024 04:21:23.921070000 usim_creator.handle_overflow                       [216] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:21:23.931346000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.79307361482828918229478123913175020846] and current target energy [-7.9909951866277760581555944084261293184]. Set energy to 0.
20.05.2024 04:21:23.953662000 usim_creator.handle_overflow                       [216] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:21:24.877196000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.39653680741414459114739061956587510423] and current target energy [9.58614722965657836458956247826350041692]. Set energy to 0.
20.05.2024 04:21:24.912342000 usim_creator.handle_overflow                       [221] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:24.921337000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.39653680741414459114739061956587510423] and current target energy [-9.58614722965657836458956247826350041692]. Set energy to 0.
20.05.2024 04:21:24.944036000 usim_creator.handle_overflow                       [221] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:25.046587000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.001859654709190039168294614543334298509038] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:25.052725000 usim_process.process_node                          Overflow for space id [2024052004211868000000000000000000000000000000000000066] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:25.070409000 usim_creator.handle_overflow                       [222] Not implemented. Handle overflow for [2024052004211868000000000000000000000000000000000000066] escape strategy [0].
20.05.2024 04:21:25.079834000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.001859654709190039168294614543334298509038] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:25.080066000 usim_process.process_node                          Overflow for space id [2024052004211870600000000000000000000000000000000000067] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:25.086926000 usim_creator.handle_overflow                       [222] Not implemented. Handle overflow for [2024052004211870600000000000000000000000000000000000067] escape strategy [0].
20.05.2024 04:21:25.109768000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.001859654709190039168294614543334298509038] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:25.111010000 usim_process.process_node                          Overflow for space id [2024052004211874300000000000000000000000000000000000068] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:25.132742000 usim_creator.handle_overflow                       [222] Not implemented. Handle overflow for [2024052004211874300000000000000000000000000000000000068] escape strategy [0].
20.05.2024 04:21:25.153122000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.001859654709190039168294614543334298509038] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:25.153743000 usim_process.process_node                          Overflow for space id [2024052004211878000000000000000000000000000000000000069] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:25.174199000 usim_creator.handle_overflow                       [222] Not implemented. Handle overflow for [2024052004211878000000000000000000000000000000000000069] escape strategy [0].
20.05.2024 04:21:25.483488000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.001859654709190039168294614543334298509038] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:25.496475000 usim_process.process_node                          Overflow for space id [2024052004211868000000000000000000000000000000000000066] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:25.517782000 usim_creator.handle_overflow                       [224] Not implemented. Handle overflow for [2024052004211868000000000000000000000000000000000000066] escape strategy [0].
20.05.2024 04:21:25.531061000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.001859654709190039168294614543334298509038] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:25.532062000 usim_process.process_node                          Overflow for space id [2024052004211870600000000000000000000000000000000000067] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:25.547352000 usim_creator.handle_overflow                       [224] Not implemented. Handle overflow for [2024052004211870600000000000000000000000000000000000067] escape strategy [0].
20.05.2024 04:21:25.561003000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.001859654709190039168294614543334298509038] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:25.591995000 usim_process.process_node                          Overflow for space id [2024052004211874300000000000000000000000000000000000068] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:25.612132000 usim_creator.handle_overflow                       [224] Not implemented. Handle overflow for [2024052004211874300000000000000000000000000000000000068] escape strategy [0].
20.05.2024 04:21:25.625205000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.001859654709190039168294614543334298509038] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:25.630300000 usim_process.process_node                          Overflow for space id [2024052004211878000000000000000000000000000000000000069] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:25.657780000 usim_creator.handle_overflow                       [224] Not implemented. Handle overflow for [2024052004211878000000000000000000000000000000000000069] escape strategy [0].
20.05.2024 04:21:26.119564000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [4.86931505906511273257812409174388988134] and current target energy [5.78689058545964579906098337957249871293]. Set energy to 0.
20.05.2024 04:21:26.147441000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:26.147750000 usim_creator.handle_overflow                       [226] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:21:26.149914000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-4.86931505906511273257812409174388988134] and current target energy [-5.78689058545964579906098337957249871293]. Set energy to 0.
20.05.2024 04:21:26.167844000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:26.190524000 usim_creator.handle_overflow                       [226] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:21:26.412452000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.60270415883488779525392886608442982436] and current target energy [9.60711740407176981695668000269127125671]. Set energy to 0.
20.05.2024 04:21:26.430702000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:26.431962000 usim_creator.handle_overflow                       [227] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:21:26.449513000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.60270415883488779525392886608442982436] and current target energy [9.60711740407176981695668000269127125671]. Set energy to 0.
20.05.2024 04:21:26.470468000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:26.480143000 usim_creator.handle_overflow                       [227] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:21:26.493623000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.60270415883488779525392886608442982436] and current target energy [-9.60711740407176981695668000269127125671]. Set energy to 0.
20.05.2024 04:21:26.514559000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:26.515287000 usim_creator.handle_overflow                       [227] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:21:26.533028000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.60270415883488779525392886608442982436] and current target energy [-9.60711740407176981695668000269127125671]. Set energy to 0.
20.05.2024 04:21:26.550904000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:26.552186000 usim_creator.handle_overflow                       [227] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:21:26.785102000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [3.10468416520090817935204845435635177966] and current target energy [9.73653024054489509769925889220926018535]. Set energy to 0.
20.05.2024 04:21:26.813877000 usim_creator.handle_overflow                       [228] Handle pos overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [3].
20.05.2024 04:21:26.832303000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-3.10468416520090817935204845435635177966] and current target energy [-9.73653024054489509769925889220926018535]. Set energy to 0.
20.05.2024 04:21:26.857672000 usim_creator.handle_overflow                       [228] Handle pos overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [3].
20.05.2024 04:21:27.714505000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.87460316327047511759707373000711113727] and current target energy [9.42281751931383485814160690936041043011]. Set energy to 0.
20.05.2024 04:21:27.743398000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:27.744185000 usim_creator.handle_overflow                       [232] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:27.772239000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.87460316327047511759707373000711113727] and current target energy [-9.42281751931383485814160690936041043011]. Set energy to 0.
20.05.2024 04:21:27.791143000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:27.792340000 usim_creator.handle_overflow                       [232] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:27.812835000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.87460316327047511759707373000711113727] and current target energy [8.46453290099556663121641322329949179134]. Set energy to 0.
20.05.2024 04:21:27.825134000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:27.826221000 usim_creator.handle_overflow                       [232] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:27.833820000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.87460316327047511759707373000711113727] and current target energy [8.46453290099556663121641322329949179134]. Set energy to 0.
20.05.2024 04:21:27.861715000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:27.862778000 usim_creator.handle_overflow                       [232] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:27.865937000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.87460316327047511759707373000711113727] and current target energy [-8.46453290099556663121641322329949179134]. Set energy to 0.
20.05.2024 04:21:27.874119000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:27.875223000 usim_creator.handle_overflow                       [232] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:27.877996000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.87460316327047511759707373000711113727] and current target energy [-8.46453290099556663121641322329949179134]. Set energy to 0.
20.05.2024 04:21:27.904693000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:27.924020000 usim_creator.handle_overflow                       [232] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:27.935230000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.87460316327047511759707373000711113727] and current target energy [6.93561508530909994276110932479008670465]. Set energy to 0.
20.05.2024 04:21:27.966002000 usim_creator.handle_overflow                       [232] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:21:27.986005000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.87460316327047511759707373000711113727] and current target energy [6.93561508530909994276110932479008670465]. Set energy to 0.
20.05.2024 04:21:28.005150000 usim_creator.handle_overflow                       [232] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:21:28.025976000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.87460316327047511759707373000711113727] and current target energy [-6.93561508530909994276110932479008670465]. Set energy to 0.
20.05.2024 04:21:28.049079000 usim_creator.handle_overflow                       [232] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:21:28.064676000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.87460316327047511759707373000711113727] and current target energy [-6.93561508530909994276110932479008670465]. Set energy to 0.
20.05.2024 04:21:28.072549000 usim_creator.handle_overflow                       [232] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:21:28.335629000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [1.55234208260045408967602422717817588983] and current target energy [9.73863011813022546515624818348777976268]. Set energy to 0.
20.05.2024 04:21:28.346770000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:28.347081000 usim_creator.handle_overflow                       [233] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:21:28.351498000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-1.55234208260045408967602422717817588983] and current target energy [-9.73863011813022546515624818348777976268]. Set energy to 0.
20.05.2024 04:21:28.367042000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:28.367791000 usim_creator.handle_overflow                       [233] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:21:28.642061000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.005385469912215348369403547740188204515363] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:28.642996000 usim_process.process_node                          Overflow for space id [2024052004211868000000000000000000000000000000000000066] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:28.653359000 usim_creator.handle_overflow                       [236] Not implemented. Handle overflow for [2024052004211868000000000000000000000000000000000000066] escape strategy [0].
20.05.2024 04:21:28.661100000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.005385469912215348369403547740188204515363] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:28.661753000 usim_process.process_node                          Overflow for space id [2024052004211870600000000000000000000000000000000000067] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:28.669701000 usim_creator.handle_overflow                       [236] Not implemented. Handle overflow for [2024052004211870600000000000000000000000000000000000067] escape strategy [0].
20.05.2024 04:21:28.676120000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.005385469912215348369403547740188204515363] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:28.676353000 usim_process.process_node                          Overflow for space id [2024052004211874300000000000000000000000000000000000068] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:28.680896000 usim_creator.handle_overflow                       [236] Not implemented. Handle overflow for [2024052004211874300000000000000000000000000000000000068] escape strategy [0].
20.05.2024 04:21:28.686300000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.005385469912215348369403547740188204515363] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:28.686490000 usim_process.process_node                          Overflow for space id [2024052004211878000000000000000000000000000000000000069] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:28.694067000 usim_creator.handle_overflow                       [236] Not implemented. Handle overflow for [2024052004211878000000000000000000000000000000000000069] escape strategy [0].
20.05.2024 04:21:28.879688000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.005385469912215348369403547740188204515363] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:28.880521000 usim_process.process_node                          Overflow for space id [2024052004211868000000000000000000000000000000000000066] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:28.888473000 usim_creator.handle_overflow                       [238] Not implemented. Handle overflow for [2024052004211868000000000000000000000000000000000000066] escape strategy [0].
20.05.2024 04:21:28.894810000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.005385469912215348369403547740188204515363] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:28.896260000 usim_process.process_node                          Overflow for space id [2024052004211870600000000000000000000000000000000000067] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:28.904350000 usim_creator.handle_overflow                       [238] Not implemented. Handle overflow for [2024052004211870600000000000000000000000000000000000067] escape strategy [0].
20.05.2024 04:21:28.910056000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.005385469912215348369403547740188204515363] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:28.910279000 usim_process.process_node                          Overflow for space id [2024052004211874300000000000000000000000000000000000068] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:28.917895000 usim_creator.handle_overflow                       [238] Not implemented. Handle overflow for [2024052004211874300000000000000000000000000000000000068] escape strategy [0].
20.05.2024 04:21:28.924224000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.005385469912215348369403547740188204515363] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:28.924866000 usim_process.process_node                          Overflow for space id [2024052004211878000000000000000000000000000000000000069] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:28.935159000 usim_creator.handle_overflow                       [238] Not implemented. Handle overflow for [2024052004211878000000000000000000000000000000000000069] escape strategy [0].
20.05.2024 04:21:28.969870000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [1.46325748500055454585410869453871242699] and current target energy [8.98254154299351347802468360739442603878]. Set energy to 0.
20.05.2024 04:21:28.978835000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:28.979594000 usim_creator.handle_overflow                       [238] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:21:28.982382000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [1.46325748500055454585410869453871242699] and current target energy [8.98254154299351347802468360739442603878]. Set energy to 0.
20.05.2024 04:21:28.988554000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:28.988788000 usim_creator.handle_overflow                       [238] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:21:28.990832000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-1.46325748500055454585410869453871242699] and current target energy [-8.98254154299351347802468360739442603878]. Set energy to 0.
20.05.2024 04:21:28.997564000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:28.999104000 usim_creator.handle_overflow                       [238] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:21:29.000940000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-1.46325748500055454585410869453871242699] and current target energy [-8.98254154299351347802468360739442603878]. Set energy to 0.
20.05.2024 04:21:29.007522000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:29.007834000 usim_creator.handle_overflow                       [238] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:21:29.807069000 usim_process.process_queue                         Overflow for target space id [2024052004205948300000000000000000000000000000000000024] with energy [.8148331948958818695980992824691230332888] and current target energy [9.86567996393186850062450405797894486849]. Set energy to 0.
20.05.2024 04:21:29.827623000 usim_creator.handle_overflow                       [242] Not implemented. Handle overflow for [2024052004205948300000000000000000000000000000000000024] escape strategy [0].
20.05.2024 04:21:29.834428000 usim_process.process_queue                         Overflow for target space id [2024052004205949500000000000000000000000000000000000025] with energy [.8148331948958818695980992824691230332888] and current target energy [9.86567996393186850062450405797894486849]. Set energy to 0.
20.05.2024 04:21:29.848761000 usim_creator.handle_overflow                       [242] Not implemented. Handle overflow for [2024052004205949500000000000000000000000000000000000025] escape strategy [0].
20.05.2024 04:21:29.852520000 usim_process.process_queue                         Overflow for target space id [2024052004205950700000000000000000000000000000000000026] with energy [-.8148331948958818695980992824691230332888] and current target energy [-9.86567996393186850062450405797894486849]. Set energy to 0.
20.05.2024 04:21:29.873888000 usim_creator.handle_overflow                       [242] Not implemented. Handle overflow for [2024052004205950700000000000000000000000000000000000026] escape strategy [0].
20.05.2024 04:21:29.884703000 usim_process.process_queue                         Overflow for target space id [2024052004205952100000000000000000000000000000000000027] with energy [-.8148331948958818695980992824691230332888] and current target energy [-9.86567996393186850062450405797894486849]. Set energy to 0.
20.05.2024 04:21:29.897576000 usim_creator.handle_overflow                       [242] Not implemented. Handle overflow for [2024052004205952100000000000000000000000000000000000027] escape strategy [0].
20.05.2024 04:21:29.926468000 usim_process.process_queue                         Overflow for target space id [2024052004210570400000000000000000000000000000000000038] with energy [.7766884100636915794987379855285972161713] and current target energy [9.41637936607083865035890541538596274138]. Set energy to 0.
20.05.2024 04:21:29.947601000 usim_creator.handle_overflow                       [242] Not implemented. Handle overflow for [2024052004210570400000000000000000000000000000000000038] escape strategy [0].
20.05.2024 04:21:29.967202000 usim_process.process_queue                         Overflow for target space id [2024052004210571900000000000000000000000000000000000039] with energy [.7766884100636915794987379855285972161713] and current target energy [9.41637936607083865035890541538596274138]. Set energy to 0.
20.05.2024 04:21:29.990308000 usim_creator.handle_overflow                       [242] Not implemented. Handle overflow for [2024052004210571900000000000000000000000000000000000039] escape strategy [0].
20.05.2024 04:21:30.002631000 usim_process.process_queue                         Overflow for target space id [2024052004210573600000000000000000000000000000000000040] with energy [-.7766884100636915794987379855285972161713] and current target energy [-9.41637936607083865035890541538596274138]. Set energy to 0.
20.05.2024 04:21:30.015229000 usim_creator.handle_overflow                       [242] Not implemented. Handle overflow for [2024052004210573600000000000000000000000000000000000040] escape strategy [0].
20.05.2024 04:21:30.033474000 usim_process.process_queue                         Overflow for target space id [2024052004210575900000000000000000000000000000000000041] with energy [-.7766884100636915794987379855285972161713] and current target energy [-9.41637936607083865035890541538596274138]. Set energy to 0.
20.05.2024 04:21:30.050873000 usim_creator.handle_overflow                       [242] Not implemented. Handle overflow for [2024052004210575900000000000000000000000000000000000041] escape strategy [0].
20.05.2024 04:21:30.270526000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [2.61594869012846244939992354754430260667] and current target energy [8.37103580841107983807975535214176834131]. Set energy to 0.
20.05.2024 04:21:30.294381000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:30.303521000 usim_creator.handle_overflow                       [243] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:21:30.314421000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-2.61594869012846244939992354754430260667] and current target energy [-8.37103580841107983807975535214176834131]. Set energy to 0.
20.05.2024 04:21:30.337239000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:30.338505000 usim_creator.handle_overflow                       [243] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:21:30.531656000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.8952275902352767704053667441786566287] and current target energy [9.74920632654095023519414746001422227454]. Set energy to 0.
20.05.2024 04:21:30.541639000 usim_creator.handle_overflow                       [245] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:30.547117000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.8952275902352767704053667441786566287] and current target energy [-9.74920632654095023519414746001422227454]. Set energy to 0.
20.05.2024 04:21:30.551771000 usim_creator.handle_overflow                       [245] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:31.060243000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.001435007140005014175560286891995207399513] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:31.062476000 usim_process.process_node                          Overflow for space id [2024052004212051500000000000000000000000000000000000074] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:31.090461000 usim_creator.handle_overflow                       [249] Not implemented. Handle overflow for [2024052004212051500000000000000000000000000000000000074] escape strategy [0].
20.05.2024 04:21:31.109345000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.001435007140005014175560286891995207399513] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:31.111000000 usim_process.process_node                          Overflow for space id [2024052004212053400000000000000000000000000000000000075] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:31.150199000 usim_creator.handle_overflow                       [249] Not implemented. Handle overflow for [2024052004212053400000000000000000000000000000000000075] escape strategy [0].
20.05.2024 04:21:31.166406000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.001435007140005014175560286891995207399513] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:31.174465000 usim_process.process_node                          Overflow for space id [2024052004212055400000000000000000000000000000000000076] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:31.201416000 usim_creator.handle_overflow                       [249] Not implemented. Handle overflow for [2024052004212055400000000000000000000000000000000000076] escape strategy [0].
20.05.2024 04:21:31.218647000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.001435007140005014175560286891995207399513] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:31.227127000 usim_process.process_node                          Overflow for space id [2024052004212057200000000000000000000000000000000000077] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:31.246221000 usim_creator.handle_overflow                       [249] Not implemented. Handle overflow for [2024052004212057200000000000000000000000000000000000077] escape strategy [0].
20.05.2024 04:21:31.687480000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [1.16087200535421651733870314067980750172] and current target energy [9.76688383492863432593382401602771751414]. Set energy to 0.
20.05.2024 04:21:31.704488000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:31.718490000 usim_creator.handle_overflow                       [251] Not implemented. Handle overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [7].
20.05.2024 04:21:31.725752000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [1.16087200535421651733870314067980750172] and current target energy [9.76688383492863432593382401602771751414]. Set energy to 0.
20.05.2024 04:21:31.739730000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:31.750009000 usim_creator.handle_overflow                       [251] Not implemented. Handle overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [7].
20.05.2024 04:21:31.780300000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-1.16087200535421651733870314067980750172] and current target energy [-9.76688383492863432593382401602771751414]. Set energy to 0.
20.05.2024 04:21:31.798427000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:31.799840000 usim_creator.handle_overflow                       [251] Not implemented. Handle overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [7].
20.05.2024 04:21:31.816645000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-1.16087200535421651733870314067980750172] and current target energy [-9.76688383492863432593382401602771751414]. Set energy to 0.
20.05.2024 04:21:31.834682000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:31.835373000 usim_creator.handle_overflow                       [251] Not implemented. Handle overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [7].
20.05.2024 04:21:32.473509000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [2.90839893923638209441631982395513852722] and current target energy [7.4480778527399884586254016197496699382]. Set energy to 0.
20.05.2024 04:21:32.494248000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:32.499900000 usim_creator.handle_overflow                       [254] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:21:32.521013000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-2.90839893923638209441631982395513852722] and current target energy [-7.4480778527399884586254016197496699382]. Set energy to 0.
20.05.2024 04:21:32.538034000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:32.538796000 usim_creator.handle_overflow                       [254] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:21:32.729700000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.26062934470182131707008156253141772026] and current target energy [8.80706825073882995148542623484920251334]. Set energy to 0.
20.05.2024 04:21:32.760299000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:32.764936000 usim_creator.handle_overflow                       [255] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:21:32.767812000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.26062934470182131707008156253141772026] and current target energy [8.80706825073882995148542623484920251334]. Set energy to 0.
20.05.2024 04:21:32.785195000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:32.785531000 usim_creator.handle_overflow                       [255] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:21:32.787729000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.26062934470182131707008156253141772026] and current target energy [-8.80706825073882995148542623484920251334]. Set energy to 0.
20.05.2024 04:21:32.796276000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:32.796609000 usim_creator.handle_overflow                       [255] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:21:32.798908000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.26062934470182131707008156253141772026] and current target energy [-8.80706825073882995148542623484920251334]. Set energy to 0.
20.05.2024 04:21:32.807217000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:32.807574000 usim_creator.handle_overflow                       [255] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:21:32.991068000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [2.21618047248306355982555452466106472487] and current target energy [8.86472188993225423930221809864425889948]. Set energy to 0.
20.05.2024 04:21:33.001880000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:33.003068000 usim_creator.handle_overflow                       [256] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:21:33.007146000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-2.21618047248306355982555452466106472487] and current target energy [-8.86472188993225423930221809864425889948]. Set energy to 0.
20.05.2024 04:21:33.013732000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:33.019305000 usim_creator.handle_overflow                       [256] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:21:33.164465000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.0908855524475295515159114289627379017] and current target energy [9.36514554110103661525425203245968947948]. Set energy to 0.
20.05.2024 04:21:33.180575000 usim_creator.handle_overflow                       [257] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:33.183228000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.0908855524475295515159114289627379017] and current target energy [-9.36514554110103661525425203245968947948]. Set energy to 0.
20.05.2024 04:21:33.196988000 usim_creator.handle_overflow                       [257] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:33.353083000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.5413869339137272805509012117861293355] and current target energy [8.96760961636590704585521423027927664074]. Set energy to 0.
20.05.2024 04:21:33.371049000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:33.383265000 usim_creator.handle_overflow                       [258] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:33.397826000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.5413869339137272805509012117861293355] and current target energy [-8.96760961636590704585521423027927664074]. Set energy to 0.
20.05.2024 04:21:33.416453000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:33.428541000 usim_creator.handle_overflow                       [258] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:33.803835000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.00412498993833262227825507979991049877455] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:33.819721000 usim_process.process_node                          Overflow for space id [2024052004212051500000000000000000000000000000000000074] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:33.834070000 usim_creator.handle_overflow                       [261] Not implemented. Handle overflow for [2024052004212051500000000000000000000000000000000000074] escape strategy [0].
20.05.2024 04:21:33.841698000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.00412498993833262227825507979991049877455] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:33.841915000 usim_process.process_node                          Overflow for space id [2024052004212053400000000000000000000000000000000000075] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:33.855643000 usim_creator.handle_overflow                       [261] Not implemented. Handle overflow for [2024052004212053400000000000000000000000000000000000075] escape strategy [0].
20.05.2024 04:21:33.870177000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.00412498993833262227825507979991049877455] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:33.871156000 usim_process.process_node                          Overflow for space id [2024052004212055400000000000000000000000000000000000076] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:33.888893000 usim_creator.handle_overflow                       [261] Not implemented. Handle overflow for [2024052004212055400000000000000000000000000000000000076] escape strategy [0].
20.05.2024 04:21:33.909745000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.00412498993833262227825507979991049877455] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:33.910755000 usim_process.process_node                          Overflow for space id [2024052004212057200000000000000000000000000000000000077] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:33.932792000 usim_creator.handle_overflow                       [261] Not implemented. Handle overflow for [2024052004212057200000000000000000000000000000000000077] escape strategy [0].
20.05.2024 04:21:35.107678000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [3.54890397334412565968520980423231742533] and current target energy [6.70305441192299075992655965521519411749]. Set energy to 0.
20.05.2024 04:21:35.135172000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:35.135489000 usim_creator.handle_overflow                       [267] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:21:35.138684000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-3.54890397334412565968520980423231742533] and current target energy [-6.70305441192299075992655965521519411749]. Set energy to 0.
20.05.2024 04:21:35.147277000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:35.147621000 usim_creator.handle_overflow                       [267] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:21:35.355511000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [1.01247574724726424958257568523319668709] and current target energy [9.37443228421428849079250982277048184296]. Set energy to 0.
20.05.2024 04:21:35.394785000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:35.396062000 usim_creator.handle_overflow                       [268] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:35.417084000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [1.01247574724726424958257568523319668709] and current target energy [9.37443228421428849079250982277048184296]. Set energy to 0.
20.05.2024 04:21:35.433914000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:35.434315000 usim_creator.handle_overflow                       [268] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:35.441174000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-1.01247574724726424958257568523319668709] and current target energy [-9.37443228421428849079250982277048184296]. Set energy to 0.
20.05.2024 04:21:35.459926000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:35.461030000 usim_creator.handle_overflow                       [268] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:35.473615000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-1.01247574724726424958257568523319668709] and current target energy [-9.37443228421428849079250982277048184296]. Set energy to 0.
20.05.2024 04:21:35.492357000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:35.496408000 usim_creator.handle_overflow                       [268] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:35.839790000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [2.27069346695686364027545060589306466775] and current target energy [9.082773867827454561101802423572258671]. Set energy to 0.
20.05.2024 04:21:35.855001000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:35.856309000 usim_creator.handle_overflow                       [269] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:21:35.882400000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-2.27069346695686364027545060589306466775] and current target energy [-9.082773867827454561101802423572258671]. Set energy to 0.
20.05.2024 04:21:35.898797000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:35.900808000 usim_creator.handle_overflow                       [269] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:21:36.316701000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [1.21653037826394592511776933562016301116] and current target energy [9.7322430261115674009421546849613040893]. Set energy to 0.
20.05.2024 04:21:36.367065000 usim_creator.handle_overflow                       [272] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:21:36.384260000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [1.21653037826394592511776933562016301116] and current target energy [9.7322430261115674009421546849613040893]. Set energy to 0.
20.05.2024 04:21:36.412860000 usim_creator.handle_overflow                       [272] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:21:36.423577000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-1.21653037826394592511776933562016301116] and current target energy [-9.7322430261115674009421546849613040893]. Set energy to 0.
20.05.2024 04:21:36.436264000 usim_creator.handle_overflow                       [272] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:21:36.455815000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-1.21653037826394592511776933562016301116] and current target energy [-9.7322430261115674009421546849613040893]. Set energy to 0.
20.05.2024 04:21:36.469287000 usim_creator.handle_overflow                       [272] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:21:36.579831000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.008778181797166315004775863359699830719275] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:36.596298000 usim_process.process_node                          Overflow for space id [2024052004212051500000000000000000000000000000000000074] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:36.621088000 usim_creator.handle_overflow                       [273] Not implemented. Handle overflow for [2024052004212051500000000000000000000000000000000000074] escape strategy [0].
20.05.2024 04:21:36.645490000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.008778181797166315004775863359699830719275] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:36.646913000 usim_process.process_node                          Overflow for space id [2024052004212053400000000000000000000000000000000000075] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:36.668804000 usim_creator.handle_overflow                       [273] Not implemented. Handle overflow for [2024052004212053400000000000000000000000000000000000075] escape strategy [0].
20.05.2024 04:21:36.680437000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.008778181797166315004775863359699830719275] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:36.680662000 usim_process.process_node                          Overflow for space id [2024052004212055400000000000000000000000000000000000076] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:36.701512000 usim_creator.handle_overflow                       [273] Not implemented. Handle overflow for [2024052004212055400000000000000000000000000000000000076] escape strategy [0].
20.05.2024 04:21:36.714863000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.008778181797166315004775863359699830719275] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:36.715965000 usim_process.process_node                          Overflow for space id [2024052004212057200000000000000000000000000000000000077] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:36.730897000 usim_creator.handle_overflow                       [273] Not implemented. Handle overflow for [2024052004212057200000000000000000000000000000000000077] escape strategy [0].
20.05.2024 04:21:37.486586000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [4.15459391440408987991400274744371368637] and current target energy [7.49256148145351187881427956171407558381]. Set energy to 0.
20.05.2024 04:21:37.508792000 usim_creator.handle_overflow                       [277] Handle pos overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [3].
20.05.2024 04:21:37.519180000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-4.15459391440408987991400274744371368637] and current target energy [-7.49256148145351187881427956171407558381]. Set energy to 0.
20.05.2024 04:21:37.534118000 usim_creator.handle_overflow                       [277] Handle pos overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [3].
20.05.2024 04:21:37.726487000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [2.2430308793088658363676141420820822975] and current target energy [7.91368856763070037243113740967012202576]. Set energy to 0.
20.05.2024 04:21:37.756788000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:37.758049000 usim_creator.handle_overflow                       [278] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:21:37.788105000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [2.2430308793088658363676141420820822975] and current target energy [7.91368856763070037243113740967012202576]. Set energy to 0.
20.05.2024 04:21:37.802877000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:37.804386000 usim_creator.handle_overflow                       [278] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:21:37.818422000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-2.2430308793088658363676141420820822975] and current target energy [-7.91368856763070037243113740967012202576]. Set energy to 0.
20.05.2024 04:21:37.828495000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:37.857233000 usim_creator.handle_overflow                       [278] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:21:37.873048000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-2.2430308793088658363676141420820822975] and current target energy [-7.91368856763070037243113740967012202576]. Set energy to 0.
20.05.2024 04:21:37.904520000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:37.917071000 usim_creator.handle_overflow                       [278] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:21:39.737047000 usim_process.process_queue                         Overflow for target space id [2024052004211990800000000000000000000000000000000000070] with energy [2.32760308721583817818652515564073341258] and current target energy [8.82664109857097375226920043305376826619]. Set energy to 0.
20.05.2024 04:21:39.759323000 usim_creator.handle_overflow                       [288] Handle pos overflow for [2024052004211990800000000000000000000000000000000000070] escape strategy [3].
20.05.2024 04:21:39.772803000 usim_process.process_queue                         Overflow for target space id [2024052004211994200000000000000000000000000000000000071] with energy [2.32760308721583817818652515564073341258] and current target energy [8.82664109857097375226920043305376826619]. Set energy to 0.
20.05.2024 04:21:39.804165000 usim_creator.handle_overflow                       [288] Handle pos overflow for [2024052004211994200000000000000000000000000000000000071] escape strategy [3].
20.05.2024 04:21:39.807489000 usim_process.process_queue                         Overflow for target space id [2024052004211998600000000000000000000000000000000000072] with energy [-2.32760308721583817818652515564073341258] and current target energy [-8.82664109857097375226920043305376826619]. Set energy to 0.
20.05.2024 04:21:39.834987000 usim_creator.handle_overflow                       [288] Handle pos overflow for [2024052004211998600000000000000000000000000000000000072] escape strategy [3].
20.05.2024 04:21:39.848307000 usim_process.process_queue                         Overflow for target space id [2024052004212000300000000000000000000000000000000000073] with energy [-2.32760308721583817818652515564073341258] and current target energy [-8.82664109857097375226920043305376826619]. Set energy to 0.
20.05.2024 04:21:39.870884000 usim_creator.handle_overflow                       [288] Handle pos overflow for [2024052004212000300000000000000000000000000000000000073] escape strategy [3].
20.05.2024 04:21:40.086627000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.88363135648122065635484805589415239384] and current target energy [8.48399642840149473278915415972062063204]. Set energy to 0.
20.05.2024 04:21:40.097429000 usim_creator.handle_overflow                       [289] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:40.100225000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.88363135648122065635484805589415239384] and current target energy [-8.48399642840149473278915415972062063204]. Set energy to 0.
20.05.2024 04:21:40.114556000 usim_creator.handle_overflow                       [289] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:40.135164000 usim_process.process_queue                         Overflow for target space id [2024052004210261400000000000000000000000000000000000034] with energy [.8392255405262238921402647747509794255275] and current target energy [9.31993131227488055915845851598289784686]. Set energy to 0.
20.05.2024 04:21:40.155684000 usim_creator.handle_overflow                       [289] Not implemented. Handle overflow for [2024052004210261400000000000000000000000000000000000034] escape strategy [0].
20.05.2024 04:21:40.165049000 usim_process.process_queue                         Overflow for target space id [2024052004210264800000000000000000000000000000000000035] with energy [.8392255405262238921402647747509794255275] and current target energy [9.31993131227488055915845851598289784686]. Set energy to 0.
20.05.2024 04:21:40.183632000 usim_creator.handle_overflow                       [289] Not implemented. Handle overflow for [2024052004210264800000000000000000000000000000000000035] escape strategy [0].
20.05.2024 04:21:40.197272000 usim_process.process_queue                         Overflow for target space id [2024052004210269400000000000000000000000000000000000036] with energy [-.8392255405262238921402647747509794255275] and current target energy [-9.31993131227488055915845851598289784686]. Set energy to 0.
20.05.2024 04:21:40.218063000 usim_creator.handle_overflow                       [289] Not implemented. Handle overflow for [2024052004210269400000000000000000000000000000000000036] escape strategy [0].
20.05.2024 04:21:40.233584000 usim_process.process_queue                         Overflow for target space id [2024052004210273800000000000000000000000000000000000037] with energy [-.8392255405262238921402647747509794255275] and current target energy [-9.31993131227488055915845851598289784686]. Set energy to 0.
20.05.2024 04:21:40.255611000 usim_creator.handle_overflow                       [289] Not implemented. Handle overflow for [2024052004210273800000000000000000000000000000000000037] escape strategy [0].
20.05.2024 04:21:40.270209000 usim_process.process_queue                         Overflow for target space id [2024052004210931900000000000000000000000000000000000044] with energy [.970528746157195850565954856739045099225] and current target energy [9.36078656942053326553847214328625475442]. Set energy to 0.
20.05.2024 04:21:40.300272000 usim_creator.handle_overflow                       [289] Not implemented. Handle overflow for [2024052004210931900000000000000000000000000000000000044] escape strategy [0].
20.05.2024 04:21:40.310928000 usim_process.process_queue                         Overflow for target space id [2024052004210936800000000000000000000000000000000000045] with energy [.970528746157195850565954856739045099225] and current target energy [9.36078656942053326553847214328625475442]. Set energy to 0.
20.05.2024 04:21:40.326059000 usim_creator.handle_overflow                       [289] Not implemented. Handle overflow for [2024052004210936800000000000000000000000000000000000045] escape strategy [0].
20.05.2024 04:21:40.340991000 usim_process.process_queue                         Overflow for target space id [2024052004210941800000000000000000000000000000000000046] with energy [-.970528746157195850565954856739045099225] and current target energy [-9.36078656942053326553847214328625475442]. Set energy to 0.
20.05.2024 04:21:40.353823000 usim_creator.handle_overflow                       [289] Not implemented. Handle overflow for [2024052004210941800000000000000000000000000000000000046] escape strategy [0].
20.05.2024 04:21:40.366108000 usim_process.process_queue                         Overflow for target space id [2024052004210944800000000000000000000000000000000000047] with energy [-.970528746157195850565954856739045099225] and current target energy [-9.36078656942053326553847214328625475442]. Set energy to 0.
20.05.2024 04:21:40.382418000 usim_creator.handle_overflow                       [289] Not implemented. Handle overflow for [2024052004210944800000000000000000000000000000000000047] escape strategy [0].
20.05.2024 04:21:40.590291000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [4.53360624065454077243008278292178269525] and current target energy [8.13419636780168714224493080583581945355]. Set energy to 0.
20.05.2024 04:21:40.604845000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:40.605965000 usim_creator.handle_overflow                       [290] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:21:40.625323000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-4.53360624065454077243008278292178269525] and current target energy [-8.13419636780168714224493080583581945355]. Set energy to 0.
20.05.2024 04:21:40.654699000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:40.667700000 usim_creator.handle_overflow                       [290] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:21:41.168994000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [3.28867683932197338041458726014464936526] and current target energy [8.30918782880817975982800549488742737274]. Set energy to 0.
20.05.2024 04:21:41.209551000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:41.212116000 usim_creator.handle_overflow                       [292] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:21:41.226208000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-3.28867683932197338041458726014464936526] and current target energy [-8.30918782880817975982800549488742737274]. Set energy to 0.
20.05.2024 04:21:41.239956000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:41.242371000 usim_creator.handle_overflow                       [292] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:21:41.458520000 usim_process.process_queue                         Overflow for target space id [2024052004205701200000000000000000000000000000000000015] with energy [.945707621798807235345006910172775513845] and current target energy [9.95253976431162164709732813668570980399]. Set energy to 0.
20.05.2024 04:21:41.466563000 usim_creator.handle_overflow                       [293] Not implemented. Handle overflow for [2024052004205701200000000000000000000000000000000000015] escape strategy [0].
20.05.2024 04:21:41.471035000 usim_process.process_queue                         Overflow for target space id [2024052004205702800000000000000000000000000000000000017] with energy [.945707621798807235345006910172775513845] and current target energy [9.95253976431162164709732813668570980399]. Set energy to 0.
20.05.2024 04:21:41.479397000 usim_creator.handle_overflow                       [293] Not implemented. Handle overflow for [2024052004205702800000000000000000000000000000000000017] escape strategy [0].
20.05.2024 04:21:41.483337000 usim_process.process_queue                         Overflow for target space id [2024052004205711900000000000000000000000000000000000019] with energy [-.945707621798807235345006910172775513845] and current target energy [-9.95253976431162164709732813668570980399]. Set energy to 0.
20.05.2024 04:21:41.491317000 usim_creator.handle_overflow                       [293] Not implemented. Handle overflow for [2024052004205711900000000000000000000000000000000000019] escape strategy [0].
20.05.2024 04:21:41.495245000 usim_process.process_queue                         Overflow for target space id [2024052004205716200000000000000000000000000000000000021] with energy [-.945707621798807235345006910172775513845] and current target energy [-9.95253976431162164709732813668570980399]. Set energy to 0.
20.05.2024 04:21:41.502289000 usim_creator.handle_overflow                       [293] Not implemented. Handle overflow for [2024052004205716200000000000000000000000000000000000021] escape strategy [0].
20.05.2024 04:21:42.070255000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.59308355224180937723097007012647769619] and current target energy [8.78369821655253002235763099023114831625]. Set energy to 0.
20.05.2024 04:21:42.094067000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:42.094385000 usim_creator.handle_overflow                       [296] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:42.104002000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.59308355224180937723097007012647769619] and current target energy [-8.78369821655253002235763099023114831625]. Set energy to 0.
20.05.2024 04:21:42.119608000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:42.133646000 usim_creator.handle_overflow                       [296] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:42.142061000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.59308355224180937723097007012647769619] and current target energy [9.58863599241470748656624929027476246849]. Set energy to 0.
20.05.2024 04:21:42.166650000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:42.172064000 usim_creator.handle_overflow                       [296] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:42.182795000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.59308355224180937723097007012647769619] and current target energy [9.58863599241470748656624929027476246849]. Set energy to 0.
20.05.2024 04:21:42.191363000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:42.192132000 usim_creator.handle_overflow                       [296] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:42.198226000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.59308355224180937723097007012647769619] and current target energy [-9.58863599241470748656624929027476246849]. Set energy to 0.
20.05.2024 04:21:42.219028000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:42.224179000 usim_creator.handle_overflow                       [296] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:42.226963000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.59308355224180937723097007012647769619] and current target energy [-9.58863599241470748656624929027476246849]. Set energy to 0.
20.05.2024 04:21:42.255994000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:42.257064000 usim_creator.handle_overflow                       [296] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:42.279460000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.59308355224180937723097007012647769619] and current target energy [7.56566097439045788276005528138220411076]. Set energy to 0.
20.05.2024 04:21:42.301464000 usim_creator.handle_overflow                       [296] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:21:42.310053000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.59308355224180937723097007012647769619] and current target energy [7.56566097439045788276005528138220411076]. Set energy to 0.
20.05.2024 04:21:42.330759000 usim_creator.handle_overflow                       [296] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:21:42.341402000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.59308355224180937723097007012647769619] and current target energy [-7.56566097439045788276005528138220411076]. Set energy to 0.
20.05.2024 04:21:42.362677000 usim_creator.handle_overflow                       [296] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:21:42.373100000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.59308355224180937723097007012647769619] and current target energy [-7.56566097439045788276005528138220411076]. Set energy to 0.
20.05.2024 04:21:42.390798000 usim_creator.handle_overflow                       [296] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:21:43.107696000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.26680312032727038621504139146089134763] and current target energy [9.18616710448361875446194014025295539237]. Set energy to 0.
20.05.2024 04:21:43.161108000 usim_creator.handle_overflow                       [299] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:43.163302000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.26680312032727038621504139146089134763] and current target energy [-9.18616710448361875446194014025295539237]. Set energy to 0.
20.05.2024 04:21:43.177903000 usim_creator.handle_overflow                       [299] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:43.195994000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [1.64433841966098669020729363007232468263] and current target energy [9.06721248130908154486016556584356539049]. Set energy to 0.
20.05.2024 04:21:43.214445000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:43.216052000 usim_creator.handle_overflow                       [299] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:21:43.232608000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-1.64433841966098669020729363007232468263] and current target energy [-9.06721248130908154486016556584356539049]. Set energy to 0.
20.05.2024 04:21:43.253060000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:43.254361000 usim_creator.handle_overflow                       [299] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:21:43.270053000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [1.43371724505430512710898960981932603676] and current target energy [9.31041234886335271274610062256293365031]. Set energy to 0.
20.05.2024 04:21:43.287586000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:43.287888000 usim_creator.handle_overflow                       [299] Not implemented. Handle overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [7].
20.05.2024 04:21:43.294333000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [1.43371724505430512710898960981932603676] and current target energy [9.31041234886335271274610062256293365031]. Set energy to 0.
20.05.2024 04:21:43.303343000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:43.304715000 usim_creator.handle_overflow                       [299] Not implemented. Handle overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [7].
20.05.2024 04:21:43.308967000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-1.43371724505430512710898960981932603676] and current target energy [-9.31041234886335271274610062256293365031]. Set energy to 0.
20.05.2024 04:21:43.316715000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:43.318260000 usim_creator.handle_overflow                       [299] Not implemented. Handle overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [7].
20.05.2024 04:21:43.324099000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-1.43371724505430512710898960981932603676] and current target energy [-9.31041234886335271274610062256293365031]. Set energy to 0.
20.05.2024 04:21:43.332215000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:43.332689000 usim_creator.handle_overflow                       [299] Not implemented. Handle overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [7].
20.05.2024 04:21:44.611433000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.43371724505430512710898960981932603676] and current target energy [8.5706302535104354424335284842083758456]. Set energy to 0.
20.05.2024 04:21:44.644668000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:44.654020000 usim_creator.handle_overflow                       [305] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:21:44.673763000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.43371724505430512710898960981932603676] and current target energy [8.5706302535104354424335284842083758456]. Set energy to 0.
20.05.2024 04:21:44.722251000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:44.723430000 usim_creator.handle_overflow                       [305] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:21:44.726272000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.43371724505430512710898960981932603676] and current target energy [-8.5706302535104354424335284842083758456]. Set energy to 0.
20.05.2024 04:21:44.794244000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:44.794652000 usim_creator.handle_overflow                       [305] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:21:44.803455000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.43371724505430512710898960981932603676] and current target energy [-8.5706302535104354424335284842083758456]. Set energy to 0.
20.05.2024 04:21:44.815767000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:44.816140000 usim_creator.handle_overflow                       [305] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:21:45.708886000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [2.69774271975630628862134111183740768245] and current target energy [8.22169209830493345103646815036162341315]. Set energy to 0.
20.05.2024 04:21:45.734616000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:45.744134000 usim_creator.handle_overflow                       [307] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:21:45.748997000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-2.69774271975630628862134111183740768245] and current target energy [-8.22169209830493345103646815036162341315]. Set energy to 0.
20.05.2024 04:21:45.756168000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:45.756924000 usim_creator.handle_overflow                       [307] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:21:45.886049000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.45259608222963732302617404354774614026] and current target energy [9.04530018080761144965370355006992902986]. Set energy to 0.
20.05.2024 04:21:45.930045000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:45.931061000 usim_creator.handle_overflow                       [308] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:45.933731000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.45259608222963732302617404354774614026] and current target energy [-9.04530018080761144965370355006992902986]. Set energy to 0.
20.05.2024 04:21:45.956445000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:45.957205000 usim_creator.handle_overflow                       [308] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:47.288907000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [4.94298118967586019620909884398640703239] and current target energy [6.19301833724128856275260904295391640441]. Set energy to 0.
20.05.2024 04:21:47.308220000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:47.309275000 usim_creator.handle_overflow                       [314] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:21:47.312012000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-4.94298118967586019620909884398640703239] and current target energy [-6.19301833724128856275260904295391640441]. Set energy to 0.
20.05.2024 04:21:47.325193000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:47.326012000 usim_creator.handle_overflow                       [314] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:21:47.338343000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [4.03264587346687858435383559169545982518] and current target energy [6.943740023822934717930834484413294466]. Set energy to 0.
20.05.2024 04:21:47.345991000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:47.346736000 usim_creator.handle_overflow                       [314] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:21:47.351304000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-4.03264587346687858435383559169545982518] and current target energy [-6.943740023822934717930834484413294466]. Set energy to 0.
20.05.2024 04:21:47.389771000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:47.391224000 usim_creator.handle_overflow                       [314] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:21:48.055089000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.94298118967586019620909884398640703239] and current target energy [5.96731524773936959306561466787736181469]. Set energy to 0.
20.05.2024 04:21:48.097280000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:48.103985000 usim_creator.handle_overflow                       [316] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:48.117785000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.94298118967586019620909884398640703239] and current target energy [-5.96731524773936959306561466787736181469]. Set energy to 0.
20.05.2024 04:21:48.139990000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:48.141386000 usim_creator.handle_overflow                       [316] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:48.610504000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [1.19163851881704429576589972628224968737] and current target energy [9.34560762772880507718171473929506247548]. Set energy to 0.
20.05.2024 04:21:48.636737000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:48.642447000 usim_creator.handle_overflow                       [318] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:48.661193000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [1.19163851881704429576589972628224968737] and current target energy [9.34560762772880507718171473929506247548]. Set energy to 0.
20.05.2024 04:21:48.682023000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:48.682771000 usim_creator.handle_overflow                       [318] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:48.702011000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-1.19163851881704429576589972628224968737] and current target energy [-9.34560762772880507718171473929506247548]. Set energy to 0.
20.05.2024 04:21:48.720699000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:48.722020000 usim_creator.handle_overflow                       [318] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:48.743277000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-1.19163851881704429576589972628224968737] and current target energy [-9.34560762772880507718171473929506247548]. Set energy to 0.
20.05.2024 04:21:48.762242000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:48.763090000 usim_creator.handle_overflow                       [318] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:48.786351000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [.5674104357804313019848671417847570917113] and current target energy [9.67998430376251700745604703472262720871]. Set energy to 0.
20.05.2024 04:21:48.803770000 usim_creator.handle_overflow                       [318] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:21:48.816807000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [.5674104357804313019848671417847570917113] and current target energy [9.67998430376251700745604703472262720871]. Set energy to 0.
20.05.2024 04:21:48.836995000 usim_creator.handle_overflow                       [318] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:21:48.847662000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-.5674104357804313019848671417847570917113] and current target energy [-9.67998430376251700745604703472262720871]. Set energy to 0.
20.05.2024 04:21:48.864318000 usim_creator.handle_overflow                       [318] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:21:48.882868000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-.5674104357804313019848671417847570917113] and current target energy [-9.67998430376251700745604703472262720871]. Set energy to 0.
20.05.2024 04:21:48.900882000 usim_creator.handle_overflow                       [318] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:21:49.429975000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [2.00288740897723905016695773306135912309] and current target energy [9.88596237935172039241819768797281406477]. Set energy to 0.
20.05.2024 04:21:49.453933000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:49.455296000 usim_creator.handle_overflow                       [321] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:21:49.469199000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-2.00288740897723905016695773306135912309] and current target energy [-9.88596237935172039241819768797281406477]. Set energy to 0.
20.05.2024 04:21:49.494770000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:49.496058000 usim_creator.handle_overflow                       [321] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:21:49.517010000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [4.28238066983392523295279923078438237287] and current target energy [9.03295086212770850663776634635246908855]. Set energy to 0.
20.05.2024 04:21:49.536869000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:49.537639000 usim_creator.handle_overflow                       [321] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:21:49.553159000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-4.28238066983392523295279923078438237287] and current target energy [-9.03295086212770850663776634635246908855]. Set energy to 0.
20.05.2024 04:21:49.575325000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:49.577045000 usim_creator.handle_overflow                       [321] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:21:50.405415000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.19641923201602931775297676565366901073] and current target energy [8.01154963590895620066783093224543649234]. Set energy to 0.
20.05.2024 04:21:50.432683000 usim_creator.handle_overflow                       [325] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:50.435353000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.19641923201602931775297676565366901073] and current target energy [-8.01154963590895620066783093224543649234]. Set energy to 0.
20.05.2024 04:21:50.454169000 usim_creator.handle_overflow                       [325] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:50.652923000 usim_process.process_queue                         Overflow for target space id [2024052004211134000000000000000000000000000000000000052] with energy [.7708843230768346409186998096826440178475] and current target energy [9.71559717528011183174664860076336403725]. Set energy to 0.
20.05.2024 04:21:50.668084000 usim_creator.handle_overflow                       [326] Not implemented. Handle overflow for [2024052004211134000000000000000000000000000000000000052] escape strategy [0].
20.05.2024 04:21:50.679154000 usim_process.process_queue                         Overflow for target space id [2024052004211138700000000000000000000000000000000000053] with energy [.7708843230768346409186998096826440178475] and current target energy [9.71559717528011183174664860076336403725]. Set energy to 0.
20.05.2024 04:21:50.695986000 usim_creator.handle_overflow                       [326] Not implemented. Handle overflow for [2024052004211138700000000000000000000000000000000000053] escape strategy [0].
20.05.2024 04:21:50.710191000 usim_process.process_queue                         Overflow for target space id [2024052004211143900000000000000000000000000000000000054] with energy [-.7708843230768346409186998096826440178475] and current target energy [-9.71559717528011183174664860076336403725]. Set energy to 0.
20.05.2024 04:21:50.731172000 usim_creator.handle_overflow                       [326] Not implemented. Handle overflow for [2024052004211143900000000000000000000000000000000000054] escape strategy [0].
20.05.2024 04:21:50.739489000 usim_process.process_queue                         Overflow for target space id [2024052004211147900000000000000000000000000000000000055] with energy [-.7708843230768346409186998096826440178475] and current target energy [-9.71559717528011183174664860076336403725]. Set energy to 0.
20.05.2024 04:21:50.746024000 usim_creator.handle_overflow                       [326] Not implemented. Handle overflow for [2024052004211147900000000000000000000000000000000000055] escape strategy [0].
20.05.2024 04:21:51.408215000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [4.57911544372030018271755266027777601718] and current target energy [6.82199676211735693240717089887892353927]. Set energy to 0.
20.05.2024 04:21:51.427665000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:51.440013000 usim_creator.handle_overflow                       [331] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:21:51.445038000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-4.57911544372030018271755266027777601718] and current target energy [-6.82199676211735693240717089887892353927]. Set energy to 0.
20.05.2024 04:21:51.455869000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:51.456181000 usim_creator.handle_overflow                       [331] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:21:51.671163000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [2.36376825260609706498854839119319415936] and current target energy [8.75343685626041311045437954203741692394]. Set energy to 0.
20.05.2024 04:21:51.692718000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:51.694026000 usim_creator.handle_overflow                       [332] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:21:51.698186000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [2.36376825260609706498854839119319415936] and current target energy [8.75343685626041311045437954203741692394]. Set energy to 0.
20.05.2024 04:21:51.726346000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:51.738306000 usim_creator.handle_overflow                       [332] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:21:51.748501000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-2.36376825260609706498854839119319415936] and current target energy [-8.75343685626041311045437954203741692394]. Set energy to 0.
20.05.2024 04:21:51.772606000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:51.786121000 usim_creator.handle_overflow                       [332] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:21:51.794272000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-2.36376825260609706498854839119319415936] and current target energy [-8.75343685626041311045437954203741692394]. Set energy to 0.
20.05.2024 04:21:51.819701000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:51.820488000 usim_creator.handle_overflow                       [332] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:21:52.101965000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.874257405785720596099825482552748931] and current target energy [9.25031161497447018988535079872141930998]. Set energy to 0.
20.05.2024 04:21:52.143405000 usim_creator.handle_overflow                       [333] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:52.161958000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.874257405785720596099825482552748931] and current target energy [-9.25031161497447018988535079872141930998]. Set energy to 0.
20.05.2024 04:21:52.178102000 usim_creator.handle_overflow                       [333] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:52.436590000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [1.36316890859519891989047915403845174432] and current target energy [9.15823088744060036543510532055555203436]. Set energy to 0.
20.05.2024 04:21:52.454086000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:52.465028000 usim_creator.handle_overflow                       [334] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:21:52.480688000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-1.36316890859519891989047915403845174432] and current target energy [-9.15823088744060036543510532055555203436]. Set energy to 0.
20.05.2024 04:21:52.500430000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:52.509307000 usim_creator.handle_overflow                       [334] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:21:52.805691000 usim_process.process_queue                         Overflow for target space id [2024052004210570400000000000000000000000000000000000038] with energy [.7851208846850252494135135431850563850238] and current target energy [9.39195881028538853226097153125841083635]. Set energy to 0.
20.05.2024 04:21:52.812907000 usim_creator.handle_overflow                       [336] Not implemented. Handle overflow for [2024052004210570400000000000000000000000000000000000038] escape strategy [0].
20.05.2024 04:21:52.818098000 usim_process.process_queue                         Overflow for target space id [2024052004210571900000000000000000000000000000000000039] with energy [.7851208846850252494135135431850563850238] and current target energy [9.39195881028538853226097153125841083635]. Set energy to 0.
20.05.2024 04:21:52.825790000 usim_creator.handle_overflow                       [336] Not implemented. Handle overflow for [2024052004210571900000000000000000000000000000000000039] escape strategy [0].
20.05.2024 04:21:52.830115000 usim_process.process_queue                         Overflow for target space id [2024052004210573600000000000000000000000000000000000040] with energy [-.7851208846850252494135135431850563850238] and current target energy [-9.39195881028538853226097153125841083635]. Set energy to 0.
20.05.2024 04:21:52.837805000 usim_creator.handle_overflow                       [336] Not implemented. Handle overflow for [2024052004210573600000000000000000000000000000000000040] escape strategy [0].
20.05.2024 04:21:52.842204000 usim_process.process_queue                         Overflow for target space id [2024052004210575900000000000000000000000000000000000041] with energy [-.7851208846850252494135135431850563850238] and current target energy [-9.39195881028538853226097153125841083635]. Set energy to 0.
20.05.2024 04:21:52.850547000 usim_creator.handle_overflow                       [336] Not implemented. Handle overflow for [2024052004210575900000000000000000000000000000000000041] escape strategy [0].
20.05.2024 04:21:52.859353000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [3.81191427599401922337132954519299138833] and current target energy [9.90134049252949575142154240540940490725]. Set energy to 0.
20.05.2024 04:21:52.869324000 usim_creator.handle_overflow                       [336] Handle pos overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [3].
20.05.2024 04:21:52.875196000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-3.81191427599401922337132954519299138833] and current target energy [-9.90134049252949575142154240540940490725]. Set energy to 0.
20.05.2024 04:21:52.885110000 usim_creator.handle_overflow                       [336] Handle pos overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [3].
20.05.2024 04:21:53.053231000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [2.06875748735924772580915610136381588186] and current target energy [9.45507301042438825995419356477277663742]. Set energy to 0.
20.05.2024 04:21:53.098391000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:53.098754000 usim_creator.handle_overflow                       [337] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:21:53.104666000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [2.06875748735924772580915610136381588186] and current target energy [9.45507301042438825995419356477277663742]. Set energy to 0.
20.05.2024 04:21:53.126087000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:53.127151000 usim_creator.handle_overflow                       [337] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:21:53.133147000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-2.06875748735924772580915610136381588186] and current target energy [-9.45507301042438825995419356477277663742]. Set energy to 0.
20.05.2024 04:21:53.151557000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:53.153052000 usim_creator.handle_overflow                       [337] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:21:53.159924000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-2.06875748735924772580915610136381588186] and current target energy [-9.45507301042438825995419356477277663742]. Set energy to 0.
20.05.2024 04:21:53.186642000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:53.189693000 usim_creator.handle_overflow                       [337] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:21:53.218759000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.76072325886994527795374995419876559609] and current target energy [5.69688434136158822787801120409981204992]. Set energy to 0.
20.05.2024 04:21:53.240547000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:53.245014000 usim_creator.handle_overflow                       [337] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:21:53.265363000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.76072325886994527795374995419876559609] and current target energy [-5.69688434136158822787801120409981204992]. Set energy to 0.
20.05.2024 04:21:53.281604000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:53.283060000 usim_creator.handle_overflow                       [337] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:21:53.553134000 usim_process.process_queue                         Overflow for target space id [2024052004205948300000000000000000000000000000000000024] with energy [.8327674549234076350748518563839346156088] and current target energy [9.89230356873138950714305890093728702826]. Set energy to 0.
20.05.2024 04:21:53.577343000 usim_creator.handle_overflow                       [338] Not implemented. Handle overflow for [2024052004205948300000000000000000000000000000000000024] escape strategy [0].
20.05.2024 04:21:53.593451000 usim_process.process_queue                         Overflow for target space id [2024052004205949500000000000000000000000000000000000025] with energy [.8327674549234076350748518563839346156088] and current target energy [9.89230356873138950714305890093728702826]. Set energy to 0.
20.05.2024 04:21:53.618496000 usim_creator.handle_overflow                       [338] Not implemented. Handle overflow for [2024052004205949500000000000000000000000000000000000025] escape strategy [0].
20.05.2024 04:21:53.634858000 usim_process.process_queue                         Overflow for target space id [2024052004205950700000000000000000000000000000000000026] with energy [-.8327674549234076350748518563839346156088] and current target energy [-9.89230356873138950714305890093728702826]. Set energy to 0.
20.05.2024 04:21:53.649200000 usim_creator.handle_overflow                       [338] Not implemented. Handle overflow for [2024052004205950700000000000000000000000000000000000026] escape strategy [0].
20.05.2024 04:21:53.660501000 usim_process.process_queue                         Overflow for target space id [2024052004205952100000000000000000000000000000000000027] with energy [-.8327674549234076350748518563839346156088] and current target energy [-9.89230356873138950714305890093728702826]. Set energy to 0.
20.05.2024 04:21:53.680250000 usim_creator.handle_overflow                       [338] Not implemented. Handle overflow for [2024052004205952100000000000000000000000000000000000027] escape strategy [0].
20.05.2024 04:21:54.152206000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [1.36316890859519891989047915403845174432] and current target energy [9.52144651773989055590749990839753119217]. Set energy to 0.
20.05.2024 04:21:54.176893000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:54.177458000 usim_creator.handle_overflow                       [340] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:54.185257000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-1.36316890859519891989047915403845174432] and current target energy [-9.52144651773989055590749990839753119217]. Set energy to 0.
20.05.2024 04:21:54.204226000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:54.205303000 usim_creator.handle_overflow                       [340] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:54.586955000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.82519174717804954998858442489746371407] and current target energy [8.27502994943699090323662440545526352743]. Set energy to 0.
20.05.2024 04:21:54.609670000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:54.617279000 usim_creator.handle_overflow                       [342] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:21:54.631159000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.82519174717804954998858442489746371407] and current target energy [8.27502994943699090323662440545526352743]. Set energy to 0.
20.05.2024 04:21:54.654261000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:54.657764000 usim_creator.handle_overflow                       [342] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:21:54.685058000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.82519174717804954998858442489746371407] and current target energy [-8.27502994943699090323662440545526352743]. Set energy to 0.
20.05.2024 04:21:54.701474000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:54.707739000 usim_creator.handle_overflow                       [342] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:21:54.719676000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.82519174717804954998858442489746371407] and current target energy [-8.27502994943699090323662440545526352743]. Set energy to 0.
20.05.2024 04:21:54.735512000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:54.738987000 usim_creator.handle_overflow                       [342] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:21:54.761217000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.82519174717804954998858442489746371407] and current target energy [7.82747146819754644273684678631504023005]. Set energy to 0.
20.05.2024 04:21:54.772673000 usim_creator.handle_overflow                       [342] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:21:54.775643000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.82519174717804954998858442489746371407] and current target energy [7.82747146819754644273684678631504023005]. Set energy to 0.
20.05.2024 04:21:54.805590000 usim_creator.handle_overflow                       [342] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:21:54.818069000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.82519174717804954998858442489746371407] and current target energy [-7.82747146819754644273684678631504023005]. Set energy to 0.
20.05.2024 04:21:54.840719000 usim_creator.handle_overflow                       [342] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:21:54.846979000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.82519174717804954998858442489746371407] and current target energy [-7.82747146819754644273684678631504023005]. Set energy to 0.
20.05.2024 04:21:54.858347000 usim_creator.handle_overflow                       [342] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:21:55.367039000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [2.31946684538971130738762526026281767284] and current target energy [7.76882311197449940529522815649050656865]. Set energy to 0.
20.05.2024 04:21:55.400341000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:55.401095000 usim_creator.handle_overflow                       [344] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:21:55.411891000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-2.31946684538971130738762526026281767284] and current target energy [-7.76882311197449940529522815649050656865]. Set energy to 0.
20.05.2024 04:21:55.423380000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:55.423692000 usim_creator.handle_overflow                       [344] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:21:55.763032000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [4.03513376579067390021422406232615881095] and current target energy [7.62382855198803844674265909038598277665]. Set energy to 0.
20.05.2024 04:21:55.783899000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:55.785004000 usim_creator.handle_overflow                       [345] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:21:55.787422000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-4.03513376579067390021422406232615881095] and current target energy [-7.62382855198803844674265909038598277665]. Set energy to 0.
20.05.2024 04:21:55.799147000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:55.799448000 usim_creator.handle_overflow                       [345] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:21:56.200822000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [3.07232929628388042868810484258014069346] and current target energy [7.68574631722505872811534134667020964648]. Set energy to 0.
20.05.2024 04:21:56.239935000 usim_creator.handle_overflow                       [347] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:21:56.248523000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-3.07232929628388042868810484258014069346] and current target energy [-7.68574631722505872811534134667020964648]. Set energy to 0.
20.05.2024 04:21:56.265594000 usim_creator.handle_overflow                       [347] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:21:57.133993000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [1.92781574676582576086583884077644400979] and current target energy [8.51670651117465715411423715891865246713]. Set energy to 0.
20.05.2024 04:21:57.149721000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:57.150494000 usim_creator.handle_overflow                       [351] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:21:57.171026000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-1.92781574676582576086583884077644400979] and current target energy [-8.51670651117465715411423715891865246713]. Set energy to 0.
20.05.2024 04:21:57.189656000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:57.199713000 usim_creator.handle_overflow                       [351] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:21:57.517159000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.009787971423049937244468708633150207722525] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:57.530390000 usim_process.process_node                          Overflow for space id [2024052004205700500000000000000000000000000000000000014] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:57.558323000 usim_creator.handle_overflow                       [353] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:21:57.574814000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.009787971423049937244468708633150207722525] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:57.575864000 usim_process.process_node                          Overflow for space id [2024052004205702100000000000000000000000000000000000016] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:57.614969000 usim_creator.handle_overflow                       [353] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:21:57.665958000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.009787971423049937244468708633150207722525] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:57.678697000 usim_process.process_node                          Overflow for space id [2024052004205707700000000000000000000000000000000000018] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:57.694617000 usim_creator.handle_overflow                       [353] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:21:57.718737000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.009787971423049937244468708633150207722525] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:21:57.719858000 usim_process.process_node                          Overflow for space id [2024052004205714100000000000000000000000000000000000020] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:21:57.735593000 usim_creator.handle_overflow                       [353] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:21:58.157115000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.81953936691456440216459710194111002446] and current target energy [6.22296236395216035533195935422548304869]. Set energy to 0.
20.05.2024 04:21:58.181965000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:58.186055000 usim_creator.handle_overflow                       [354] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:21:58.190674000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.81953936691456440216459710194111002446] and current target energy [-6.22296236395216035533195935422548304869]. Set energy to 0.
20.05.2024 04:21:58.200194000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:58.200750000 usim_creator.handle_overflow                       [354] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:21:58.831076000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [2.16879271511155398097406869587349951101] and current target energy [8.0702675315813478004284481246523176219]. Set energy to 0.
20.05.2024 04:21:58.852820000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:58.863803000 usim_creator.handle_overflow                       [358] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:21:58.873385000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-2.16879271511155398097406869587349951101] and current target energy [-8.0702675315813478004284481246523176219]. Set energy to 0.
20.05.2024 04:21:58.899911000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:58.901271000 usim_creator.handle_overflow                       [358] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:21:59.611224000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [2.30721742735225852177080034154190695417] and current target energy [9.63907873382912880432919420388222004892]. Set energy to 0.
20.05.2024 04:21:59.637738000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:59.643925000 usim_creator.handle_overflow                       [361] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:21:59.659847000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-2.30721742735225852177080034154190695417] and current target energy [-9.63907873382912880432919420388222004892]. Set energy to 0.
20.05.2024 04:21:59.683116000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:21:59.684275000 usim_creator.handle_overflow                       [361] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:22:00.424071000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.82246983208686994802894089134412316983] and current target energy [5.6020152711294777608747406164760557261]. Set energy to 0.
20.05.2024 04:22:00.462454000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:00.471917000 usim_creator.handle_overflow                       [364] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:22:00.479337000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.82246983208686994802894089134412316983] and current target energy [5.6020152711294777608747406164760557261]. Set energy to 0.
20.05.2024 04:22:00.494267000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:00.494581000 usim_creator.handle_overflow                       [364] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:22:00.510300000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.82246983208686994802894089134412316983] and current target energy [-5.6020152711294777608747406164760557261]. Set energy to 0.
20.05.2024 04:22:00.546450000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:00.548226000 usim_creator.handle_overflow                       [364] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:22:00.560335000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.82246983208686994802894089134412316983] and current target energy [-5.6020152711294777608747406164760557261]. Set energy to 0.
20.05.2024 04:22:00.574108000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:00.575250000 usim_creator.handle_overflow                       [364] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:22:00.577606000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.82246983208686994802894089134412316983] and current target energy [6.41153731156427511428213053906925732777]. Set energy to 0.
20.05.2024 04:22:00.598376000 usim_creator.handle_overflow                       [364] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:22:00.617734000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.82246983208686994802894089134412316983] and current target energy [6.41153731156427511428213053906925732777]. Set energy to 0.
20.05.2024 04:22:00.638976000 usim_creator.handle_overflow                       [364] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:22:00.658072000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.82246983208686994802894089134412316983] and current target energy [-6.41153731156427511428213053906925732777]. Set energy to 0.
20.05.2024 04:22:00.681502000 usim_creator.handle_overflow                       [364] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:22:00.697973000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.82246983208686994802894089134412316983] and current target energy [-6.41153731156427511428213053906925732777]. Set energy to 0.
20.05.2024 04:22:00.713016000 usim_creator.handle_overflow                       [364] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:22:01.183651000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [2.35922617169784674789263539360698426955] and current target energy [8.67517086044621592389627478349399804403]. Set energy to 0.
20.05.2024 04:22:01.212356000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:01.224157000 usim_creator.handle_overflow                       [366] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:22:01.244459000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-2.35922617169784674789263539360698426955] and current target energy [-8.67517086044621592389627478349399804403]. Set energy to 0.
20.05.2024 04:22:01.261228000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:01.263037000 usim_creator.handle_overflow                       [366] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:22:01.289865000 usim_process.process_queue                         Overflow for target space id [2024052004211990800000000000000000000000000000000000070] with energy [1.44003849169883360045774266339865452418] and current target energy [9.28302570157978565678985152005788938087]. Set energy to 0.
20.05.2024 04:22:01.311802000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:01.320021000 usim_creator.handle_overflow                       [366] Not implemented. Handle overflow for [2024052004211990800000000000000000000000000000000000070] escape strategy [7].
20.05.2024 04:22:01.331394000 usim_process.process_queue                         Overflow for target space id [2024052004211994200000000000000000000000000000000000071] with energy [1.44003849169883360045774266339865452418] and current target energy [9.28302570157978565678985152005788938087]. Set energy to 0.
20.05.2024 04:22:01.352506000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:01.353924000 usim_creator.handle_overflow                       [366] Not implemented. Handle overflow for [2024052004211994200000000000000000000000000000000000071] escape strategy [7].
20.05.2024 04:22:01.356629000 usim_process.process_queue                         Overflow for target space id [2024052004211998600000000000000000000000000000000000072] with energy [-1.44003849169883360045774266339865452418] and current target energy [-9.28302570157978565678985152005788938087]. Set energy to 0.
20.05.2024 04:22:01.390222000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:01.390940000 usim_creator.handle_overflow                       [366] Not implemented. Handle overflow for [2024052004211998600000000000000000000000000000000000072] escape strategy [7].
20.05.2024 04:22:01.395837000 usim_process.process_queue                         Overflow for target space id [2024052004212000300000000000000000000000000000000000073] with energy [-1.44003849169883360045774266339865452418] and current target energy [-9.28302570157978565678985152005788938087]. Set energy to 0.
20.05.2024 04:22:01.404742000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:01.406257000 usim_creator.handle_overflow                       [366] Not implemented. Handle overflow for [2024052004212000300000000000000000000000000000000000073] escape strategy [7].
20.05.2024 04:22:01.621899000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.82246983208686994802894089134412316983] and current target energy [9.43690468679138699157054157442793707817]. Set energy to 0.
20.05.2024 04:22:01.637938000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:01.639521000 usim_creator.handle_overflow                       [368] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:22:01.644756000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.82246983208686994802894089134412316983] and current target energy [-9.43690468679138699157054157442793707817]. Set energy to 0.
20.05.2024 04:22:01.653732000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:01.655979000 usim_creator.handle_overflow                       [368] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:22:01.792912000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.7212283308232816759198712503710726857038] and current target energy [9.64493966417373989605788178268824633966]. Set energy to 0.
20.05.2024 04:22:01.806401000 usim_creator.handle_overflow                       [369] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:01.810416000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.7212283308232816759198712503710726857038] and current target energy [-9.64493966417373989605788178268824633966]. Set energy to 0.
20.05.2024 04:22:01.819867000 usim_creator.handle_overflow                       [369] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:02.547043000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [2.30691206956183247432814238994872468138] and current target energy [8.6831730268285139526855101265978272831]. Set energy to 0.
20.05.2024 04:22:02.564339000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:02.565447000 usim_creator.handle_overflow                       [374] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:22:02.567883000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [2.30691206956183247432814238994872468138] and current target energy [8.6831730268285139526855101265978272831]. Set energy to 0.
20.05.2024 04:22:02.585062000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:02.585820000 usim_creator.handle_overflow                       [374] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:22:02.590841000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-2.30691206956183247432814238994872468138] and current target energy [-8.6831730268285139526855101265978272831]. Set energy to 0.
20.05.2024 04:22:02.598976000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:02.599675000 usim_creator.handle_overflow                       [374] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:22:02.605676000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-2.30691206956183247432814238994872468138] and current target energy [-8.6831730268285139526855101265978272831]. Set energy to 0.
20.05.2024 04:22:02.614649000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:02.621209000 usim_creator.handle_overflow                       [374] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:22:03.511538000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [1.0164620874143938330274608972456603972] and current target energy [9.88540181819761593092555642572795130211]. Set energy to 0.
20.05.2024 04:22:03.532324000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:03.533556000 usim_creator.handle_overflow                       [379] Not implemented. Handle overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [7].
20.05.2024 04:22:03.548765000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [1.0164620874143938330274608972456603972] and current target energy [9.88540181819761593092555642572795130211]. Set energy to 0.
20.05.2024 04:22:03.571791000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:03.573062000 usim_creator.handle_overflow                       [379] Not implemented. Handle overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [7].
20.05.2024 04:22:03.586689000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-1.0164620874143938330274608972456603972] and current target energy [-9.88540181819761593092555642572795130211]. Set energy to 0.
20.05.2024 04:22:03.595644000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:03.598346000 usim_creator.handle_overflow                       [379] Not implemented. Handle overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [7].
20.05.2024 04:22:03.601958000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-1.0164620874143938330274608972456603972] and current target energy [-9.88540181819761593092555642572795130211]. Set energy to 0.
20.05.2024 04:22:03.611441000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:03.612176000 usim_creator.handle_overflow                       [379] Not implemented. Handle overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [7].
20.05.2024 04:22:03.927457000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [2.72484284418261822684702576127919844881] and current target energy [8.26595003089704628679082119570185258111]. Set energy to 0.
20.05.2024 04:22:03.951209000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:03.952473000 usim_creator.handle_overflow                       [382] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:22:03.967547000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [2.72484284418261822684702576127919844881] and current target energy [8.26595003089704628679082119570185258111]. Set energy to 0.
20.05.2024 04:22:03.989062000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:03.990158000 usim_creator.handle_overflow                       [382] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:22:03.992623000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-2.72484284418261822684702576127919844881] and current target energy [-8.26595003089704628679082119570185258111]. Set energy to 0.
20.05.2024 04:22:04.019958000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:04.021881000 usim_creator.handle_overflow                       [382] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:22:04.030937000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-2.72484284418261822684702576127919844881] and current target energy [-8.26595003089704628679082119570185258111]. Set energy to 0.
20.05.2024 04:22:04.053477000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:04.059998000 usim_creator.handle_overflow                       [382] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:22:04.077721000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [2.72484284418261822684702576127919844881] and current target energy [8.57322270402567175591089217711062346072]. Set energy to 0.
20.05.2024 04:22:04.098569000 usim_creator.handle_overflow                       [382] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:22:04.101715000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [2.72484284418261822684702576127919844881] and current target energy [8.57322270402567175591089217711062346072]. Set energy to 0.
20.05.2024 04:22:04.129360000 usim_creator.handle_overflow                       [382] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:22:04.138613000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-2.72484284418261822684702576127919844881] and current target energy [-8.57322270402567175591089217711062346072]. Set energy to 0.
20.05.2024 04:22:04.156405000 usim_creator.handle_overflow                       [382] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:22:04.168563000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-2.72484284418261822684702576127919844881] and current target energy [-8.57322270402567175591089217711062346072]. Set energy to 0.
20.05.2024 04:22:04.182692000 usim_creator.handle_overflow                       [382] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:22:04.870351000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.41869752026136211154749641434218390534] and current target energy [8.1973839071351525821035132618036596551]. Set energy to 0.
20.05.2024 04:22:04.881773000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:04.882891000 usim_creator.handle_overflow                       [386] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:22:04.886333000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.41869752026136211154749641434218390534] and current target energy [-8.1973839071351525821035132618036596551]. Set energy to 0.
20.05.2024 04:22:04.895963000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:04.896717000 usim_creator.handle_overflow                       [386] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:22:05.013402000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [.9548377641932812744745808153460226725175] and current target energy [9.2276482782473298973125695597948987255]. Set energy to 0.
20.05.2024 04:22:05.031131000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:05.041145000 usim_creator.handle_overflow                       [387] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:22:05.053379000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [.9548377641932812744745808153460226725175] and current target energy [9.2276482782473298973125695597948987255]. Set energy to 0.
20.05.2024 04:22:05.070984000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:05.071314000 usim_creator.handle_overflow                       [387] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:22:05.074494000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-.9548377641932812744745808153460226725175] and current target energy [-9.2276482782473298973125695597948987255]. Set energy to 0.
20.05.2024 04:22:05.108537000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:05.111973000 usim_creator.handle_overflow                       [387] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:22:05.132563000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-.9548377641932812744745808153460226725175] and current target energy [-9.2276482782473298973125695597948987255]. Set energy to 0.
20.05.2024 04:22:05.148592000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:05.158105000 usim_creator.handle_overflow                       [387] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:22:05.362750000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [4.41869752026136211154749641434218390534] and current target energy [6.58469538807465219726127984380042802696]. Set energy to 0.
20.05.2024 04:22:05.384919000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:05.386109000 usim_creator.handle_overflow                       [388] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:22:05.403938000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-4.41869752026136211154749641434218390534] and current target energy [-6.58469538807465219726127984380042802696]. Set energy to 0.
20.05.2024 04:22:05.425663000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:05.425996000 usim_creator.handle_overflow                       [388] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:22:05.641342000 usim_process.process_queue                         Overflow for target space id [2024052004211570000000000000000000000000000000000000058] with energy [.7298666665402784210799025683769998024275] and current target energy [9.54056468344415682528013680918863280082]. Set energy to 0.
20.05.2024 04:22:05.655650000 usim_creator.handle_overflow                       [389] Not implemented. Handle overflow for [2024052004211570000000000000000000000000000000000000058] escape strategy [0].
20.05.2024 04:22:05.674496000 usim_process.process_queue                         Overflow for target space id [2024052004211574500000000000000000000000000000000000059] with energy [.7298666665402784210799025683769998024275] and current target energy [9.54056468344415682528013680918863280082]. Set energy to 0.
20.05.2024 04:22:05.683743000 usim_creator.handle_overflow                       [389] Not implemented. Handle overflow for [2024052004211574500000000000000000000000000000000000059] escape strategy [0].
20.05.2024 04:22:05.692007000 usim_process.process_queue                         Overflow for target space id [2024052004211579500000000000000000000000000000000000060] with energy [-.7298666665402784210799025683769998024275] and current target energy [-9.54056468344415682528013680918863280082]. Set energy to 0.
20.05.2024 04:22:05.699947000 usim_creator.handle_overflow                       [389] Not implemented. Handle overflow for [2024052004211579500000000000000000000000000000000000060] escape strategy [0].
20.05.2024 04:22:05.702576000 usim_process.process_queue                         Overflow for target space id [2024052004211584300000000000000000000000000000000000061] with energy [-.7298666665402784210799025683769998024275] and current target energy [-9.54056468344415682528013680918863280082]. Set energy to 0.
20.05.2024 04:22:05.710347000 usim_creator.handle_overflow                       [389] Not implemented. Handle overflow for [2024052004211584300000000000000000000000000000000000061] escape strategy [0].
20.05.2024 04:22:05.924273000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.14838496943488286756780683452855101317] and current target energy [8.59353987773953147027122733811420405266]. Set energy to 0.
20.05.2024 04:22:05.937258000 usim_creator.handle_overflow                       [391] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:05.943570000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.14838496943488286756780683452855101317] and current target energy [-8.59353987773953147027122733811420405266]. Set energy to 0.
20.05.2024 04:22:05.953449000 usim_creator.handle_overflow                       [391] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:05.957560000 usim_process.process_queue                         Overflow for target space id [2024052004205701200000000000000000000000000000000000015] with energy [1.01451512445536135412924211630514908955] and current target energy [9.20164841008007272955006348001337167098]. Set energy to 0.
20.05.2024 04:22:05.966223000 usim_creator.handle_overflow                       [391] Not implemented. Handle overflow for [2024052004205701200000000000000000000000000000000000015] escape strategy [0].
20.05.2024 04:22:05.970527000 usim_process.process_queue                         Overflow for target space id [2024052004205702800000000000000000000000000000000000017] with energy [1.01451512445536135412924211630514908955] and current target energy [9.20164841008007272955006348001337167098]. Set energy to 0.
20.05.2024 04:22:05.978100000 usim_creator.handle_overflow                       [391] Not implemented. Handle overflow for [2024052004205702800000000000000000000000000000000000017] escape strategy [0].
20.05.2024 04:22:05.983460000 usim_process.process_queue                         Overflow for target space id [2024052004205711900000000000000000000000000000000000019] with energy [-1.01451512445536135412924211630514908955] and current target energy [-9.20164841008007272955006348001337167098]. Set energy to 0.
20.05.2024 04:22:05.987331000 usim_creator.handle_overflow                       [391] Not implemented. Handle overflow for [2024052004205711900000000000000000000000000000000000019] escape strategy [0].
20.05.2024 04:22:05.992099000 usim_process.process_queue                         Overflow for target space id [2024052004205716200000000000000000000000000000000000021] with energy [-1.01451512445536135412924211630514908955] and current target energy [-9.20164841008007272955006348001337167098]. Set energy to 0.
20.05.2024 04:22:05.999111000 usim_creator.handle_overflow                       [391] Not implemented. Handle overflow for [2024052004205716200000000000000000000000000000000000021] escape strategy [0].
20.05.2024 04:22:06.957835000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [2.65564253166256354463242789268112555794] and current target energy [8.83739504052272422309499282868436781068]. Set energy to 0.
20.05.2024 04:22:06.985224000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:07.008507000 usim_creator.handle_overflow                       [395] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:22:07.023583000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-2.65564253166256354463242789268112555794] and current target energy [-8.83739504052272422309499282868436781068]. Set energy to 0.
20.05.2024 04:22:07.042958000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:07.044160000 usim_creator.handle_overflow                       [395] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:22:07.347501000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [4.05479939591248754231261808108270961981] and current target energy [7.61316404047085068901706571515568069916]. Set energy to 0.
20.05.2024 04:22:07.373973000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:07.375835000 usim_creator.handle_overflow                       [396] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:22:07.388188000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-4.05479939591248754231261808108270961981] and current target energy [-7.61316404047085068901706571515568069916]. Set energy to 0.
20.05.2024 04:22:07.405827000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:07.406131000 usim_creator.handle_overflow                       [396] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:22:07.913925000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.17254600497448694183942642792998435467] and current target energy [9.54687490251341113579741576593761452156]. Set energy to 0.
20.05.2024 04:22:07.947014000 usim_creator.handle_overflow                       [399] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:07.959814000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.17254600497448694183942642792998435467] and current target energy [-9.54687490251341113579741576593761452156]. Set energy to 0.
20.05.2024 04:22:07.989058000 usim_creator.handle_overflow                       [399] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:08.419371000 usim_process.process_queue                         Overflow for target space id [2024052004210261400000000000000000000000000000000000034] with energy [1.01078750125163460808506433405652201404] and current target energy [9.87274615569723846800657288649923126192]. Set energy to 0.
20.05.2024 04:22:08.441789000 usim_creator.handle_overflow                       [401] Not implemented. Handle overflow for [2024052004210261400000000000000000000000000000000000034] escape strategy [0].
20.05.2024 04:22:08.453667000 usim_process.process_queue                         Overflow for target space id [2024052004210264800000000000000000000000000000000000035] with energy [1.01078750125163460808506433405652201404] and current target energy [9.87274615569723846800657288649923126192]. Set energy to 0.
20.05.2024 04:22:08.474756000 usim_creator.handle_overflow                       [401] Not implemented. Handle overflow for [2024052004210264800000000000000000000000000000000000035] escape strategy [0].
20.05.2024 04:22:08.485403000 usim_process.process_queue                         Overflow for target space id [2024052004210269400000000000000000000000000000000000036] with energy [-1.01078750125163460808506433405652201404] and current target energy [-9.87274615569723846800657288649923126192]. Set energy to 0.
20.05.2024 04:22:08.505186000 usim_creator.handle_overflow                       [401] Not implemented. Handle overflow for [2024052004210269400000000000000000000000000000000000036] escape strategy [0].
20.05.2024 04:22:08.524693000 usim_process.process_queue                         Overflow for target space id [2024052004210273800000000000000000000000000000000000037] with energy [-1.01078750125163460808506433405652201404] and current target energy [-9.87274615569723846800657288649923126192]. Set energy to 0.
20.05.2024 04:22:08.542697000 usim_creator.handle_overflow                       [401] Not implemented. Handle overflow for [2024052004210273800000000000000000000000000000000000037] escape strategy [0].
20.05.2024 04:22:08.572678000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [2.38260732176997070939318961900521945523] and current target energy [7.62434342966390627005820678081670225672]. Set energy to 0.
20.05.2024 04:22:08.594644000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:08.626817000 usim_creator.handle_overflow                       [401] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:22:08.646459000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-2.38260732176997070939318961900521945523] and current target energy [-7.62434342966390627005820678081670225672]. Set energy to 0.
20.05.2024 04:22:08.667916000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:08.679044000 usim_creator.handle_overflow                       [401] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:22:09.689180000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [3.13668841920772997984983500807742646539] and current target energy [7.59214925786439714533834557930490167694]. Set energy to 0.
20.05.2024 04:22:09.709655000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:09.709988000 usim_creator.handle_overflow                       [406] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:22:09.727792000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-3.13668841920772997984983500807742646539] and current target energy [-7.59214925786439714533834557930490167694]. Set energy to 0.
20.05.2024 04:22:09.749349000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:09.754853000 usim_creator.handle_overflow                       [406] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:22:09.759698000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.13668841920772997984983500807742646539] and current target energy [9.72440424388024976581300728129238156902]. Set energy to 0.
20.05.2024 04:22:09.777025000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:09.778225000 usim_creator.handle_overflow                       [406] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:22:09.783404000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.13668841920772997984983500807742646539] and current target energy [9.72440424388024976581300728129238156902]. Set energy to 0.
20.05.2024 04:22:09.802326000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:09.805134000 usim_creator.handle_overflow                       [406] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:22:09.830759000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.13668841920772997984983500807742646539] and current target energy [-9.72440424388024976581300728129238156902]. Set energy to 0.
20.05.2024 04:22:09.850729000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:09.858037000 usim_creator.handle_overflow                       [406] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:22:09.875492000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.13668841920772997984983500807742646539] and current target energy [-9.72440424388024976581300728129238156902]. Set energy to 0.
20.05.2024 04:22:09.887474000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:09.888851000 usim_creator.handle_overflow                       [406] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:22:09.903894000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.13668841920772997984983500807742646539] and current target energy [9.90920883793304554812198890600960836917]. Set energy to 0.
20.05.2024 04:22:09.919403000 usim_creator.handle_overflow                       [406] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:22:09.939914000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.13668841920772997984983500807742646539] and current target energy [9.90920883793304554812198890600960836917]. Set energy to 0.
20.05.2024 04:22:09.963886000 usim_creator.handle_overflow                       [406] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:22:09.975395000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.13668841920772997984983500807742646539] and current target energy [-9.90920883793304554812198890600960836917]. Set energy to 0.
20.05.2024 04:22:09.994776000 usim_creator.handle_overflow                       [406] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:22:10.007073000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.13668841920772997984983500807742646539] and current target energy [-9.90920883793304554812198890600960836917]. Set energy to 0.
20.05.2024 04:22:10.026604000 usim_creator.handle_overflow                       [406] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:22:10.057273000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [3.33918747908982423558926400691411483952] and current target energy [8.90455817022491179272262662815462405932]. Set energy to 0.
20.05.2024 04:22:10.078993000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:10.080107000 usim_creator.handle_overflow                       [406] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:22:10.093136000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-3.33918747908982423558926400691411483952] and current target energy [-8.90455817022491179272262662815462405932]. Set energy to 0.
20.05.2024 04:22:10.102140000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:10.102609000 usim_creator.handle_overflow                       [406] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:22:11.124665000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.3920860524009662474812293760096783081738] and current target energy [9.86291300004886141201881604615902762794]. Set energy to 0.
20.05.2024 04:22:11.164928000 usim_creator.handle_overflow                       [411] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:11.173196000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.3920860524009662474812293760096783081738] and current target energy [-9.86291300004886141201881604615902762794]. Set energy to 0.
20.05.2024 04:22:11.189707000 usim_creator.handle_overflow                       [411] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:11.588702000 usim_process.process_queue                         Overflow for target space id [2024052004210931900000000000000000000000000000000000044] with energy [.942700351636857711539163024403705714395] and current target energy [9.71442995422594592051056074756364370836]. Set energy to 0.
20.05.2024 04:22:11.596665000 usim_creator.handle_overflow                       [413] Not implemented. Handle overflow for [2024052004210931900000000000000000000000000000000000044] escape strategy [0].
20.05.2024 04:22:11.602089000 usim_process.process_queue                         Overflow for target space id [2024052004210936800000000000000000000000000000000000045] with energy [.942700351636857711539163024403705714395] and current target energy [9.71442995422594592051056074756364370836]. Set energy to 0.
20.05.2024 04:22:11.609159000 usim_creator.handle_overflow                       [413] Not implemented. Handle overflow for [2024052004210936800000000000000000000000000000000000045] escape strategy [0].
20.05.2024 04:22:11.614803000 usim_process.process_queue                         Overflow for target space id [2024052004210941800000000000000000000000000000000000046] with energy [-.942700351636857711539163024403705714395] and current target energy [-9.71442995422594592051056074756364370836]. Set energy to 0.
20.05.2024 04:22:11.622146000 usim_creator.handle_overflow                       [413] Not implemented. Handle overflow for [2024052004210941800000000000000000000000000000000000046] escape strategy [0].
20.05.2024 04:22:11.626164000 usim_process.process_queue                         Overflow for target space id [2024052004210944800000000000000000000000000000000000047] with energy [-.942700351636857711539163024403705714395] and current target energy [-9.71442995422594592051056074756364370836]. Set energy to 0.
20.05.2024 04:22:11.634518000 usim_creator.handle_overflow                       [413] Not implemented. Handle overflow for [2024052004210944800000000000000000000000000000000000047] escape strategy [0].
20.05.2024 04:22:11.644740000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [3.54172195832747138400013924470466437195] and current target energy [8.10959879182497508462523616216541923962]. Set energy to 0.
20.05.2024 04:22:11.654201000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:11.654660000 usim_creator.handle_overflow                       [413] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:22:11.659003000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-3.54172195832747138400013924470466437195] and current target energy [-8.10959879182497508462523616216541923962]. Set energy to 0.
20.05.2024 04:22:11.668024000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:11.669295000 usim_creator.handle_overflow                       [413] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:22:12.125833000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [3.58953616163340145231914603000417469717] and current target energy [8.08476780811814584957691410386184585788]. Set energy to 0.
20.05.2024 04:22:12.152836000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:12.154331000 usim_creator.handle_overflow                       [415] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:22:12.167988000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-3.58953616163340145231914603000417469717] and current target energy [-8.08476780811814584957691410386184585788]. Set energy to 0.
20.05.2024 04:22:12.188767000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:12.190078000 usim_creator.handle_overflow                       [415] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:22:12.218881000 usim_process.process_queue                         Overflow for target space id [2024052004213975700000000000000000000000000000000000082] with energy [2.4752340729228342691023485621318167232] and current target energy [8.99003253162781500610245054502604397668]. Set energy to 0.
20.05.2024 04:22:12.241100000 usim_creator.handle_overflow                       [415] Handle pos overflow for [2024052004213975700000000000000000000000000000000000082] escape strategy [3].
20.05.2024 04:22:12.253750000 usim_process.process_queue                         Overflow for target space id [2024052004213980000000000000000000000000000000000000083] with energy [2.4752340729228342691023485621318167232] and current target energy [8.99003253162781500610245054502604397668]. Set energy to 0.
20.05.2024 04:22:12.280279000 usim_creator.handle_overflow                       [415] Handle pos overflow for [2024052004213980000000000000000000000000000000000000083] escape strategy [3].
20.05.2024 04:22:12.298038000 usim_process.process_queue                         Overflow for target space id [2024052004213983100000000000000000000000000000000000084] with energy [-2.4752340729228342691023485621318167232] and current target energy [-8.99003253162781500610245054502604397668]. Set energy to 0.
20.05.2024 04:22:12.321335000 usim_creator.handle_overflow                       [415] Handle pos overflow for [2024052004213983100000000000000000000000000000000000084] escape strategy [3].
20.05.2024 04:22:12.325246000 usim_process.process_queue                         Overflow for target space id [2024052004213986900000000000000000000000000000000000085] with energy [-2.4752340729228342691023485621318167232] and current target energy [-8.99003253162781500610245054502604397668]. Set energy to 0.
20.05.2024 04:22:12.353600000 usim_creator.handle_overflow                       [415] Handle pos overflow for [2024052004213986900000000000000000000000000000000000085] escape strategy [3].
20.05.2024 04:22:12.768143000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [2.01494467176433334010950588805594171912] and current target energy [8.77998463851115295395896305538387543101]. Set energy to 0.
20.05.2024 04:22:12.782725000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:12.783181000 usim_creator.handle_overflow                       [418] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:22:12.788992000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-2.01494467176433334010950588805594171912] and current target energy [-8.77998463851115295395896305538387543101]. Set energy to 0.
20.05.2024 04:22:12.797279000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:12.797747000 usim_creator.handle_overflow                       [418] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:22:13.015619000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [3.95912039321369941344879724556892872689] and current target energy [6.05728904148491045137532081665323824815]. Set energy to 0.
20.05.2024 04:22:13.039532000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:13.040185000 usim_creator.handle_overflow                       [419] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:22:13.049405000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-3.95912039321369941344879724556892872689] and current target energy [-6.05728904148491045137532081665323824815]. Set energy to 0.
20.05.2024 04:22:13.063652000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:13.064902000 usim_creator.handle_overflow                       [419] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:22:13.728564000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.41044473636405012682891442110706074446] and current target energy [8.12546923875863297196396390882704165443]. Set energy to 0.
20.05.2024 04:22:13.752420000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:13.753047000 usim_creator.handle_overflow                       [422] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:22:13.756334000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.41044473636405012682891442110706074446] and current target energy [8.12546923875863297196396390882704165443]. Set energy to 0.
20.05.2024 04:22:13.765601000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:13.766681000 usim_creator.handle_overflow                       [422] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:22:13.773265000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.41044473636405012682891442110706074446] and current target energy [-8.12546923875863297196396390882704165443]. Set energy to 0.
20.05.2024 04:22:13.781365000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:13.782121000 usim_creator.handle_overflow                       [422] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:22:13.785509000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.41044473636405012682891442110706074446] and current target energy [-8.12546923875863297196396390882704165443]. Set energy to 0.
20.05.2024 04:22:13.796148000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:13.796596000 usim_creator.handle_overflow                       [422] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:22:13.801499000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.41044473636405012682891442110706074446] and current target energy [6.22532089144033467613801958819819435332]. Set energy to 0.
20.05.2024 04:22:13.808445000 usim_creator.handle_overflow                       [422] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:22:13.812039000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.41044473636405012682891442110706074446] and current target energy [6.22532089144033467613801958819819435332]. Set energy to 0.
20.05.2024 04:22:13.821773000 usim_creator.handle_overflow                       [422] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:22:13.826960000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.41044473636405012682891442110706074446] and current target energy [-6.22532089144033467613801958819819435332]. Set energy to 0.
20.05.2024 04:22:13.834933000 usim_creator.handle_overflow                       [422] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:22:13.839077000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.41044473636405012682891442110706074446] and current target energy [-6.22532089144033467613801958819819435332]. Set energy to 0.
20.05.2024 04:22:13.847178000 usim_creator.handle_overflow                       [422] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:22:14.315796000 usim_process.process_queue                         Overflow for target space id [2024052004205948300000000000000000000000000000000000024] with energy [.8158755347298816669913556738824333934588] and current target energy [9.88359769478955069917658646097804489083]. Set energy to 0.
20.05.2024 04:22:14.335808000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004205948300000000000000000000000000000000000024] escape strategy [0].
20.05.2024 04:22:14.338886000 usim_process.process_queue                         Overflow for target space id [2024052004205949500000000000000000000000000000000000025] with energy [.8158755347298816669913556738824333934588] and current target energy [9.88359769478955069917658646097804489083]. Set energy to 0.
20.05.2024 04:22:14.347237000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004205949500000000000000000000000000000000000025] escape strategy [0].
20.05.2024 04:22:14.350448000 usim_process.process_queue                         Overflow for target space id [2024052004205950700000000000000000000000000000000000026] with energy [-.8158755347298816669913556738824333934588] and current target energy [-9.88359769478955069917658646097804489083]. Set energy to 0.
20.05.2024 04:22:14.366368000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004205950700000000000000000000000000000000000026] escape strategy [0].
20.05.2024 04:22:14.376662000 usim_process.process_queue                         Overflow for target space id [2024052004205952100000000000000000000000000000000000027] with energy [-.8158755347298816669913556738824333934588] and current target energy [-9.88359769478955069917658646097804489083]. Set energy to 0.
20.05.2024 04:22:14.388796000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004205952100000000000000000000000000000000000027] escape strategy [0].
20.05.2024 04:22:14.391989000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [3.11755585585534587181673449333270690524] and current target energy [8.05977868705733336043802355222376687647]. Set energy to 0.
20.05.2024 04:22:14.411941000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:14.413390000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:22:14.419057000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-3.11755585585534587181673449333270690524] and current target energy [-8.05977868705733336043802355222376687647]. Set energy to 0.
20.05.2024 04:22:14.439007000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:14.440200000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:22:14.455134000 usim_process.process_queue                         Overflow for target space id [2024052004211700300000000000000000000000000000000000062] with energy [.9527417797408769861450589793549182317475] and current target energy [9.17272446165172905962345446505812672702]. Set energy to 0.
20.05.2024 04:22:14.471818000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004211700300000000000000000000000000000000000062] escape strategy [0].
20.05.2024 04:22:14.478275000 usim_process.process_queue                         Overflow for target space id [2024052004211706000000000000000000000000000000000000063] with energy [.9527417797408769861450589793549182317475] and current target energy [9.17272446165172905962345446505812672702]. Set energy to 0.
20.05.2024 04:22:14.491799000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004211706000000000000000000000000000000000000063] escape strategy [0].
20.05.2024 04:22:14.503952000 usim_process.process_queue                         Overflow for target space id [2024052004211711600000000000000000000000000000000000064] with energy [-.9527417797408769861450589793549182317475] and current target energy [-9.17272446165172905962345446505812672702]. Set energy to 0.
20.05.2024 04:22:14.517359000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004211711600000000000000000000000000000000000064] escape strategy [0].
20.05.2024 04:22:14.524385000 usim_process.process_queue                         Overflow for target space id [2024052004211716600000000000000000000000000000000000065] with energy [-.9527417797408769861450589793549182317475] and current target energy [-9.17272446165172905962345446505812672702]. Set energy to 0.
20.05.2024 04:22:14.537150000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004211716600000000000000000000000000000000000065] escape strategy [0].
20.05.2024 04:22:14.552480000 usim_process.process_queue                         Overflow for target space id [2024052004211990800000000000000000000000000000000000070] with energy [2.42238567045039224677716447706927996456] and current target energy [9.90093629169133707640939424852726689281]. Set energy to 0.
20.05.2024 04:22:14.576186000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:14.576909000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004211990800000000000000000000000000000000000070] escape strategy [7].
20.05.2024 04:22:14.593254000 usim_process.process_queue                         Overflow for target space id [2024052004211994200000000000000000000000000000000000071] with energy [2.42238567045039224677716447706927996456] and current target energy [9.90093629169133707640939424852726689281]. Set energy to 0.
20.05.2024 04:22:14.617840000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:14.618567000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004211994200000000000000000000000000000000000071] escape strategy [7].
20.05.2024 04:22:14.629667000 usim_process.process_queue                         Overflow for target space id [2024052004211998600000000000000000000000000000000000072] with energy [-2.42238567045039224677716447706927996456] and current target energy [-9.90093629169133707640939424852726689281]. Set energy to 0.
20.05.2024 04:22:14.651941000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:14.664145000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004211998600000000000000000000000000000000000072] escape strategy [7].
20.05.2024 04:22:14.687835000 usim_process.process_queue                         Overflow for target space id [2024052004212000300000000000000000000000000000000000073] with energy [-2.42238567045039224677716447706927996456] and current target energy [-9.90093629169133707640939424852726689281]. Set energy to 0.
20.05.2024 04:22:14.711760000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:14.713098000 usim_creator.handle_overflow                       [424] Not implemented. Handle overflow for [2024052004212000300000000000000000000000000000000000073] escape strategy [7].
20.05.2024 04:22:14.941911000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.6017973251360418028555501143520406878275] and current target energy [9.42268679786414205651337895656616217675]. Set energy to 0.
20.05.2024 04:22:14.956021000 usim_creator.handle_overflow                       [425] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:14.961020000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.6017973251360418028555501143520406878275] and current target energy [-9.42268679786414205651337895656616217675]. Set energy to 0.
20.05.2024 04:22:14.969687000 usim_creator.handle_overflow                       [425] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:14.995720000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [3.32864035670510666811917755172054667132] and current target energy [6.67837495817964847117852801382822967903]. Set energy to 0.
20.05.2024 04:22:15.022650000 usim_creator.handle_overflow                       [425] Handle pos overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [3].
20.05.2024 04:22:15.035798000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-3.32864035670510666811917755172054667132] and current target energy [-6.67837495817964847117852801382822967903]. Set energy to 0.
20.05.2024 04:22:15.058046000 usim_creator.handle_overflow                       [425] Handle pos overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [3].
20.05.2024 04:22:15.908203000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.09779347261006285486438303631335220948] and current target energy [9.62875720217666884568880182963265100525]. Set energy to 0.
20.05.2024 04:22:15.947056000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:15.950150000 usim_creator.handle_overflow                       [429] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:22:15.960701000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.09779347261006285486438303631335220948] and current target energy [9.62875720217666884568880182963265100525]. Set energy to 0.
20.05.2024 04:22:15.976092000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:15.983741000 usim_creator.handle_overflow                       [429] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:22:15.995180000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.09779347261006285486438303631335220948] and current target energy [-9.62875720217666884568880182963265100525]. Set energy to 0.
20.05.2024 04:22:16.022450000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:16.024120000 usim_creator.handle_overflow                       [429] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:22:16.042642000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.09779347261006285486438303631335220948] and current target energy [-9.62875720217666884568880182963265100525]. Set energy to 0.
20.05.2024 04:22:16.061195000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:16.063015000 usim_creator.handle_overflow                       [429] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:22:16.086422000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.75599259105774010334049030114250686816] and current target energy [6.23511171171069174363346898666541381047]. Set energy to 0.
20.05.2024 04:22:16.106900000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:16.107714000 usim_creator.handle_overflow                       [429] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:22:16.120454000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.75599259105774010334049030114250686816] and current target energy [-6.23511171171069174363346898666541381047]. Set energy to 0.
20.05.2024 04:22:16.135417000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:16.140349000 usim_creator.handle_overflow                       [429] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:22:16.376370000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [2.42238567045039224677716447706927996456] and current target energy [8.51943117693189530979972151322630384997]. Set energy to 0.
20.05.2024 04:22:16.395914000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:16.402546000 usim_creator.handle_overflow                       [430] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:22:16.418814000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [2.42238567045039224677716447706927996456] and current target energy [8.51943117693189530979972151322630384997]. Set energy to 0.
20.05.2024 04:22:16.438831000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:16.440213000 usim_creator.handle_overflow                       [430] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:22:16.464045000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-2.42238567045039224677716447706927996456] and current target energy [-8.51943117693189530979972151322630384997]. Set energy to 0.
20.05.2024 04:22:16.492105000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:16.499480000 usim_creator.handle_overflow                       [430] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:22:16.508860000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-2.42238567045039224677716447706927996456] and current target energy [-8.51943117693189530979972151322630384997]. Set energy to 0.
20.05.2024 04:22:16.527834000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:16.540058000 usim_creator.handle_overflow                       [430] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:22:16.553855000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [4.98241341267294243470867987238725183877] and current target energy [9.93318545819173216700710037919379917289]. Set energy to 0.
20.05.2024 04:22:16.582847000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:16.584086000 usim_creator.handle_overflow                       [430] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:22:16.598407000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-4.98241341267294243470867987238725183877] and current target energy [-9.93318545819173216700710037919379917289]. Set energy to 0.
20.05.2024 04:22:16.618464000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:16.619993000 usim_creator.handle_overflow                       [430] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:22:17.351123000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [.50373616794108333502737647201398542978] and current target energy [9.51198518211548020668098060228501373631]. Set energy to 0.
20.05.2024 04:22:17.373041000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:17.377110000 usim_creator.handle_overflow                       [434] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:22:17.393902000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-.50373616794108333502737647201398542978] and current target energy [-9.51198518211548020668098060228501373631]. Set energy to 0.
20.05.2024 04:22:17.413793000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:17.423959000 usim_creator.handle_overflow                       [434] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:22:18.526260000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.81698283589766118014051498489438301811] and current target energy [7.47295195294639848235724686941200713401]. Set energy to 0.
20.05.2024 04:22:18.535389000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:18.536180000 usim_creator.handle_overflow                       [440] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:22:18.541498000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.81698283589766118014051498489438301811] and current target energy [7.47295195294639848235724686941200713401]. Set energy to 0.
20.05.2024 04:22:18.550449000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:18.551120000 usim_creator.handle_overflow                       [440] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:22:18.557805000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.81698283589766118014051498489438301811] and current target energy [-7.47295195294639848235724686941200713401]. Set energy to 0.
20.05.2024 04:22:18.565317000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:18.566657000 usim_creator.handle_overflow                       [440] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:22:18.573798000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.81698283589766118014051498489438301811] and current target energy [-7.47295195294639848235724686941200713401]. Set energy to 0.
20.05.2024 04:22:18.582981000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:18.583711000 usim_creator.handle_overflow                       [440] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:22:18.739597000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [3.4493804492019041215201148545264906571] and current target energy [7.63396567179532236028102996978876603621]. Set energy to 0.
20.05.2024 04:22:18.751551000 usim_creator.handle_overflow                       [441] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:18.755526000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-3.4493804492019041215201148545264906571] and current target energy [-7.63396567179532236028102996978876603621]. Set energy to 0.
20.05.2024 04:22:18.762346000 usim_creator.handle_overflow                       [441] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:18.779110000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [1.41861300529866085016247932416666794993] and current target energy [9.96482682534588486941735974477450367753]. Set energy to 0.
20.05.2024 04:22:18.798356000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:18.799040000 usim_creator.handle_overflow                       [441] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:22:18.808190000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-1.41861300529866085016247932416666794993] and current target energy [-9.96482682534588486941735974477450367753]. Set energy to 0.
20.05.2024 04:22:18.824020000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:18.829140000 usim_creator.handle_overflow                       [441] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:22:18.947247000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [1.01116430266200260438344324314037621025] and current target energy [9.69862102302977411806691707078066079427]. Set energy to 0.
20.05.2024 04:22:18.957475000 usim_creator.handle_overflow                       [442] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:22:18.960534000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [1.01116430266200260438344324314037621025] and current target energy [9.69862102302977411806691707078066079427]. Set energy to 0.
20.05.2024 04:22:18.968809000 usim_creator.handle_overflow                       [442] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:22:18.974312000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-1.01116430266200260438344324314037621025] and current target energy [-9.69862102302977411806691707078066079427]. Set energy to 0.
20.05.2024 04:22:18.981479000 usim_creator.handle_overflow                       [442] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:22:18.986358000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-1.01116430266200260438344324314037621025] and current target energy [-9.69862102302977411806691707078066079427]. Set energy to 0.
20.05.2024 04:22:18.993764000 usim_creator.handle_overflow                       [442] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:22:19.565876000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [.653594229200711746705802915072507156795] and current target energy [9.8063075560663564633954898906116824697]. Set energy to 0.
20.05.2024 04:22:19.592422000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:19.597595000 usim_creator.handle_overflow                       [445] Not implemented. Handle overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [7].
20.05.2024 04:22:19.618185000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [.653594229200711746705802915072507156795] and current target energy [9.8063075560663564633954898906116824697]. Set energy to 0.
20.05.2024 04:22:19.637579000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:19.638825000 usim_creator.handle_overflow                       [445] Not implemented. Handle overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [7].
20.05.2024 04:22:19.659007000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-.653594229200711746705802915072507156795] and current target energy [-9.8063075560663564633954898906116824697]. Set energy to 0.
20.05.2024 04:22:19.676862000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:19.677984000 usim_creator.handle_overflow                       [445] Not implemented. Handle overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [7].
20.05.2024 04:22:19.691411000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-.653594229200711746705802915072507156795] and current target energy [-9.8063075560663564633954898906116824697]. Set energy to 0.
20.05.2024 04:22:19.709522000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:19.710773000 usim_creator.handle_overflow                       [445] Not implemented. Handle overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [7].
20.05.2024 04:22:20.359403000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [2.72339081660845322448774815545470206399] and current target energy [9.89763180657238040455259228936986164656]. Set energy to 0.
20.05.2024 04:22:20.401243000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:20.419739000 usim_creator.handle_overflow                       [450] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:22:20.432297000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-2.72339081660845322448774815545470206399] and current target energy [-9.89763180657238040455259228936986164656]. Set energy to 0.
20.05.2024 04:22:20.449497000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:20.450910000 usim_creator.handle_overflow                       [450] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:22:20.980394000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [4.84431163994370644376394055996823002886] and current target energy [7.38176292710053712900631191860539878602]. Set energy to 0.
20.05.2024 04:22:20.999244000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:21.003956000 usim_creator.handle_overflow                       [452] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:22:21.008697000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-4.84431163994370644376394055996823002886] and current target energy [-7.38176292710053712900631191860539878602]. Set energy to 0.
20.05.2024 04:22:21.025916000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:21.027032000 usim_creator.handle_overflow                       [452] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:22:22.037218000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [4.46299118820113416080887771685305043206] and current target energy [8.73768093635090500381284107326643501221]. Set energy to 0.
20.05.2024 04:22:22.063806000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:22.076143000 usim_creator.handle_overflow                       [456] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:22:22.100403000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-4.46299118820113416080887771685305043206] and current target energy [-8.73768093635090500381284107326643501221]. Set energy to 0.
20.05.2024 04:22:22.131428000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:22.151881000 usim_creator.handle_overflow                       [456] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:22:22.422119000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.9345064502869706750427146479230496550175] and current target energy [9.23729215020686749837956055427075712278]. Set energy to 0.
20.05.2024 04:22:22.453824000 usim_creator.handle_overflow                       [457] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:22.476219000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.9345064502869706750427146479230496550175] and current target energy [-9.23729215020686749837956055427075712278]. Set energy to 0.
20.05.2024 04:22:22.499028000 usim_creator.handle_overflow                       [457] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:23.535652000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [1.84745843004137349967591211085415142456] and current target energy [9.68862327988741288752788111993646005772]. Set energy to 0.
20.05.2024 04:22:23.562315000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:23.574248000 usim_creator.handle_overflow                       [461] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:22:23.587121000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-1.84745843004137349967591211085415142456] and current target energy [-9.68862327988741288752788111993646005772]. Set energy to 0.
20.05.2024 04:22:23.604623000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:23.605830000 usim_creator.handle_overflow                       [461] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:22:23.628454000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [1.50829016163200145899150232812337271045] and current target energy [8.92598237640226832161775543370610086412]. Set energy to 0.
20.05.2024 04:22:23.646918000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:23.654398000 usim_creator.handle_overflow                       [461] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:22:23.661999000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-1.50829016163200145899150232812337271045] and current target energy [-8.92598237640226832161775543370610086412]. Set energy to 0.
20.05.2024 04:22:23.680640000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:23.681860000 usim_creator.handle_overflow                       [461] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:22:24.013598000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [4.55714190822681581971133489707288335801] and current target energy [8.18527514353716737628900175499164412617]. Set energy to 0.
20.05.2024 04:22:24.024287000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:24.025047000 usim_creator.handle_overflow                       [463] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:22:24.032238000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-4.55714190822681581971133489707288335801] and current target energy [-8.18527514353716737628900175499164412617]. Set energy to 0.
20.05.2024 04:22:24.041072000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:24.041697000 usim_creator.handle_overflow                       [463] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:22:24.235721000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.9076956065823273150074467268730471783] and current target energy [7.58102103397992209880812848672270598959]. Set energy to 0.
20.05.2024 04:22:24.259251000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:24.270750000 usim_creator.handle_overflow                       [464] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:22:24.280023000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.9076956065823273150074467268730471783] and current target energy [7.58102103397992209880812848672270598959]. Set energy to 0.
20.05.2024 04:22:24.304520000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:24.304882000 usim_creator.handle_overflow                       [464] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:22:24.307565000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.9076956065823273150074467268730471783] and current target energy [-7.58102103397992209880812848672270598959]. Set energy to 0.
20.05.2024 04:22:24.320057000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:24.320359000 usim_creator.handle_overflow                       [464] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:22:24.324111000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.9076956065823273150074467268730471783] and current target energy [-7.58102103397992209880812848672270598959]. Set energy to 0.
20.05.2024 04:22:24.332750000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:24.333075000 usim_creator.handle_overflow                       [464] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:22:24.359545000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.9076956065823273150074467268730471783] and current target energy [8.70968906453328032373966839812235974892]. Set energy to 0.
20.05.2024 04:22:24.380818000 usim_creator.handle_overflow                       [464] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:22:24.383564000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.9076956065823273150074467268730471783] and current target energy [8.70968906453328032373966839812235974892]. Set energy to 0.
20.05.2024 04:22:24.396569000 usim_creator.handle_overflow                       [464] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:22:24.410455000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.9076956065823273150074467268730471783] and current target energy [-8.70968906453328032373966839812235974892]. Set energy to 0.
20.05.2024 04:22:24.426411000 usim_creator.handle_overflow                       [464] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:22:24.439701000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.9076956065823273150074467268730471783] and current target energy [-8.70968906453328032373966839812235974892]. Set energy to 0.
20.05.2024 04:22:24.475117000 usim_creator.handle_overflow                       [464] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:22:24.498354000 usim_process.process_queue                         Overflow for target space id [2024052004211134000000000000000000000000000000000000052] with energy [.8533924789674112960360395261517746646588] and current target energy [9.70511538520786726920031349997378030723]. Set energy to 0.
20.05.2024 04:22:24.523236000 usim_creator.handle_overflow                       [464] Not implemented. Handle overflow for [2024052004211134000000000000000000000000000000000000052] escape strategy [0].
20.05.2024 04:22:24.538944000 usim_process.process_queue                         Overflow for target space id [2024052004211138700000000000000000000000000000000000053] with energy [.8533924789674112960360395261517746646588] and current target energy [9.70511538520786726920031349997378030723]. Set energy to 0.
20.05.2024 04:22:24.559854000 usim_creator.handle_overflow                       [464] Not implemented. Handle overflow for [2024052004211138700000000000000000000000000000000000053] escape strategy [0].
20.05.2024 04:22:24.571784000 usim_process.process_queue                         Overflow for target space id [2024052004211143900000000000000000000000000000000000054] with energy [-.8533924789674112960360395261517746646588] and current target energy [-9.70511538520786726920031349997378030723]. Set energy to 0.
20.05.2024 04:22:24.588246000 usim_creator.handle_overflow                       [464] Not implemented. Handle overflow for [2024052004211143900000000000000000000000000000000000054] escape strategy [0].
20.05.2024 04:22:24.591728000 usim_process.process_queue                         Overflow for target space id [2024052004211147900000000000000000000000000000000000055] with energy [-.8533924789674112960360395261517746646588] and current target energy [-9.70511538520786726920031349997378030723]. Set energy to 0.
20.05.2024 04:22:24.612395000 usim_creator.handle_overflow                       [464] Not implemented. Handle overflow for [2024052004211147900000000000000000000000000000000000055] escape strategy [0].
20.05.2024 04:22:25.462298000 usim_process.process_queue                         Overflow for target space id [2024052004205701200000000000000000000000000000000000015] with energy [.666444685814145391001557891958821910725] and current target energy [9.86909969790011938718360971790370007025]. Set energy to 0.
20.05.2024 04:22:25.501998000 usim_creator.handle_overflow                       [467] Not implemented. Handle overflow for [2024052004205701200000000000000000000000000000000000015] escape strategy [0].
20.05.2024 04:22:25.525022000 usim_process.process_queue                         Overflow for target space id [2024052004205702800000000000000000000000000000000000017] with energy [.666444685814145391001557891958821910725] and current target energy [9.86909969790011938718360971790370007025]. Set energy to 0.
20.05.2024 04:22:25.546031000 usim_creator.handle_overflow                       [467] Not implemented. Handle overflow for [2024052004205702800000000000000000000000000000000000017] escape strategy [0].
20.05.2024 04:22:25.567126000 usim_process.process_queue                         Overflow for target space id [2024052004205711900000000000000000000000000000000000019] with energy [-.666444685814145391001557891958821910725] and current target energy [-9.86909969790011938718360971790370007025]. Set energy to 0.
20.05.2024 04:22:25.597513000 usim_creator.handle_overflow                       [467] Not implemented. Handle overflow for [2024052004205711900000000000000000000000000000000000019] escape strategy [0].
20.05.2024 04:22:25.622210000 usim_process.process_queue                         Overflow for target space id [2024052004205716200000000000000000000000000000000000021] with energy [-.666444685814145391001557891958821910725] and current target energy [-9.86909969790011938718360971790370007025]. Set energy to 0.
20.05.2024 04:22:25.639427000 usim_creator.handle_overflow                       [467] Not implemented. Handle overflow for [2024052004205716200000000000000000000000000000000000021] escape strategy [0].
20.05.2024 04:22:26.435330000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.21901859756448942538014194130626619549] and current target energy [7.60261246666507431435927094858135002741]. Set energy to 0.
20.05.2024 04:22:26.460626000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:26.462053000 usim_creator.handle_overflow                       [470] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:22:26.472092000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.21901859756448942538014194130626619549] and current target energy [-7.60261246666507431435927094858135002741]. Set energy to 0.
20.05.2024 04:22:26.503035000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:26.514537000 usim_creator.handle_overflow                       [470] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:22:27.473277000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.81148331129686574016720694719863642441] and current target energy [8.43803719512897885076028388261253239098]. Set energy to 0.
20.05.2024 04:22:27.503282000 usim_creator.handle_overflow                       [473] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:27.518921000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.81148331129686574016720694719863642441] and current target energy [-8.43803719512897885076028388261253239098]. Set energy to 0.
20.05.2024 04:22:27.528696000 usim_creator.handle_overflow                       [473] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:27.586763000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [4.05739312442475553655860666513552654983] and current target energy [8.74013169511253214296627716917087618881]. Set energy to 0.
20.05.2024 04:22:27.609646000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:27.620065000 usim_creator.handle_overflow                       [473] Not implemented. Handle overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [7].
20.05.2024 04:22:27.622686000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-4.05739312442475553655860666513552654983] and current target energy [-8.74013169511253214296627716917087618881]. Set energy to 0.
20.05.2024 04:22:27.632215000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:27.632513000 usim_creator.handle_overflow                       [473] Not implemented. Handle overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [7].
20.05.2024 04:22:28.416784000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [3.75084729819731284951766498544671794671] and current target energy [9.58944709562019878407012422843210109273]. Set energy to 0.
20.05.2024 04:22:28.442005000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:28.448335000 usim_creator.handle_overflow                       [476] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:22:28.476036000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-3.75084729819731284951766498544671794671] and current target energy [-9.58944709562019878407012422843210109273]. Set energy to 0.
20.05.2024 04:22:28.496735000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:28.497101000 usim_creator.handle_overflow                       [476] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:22:28.730327000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [2.02909491446949906630066228467067669703] and current target energy [8.93797404607416611535882690622025015797]. Set energy to 0.
20.05.2024 04:22:28.750973000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:28.752351000 usim_creator.handle_overflow                       [477] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:22:28.758652000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [2.02909491446949906630066228467067669703] and current target energy [8.93797404607416611535882690622025015797]. Set energy to 0.
20.05.2024 04:22:28.775859000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:28.776241000 usim_creator.handle_overflow                       [477] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:22:28.778965000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-2.02909491446949906630066228467067669703] and current target energy [-8.93797404607416611535882690622025015797]. Set energy to 0.
20.05.2024 04:22:28.790395000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:28.790767000 usim_creator.handle_overflow                       [477] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:22:28.795116000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-2.02909491446949906630066228467067669703] and current target energy [-8.93797404607416611535882690622025015797]. Set energy to 0.
20.05.2024 04:22:28.813907000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:28.837144000 usim_creator.handle_overflow                       [477] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:22:28.845101000 usim_process.process_queue                         Overflow for target space id [2024052004211868000000000000000000000000000000000000066] with energy [.845846916737460776305498540413206223565] and current target energy [9.81552973252892969506224037384992195428]. Set energy to 0.
20.05.2024 04:22:28.870390000 usim_creator.handle_overflow                       [477] Not implemented. Handle overflow for [2024052004211868000000000000000000000000000000000000066] escape strategy [0].
20.05.2024 04:22:28.891300000 usim_process.process_queue                         Overflow for target space id [2024052004211870600000000000000000000000000000000000067] with energy [.845846916737460776305498540413206223565] and current target energy [9.81552973252892969506224037384992195428]. Set energy to 0.
20.05.2024 04:22:28.915861000 usim_creator.handle_overflow                       [477] Not implemented. Handle overflow for [2024052004211870600000000000000000000000000000000000067] escape strategy [0].
20.05.2024 04:22:28.938401000 usim_process.process_queue                         Overflow for target space id [2024052004211874300000000000000000000000000000000000068] with energy [-.845846916737460776305498540413206223565] and current target energy [-9.81552973252892969506224037384992195428]. Set energy to 0.
20.05.2024 04:22:28.973958000 usim_creator.handle_overflow                       [477] Not implemented. Handle overflow for [2024052004211874300000000000000000000000000000000000068] escape strategy [0].
20.05.2024 04:22:28.995088000 usim_process.process_queue                         Overflow for target space id [2024052004211878000000000000000000000000000000000000069] with energy [-.845846916737460776305498540413206223565] and current target energy [-9.81552973252892969506224037384992195428]. Set energy to 0.
20.05.2024 04:22:29.023117000 usim_creator.handle_overflow                       [477] Not implemented. Handle overflow for [2024052004211878000000000000000000000000000000000000069] escape strategy [0].
20.05.2024 04:22:30.212035000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.09014764152365692528363893372449111181] and current target energy [8.26886470936889590876197337801522944757]. Set energy to 0.
20.05.2024 04:22:30.231684000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:30.235906000 usim_creator.handle_overflow                       [482] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:22:30.259802000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.09014764152365692528363893372449111181] and current target energy [8.26886470936889590876197337801522944757]. Set energy to 0.
20.05.2024 04:22:30.281508000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:30.290536000 usim_creator.handle_overflow                       [482] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:22:30.308884000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.09014764152365692528363893372449111181] and current target energy [-8.26886470936889590876197337801522944757]. Set energy to 0.
20.05.2024 04:22:30.330800000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:30.335536000 usim_creator.handle_overflow                       [482] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:22:30.338426000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.09014764152365692528363893372449111181] and current target energy [-8.26886470936889590876197337801522944757]. Set energy to 0.
20.05.2024 04:22:30.368061000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:30.381365000 usim_creator.handle_overflow                       [482] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:22:30.416815000 usim_process.process_queue                         Overflow for target space id [2024052004210570400000000000000000000000000000000000038] with energy [.7779754171699606162474755397760903793338] and current target energy [9.62334172376483418346955091128546518456]. Set energy to 0.
20.05.2024 04:22:30.438716000 usim_creator.handle_overflow                       [482] Not implemented. Handle overflow for [2024052004210570400000000000000000000000000000000000038] escape strategy [0].
20.05.2024 04:22:30.461675000 usim_process.process_queue                         Overflow for target space id [2024052004210571900000000000000000000000000000000000039] with energy [.7779754171699606162474755397760903793338] and current target energy [9.62334172376483418346955091128546518456]. Set energy to 0.
20.05.2024 04:22:30.482187000 usim_creator.handle_overflow                       [482] Not implemented. Handle overflow for [2024052004210571900000000000000000000000000000000000039] escape strategy [0].
20.05.2024 04:22:30.509851000 usim_process.process_queue                         Overflow for target space id [2024052004210573600000000000000000000000000000000000040] with energy [-.7779754171699606162474755397760903793338] and current target energy [-9.62334172376483418346955091128546518456]. Set energy to 0.
20.05.2024 04:22:30.533788000 usim_creator.handle_overflow                       [482] Not implemented. Handle overflow for [2024052004210573600000000000000000000000000000000000040] escape strategy [0].
20.05.2024 04:22:30.536544000 usim_process.process_queue                         Overflow for target space id [2024052004210575900000000000000000000000000000000000041] with energy [-.7779754171699606162474755397760903793338] and current target energy [-9.62334172376483418346955091128546518456]. Set energy to 0.
20.05.2024 04:22:30.545774000 usim_creator.handle_overflow                       [482] Not implemented. Handle overflow for [2024052004210575900000000000000000000000000000000000041] escape strategy [0].
20.05.2024 04:22:30.820223000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.06190307322800203761778922030249623092] and current target energy [9.18716139423299307655057899749423840791]. Set energy to 0.
20.05.2024 04:22:30.855024000 usim_creator.handle_overflow                       [483] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:30.858386000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.06190307322800203761778922030249623092] and current target energy [-9.18716139423299307655057899749423840791]. Set energy to 0.
20.05.2024 04:22:30.887910000 usim_creator.handle_overflow                       [483] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:31.724621000 usim_process.process_queue                         Overflow for target space id [2024052004221501800000000000000000000000000000000000092] with energy [2.4084156749874586657685652765780560693] and current target energy [8.11478624884951107311721333027105309965]. Set energy to 0.
20.05.2024 04:22:31.752361000 usim_creator.handle_overflow                       [486] Handle pos overflow for [2024052004221501800000000000000000000000000000000000092] escape strategy [3].
20.05.2024 04:22:31.766115000 usim_process.process_queue                         Overflow for target space id [2024052004221505600000000000000000000000000000000000093] with energy [-2.4084156749874586657685652765780560693] and current target energy [-8.11478624884951107311721333027105309965]. Set energy to 0.
20.05.2024 04:22:31.791281000 usim_creator.handle_overflow                       [486] Handle pos overflow for [2024052004221505600000000000000000000000000000000000093] escape strategy [3].
20.05.2024 04:22:32.385995000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.7289364164292425040615271766173888841] and current target energy [6.01373222237135845196660226009051236859]. Set energy to 0.
20.05.2024 04:22:32.406591000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:32.411153000 usim_creator.handle_overflow                       [488] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:22:32.419623000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.7289364164292425040615271766173888841] and current target energy [-6.01373222237135845196660226009051236859]. Set energy to 0.
20.05.2024 04:22:32.439008000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:32.439613000 usim_creator.handle_overflow                       [488] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:22:32.986389000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [.64582700861002754676289621319274023391] and current target energy [9.96730882218580614955546694739838390728]. Set energy to 0.
20.05.2024 04:22:33.016448000 usim_creator.handle_overflow                       [490] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:22:33.026461000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [.64582700861002754676289621319274023391] and current target energy [9.96730882218580614955546694739838390728]. Set energy to 0.
20.05.2024 04:22:33.051922000 usim_creator.handle_overflow                       [490] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:22:33.069686000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-.64582700861002754676289621319274023391] and current target energy [-9.96730882218580614955546694739838390728]. Set energy to 0.
20.05.2024 04:22:33.086048000 usim_creator.handle_overflow                       [490] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:22:33.096642000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-.64582700861002754676289621319274023391] and current target energy [-9.96730882218580614955546694739838390728]. Set energy to 0.
20.05.2024 04:22:33.111268000 usim_creator.handle_overflow                       [490] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:22:33.158011000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [2.4084156749874586657685652765780560693] and current target energy [9.63366269994983466307426110631222427719]. Set energy to 0.
20.05.2024 04:22:33.181007000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:33.182398000 usim_creator.handle_overflow                       [490] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:22:33.195440000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-2.4084156749874586657685652765780560693] and current target energy [-9.63366269994983466307426110631222427719]. Set energy to 0.
20.05.2024 04:22:33.222507000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:33.232955000 usim_creator.handle_overflow                       [490] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:22:33.579902000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [.55373937901032256386419260818879910596] and current target energy [9.45787283285848500812305435323477776819]. Set energy to 0.
20.05.2024 04:22:33.619298000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:33.624359000 usim_creator.handle_overflow                       [491] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:22:33.627591000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-.55373937901032256386419260818879910596] and current target energy [-9.45787283285848500812305435323477776819]. Set energy to 0.
20.05.2024 04:22:33.663153000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:33.677922000 usim_creator.handle_overflow                       [491] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:22:33.994491000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [2.44064752529756146576453439210561463603] and current target energy [8.11637965787799626520264913868270678812]. Set energy to 0.
20.05.2024 04:22:34.021521000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:34.028363000 usim_creator.handle_overflow                       [492] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:22:34.038866000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [2.44064752529756146576453439210561463603] and current target energy [8.11637965787799626520264913868270678812]. Set energy to 0.
20.05.2024 04:22:34.070852000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:34.072281000 usim_creator.handle_overflow                       [492] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:22:34.094104000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-2.44064752529756146576453439210561463603] and current target energy [-8.11637965787799626520264913868270678812]. Set energy to 0.
20.05.2024 04:22:34.115105000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:34.116115000 usim_creator.handle_overflow                       [492] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:22:34.118825000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-2.44064752529756146576453439210561463603] and current target energy [-8.11637965787799626520264913868270678812]. Set energy to 0.
20.05.2024 04:22:34.147287000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:34.150605000 usim_creator.handle_overflow                       [492] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:22:34.529264000 usim_process.process_queue                         Overflow for target space id [2024052004210261400000000000000000000000000000000000034] with energy [1.2230218602066709226420027670068894043] and current target energy [9.16603491120543881136497378594773122685]. Set energy to 0.
20.05.2024 04:22:34.554658000 usim_creator.handle_overflow                       [493] Not implemented. Handle overflow for [2024052004210261400000000000000000000000000000000000034] escape strategy [0].
20.05.2024 04:22:34.566001000 usim_process.process_queue                         Overflow for target space id [2024052004210264800000000000000000000000000000000000035] with energy [1.2230218602066709226420027670068894043] and current target energy [9.16603491120543881136497378594773122685]. Set energy to 0.
20.05.2024 04:22:34.577682000 usim_creator.handle_overflow                       [493] Not implemented. Handle overflow for [2024052004210264800000000000000000000000000000000000035] escape strategy [0].
20.05.2024 04:22:34.582104000 usim_process.process_queue                         Overflow for target space id [2024052004210269400000000000000000000000000000000000036] with energy [-1.2230218602066709226420027670068894043] and current target energy [-9.16603491120543881136497378594773122685]. Set energy to 0.
20.05.2024 04:22:34.591592000 usim_creator.handle_overflow                       [493] Not implemented. Handle overflow for [2024052004210269400000000000000000000000000000000000036] escape strategy [0].
20.05.2024 04:22:34.596316000 usim_process.process_queue                         Overflow for target space id [2024052004210273800000000000000000000000000000000000037] with energy [-1.2230218602066709226420027670068894043] and current target energy [-9.16603491120543881136497378594773122685]. Set energy to 0.
20.05.2024 04:22:34.605120000 usim_creator.handle_overflow                       [493] Not implemented. Handle overflow for [2024052004210273800000000000000000000000000000000000037] escape strategy [0].
20.05.2024 04:22:34.995408000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [4.50030821514089006217794108440973712666] and current target energy [6.79859334722508302009746677158608315556]. Set energy to 0.
20.05.2024 04:22:35.016566000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:35.017347000 usim_creator.handle_overflow                       [495] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:22:35.030344000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-4.50030821514089006217794108440973712666] and current target energy [-6.79859334722508302009746677158608315556]. Set energy to 0.
20.05.2024 04:22:35.049509000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:35.050904000 usim_creator.handle_overflow                       [495] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:22:35.389571000 usim_process.process_queue                         Overflow for target space id [2024052004211990800000000000000000000000000000000000070] with energy [2.44497361419607961079472339685708962905] and current target energy [9.7371500588707921598073925911528611941]. Set energy to 0.
20.05.2024 04:22:35.418405000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:35.421776000 usim_creator.handle_overflow                       [496] Not implemented. Handle overflow for [2024052004211990800000000000000000000000000000000000070] escape strategy [7].
20.05.2024 04:22:35.429275000 usim_process.process_queue                         Overflow for target space id [2024052004211994200000000000000000000000000000000000071] with energy [2.44497361419607961079472339685708962905] and current target energy [9.7371500588707921598073925911528611941]. Set energy to 0.
20.05.2024 04:22:35.446052000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:35.446775000 usim_creator.handle_overflow                       [496] Not implemented. Handle overflow for [2024052004211994200000000000000000000000000000000000071] escape strategy [7].
20.05.2024 04:22:35.462641000 usim_process.process_queue                         Overflow for target space id [2024052004211998600000000000000000000000000000000000072] with energy [-2.44497361419607961079472339685708962905] and current target energy [-9.7371500588707921598073925911528611941]. Set energy to 0.
20.05.2024 04:22:35.486863000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:35.494235000 usim_creator.handle_overflow                       [496] Not implemented. Handle overflow for [2024052004211998600000000000000000000000000000000000072] escape strategy [7].
20.05.2024 04:22:35.505087000 usim_process.process_queue                         Overflow for target space id [2024052004212000300000000000000000000000000000000000073] with energy [-2.44497361419607961079472339685708962905] and current target energy [-9.7371500588707921598073925911528611941]. Set energy to 0.
20.05.2024 04:22:35.523131000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:35.524248000 usim_creator.handle_overflow                       [496] Not implemented. Handle overflow for [2024052004212000300000000000000000000000000000000000073] escape strategy [7].
20.05.2024 04:22:35.850536000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [3.04760691055732942364898351150019806436] and current target energy [8.43944120556156409814745078591490716621]. Set energy to 0.
20.05.2024 04:22:35.876656000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:35.877707000 usim_creator.handle_overflow                       [497] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:22:35.880654000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-3.04760691055732942364898351150019806436] and current target energy [-8.43944120556156409814745078591490716621]. Set energy to 0.
20.05.2024 04:22:35.891264000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:35.891627000 usim_creator.handle_overflow                       [497] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:22:36.208276000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [2.53443335781851527017996295941802209713] and current target energy [9.00061643028178012435588216881947425331]. Set energy to 0.
20.05.2024 04:22:36.239238000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:36.241110000 usim_creator.handle_overflow                       [498] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:22:36.252133000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-2.53443335781851527017996295941802209713] and current target energy [-9.00061643028178012435588216881947425331]. Set energy to 0.
20.05.2024 04:22:36.270912000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:36.272977000 usim_creator.handle_overflow                       [498] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:22:36.634772000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [2.53443335781851527017996295941802209713] and current target energy [7.68730674983716264956727446668810815795]. Set energy to 0.
20.05.2024 04:22:36.651657000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:36.652345000 usim_creator.handle_overflow                       [500] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:22:36.658589000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-2.53443335781851527017996295941802209713] and current target energy [-7.68730674983716264956727446668810815795]. Set energy to 0.
20.05.2024 04:22:36.667138000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:36.667882000 usim_creator.handle_overflow                       [500] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:22:36.687378000 usim_process.process_queue                         Overflow for target space id [2024052004205948300000000000000000000000000000000000024] with energy [.843134585660484518318851240818345730125] and current target energy [9.80012597681462247159206883676018431185]. Set energy to 0.
20.05.2024 04:22:36.697436000 usim_creator.handle_overflow                       [500] Not implemented. Handle overflow for [2024052004205948300000000000000000000000000000000000024] escape strategy [0].
20.05.2024 04:22:36.702024000 usim_process.process_queue                         Overflow for target space id [2024052004205949500000000000000000000000000000000000025] with energy [.843134585660484518318851240818345730125] and current target energy [9.80012597681462247159206883676018431185]. Set energy to 0.
20.05.2024 04:22:36.709676000 usim_creator.handle_overflow                       [500] Not implemented. Handle overflow for [2024052004205949500000000000000000000000000000000000025] escape strategy [0].
20.05.2024 04:22:36.714395000 usim_process.process_queue                         Overflow for target space id [2024052004205950700000000000000000000000000000000000026] with energy [-.843134585660484518318851240818345730125] and current target energy [-9.80012597681462247159206883676018431185]. Set energy to 0.
20.05.2024 04:22:36.722544000 usim_creator.handle_overflow                       [500] Not implemented. Handle overflow for [2024052004205950700000000000000000000000000000000000026] escape strategy [0].
20.05.2024 04:22:36.727014000 usim_process.process_queue                         Overflow for target space id [2024052004205952100000000000000000000000000000000000027] with energy [-.843134585660484518318851240818345730125] and current target energy [-9.80012597681462247159206883676018431185]. Set energy to 0.
20.05.2024 04:22:36.735099000 usim_creator.handle_overflow                       [500] Not implemented. Handle overflow for [2024052004205952100000000000000000000000000000000000027] escape strategy [0].
20.05.2024 04:22:36.995208000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [.5345776581340890624906365559717902559675] and current target energy [9.77989445678431844317889358742835851619]. Set energy to 0.
20.05.2024 04:22:37.005211000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:37.006133000 usim_creator.handle_overflow                       [501] Not implemented. Handle overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [7].
20.05.2024 04:22:37.010023000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [.5345776581340890624906365559717902559675] and current target energy [9.77989445678431844317889358742835851619]. Set energy to 0.
20.05.2024 04:22:37.020211000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:37.020979000 usim_creator.handle_overflow                       [501] Not implemented. Handle overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [7].
20.05.2024 04:22:37.027589000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-.5345776581340890624906365559717902559675] and current target energy [-9.77989445678431844317889358742835851619]. Set energy to 0.
20.05.2024 04:22:37.037288000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:37.038223000 usim_creator.handle_overflow                       [501] Not implemented. Handle overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [7].
20.05.2024 04:22:37.040832000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-.5345776581340890624906365559717902559675] and current target energy [-9.77989445678431844317889358742835851619]. Set energy to 0.
20.05.2024 04:22:37.056227000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:37.056567000 usim_creator.handle_overflow                       [501] Not implemented. Handle overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [7].
20.05.2024 04:22:37.774705000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.89819957893821066954752445495757993134] and current target energy [6.62574297778579633278896916891074023008]. Set energy to 0.
20.05.2024 04:22:37.797765000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:37.798890000 usim_creator.handle_overflow                       [504] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:22:37.813218000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.89819957893821066954752445495757993134] and current target energy [6.62574297778579633278896916891074023008]. Set energy to 0.
20.05.2024 04:22:37.832429000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:37.835669000 usim_creator.handle_overflow                       [504] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:22:37.845913000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.89819957893821066954752445495757993134] and current target energy [-6.62574297778579633278896916891074023008]. Set energy to 0.
20.05.2024 04:22:37.867442000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:37.872952000 usim_creator.handle_overflow                       [504] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:22:37.891819000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.89819957893821066954752445495757993134] and current target energy [-6.62574297778579633278896916891074023008]. Set energy to 0.
20.05.2024 04:22:37.919150000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:37.926800000 usim_creator.handle_overflow                       [504] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:22:38.050421000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.005677670878464104830680051971242012517525] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:22:38.052264000 usim_process.process_node                          Overflow for space id [2024052004205948300000000000000000000000000000000000024] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:22:38.076657000 usim_creator.handle_overflow                       [505] Not implemented. Handle overflow for [2024052004205948300000000000000000000000000000000000024] escape strategy [0].
20.05.2024 04:22:38.096037000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.005677670878464104830680051971242012517525] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:22:38.096635000 usim_process.process_node                          Overflow for space id [2024052004205949500000000000000000000000000000000000025] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:22:38.118106000 usim_creator.handle_overflow                       [505] Not implemented. Handle overflow for [2024052004205949500000000000000000000000000000000000025] escape strategy [0].
20.05.2024 04:22:38.137269000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.005677670878464104830680051971242012517525] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:22:38.138683000 usim_process.process_node                          Overflow for space id [2024052004205950700000000000000000000000000000000000026] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:22:38.161340000 usim_creator.handle_overflow                       [505] Not implemented. Handle overflow for [2024052004205950700000000000000000000000000000000000026] escape strategy [0].
20.05.2024 04:22:38.179623000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.005677670878464104830680051971242012517525] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:22:38.180927000 usim_process.process_node                          Overflow for space id [2024052004205952100000000000000000000000000000000000027] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:22:38.198782000 usim_creator.handle_overflow                       [505] Not implemented. Handle overflow for [2024052004205952100000000000000000000000000000000000027] escape strategy [0].
20.05.2024 04:22:38.618458000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [.9974572670446278708296504407914488523475] and current target energy [9.87665160858517456069114879827859982226]. Set energy to 0.
20.05.2024 04:22:38.628411000 usim_creator.handle_overflow                       [506] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:22:38.633175000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [.9974572670446278708296504407914488523475] and current target energy [9.87665160858517456069114879827859982226]. Set energy to 0.
20.05.2024 04:22:38.642767000 usim_creator.handle_overflow                       [506] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:22:38.646173000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-.9974572670446278708296504407914488523475] and current target energy [-9.87665160858517456069114879827859982226]. Set energy to 0.
20.05.2024 04:22:38.654413000 usim_creator.handle_overflow                       [506] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:22:38.659829000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-.9974572670446278708296504407914488523475] and current target energy [-9.87665160858517456069114879827859982226]. Set energy to 0.
20.05.2024 04:22:38.668113000 usim_creator.handle_overflow                       [506] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:22:39.350871000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [3.89819957893821066954752445495757993134] and current target energy [7.79639915787642133909504890991515986267]. Set energy to 0.
20.05.2024 04:22:39.375802000 usim_creator.handle_overflow                       [509] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:39.391076000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-3.89819957893821066954752445495757993134] and current target energy [-7.79639915787642133909504890991515986267]. Set energy to 0.
20.05.2024 04:22:39.417138000 usim_creator.handle_overflow                       [509] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:39.458993000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [3.05379893465440730122968723377058202204] and current target energy [7.01796650510613587513368814631483415993]. Set energy to 0.
20.05.2024 04:22:39.469184000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:39.469541000 usim_creator.handle_overflow                       [509] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:22:39.473258000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-3.05379893465440730122968723377058202204] and current target energy [-7.01796650510613587513368814631483415993]. Set energy to 0.
20.05.2024 04:22:39.488508000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:39.501409000 usim_creator.handle_overflow                       [509] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:22:39.994860000 usim_process.process_queue                         Overflow for target space id [2024052004211570000000000000000000000000000000000000058] with energy [.8344392037832628920536171121679572570213] and current target energy [9.94447687244568535847110933101874502873]. Set energy to 0.
20.05.2024 04:22:40.018680000 usim_creator.handle_overflow                       [511] Not implemented. Handle overflow for [2024052004211570000000000000000000000000000000000000058] escape strategy [0].
20.05.2024 04:22:40.035918000 usim_process.process_queue                         Overflow for target space id [2024052004211574500000000000000000000000000000000000059] with energy [.8344392037832628920536171121679572570213] and current target energy [9.94447687244568535847110933101874502873]. Set energy to 0.
20.05.2024 04:22:40.056263000 usim_creator.handle_overflow                       [511] Not implemented. Handle overflow for [2024052004211574500000000000000000000000000000000000059] escape strategy [0].
20.05.2024 04:22:40.072117000 usim_process.process_queue                         Overflow for target space id [2024052004211579500000000000000000000000000000000000060] with energy [-.8344392037832628920536171121679572570213] and current target energy [-9.94447687244568535847110933101874502873]. Set energy to 0.
20.05.2024 04:22:40.096276000 usim_creator.handle_overflow                       [511] Not implemented. Handle overflow for [2024052004211579500000000000000000000000000000000000060] escape strategy [0].
20.05.2024 04:22:40.105177000 usim_process.process_queue                         Overflow for target space id [2024052004211584300000000000000000000000000000000000061] with energy [-.8344392037832628920536171121679572570213] and current target energy [-9.94447687244568535847110933101874502873]. Set energy to 0.
20.05.2024 04:22:40.122622000 usim_creator.handle_overflow                       [511] Not implemented. Handle overflow for [2024052004211584300000000000000000000000000000000000061] escape strategy [0].
20.05.2024 04:22:40.982625000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [4.61278903145022664920081456813873546655] and current target energy [6.88547521446991872200327750437757077645]. Set energy to 0.
20.05.2024 04:22:41.021015000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:41.021328000 usim_creator.handle_overflow                       [514] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:22:41.023963000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-4.61278903145022664920081456813873546655] and current target energy [-6.88547521446991872200327750437757077645]. Set energy to 0.
20.05.2024 04:22:41.066005000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:41.083079000 usim_creator.handle_overflow                       [514] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:22:41.371474000 usim_process.process_queue                         Overflow for target space id [2024052004213975700000000000000000000000000000000000082] with energy [1.91758282471391655158585769939242583228] and current target energy [9.11480807815004814495072993861298641337]. Set energy to 0.
20.05.2024 04:22:41.400998000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:41.404130000 usim_creator.handle_overflow                       [515] Not implemented. Handle overflow for [2024052004213975700000000000000000000000000000000000082] escape strategy [7].
20.05.2024 04:22:41.418304000 usim_process.process_queue                         Overflow for target space id [2024052004213980000000000000000000000000000000000000083] with energy [1.91758282471391655158585769939242583228] and current target energy [9.11480807815004814495072993861298641337]. Set energy to 0.
20.05.2024 04:22:41.448843000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:41.468549000 usim_creator.handle_overflow                       [515] Not implemented. Handle overflow for [2024052004213980000000000000000000000000000000000000083] escape strategy [7].
20.05.2024 04:22:41.483236000 usim_process.process_queue                         Overflow for target space id [2024052004213983100000000000000000000000000000000000084] with energy [-1.91758282471391655158585769939242583228] and current target energy [-9.11480807815004814495072993861298641337]. Set energy to 0.
20.05.2024 04:22:41.512532000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:41.513408000 usim_creator.handle_overflow                       [515] Not implemented. Handle overflow for [2024052004213983100000000000000000000000000000000000084] escape strategy [7].
20.05.2024 04:22:41.531091000 usim_process.process_queue                         Overflow for target space id [2024052004213986900000000000000000000000000000000000085] with energy [-1.91758282471391655158585769939242583228] and current target energy [-9.11480807815004814495072993861298641337]. Set energy to 0.
20.05.2024 04:22:41.554279000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:41.555498000 usim_creator.handle_overflow                       [515] Not implemented. Handle overflow for [2024052004213986900000000000000000000000000000000000085] escape strategy [7].
20.05.2024 04:22:41.755901000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [3.41092463157093433585408389808788243993] and current target energy [7.79639915787642133909504890991515986268]. Set energy to 0.
20.05.2024 04:22:41.767254000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:41.767596000 usim_creator.handle_overflow                       [516] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:22:41.773469000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-3.41092463157093433585408389808788243993] and current target energy [-7.79639915787642133909504890991515986268]. Set energy to 0.
20.05.2024 04:22:41.801286000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:41.815067000 usim_creator.handle_overflow                       [516] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:22:42.862513000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.18507358053814806191888989449949355661] and current target energy [9.98147273841456940101393880441465341931]. Set energy to 0.
20.05.2024 04:22:42.879154000 usim_creator.handle_overflow                       [519] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:42.884220000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.18507358053814806191888989449949355661] and current target energy [-9.98147273841456940101393880441465341931]. Set energy to 0.
20.05.2024 04:22:42.919984000 usim_creator.handle_overflow                       [519] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:43.469888000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [4.77567190240433087972956229891771762571] and current target energy [8.29774463023022868440576005446033380127]. Set energy to 0.
20.05.2024 04:22:43.489018000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:43.489603000 usim_creator.handle_overflow                       [521] Not implemented. Handle overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [7].
20.05.2024 04:22:43.496390000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-4.77567190240433087972956229891771762571] and current target energy [-8.29774463023022868440576005446033380127]. Set energy to 0.
20.05.2024 04:22:43.512454000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:43.515881000 usim_creator.handle_overflow                       [521] Not implemented. Handle overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [7].
20.05.2024 04:22:44.301377000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [2.10091150041532634548798078501861185615] and current target energy [8.74029432215259224767555957799797422642]. Set energy to 0.
20.05.2024 04:22:44.324232000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:44.326037000 usim_creator.handle_overflow                       [524] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:22:44.352230000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [2.10091150041532634548798078501861185615] and current target energy [8.74029432215259224767555957799797422642]. Set energy to 0.
20.05.2024 04:22:44.376999000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:44.377673000 usim_creator.handle_overflow                       [524] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:22:44.380619000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-2.10091150041532634548798078501861185615] and current target energy [-8.74029432215259224767555957799797422642]. Set energy to 0.
20.05.2024 04:22:44.400727000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:44.401049000 usim_creator.handle_overflow                       [524] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:22:44.404552000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-2.10091150041532634548798078501861185615] and current target energy [-8.74029432215259224767555957799797422642]. Set energy to 0.
20.05.2024 04:22:44.431332000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:44.445759000 usim_creator.handle_overflow                       [524] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:22:44.451039000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [2.43637473683638166846720278434848745709] and current target energy [8.05669765877791993723313669501995400975]. Set energy to 0.
20.05.2024 04:22:44.472001000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:44.473313000 usim_creator.handle_overflow                       [524] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:22:44.494268000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-2.43637473683638166846720278434848745709] and current target energy [-8.05669765877791993723313669501995400975]. Set energy to 0.
20.05.2024 04:22:44.514083000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:44.514868000 usim_creator.handle_overflow                       [524] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:22:44.829282000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [.88904406752466735904347429154932147871] and current target energy [9.2255780629004532984016291362774709331]. Set energy to 0.
20.05.2024 04:22:44.848740000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:44.849705000 usim_creator.handle_overflow                       [525] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:22:44.855825000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-.88904406752466735904347429154932147871] and current target energy [-9.2255780629004532984016291362774709331]. Set energy to 0.
20.05.2024 04:22:44.880522000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:44.886213000 usim_creator.handle_overflow                       [525] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:22:45.461097000 usim_process.process_queue                         Overflow for target space id [2024052004205701200000000000000000000000000000000000015] with energy [1.17934151874718184932425511868649235765] and current target energy [9.66673851020845791774409558863363724946]. Set energy to 0.
20.05.2024 04:22:45.471623000 usim_creator.handle_overflow                       [527] Not implemented. Handle overflow for [2024052004205701200000000000000000000000000000000000015] escape strategy [0].
20.05.2024 04:22:45.476454000 usim_process.process_queue                         Overflow for target space id [2024052004205702800000000000000000000000000000000000017] with energy [1.17934151874718184932425511868649235765] and current target energy [9.66673851020845791774409558863363724946]. Set energy to 0.
20.05.2024 04:22:45.485920000 usim_creator.handle_overflow                       [527] Not implemented. Handle overflow for [2024052004205702800000000000000000000000000000000000017] escape strategy [0].
20.05.2024 04:22:45.490461000 usim_process.process_queue                         Overflow for target space id [2024052004205711900000000000000000000000000000000000019] with energy [-1.17934151874718184932425511868649235765] and current target energy [-9.66673851020845791774409558863363724946]. Set energy to 0.
20.05.2024 04:22:45.498477000 usim_creator.handle_overflow                       [527] Not implemented. Handle overflow for [2024052004205711900000000000000000000000000000000000019] escape strategy [0].
20.05.2024 04:22:45.503139000 usim_process.process_queue                         Overflow for target space id [2024052004205716200000000000000000000000000000000000021] with energy [-1.17934151874718184932425511868649235765] and current target energy [-9.66673851020845791774409558863363724946]. Set energy to 0.
20.05.2024 04:22:45.512345000 usim_creator.handle_overflow                       [527] Not implemented. Handle overflow for [2024052004205716200000000000000000000000000000000000021] escape strategy [0].
20.05.2024 04:22:45.926350000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.59413921783214807013238915242655105872] and current target energy [8.6657218947162346818017576108936679485]. Set energy to 0.
20.05.2024 04:22:45.945393000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:45.948388000 usim_creator.handle_overflow                       [529] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:22:45.957756000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.59413921783214807013238915242655105872] and current target energy [8.6657218947162346818017576108936679485]. Set energy to 0.
20.05.2024 04:22:45.977173000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:45.980233000 usim_creator.handle_overflow                       [529] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:22:45.988598000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.59413921783214807013238915242655105872] and current target energy [-8.6657218947162346818017576108936679485]. Set energy to 0.
20.05.2024 04:22:45.998795000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:45.999092000 usim_creator.handle_overflow                       [529] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:22:46.001724000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.59413921783214807013238915242655105872] and current target energy [-8.6657218947162346818017576108936679485]. Set energy to 0.
20.05.2024 04:22:46.016106000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:46.016461000 usim_creator.handle_overflow                       [529] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:22:46.185478000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.58608961559820009938366872573941433296] and current target energy [9.43473214997745479459404094949193886118]. Set energy to 0.
20.05.2024 04:22:46.196548000 usim_creator.handle_overflow                       [530] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:22:46.200348000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.58608961559820009938366872573941433296] and current target energy [9.43473214997745479459404094949193886118]. Set energy to 0.
20.05.2024 04:22:46.211407000 usim_creator.handle_overflow                       [530] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:22:46.214257000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.58608961559820009938366872573941433296] and current target energy [-9.43473214997745479459404094949193886118]. Set energy to 0.
20.05.2024 04:22:46.223442000 usim_creator.handle_overflow                       [530] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:22:46.226566000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.58608961559820009938366872573941433296] and current target energy [-9.43473214997745479459404094949193886118]. Set energy to 0.
20.05.2024 04:22:46.236665000 usim_creator.handle_overflow                       [530] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:22:46.433194000 usim_process.process_queue                         Overflow for target space id [2024052004210931900000000000000000000000000000000000044] with energy [1.04596794455644448365683602996416524344] and current target energy [9.46476743253770002153537838597392396291]. Set energy to 0.
20.05.2024 04:22:46.443188000 usim_creator.handle_overflow                       [531] Not implemented. Handle overflow for [2024052004210931900000000000000000000000000000000000044] escape strategy [0].
20.05.2024 04:22:46.446038000 usim_process.process_queue                         Overflow for target space id [2024052004210936800000000000000000000000000000000000045] with energy [1.04596794455644448365683602996416524344] and current target energy [9.46476743253770002153537838597392396291]. Set energy to 0.
20.05.2024 04:22:46.454673000 usim_creator.handle_overflow                       [531] Not implemented. Handle overflow for [2024052004210936800000000000000000000000000000000000045] escape strategy [0].
20.05.2024 04:22:46.457454000 usim_process.process_queue                         Overflow for target space id [2024052004210941800000000000000000000000000000000000046] with energy [-1.04596794455644448365683602996416524344] and current target energy [-9.46476743253770002153537838597392396291]. Set energy to 0.
20.05.2024 04:22:46.465721000 usim_creator.handle_overflow                       [531] Not implemented. Handle overflow for [2024052004210941800000000000000000000000000000000000046] escape strategy [0].
20.05.2024 04:22:46.469407000 usim_process.process_queue                         Overflow for target space id [2024052004210944800000000000000000000000000000000000047] with energy [-1.04596794455644448365683602996416524344] and current target energy [-9.46476743253770002153537838597392396291]. Set energy to 0.
20.05.2024 04:22:46.477718000 usim_creator.handle_overflow                       [531] Not implemented. Handle overflow for [2024052004210944800000000000000000000000000000000000047] escape strategy [0].
20.05.2024 04:22:46.665106000 usim_process.process_queue                         Overflow for target space id [2024052004221501800000000000000000000000000000000000092] with energy [1.54347928389699194278380953393979423387] and current target energy [9.55134380480866175945912459783543525142]. Set energy to 0.
20.05.2024 04:22:46.677968000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:46.678296000 usim_creator.handle_overflow                       [532] Not implemented. Handle overflow for [2024052004221501800000000000000000000000000000000000092] escape strategy [7].
20.05.2024 04:22:46.680992000 usim_process.process_queue                         Overflow for target space id [2024052004221505600000000000000000000000000000000000093] with energy [-1.54347928389699194278380953393979423387] and current target energy [-9.55134380480866175945912459783543525142]. Set energy to 0.
20.05.2024 04:22:46.689860000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:46.690154000 usim_creator.handle_overflow                       [532] Not implemented. Handle overflow for [2024052004221505600000000000000000000000000000000000093] escape strategy [7].
20.05.2024 04:22:46.951007000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [2.34567083268361637198659784477969045998] and current target energy [9.38268333073446548794639137911876183989]. Set energy to 0.
20.05.2024 04:22:46.983284000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:46.984438000 usim_creator.handle_overflow                       [533] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:22:46.998651000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-2.34567083268361637198659784477969045998] and current target energy [-9.38268333073446548794639137911876183989]. Set energy to 0.
20.05.2024 04:22:47.016651000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:47.017823000 usim_creator.handle_overflow                       [533] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:22:47.270022000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.74468791255267942407942037799348844012] and current target energy [9.01986771412340430202397162084357385141]. Set energy to 0.
20.05.2024 04:22:47.297449000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:47.297795000 usim_creator.handle_overflow                       [534] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:22:47.300643000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.74468791255267942407942037799348844012] and current target energy [-9.01986771412340430202397162084357385141]. Set energy to 0.
20.05.2024 04:22:47.327830000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:47.351356000 usim_creator.handle_overflow                       [534] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:22:47.590131000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.59781324912356068696272231468243398354] and current target energy [9.48937582510535884815884075598697688023]. Set energy to 0.
20.05.2024 04:22:47.629643000 usim_creator.handle_overflow                       [535] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:47.636165000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.59781324912356068696272231468243398354] and current target energy [-9.48937582510535884815884075598697688023]. Set energy to 0.
20.05.2024 04:22:47.658860000 usim_creator.handle_overflow                       [535] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:49.453013000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [2.34477027509264918071560674675244621719] and current target energy [9.37908110037059672286242698700978486877]. Set energy to 0.
20.05.2024 04:22:49.482361000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:49.483783000 usim_creator.handle_overflow                       [542] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:22:49.502011000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [2.34477027509264918071560674675244621719] and current target energy [9.37908110037059672286242698700978486877]. Set energy to 0.
20.05.2024 04:22:49.533285000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:49.539834000 usim_creator.handle_overflow                       [542] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:22:49.551175000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-2.34477027509264918071560674675244621719] and current target energy [-9.37908110037059672286242698700978486877]. Set energy to 0.
20.05.2024 04:22:49.579767000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:49.588166000 usim_creator.handle_overflow                       [542] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:22:49.601074000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-2.34477027509264918071560674675244621719] and current target energy [-9.37908110037059672286242698700978486877]. Set energy to 0.
20.05.2024 04:22:49.622160000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:49.624034000 usim_creator.handle_overflow                       [542] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:22:49.941898000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [4.57611872213414114109994913023754823527] and current target energy [8.60291253436071966280758753945643026123]. Set energy to 0.
20.05.2024 04:22:49.966660000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:49.968034000 usim_creator.handle_overflow                       [543] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:22:49.972573000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-4.57611872213414114109994913023754823527] and current target energy [-8.60291253436071966280758753945643026123]. Set energy to 0.
20.05.2024 04:22:49.994628000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:49.998943000 usim_creator.handle_overflow                       [543] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:22:50.269561000 usim_process.process_queue                         Overflow for target space id [2024052004211700300000000000000000000000000000000000062] with energy [1.195932378948257602683524320767679865] and current target energy [9.48430682801135263277851114760418469461]. Set energy to 0.
20.05.2024 04:22:50.286552000 usim_creator.handle_overflow                       [544] Not implemented. Handle overflow for [2024052004211700300000000000000000000000000000000000062] escape strategy [0].
20.05.2024 04:22:50.295283000 usim_process.process_queue                         Overflow for target space id [2024052004211706000000000000000000000000000000000000063] with energy [1.195932378948257602683524320767679865] and current target energy [9.48430682801135263277851114760418469461]. Set energy to 0.
20.05.2024 04:22:50.334124000 usim_creator.handle_overflow                       [544] Not implemented. Handle overflow for [2024052004211706000000000000000000000000000000000000063] escape strategy [0].
20.05.2024 04:22:50.345661000 usim_process.process_queue                         Overflow for target space id [2024052004211711600000000000000000000000000000000000064] with energy [-1.195932378948257602683524320767679865] and current target energy [-9.48430682801135263277851114760418469461]. Set energy to 0.
20.05.2024 04:22:50.364994000 usim_creator.handle_overflow                       [544] Not implemented. Handle overflow for [2024052004211711600000000000000000000000000000000000064] escape strategy [0].
20.05.2024 04:22:50.381399000 usim_process.process_queue                         Overflow for target space id [2024052004211716600000000000000000000000000000000000065] with energy [-1.195932378948257602683524320767679865] and current target energy [-9.48430682801135263277851114760418469461]. Set energy to 0.
20.05.2024 04:22:50.402338000 usim_creator.handle_overflow                       [544] Not implemented. Handle overflow for [2024052004211716600000000000000000000000000000000000065] escape strategy [0].
20.05.2024 04:22:50.928256000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.98784848076227496842834605371813371466] and current target energy [7.28269995762538334991289758884438443683]. Set energy to 0.
20.05.2024 04:22:50.953000000 usim_creator.handle_overflow                       [546] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:22:50.984820000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.98784848076227496842834605371813371466] and current target energy [7.28269995762538334991289758884438443683]. Set energy to 0.
20.05.2024 04:22:50.997198000 usim_creator.handle_overflow                       [546] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:22:51.001085000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.98784848076227496842834605371813371466] and current target energy [-7.28269995762538334991289758884438443683]. Set energy to 0.
20.05.2024 04:22:51.011681000 usim_creator.handle_overflow                       [546] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:22:51.014767000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.98784848076227496842834605371813371466] and current target energy [-7.28269995762538334991289758884438443683]. Set energy to 0.
20.05.2024 04:22:51.043674000 usim_creator.handle_overflow                       [546] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:22:51.739077000 usim_process.process_queue                         Overflow for target space id [2024052004221501800000000000000000000000000000000000092] with energy [4.04501820901290245576699798573221788863] and current target energy [6.61226525221471348288584004339807849791]. Set energy to 0.
20.05.2024 04:22:51.767118000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:51.770115000 usim_creator.handle_overflow                       [548] Not implemented. Handle overflow for [2024052004221501800000000000000000000000000000000000092] escape strategy [7].
20.05.2024 04:22:51.777890000 usim_process.process_queue                         Overflow for target space id [2024052004221505600000000000000000000000000000000000093] with energy [-4.04501820901290245576699798573221788863] and current target energy [-6.61226525221471348288584004339807849791]. Set energy to 0.
20.05.2024 04:22:51.799171000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:51.800519000 usim_creator.handle_overflow                       [548] Not implemented. Handle overflow for [2024052004221505600000000000000000000000000000000000093] escape strategy [7].
20.05.2024 04:22:52.092859000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [3.95788672240932759321497050029411245741] and current target energy [7.97569696152454993685669210743626742932]. Set energy to 0.
20.05.2024 04:22:52.126408000 usim_creator.handle_overflow                       [549] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:52.130004000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-3.95788672240932759321497050029411245741] and current target energy [-7.97569696152454993685669210743626742932]. Set energy to 0.
20.05.2024 04:22:52.152103000 usim_creator.handle_overflow                       [549] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:52.407169000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [4.22031335625548939784030206851538023376] and current target energy [8.31538439347476573518043216341964573538]. Set energy to 0.
20.05.2024 04:22:52.428046000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:52.432591000 usim_creator.handle_overflow                       [550] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:22:52.447496000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-4.22031335625548939784030206851538023376] and current target energy [-8.31538439347476573518043216341964573538]. Set energy to 0.
20.05.2024 04:22:52.465168000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:52.466331000 usim_creator.handle_overflow                       [550] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:22:52.469977000 usim_process.process_queue                         Overflow for target space id [2024052004221223900000000000000000000000000000000000088] with energy [1.99321714033428200954799954445436340098] and current target energy [8.78036605216127526302667352812114286379]. Set energy to 0.
20.05.2024 04:22:52.500763000 usim_creator.handle_overflow                       [550] Handle pos overflow for [2024052004221223900000000000000000000000000000000000088] escape strategy [3].
20.05.2024 04:22:52.521265000 usim_process.process_queue                         Overflow for target space id [2024052004221227000000000000000000000000000000000000089] with energy [1.99321714033428200954799954445436340098] and current target energy [8.78036605216127526302667352812114286379]. Set energy to 0.
20.05.2024 04:22:52.540451000 usim_creator.handle_overflow                       [550] Handle pos overflow for [2024052004221227000000000000000000000000000000000000089] escape strategy [3].
20.05.2024 04:22:52.548147000 usim_process.process_queue                         Overflow for target space id [2024052004221231900000000000000000000000000000000000090] with energy [-1.99321714033428200954799954445436340098] and current target energy [-8.78036605216127526302667352812114286379]. Set energy to 0.
20.05.2024 04:22:52.563855000 usim_creator.handle_overflow                       [550] Handle pos overflow for [2024052004221231900000000000000000000000000000000000090] escape strategy [3].
20.05.2024 04:22:52.579232000 usim_process.process_queue                         Overflow for target space id [2024052004221235100000000000000000000000000000000000091] with energy [-1.99321714033428200954799954445436340098] and current target energy [-8.78036605216127526302667352812114286379]. Set energy to 0.
20.05.2024 04:22:52.603364000 usim_creator.handle_overflow                       [550] Handle pos overflow for [2024052004221235100000000000000000000000000000000000091] escape strategy [3].
20.05.2024 04:22:53.367388000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [4.57611872213414114109994913023754823527] and current target energy [6.145386084077175465418311815296476765]. Set energy to 0.
20.05.2024 04:22:53.393752000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:53.395344000 usim_creator.handle_overflow                       [553] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:22:53.410520000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-4.57611872213414114109994913023754823527] and current target energy [-6.145386084077175465418311815296476765]. Set energy to 0.
20.05.2024 04:22:53.424110000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:53.425740000 usim_creator.handle_overflow                       [553] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:22:53.574815000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [1.77368669293335796975615095066337891121] and current target energy [9.56594632189629143704603975901639684337]. Set energy to 0.
20.05.2024 04:22:53.604674000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:53.610642000 usim_creator.handle_overflow                       [554] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:22:53.621804000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [1.77368669293335796975615095066337891121] and current target energy [9.56594632189629143704603975901639684337]. Set energy to 0.
20.05.2024 04:22:53.641404000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:53.660579000 usim_creator.handle_overflow                       [554] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:22:53.669910000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-1.77368669293335796975615095066337891121] and current target energy [-9.56594632189629143704603975901639684337]. Set energy to 0.
20.05.2024 04:22:53.699427000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:53.711410000 usim_creator.handle_overflow                       [554] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:22:53.725795000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-1.77368669293335796975615095066337891121] and current target energy [-9.56594632189629143704603975901639684337]. Set energy to 0.
20.05.2024 04:22:53.747927000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:53.749342000 usim_creator.handle_overflow                       [554] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:22:53.782977000 usim_process.process_queue                         Overflow for target space id [2024052004211990800000000000000000000000000000000000070] with energy [1.99321714033428200954799954445436340098] and current target energy [8.06579546651666810078620910662263736175]. Set energy to 0.
20.05.2024 04:22:53.801153000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:53.802502000 usim_creator.handle_overflow                       [554] Not implemented. Handle overflow for [2024052004211990800000000000000000000000000000000000070] escape strategy [7].
20.05.2024 04:22:53.816608000 usim_process.process_queue                         Overflow for target space id [2024052004211994200000000000000000000000000000000000071] with energy [1.99321714033428200954799954445436340098] and current target energy [8.06579546651666810078620910662263736175]. Set energy to 0.
20.05.2024 04:22:53.834835000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:53.835941000 usim_creator.handle_overflow                       [554] Not implemented. Handle overflow for [2024052004211994200000000000000000000000000000000000071] escape strategy [7].
20.05.2024 04:22:53.838635000 usim_process.process_queue                         Overflow for target space id [2024052004211998600000000000000000000000000000000000072] with energy [-1.99321714033428200954799954445436340098] and current target energy [-8.06579546651666810078620910662263736175]. Set energy to 0.
20.05.2024 04:22:53.869911000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:53.870970000 usim_creator.handle_overflow                       [554] Not implemented. Handle overflow for [2024052004211998600000000000000000000000000000000000072] escape strategy [7].
20.05.2024 04:22:53.874279000 usim_process.process_queue                         Overflow for target space id [2024052004212000300000000000000000000000000000000000073] with energy [-1.99321714033428200954799954445436340098] and current target energy [-8.06579546651666810078620910662263736175]. Set energy to 0.
20.05.2024 04:22:53.884343000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:53.884680000 usim_creator.handle_overflow                       [554] Not implemented. Handle overflow for [2024052004212000300000000000000000000000000000000000073] escape strategy [7].
20.05.2024 04:22:54.124024000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.88666290804652560761967736401539832682] and current target energy [7.12419610033678966778694690052940242334]. Set energy to 0.
20.05.2024 04:22:54.146066000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:54.151242000 usim_creator.handle_overflow                       [555] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:22:54.165461000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.88666290804652560761967736401539832682] and current target energy [-7.12419610033678966778694690052940242334]. Set energy to 0.
20.05.2024 04:22:54.185251000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:54.186262000 usim_creator.handle_overflow                       [555] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:22:55.335537000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [3.95466998008277377712742645716724851694] and current target energy [7.94158807642986763207393175410765282881]. Set energy to 0.
20.05.2024 04:22:55.384791000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:55.393494000 usim_creator.handle_overflow                       [560] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:22:55.413303000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-3.95466998008277377712742645716724851694] and current target energy [-7.94158807642986763207393175410765282881]. Set energy to 0.
20.05.2024 04:22:55.437236000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:55.438527000 usim_creator.handle_overflow                       [560] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:22:55.457739000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.95466998008277377712742645716724851694] and current target energy [7.77383331745637769385981106048362958301]. Set energy to 0.
20.05.2024 04:22:55.474707000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:55.476181000 usim_creator.handle_overflow                       [560] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:22:55.503103000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.95466998008277377712742645716724851694] and current target energy [7.77383331745637769385981106048362958301]. Set energy to 0.
20.05.2024 04:22:55.523948000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:55.529310000 usim_creator.handle_overflow                       [560] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:22:55.539316000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.95466998008277377712742645716724851694] and current target energy [-7.77383331745637769385981106048362958301]. Set energy to 0.
20.05.2024 04:22:55.556244000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:55.561323000 usim_creator.handle_overflow                       [560] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:22:55.565024000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.95466998008277377712742645716724851694] and current target energy [-7.77383331745637769385981106048362958301]. Set energy to 0.
20.05.2024 04:22:55.592937000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:55.594384000 usim_creator.handle_overflow                       [560] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:22:56.442322000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [2.44333145402326280380983868200769916341] and current target energy [9.15223744426828228219989826047509647054]. Set energy to 0.
20.05.2024 04:22:56.452025000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:56.454502000 usim_creator.handle_overflow                       [564] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:22:56.459255000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-2.44333145402326280380983868200769916341] and current target energy [-9.15223744426828228219989826047509647054]. Set energy to 0.
20.05.2024 04:22:56.467749000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:56.469067000 usim_creator.handle_overflow                       [564] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:22:56.754820000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.2390225940778672503089221810112554924] and current target energy [8.95609037631146900123568872404502196958]. Set energy to 0.
20.05.2024 04:22:56.796287000 usim_creator.handle_overflow                       [565] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:22:56.809597000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.2390225940778672503089221810112554924] and current target energy [-8.95609037631146900123568872404502196958]. Set energy to 0.
20.05.2024 04:22:56.827381000 usim_creator.handle_overflow                       [565] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:22:57.121864000 usim_process.process_queue                         Overflow for target space id [2024052004212051500000000000000000000000000000000000074] with energy [1.20629530781917852615763102715460885135] and current target energy [9.48683263389480817395396285079080968973]. Set energy to 0.
20.05.2024 04:22:57.142110000 usim_creator.handle_overflow                       [566] Not implemented. Handle overflow for [2024052004212051500000000000000000000000000000000000074] escape strategy [0].
20.05.2024 04:22:57.150608000 usim_process.process_queue                         Overflow for target space id [2024052004212053400000000000000000000000000000000000075] with energy [1.20629530781917852615763102715460885135] and current target energy [9.48683263389480817395396285079080968973]. Set energy to 0.
20.05.2024 04:22:57.169578000 usim_creator.handle_overflow                       [566] Not implemented. Handle overflow for [2024052004212053400000000000000000000000000000000000075] escape strategy [0].
20.05.2024 04:22:57.178431000 usim_process.process_queue                         Overflow for target space id [2024052004212055400000000000000000000000000000000000076] with energy [-1.20629530781917852615763102715460885135] and current target energy [-9.48683263389480817395396285079080968973]. Set energy to 0.
20.05.2024 04:22:57.194826000 usim_creator.handle_overflow                       [566] Not implemented. Handle overflow for [2024052004212055400000000000000000000000000000000000076] escape strategy [0].
20.05.2024 04:22:57.203555000 usim_process.process_queue                         Overflow for target space id [2024052004212057200000000000000000000000000000000000077] with energy [-1.20629530781917852615763102715460885135] and current target energy [-9.48683263389480817395396285079080968973]. Set energy to 0.
20.05.2024 04:22:57.220792000 usim_creator.handle_overflow                       [566] Not implemented. Handle overflow for [2024052004212057200000000000000000000000000000000000077] escape strategy [0].
20.05.2024 04:22:57.432161000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [1.5895160308580142733526196249546482957] and current target energy [9.99088912546419693351334893485518229685]. Set energy to 0.
20.05.2024 04:22:57.453910000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:57.455205000 usim_creator.handle_overflow                       [567] Not implemented. Handle overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [7].
20.05.2024 04:22:57.480764000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [1.5895160308580142733526196249546482957] and current target energy [9.99088912546419693351334893485518229685]. Set energy to 0.
20.05.2024 04:22:57.500530000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:57.519511000 usim_creator.handle_overflow                       [567] Not implemented. Handle overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [7].
20.05.2024 04:22:57.532213000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-1.5895160308580142733526196249546482957] and current target energy [-9.99088912546419693351334893485518229685]. Set energy to 0.
20.05.2024 04:22:57.551409000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:57.557461000 usim_creator.handle_overflow                       [567] Not implemented. Handle overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [7].
20.05.2024 04:22:57.568913000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-1.5895160308580142733526196249546482957] and current target energy [-9.99088912546419693351334893485518229685]. Set energy to 0.
20.05.2024 04:22:57.588766000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:57.589933000 usim_creator.handle_overflow                       [567] Not implemented. Handle overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [7].
20.05.2024 04:22:57.846091000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [1.12632318065918750573378198562465164157] and current target energy [9.01058544527350004587025588499721313252]. Set energy to 0.
20.05.2024 04:22:57.863221000 usim_creator.handle_overflow                       [568] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:22:57.879631000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [1.12632318065918750573378198562465164157] and current target energy [9.01058544527350004587025588499721313252]. Set energy to 0.
20.05.2024 04:22:57.909254000 usim_creator.handle_overflow                       [568] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:22:57.922855000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-1.12632318065918750573378198562465164157] and current target energy [-9.01058544527350004587025588499721313252]. Set energy to 0.
20.05.2024 04:22:57.944348000 usim_creator.handle_overflow                       [568] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:22:57.954759000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-1.12632318065918750573378198562465164157] and current target energy [-9.01058544527350004587025588499721313252]. Set energy to 0.
20.05.2024 04:22:57.976704000 usim_creator.handle_overflow                       [568] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:22:58.202238000 usim_process.process_queue                         Overflow for target space id [2024052004213975700000000000000000000000000000000000082] with energy [1.12260474165043489984039009422915283309] and current target energy [9.09339148259319636377328266704041586561]. Set energy to 0.
20.05.2024 04:22:58.222728000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:58.223473000 usim_creator.handle_overflow                       [569] Not implemented. Handle overflow for [2024052004213975700000000000000000000000000000000000082] escape strategy [7].
20.05.2024 04:22:58.240139000 usim_process.process_queue                         Overflow for target space id [2024052004213980000000000000000000000000000000000000083] with energy [1.12260474165043489984039009422915283309] and current target energy [9.09339148259319636377328266704041586561]. Set energy to 0.
20.05.2024 04:22:58.269665000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:58.288161000 usim_creator.handle_overflow                       [569] Not implemented. Handle overflow for [2024052004213980000000000000000000000000000000000000083] escape strategy [7].
20.05.2024 04:22:58.291047000 usim_process.process_queue                         Overflow for target space id [2024052004213983100000000000000000000000000000000000084] with energy [-1.12260474165043489984039009422915283309] and current target energy [-9.09339148259319636377328266704041586561]. Set energy to 0.
20.05.2024 04:22:58.301489000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:58.301791000 usim_creator.handle_overflow                       [569] Not implemented. Handle overflow for [2024052004213983100000000000000000000000000000000000084] escape strategy [7].
20.05.2024 04:22:58.304379000 usim_process.process_queue                         Overflow for target space id [2024052004213986900000000000000000000000000000000000085] with energy [-1.12260474165043489984039009422915283309] and current target energy [-9.09339148259319636377328266704041586561]. Set energy to 0.
20.05.2024 04:22:58.326824000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:58.353328000 usim_creator.handle_overflow                       [569] Not implemented. Handle overflow for [2024052004213986900000000000000000000000000000000000085] escape strategy [7].
20.05.2024 04:22:58.361760000 usim_process.process_queue                         Overflow for target space id [2024052004223175000000000000000000000000000000000000094] with energy [2.11015667812774469892015103425769011688] and current target energy [8.09003641802580491153399597146443577725]. Set energy to 0.
20.05.2024 04:22:58.384794000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:58.398910000 usim_creator.handle_overflow                       [569] Not implemented. Handle overflow for [2024052004223175000000000000000000000000000000000000094] escape strategy [7].
20.05.2024 04:22:58.414911000 usim_process.process_queue                         Overflow for target space id [2024052004223178700000000000000000000000000000000000095] with energy [-2.11015667812774469892015103425769011688] and current target energy [-8.09003641802580491153399597146443577725]. Set energy to 0.
20.05.2024 04:22:58.447267000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:58.448437000 usim_creator.handle_overflow                       [569] Not implemented. Handle overflow for [2024052004223178700000000000000000000000000000000000095] escape strategy [7].
20.05.2024 04:22:59.010844000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [2.21230752079359459903215622814466316407] and current target energy [9.96466383896928521087258565104023789401]. Set energy to 0.
20.05.2024 04:22:59.027543000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:59.028737000 usim_creator.handle_overflow                       [571] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:22:59.041338000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [2.21230752079359459903215622814466316407] and current target energy [9.96466383896928521087258565104023789401]. Set energy to 0.
20.05.2024 04:22:59.062021000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:59.063092000 usim_creator.handle_overflow                       [571] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:22:59.072324000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-2.21230752079359459903215622814466316407] and current target energy [-9.96466383896928521087258565104023789401]. Set energy to 0.
20.05.2024 04:22:59.086294000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:59.087061000 usim_creator.handle_overflow                       [571] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:22:59.099840000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-2.21230752079359459903215622814466316407] and current target energy [-9.96466383896928521087258565104023789401]. Set energy to 0.
20.05.2024 04:22:59.119538000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:59.120853000 usim_creator.handle_overflow                       [571] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:22:59.156715000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [2.11015667812774469892015103425769011688] and current target energy [8.44062671251097879568060413703076046751]. Set energy to 0.
20.05.2024 04:22:59.171779000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:59.173030000 usim_creator.handle_overflow                       [571] Not implemented. Handle overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [7].
20.05.2024 04:22:59.186132000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-2.11015667812774469892015103425769011688] and current target energy [-8.44062671251097879568060413703076046751]. Set energy to 0.
20.05.2024 04:22:59.202555000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:22:59.204013000 usim_creator.handle_overflow                       [571] Not implemented. Handle overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [7].
20.05.2024 04:22:59.995190000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.83318422100094431910494090683186104109] and current target energy [7.00546046101865250793953293455895328295]. Set energy to 0.
20.05.2024 04:23:00.027999000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:00.029025000 usim_creator.handle_overflow                       [574] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:23:00.036324000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.83318422100094431910494090683186104109] and current target energy [-7.00546046101865250793953293455895328295]. Set energy to 0.
20.05.2024 04:23:00.053488000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:00.057950000 usim_creator.handle_overflow                       [574] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:23:00.075262000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.83318422100094431910494090683186104109] and current target energy [7.61932642687740546735978612744209138811]. Set energy to 0.
20.05.2024 04:23:00.096386000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:00.097185000 usim_creator.handle_overflow                       [574] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:23:00.133560000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.83318422100094431910494090683186104109] and current target energy [7.61932642687740546735978612744209138811]. Set energy to 0.
20.05.2024 04:23:00.155040000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:00.160040000 usim_creator.handle_overflow                       [574] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:23:00.165438000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.83318422100094431910494090683186104109] and current target energy [-7.61932642687740546735978612744209138811]. Set energy to 0.
20.05.2024 04:23:00.179796000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:00.180105000 usim_creator.handle_overflow                       [574] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:23:00.188051000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.83318422100094431910494090683186104109] and current target energy [-7.61932642687740546735978612744209138811]. Set energy to 0.
20.05.2024 04:23:00.208427000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:00.210051000 usim_creator.handle_overflow                       [574] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:23:00.844224000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [1.40109209220373050158790658691179065659] and current target energy [9.77332581609305121523935472803079665363]. Set energy to 0.
20.05.2024 04:23:00.867710000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:00.869130000 usim_creator.handle_overflow                       [576] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:23:00.884509000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-1.40109209220373050158790658691179065659] and current target energy [-9.77332581609305121523935472803079665363]. Set energy to 0.
20.05.2024 04:23:00.905773000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:00.906888000 usim_creator.handle_overflow                       [576] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:23:01.388108000 usim_process.process_queue                         Overflow for target space id [2024052004211134000000000000000000000000000000000000052] with energy [.5387247962060799170697034942857250065538] and current target energy [9.93656168456403163101511612936831951493]. Set energy to 0.
20.05.2024 04:23:01.413170000 usim_creator.handle_overflow                       [578] Not implemented. Handle overflow for [2024052004211134000000000000000000000000000000000000052] escape strategy [0].
20.05.2024 04:23:01.429795000 usim_process.process_queue                         Overflow for target space id [2024052004211138700000000000000000000000000000000000053] with energy [.5387247962060799170697034942857250065538] and current target energy [9.93656168456403163101511612936831951493]. Set energy to 0.
20.05.2024 04:23:01.453537000 usim_creator.handle_overflow                       [578] Not implemented. Handle overflow for [2024052004211138700000000000000000000000000000000000053] escape strategy [0].
20.05.2024 04:23:01.469579000 usim_process.process_queue                         Overflow for target space id [2024052004211143900000000000000000000000000000000000054] with energy [-.5387247962060799170697034942857250065538] and current target energy [-9.93656168456403163101511612936831951493]. Set energy to 0.
20.05.2024 04:23:01.489878000 usim_creator.handle_overflow                       [578] Not implemented. Handle overflow for [2024052004211143900000000000000000000000000000000000054] escape strategy [0].
20.05.2024 04:23:01.503043000 usim_process.process_queue                         Overflow for target space id [2024052004211147900000000000000000000000000000000000055] with energy [-.5387247962060799170697034942857250065538] and current target energy [-9.93656168456403163101511612936831951493]. Set energy to 0.
20.05.2024 04:23:01.532676000 usim_creator.handle_overflow                       [578] Not implemented. Handle overflow for [2024052004211147900000000000000000000000000000000000055] escape strategy [0].
20.05.2024 04:23:01.761293000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.700546046101865250793953293455895328295] and current target energy [9.66636844200188863820988181366372208218]. Set energy to 0.
20.05.2024 04:23:01.803543000 usim_creator.handle_overflow                       [579] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:23:01.820714000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.700546046101865250793953293455895328295] and current target energy [-9.66636844200188863820988181366372208218]. Set energy to 0.
20.05.2024 04:23:01.832684000 usim_creator.handle_overflow                       [579] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:23:02.755631000 usim_process.process_queue                         Overflow for target space id [2024052004211868000000000000000000000000000000000000066] with energy [.1557907445249610898298378806128177838663] and current target energy [9.97060764959750974910962435922033816747]. Set energy to 0.
20.05.2024 04:23:02.774820000 usim_creator.handle_overflow                       [583] Not implemented. Handle overflow for [2024052004211868000000000000000000000000000000000000066] escape strategy [0].
20.05.2024 04:23:02.786445000 usim_process.process_queue                         Overflow for target space id [2024052004211870600000000000000000000000000000000000067] with energy [.1557907445249610898298378806128177838663] and current target energy [9.97060764959750974910962435922033816747]. Set energy to 0.
20.05.2024 04:23:02.808330000 usim_creator.handle_overflow                       [583] Not implemented. Handle overflow for [2024052004211870600000000000000000000000000000000000067] escape strategy [0].
20.05.2024 04:23:02.823015000 usim_process.process_queue                         Overflow for target space id [2024052004211874300000000000000000000000000000000000068] with energy [-.1557907445249610898298378806128177838663] and current target energy [-9.97060764959750974910962435922033816747]. Set energy to 0.
20.05.2024 04:23:02.841447000 usim_creator.handle_overflow                       [583] Not implemented. Handle overflow for [2024052004211874300000000000000000000000000000000000068] escape strategy [0].
20.05.2024 04:23:02.855384000 usim_process.process_queue                         Overflow for target space id [2024052004211878000000000000000000000000000000000000069] with energy [-.1557907445249610898298378806128177838663] and current target energy [-9.97060764959750974910962435922033816747]. Set energy to 0.
20.05.2024 04:23:02.867473000 usim_creator.handle_overflow                       [583] Not implemented. Handle overflow for [2024052004211878000000000000000000000000000000000000069] escape strategy [0].
20.05.2024 04:23:03.764029000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [1.25139695055056678483968015474724784506] and current target energy [9.13980244390389032654227258499356780637]. Set energy to 0.
20.05.2024 04:23:03.790399000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:03.802383000 usim_creator.handle_overflow                       [586] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:23:03.814633000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [1.25139695055056678483968015474724784506] and current target energy [9.13980244390389032654227258499356780637]. Set energy to 0.
20.05.2024 04:23:03.862039000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:03.869550000 usim_creator.handle_overflow                       [586] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:23:03.891545000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-1.25139695055056678483968015474724784506] and current target energy [-9.13980244390389032654227258499356780637]. Set energy to 0.
20.05.2024 04:23:03.915214000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:03.928409000 usim_creator.handle_overflow                       [586] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:23:03.942586000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-1.25139695055056678483968015474724784506] and current target energy [-9.13980244390389032654227258499356780637]. Set energy to 0.
20.05.2024 04:23:03.962283000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:03.967440000 usim_creator.handle_overflow                       [586] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:23:06.188576000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.24034324336830613366762722063185232608] and current target energy [7.62556235817926269918206001178016118737]. Set energy to 0.
20.05.2024 04:23:06.203696000 usim_creator.handle_overflow                       [594] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:23:06.226011000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.24034324336830613366762722063185232608] and current target energy [7.62556235817926269918206001178016118737]. Set energy to 0.
20.05.2024 04:23:06.245285000 usim_creator.handle_overflow                       [594] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:23:06.252801000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.24034324336830613366762722063185232608] and current target energy [-7.62556235817926269918206001178016118737]. Set energy to 0.
20.05.2024 04:23:06.275924000 usim_creator.handle_overflow                       [594] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:23:06.287009000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.24034324336830613366762722063185232608] and current target energy [-7.62556235817926269918206001178016118737]. Set energy to 0.
20.05.2024 04:23:06.305140000 usim_creator.handle_overflow                       [594] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:23:07.171714000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [3.07184268050809778801892321849394177747] and current target energy [8.78464049152306489810592640669629046838]. Set energy to 0.
20.05.2024 04:23:07.186920000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:07.188118000 usim_creator.handle_overflow                       [597] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:23:07.201691000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-3.07184268050809778801892321849394177747] and current target energy [-8.78464049152306489810592640669629046838]. Set energy to 0.
20.05.2024 04:23:07.220152000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:07.221158000 usim_creator.handle_overflow                       [597] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:23:07.517751000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.31927960487106204475642509290209407756] and current target energy [8.08732622718102927599684902347272231736]. Set energy to 0.
20.05.2024 04:23:07.535580000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:07.536265000 usim_creator.handle_overflow                       [598] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:23:07.543090000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.31927960487106204475642509290209407756] and current target energy [-8.08732622718102927599684902347272231736]. Set energy to 0.
20.05.2024 04:23:07.551330000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:07.552118000 usim_creator.handle_overflow                       [598] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:23:07.572588000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [3.92375716858469388612032837955369343079] and current target energy [6.14368536101619557603784643698788355493]. Set energy to 0.
20.05.2024 04:23:07.581544000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:07.582695000 usim_creator.handle_overflow                       [598] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:23:07.589173000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-3.92375716858469388612032837955369343079] and current target energy [-6.14368536101619557603784643698788355493]. Set energy to 0.
20.05.2024 04:23:07.597243000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:07.598015000 usim_creator.handle_overflow                       [598] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:23:08.316112000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.31048168855684647227476634628376801717] and current target energy [9.71837911095988960070195645902971167451]. Set energy to 0.
20.05.2024 04:23:08.344265000 usim_creator.handle_overflow                       [601] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:23:08.358522000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.31048168855684647227476634628376801717] and current target energy [-9.71837911095988960070195645902971167451]. Set energy to 0.
20.05.2024 04:23:08.377125000 usim_creator.handle_overflow                       [601] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:23:09.168386000 usim_process.process_queue                         Overflow for target space id [2024052004205948300000000000000000000000000000000000024] with energy [1.21568997337895018821437609243504231718] and current target energy [9.99067099588675306848649341666469099865]. Set energy to 0.
20.05.2024 04:23:09.184494000 usim_creator.handle_overflow                       [604] Not implemented. Handle overflow for [2024052004205948300000000000000000000000000000000000024] escape strategy [0].
20.05.2024 04:23:09.197785000 usim_process.process_queue                         Overflow for target space id [2024052004205949500000000000000000000000000000000000025] with energy [1.21568997337895018821437609243504231718] and current target energy [9.99067099588675306848649341666469099865]. Set energy to 0.
20.05.2024 04:23:09.216981000 usim_creator.handle_overflow                       [604] Not implemented. Handle overflow for [2024052004205949500000000000000000000000000000000000025] escape strategy [0].
20.05.2024 04:23:09.229028000 usim_process.process_queue                         Overflow for target space id [2024052004205950700000000000000000000000000000000000026] with energy [-1.21568997337895018821437609243504231718] and current target energy [-9.99067099588675306848649341666469099865]. Set energy to 0.
20.05.2024 04:23:09.248450000 usim_creator.handle_overflow                       [604] Not implemented. Handle overflow for [2024052004205950700000000000000000000000000000000000026] escape strategy [0].
20.05.2024 04:23:09.260426000 usim_process.process_queue                         Overflow for target space id [2024052004205952100000000000000000000000000000000000027] with energy [-1.21568997337895018821437609243504231718] and current target energy [-9.99067099588675306848649341666469099865]. Set energy to 0.
20.05.2024 04:23:09.275190000 usim_creator.handle_overflow                       [604] Not implemented. Handle overflow for [2024052004205952100000000000000000000000000000000000027] escape strategy [0].
20.05.2024 04:23:09.884231000 usim_process.process_queue                         Overflow for target space id [2024052004210570400000000000000000000000000000000000038] with energy [1.14683769358406263606580446530466453017] and current target energy [9.12163757316390240034301740654197949474]. Set energy to 0.
20.05.2024 04:23:09.899228000 usim_creator.handle_overflow                       [606] Not implemented. Handle overflow for [2024052004210570400000000000000000000000000000000000038] escape strategy [0].
20.05.2024 04:23:09.908687000 usim_process.process_queue                         Overflow for target space id [2024052004210571900000000000000000000000000000000000039] with energy [1.14683769358406263606580446530466453017] and current target energy [9.12163757316390240034301740654197949474]. Set energy to 0.
20.05.2024 04:23:09.917777000 usim_creator.handle_overflow                       [606] Not implemented. Handle overflow for [2024052004210571900000000000000000000000000000000000039] escape strategy [0].
20.05.2024 04:23:09.920715000 usim_process.process_queue                         Overflow for target space id [2024052004210573600000000000000000000000000000000000040] with energy [-1.14683769358406263606580446530466453017] and current target energy [-9.12163757316390240034301740654197949474]. Set energy to 0.
20.05.2024 04:23:09.929828000 usim_creator.handle_overflow                       [606] Not implemented. Handle overflow for [2024052004210573600000000000000000000000000000000000040] escape strategy [0].
20.05.2024 04:23:09.939901000 usim_process.process_queue                         Overflow for target space id [2024052004210575900000000000000000000000000000000000041] with energy [-1.14683769358406263606580446530466453017] and current target energy [-9.12163757316390240034301740654197949474]. Set energy to 0.
20.05.2024 04:23:09.949288000 usim_creator.handle_overflow                       [606] Not implemented. Handle overflow for [2024052004210575900000000000000000000000000000000000041] escape strategy [0].
20.05.2024 04:23:09.960505000 usim_process.process_queue                         Overflow for target space id [2024052004211990800000000000000000000000000000000000070] with energy [2.01869596946387807534667607284713352634] and current target energy [9.02054307424035270992708857429581099847]. Set energy to 0.
20.05.2024 04:23:09.968919000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:09.969713000 usim_creator.handle_overflow                       [606] Not implemented. Handle overflow for [2024052004211990800000000000000000000000000000000000070] escape strategy [7].
20.05.2024 04:23:09.976004000 usim_process.process_queue                         Overflow for target space id [2024052004211994200000000000000000000000000000000000071] with energy [2.01869596946387807534667607284713352634] and current target energy [9.02054307424035270992708857429581099847]. Set energy to 0.
20.05.2024 04:23:09.987981000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:09.988434000 usim_creator.handle_overflow                       [606] Not implemented. Handle overflow for [2024052004211994200000000000000000000000000000000000071] escape strategy [7].
20.05.2024 04:23:09.991952000 usim_process.process_queue                         Overflow for target space id [2024052004211998600000000000000000000000000000000000072] with energy [-2.01869596946387807534667607284713352634] and current target energy [-9.02054307424035270992708857429581099847]. Set energy to 0.
20.05.2024 04:23:10.000413000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:10.001191000 usim_creator.handle_overflow                       [606] Not implemented. Handle overflow for [2024052004211998600000000000000000000000000000000000072] escape strategy [7].
20.05.2024 04:23:10.007437000 usim_process.process_queue                         Overflow for target space id [2024052004212000300000000000000000000000000000000000073] with energy [-2.01869596946387807534667607284713352634] and current target energy [-9.02054307424035270992708857429581099847]. Set energy to 0.
20.05.2024 04:23:10.016711000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:10.017738000 usim_creator.handle_overflow                       [606] Not implemented. Handle overflow for [2024052004212000300000000000000000000000000000000000073] escape strategy [7].
20.05.2024 04:23:10.023869000 usim_process.process_queue                         Overflow for target space id [2024052004221501800000000000000000000000000000000000092] with energy [3.21327702578933306996358334438598292351] and current target energy [8.45272145109953484541677759087744935128]. Set energy to 0.
20.05.2024 04:23:10.032155000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:10.032894000 usim_creator.handle_overflow                       [606] Not implemented. Handle overflow for [2024052004221501800000000000000000000000000000000000092] escape strategy [7].
20.05.2024 04:23:10.036783000 usim_process.process_queue                         Overflow for target space id [2024052004221505600000000000000000000000000000000000093] with energy [-3.21327702578933306996358334438598292351] and current target energy [-8.45272145109953484541677759087744935128]. Set energy to 0.
20.05.2024 04:23:10.047252000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:10.047950000 usim_creator.handle_overflow                       [606] Not implemented. Handle overflow for [2024052004221505600000000000000000000000000000000000093] escape strategy [7].
20.05.2024 04:23:10.531247000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [4.27020709092748066120660234089211037494] and current target energy [6.62537747609614277759073410030217610007]. Set energy to 0.
20.05.2024 04:23:10.565910000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:10.579325000 usim_creator.handle_overflow                       [609] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:23:10.592200000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-4.27020709092748066120660234089211037494] and current target energy [-6.62537747609614277759073410030217610007]. Set energy to 0.
20.05.2024 04:23:10.610330000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:10.612045000 usim_creator.handle_overflow                       [609] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:23:11.148494000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [4.04704745578787754418870196804896608977] and current target energy [7.84751433716938777224065675910738686157]. Set energy to 0.
20.05.2024 04:23:11.159967000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:11.161577000 usim_creator.handle_overflow                       [611] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:23:11.166219000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-4.04704745578787754418870196804896608977] and current target energy [-7.84751433716938777224065675910738686157]. Set energy to 0.
20.05.2024 04:23:11.173882000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:11.174669000 usim_creator.handle_overflow                       [611] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:23:11.734237000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.14590987761488273911865106653363249754] and current target energy [9.24192675422738588909906538513507206869]. Set energy to 0.
20.05.2024 04:23:11.756353000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:11.761601000 usim_creator.handle_overflow                       [614] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:23:11.777779000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.14590987761488273911865106653363249754] and current target energy [9.24192675422738588909906538513507206869]. Set energy to 0.
20.05.2024 04:23:11.804588000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:11.805373000 usim_creator.handle_overflow                       [614] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:23:11.820213000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.14590987761488273911865106653363249754] and current target energy [-9.24192675422738588909906538513507206869]. Set energy to 0.
20.05.2024 04:23:11.835839000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:11.837922000 usim_creator.handle_overflow                       [614] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:23:11.845914000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.14590987761488273911865106653363249754] and current target energy [-9.24192675422738588909906538513507206869]. Set energy to 0.
20.05.2024 04:23:11.862346000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:11.863974000 usim_creator.handle_overflow                       [614] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:23:12.202818000 usim_process.process_queue                         Overflow for target space id [2024052004205701200000000000000000000000000000000000015] with energy [1.22866692375989660923371610356656854256] and current target energy [9.86887449872960933522323429764342160371]. Set energy to 0.
20.05.2024 04:23:12.221950000 usim_creator.handle_overflow                       [615] Not implemented. Handle overflow for [2024052004205701200000000000000000000000000000000000015] escape strategy [0].
20.05.2024 04:23:12.227665000 usim_process.process_queue                         Overflow for target space id [2024052004205702800000000000000000000000000000000000017] with energy [1.22866692375989660923371610356656854256] and current target energy [9.86887449872960933522323429764342160371]. Set energy to 0.
20.05.2024 04:23:12.236189000 usim_creator.handle_overflow                       [615] Not implemented. Handle overflow for [2024052004205702800000000000000000000000000000000000017] escape strategy [0].
20.05.2024 04:23:12.240129000 usim_process.process_queue                         Overflow for target space id [2024052004205711900000000000000000000000000000000000019] with energy [-1.22866692375989660923371610356656854256] and current target energy [-9.86887449872960933522323429764342160371]. Set energy to 0.
20.05.2024 04:23:12.249079000 usim_creator.handle_overflow                       [615] Not implemented. Handle overflow for [2024052004205711900000000000000000000000000000000000019] escape strategy [0].
20.05.2024 04:23:12.253271000 usim_process.process_queue                         Overflow for target space id [2024052004205716200000000000000000000000000000000000021] with energy [-1.22866692375989660923371610356656854256] and current target energy [-9.86887449872960933522323429764342160371]. Set energy to 0.
20.05.2024 04:23:12.261605000 usim_creator.handle_overflow                       [615] Not implemented. Handle overflow for [2024052004205716200000000000000000000000000000000000021] escape strategy [0].
20.05.2024 04:23:12.421460000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [2.02352372789393877209435098402448304489] and current target energy [8.54041418185496132241320468178422074988]. Set energy to 0.
20.05.2024 04:23:12.431026000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:12.431774000 usim_creator.handle_overflow                       [616] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:23:12.438915000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-2.02352372789393877209435098402448304489] and current target energy [-8.54041418185496132241320468178422074988]. Set energy to 0.
20.05.2024 04:23:12.446878000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:12.447655000 usim_creator.handle_overflow                       [616] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:23:12.881294000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.34136178706630189418649141078728007014] and current target energy [9.82933539007917287386972882853254834051]. Set energy to 0.
20.05.2024 04:23:12.897359000 usim_creator.handle_overflow                       [618] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:23:12.914543000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.34136178706630189418649141078728007014] and current target energy [9.82933539007917287386972882853254834051]. Set energy to 0.
20.05.2024 04:23:12.933562000 usim_creator.handle_overflow                       [618] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:23:12.949530000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.34136178706630189418649141078728007014] and current target energy [-9.82933539007917287386972882853254834051]. Set energy to 0.
20.05.2024 04:23:12.964732000 usim_creator.handle_overflow                       [618] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:23:12.968273000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.34136178706630189418649141078728007014] and current target energy [-9.82933539007917287386972882853254834051]. Set energy to 0.
20.05.2024 04:23:12.976538000 usim_creator.handle_overflow                       [618] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:23:13.902616000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [4.6795447904257403958157140483255703548] and current target energy [8.68272357413260378837298282157456014027]. Set energy to 0.
20.05.2024 04:23:13.916370000 usim_creator.handle_overflow                       [621] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:23:13.921097000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-4.6795447904257403958157140483255703548] and current target energy [-8.68272357413260378837298282157456014027]. Set energy to 0.
20.05.2024 04:23:13.929521000 usim_creator.handle_overflow                       [621] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:23:13.940718000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [1.83622307924626089693807747371146611464] and current target energy [8.58554897753289250749610451304540625887]. Set energy to 0.
20.05.2024 04:23:13.965543000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:13.971159000 usim_creator.handle_overflow                       [621] Not implemented. Handle overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [7].
20.05.2024 04:23:13.985051000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [1.83622307924626089693807747371146611464] and current target energy [8.58554897753289250749610451304540625887]. Set energy to 0.
20.05.2024 04:23:14.006540000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:14.020338000 usim_creator.handle_overflow                       [621] Not implemented. Handle overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [7].
20.05.2024 04:23:14.030674000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-1.83622307924626089693807747371146611464] and current target energy [-8.58554897753289250749610451304540625887]. Set energy to 0.
20.05.2024 04:23:14.052982000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:14.054218000 usim_creator.handle_overflow                       [621] Not implemented. Handle overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [7].
20.05.2024 04:23:14.083464000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-1.83622307924626089693807747371146611464] and current target energy [-8.58554897753289250749610451304540625887]. Set energy to 0.
20.05.2024 04:23:14.101986000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:14.103107000 usim_creator.handle_overflow                       [621] Not implemented. Handle overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [7].
20.05.2024 04:23:14.475009000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.004577995682021869522183475173319468645975] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:23:14.477321000 usim_process.process_node                          Overflow for space id [2024052004205700500000000000000000000000000000000000014] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:23:14.502513000 usim_creator.handle_overflow                       [623] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:23:14.517013000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[.004577995682021869522183475173319468645975] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:23:14.518220000 usim_process.process_node                          Overflow for space id [2024052004205702100000000000000000000000000000000000016] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:23:14.548783000 usim_creator.handle_overflow                       [623] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:23:14.564959000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.004577995682021869522183475173319468645975] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:23:14.566059000 usim_process.process_node                          Overflow for space id [2024052004205707700000000000000000000000000000000000018] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:23:14.588624000 usim_creator.handle_overflow                       [623] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:23:14.616162000 usim_dbif.get_acceleration                         Numerical overflow for l_energy[-.004577995682021869522183475173319468645975] overflow [10,-10] underflow[.01,-.01].
20.05.2024 04:23:14.617273000 usim_process.process_node                          Overflow for space id [2024052004205714100000000000000000000000000000000000020] usim_dbif.get_acceleration. Set target energy to 0.
20.05.2024 04:23:14.646730000 usim_creator.handle_overflow                       [623] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:23:15.187325000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [3.19305668038972598115092634943034564761] and current target energy [8.09409491157575508837740393609793217954]. Set energy to 0.
20.05.2024 04:23:15.211019000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:15.221348000 usim_creator.handle_overflow                       [624] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:23:15.227402000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-3.19305668038972598115092634943034564761] and current target energy [-8.09409491157575508837740393609793217954]. Set energy to 0.
20.05.2024 04:23:15.246772000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:15.247743000 usim_creator.handle_overflow                       [624] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:23:15.254459000 usim_process.process_queue                         Overflow for target space id [2024052004221223900000000000000000000000000000000000088] with energy [2.17075167362886587596495094204170665239] and current target energy [8.18409692970872574240900635722096204778]. Set energy to 0.
20.05.2024 04:23:15.281186000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:15.289543000 usim_creator.handle_overflow                       [624] Not implemented. Handle overflow for [2024052004221223900000000000000000000000000000000000088] escape strategy [7].
20.05.2024 04:23:15.293344000 usim_process.process_queue                         Overflow for target space id [2024052004221227000000000000000000000000000000000000089] with energy [2.17075167362886587596495094204170665239] and current target energy [8.18409692970872574240900635722096204778]. Set energy to 0.
20.05.2024 04:23:15.310440000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:15.312000000 usim_creator.handle_overflow                       [624] Not implemented. Handle overflow for [2024052004221227000000000000000000000000000000000000089] escape strategy [7].
20.05.2024 04:23:15.317794000 usim_process.process_queue                         Overflow for target space id [2024052004221231900000000000000000000000000000000000090] with energy [-2.17075167362886587596495094204170665239] and current target energy [-8.18409692970872574240900635722096204778]. Set energy to 0.
20.05.2024 04:23:15.332349000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:15.332681000 usim_creator.handle_overflow                       [624] Not implemented. Handle overflow for [2024052004221231900000000000000000000000000000000000090] escape strategy [7].
20.05.2024 04:23:15.344464000 usim_process.process_queue                         Overflow for target space id [2024052004221235100000000000000000000000000000000000091] with energy [-2.17075167362886587596495094204170665239] and current target energy [-8.18409692970872574240900635722096204778]. Set energy to 0.
20.05.2024 04:23:15.363150000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:15.364496000 usim_creator.handle_overflow                       [624] Not implemented. Handle overflow for [2024052004221235100000000000000000000000000000000000091] escape strategy [7].
20.05.2024 04:23:15.610579000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [2.10579515569158317811707132174650665966] and current target energy [8.42318062276633271246828528698602663864]. Set energy to 0.
20.05.2024 04:23:15.625726000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:15.626616000 usim_creator.handle_overflow                       [625] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:23:15.665707000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-2.10579515569158317811707132174650665966] and current target energy [-8.42318062276633271246828528698602663864]. Set energy to 0.
20.05.2024 04:23:15.680841000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:15.682114000 usim_creator.handle_overflow                       [625] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:23:15.986108000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [1.49431488681427394383480043031705946575] and current target energy [9.3590895808514807916314280966511407096]. Set energy to 0.
20.05.2024 04:23:16.036232000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:16.045142000 usim_creator.handle_overflow                       [626] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:23:16.061094000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-1.49431488681427394383480043031705946575] and current target energy [-9.3590895808514807916314280966511407096]. Set energy to 0.
20.05.2024 04:23:16.087204000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:16.103396000 usim_creator.handle_overflow                       [626] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:23:17.042320000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.17268832287187822976978088530991163538] and current target energy [9.94802431809519269373378770411960107105]. Set energy to 0.
20.05.2024 04:23:17.058765000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:17.059080000 usim_creator.handle_overflow                       [630] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:23:17.062473000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.17268832287187822976978088530991163538] and current target energy [9.94802431809519269373378770411960107105]. Set energy to 0.
20.05.2024 04:23:17.082097000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:17.086656000 usim_creator.handle_overflow                       [630] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:23:17.106165000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.17268832287187822976978088530991163538] and current target energy [-9.94802431809519269373378770411960107105]. Set energy to 0.
20.05.2024 04:23:17.133687000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:17.141391000 usim_creator.handle_overflow                       [630] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:23:17.158732000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.17268832287187822976978088530991163538] and current target energy [-9.94802431809519269373378770411960107105]. Set energy to 0.
20.05.2024 04:23:17.176610000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:17.182995000 usim_creator.handle_overflow                       [630] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:23:17.418474000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.90323130811336135532522957822136092025] and current target energy [9.90579953609529189823914221013721496929]. Set energy to 0.
20.05.2024 04:23:17.450348000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:17.450670000 usim_creator.handle_overflow                       [631] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:23:17.459468000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.90323130811336135532522957822136092025] and current target energy [9.90579953609529189823914221013721496929]. Set energy to 0.
20.05.2024 04:23:17.480255000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:17.484797000 usim_creator.handle_overflow                       [631] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:23:17.495018000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.90323130811336135532522957822136092025] and current target energy [-9.90579953609529189823914221013721496929]. Set energy to 0.
20.05.2024 04:23:17.520866000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:17.522268000 usim_creator.handle_overflow                       [631] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:23:17.541327000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.90323130811336135532522957822136092025] and current target energy [-9.90579953609529189823914221013721496929]. Set energy to 0.
20.05.2024 04:23:17.565883000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:17.567327000 usim_creator.handle_overflow                       [631] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:23:17.622251000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [4.06720644241716135732093086313605469547] and current target energy [9.35626361996629767245260292324690082173]. Set energy to 0.
20.05.2024 04:23:17.646941000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:17.651140000 usim_creator.handle_overflow                       [631] Not implemented. Handle overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [7].
20.05.2024 04:23:17.663735000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-4.06720644241716135732093086313605469547] and current target energy [-9.35626361996629767245260292324690082173]. Set energy to 0.
20.05.2024 04:23:17.683023000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:17.690812000 usim_creator.handle_overflow                       [631] Not implemented. Handle overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [7].
20.05.2024 04:23:18.209236000 usim_process.process_queue                         Overflow for target space id [2024052004223175000000000000000000000000000000000000094] with energy [3.45178734791172156771293720815820797604] and current target energy [7.90267311959231016611208311754413905844]. Set energy to 0.
20.05.2024 04:23:18.228212000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:18.232325000 usim_creator.handle_overflow                       [633] Not implemented. Handle overflow for [2024052004223175000000000000000000000000000000000000094] escape strategy [7].
20.05.2024 04:23:18.241909000 usim_process.process_queue                         Overflow for target space id [2024052004223178700000000000000000000000000000000000095] with energy [-3.45178734791172156771293720815820797604] and current target energy [-7.90267311959231016611208311754413905844]. Set energy to 0.
20.05.2024 04:23:18.259724000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:18.269892000 usim_creator.handle_overflow                       [633] Not implemented. Handle overflow for [2024052004223178700000000000000000000000000000000000095] escape strategy [7].
20.05.2024 04:23:18.761446000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [3.26477550080756588281568653642125617564] and current target energy [9.80271922454628169638015212958317800988]. Set energy to 0.
20.05.2024 04:23:18.800693000 usim_creator.handle_overflow                       [635] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:23:18.807121000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-3.26477550080756588281568653642125617564] and current target energy [-9.80271922454628169638015212958317800988]. Set energy to 0.
20.05.2024 04:23:18.837808000 usim_creator.handle_overflow                       [635] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:23:18.847368000 usim_process.process_queue                         Overflow for target space id [2024052004211570000000000000000000000000000000000000058] with energy [.9107687848270412721494272261382460227225] and current target energy [9.59307436341485920501360426861410518996]. Set energy to 0.
20.05.2024 04:23:18.867448000 usim_creator.handle_overflow                       [635] Not implemented. Handle overflow for [2024052004211570000000000000000000000000000000000000058] escape strategy [0].
20.05.2024 04:23:18.884655000 usim_process.process_queue                         Overflow for target space id [2024052004211574500000000000000000000000000000000000059] with energy [.9107687848270412721494272261382460227225] and current target energy [9.59307436341485920501360426861410518996]. Set energy to 0.
20.05.2024 04:23:18.912932000 usim_creator.handle_overflow                       [635] Not implemented. Handle overflow for [2024052004211574500000000000000000000000000000000000059] escape strategy [0].
20.05.2024 04:23:18.924437000 usim_process.process_queue                         Overflow for target space id [2024052004211579500000000000000000000000000000000000060] with energy [-.9107687848270412721494272261382460227225] and current target energy [-9.59307436341485920501360426861410518996]. Set energy to 0.
20.05.2024 04:23:18.940686000 usim_creator.handle_overflow                       [635] Not implemented. Handle overflow for [2024052004211579500000000000000000000000000000000000060] escape strategy [0].
20.05.2024 04:23:18.948522000 usim_process.process_queue                         Overflow for target space id [2024052004211584300000000000000000000000000000000000061] with energy [-.9107687848270412721494272261382460227225] and current target energy [-9.59307436341485920501360426861410518996]. Set energy to 0.
20.05.2024 04:23:18.966299000 usim_creator.handle_overflow                       [635] Not implemented. Handle overflow for [2024052004211584300000000000000000000000000000000000061] escape strategy [0].
20.05.2024 04:23:18.983307000 usim_process.process_queue                         Overflow for target space id [2024052004213975700000000000000000000000000000000000082] with energy [1.25809184749779287728941262530704675282] and current target energy [8.98186499513963404936053520802311577905]. Set energy to 0.
20.05.2024 04:23:19.004162000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:19.012229000 usim_creator.handle_overflow                       [635] Not implemented. Handle overflow for [2024052004213975700000000000000000000000000000000000082] escape strategy [7].
20.05.2024 04:23:19.023654000 usim_process.process_queue                         Overflow for target space id [2024052004213980000000000000000000000000000000000000083] with energy [1.25809184749779287728941262530704675282] and current target energy [8.98186499513963404936053520802311577905]. Set energy to 0.
20.05.2024 04:23:19.045123000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:19.051933000 usim_creator.handle_overflow                       [635] Not implemented. Handle overflow for [2024052004213980000000000000000000000000000000000000083] escape strategy [7].
20.05.2024 04:23:19.062742000 usim_process.process_queue                         Overflow for target space id [2024052004213983100000000000000000000000000000000000084] with energy [-1.25809184749779287728941262530704675282] and current target energy [-8.98186499513963404936053520802311577905]. Set energy to 0.
20.05.2024 04:23:19.086511000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:19.087830000 usim_creator.handle_overflow                       [635] Not implemented. Handle overflow for [2024052004213983100000000000000000000000000000000000084] escape strategy [7].
20.05.2024 04:23:19.111584000 usim_process.process_queue                         Overflow for target space id [2024052004213986900000000000000000000000000000000000085] with energy [-1.25809184749779287728941262530704675282] and current target energy [-8.98186499513963404936053520802311577905]. Set energy to 0.
20.05.2024 04:23:19.128566000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:19.129809000 usim_creator.handle_overflow                       [635] Not implemented. Handle overflow for [2024052004213986900000000000000000000000000000000000085] escape strategy [7].
20.05.2024 04:23:19.793180000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [4.93015327939509174924916516517560668948] and current target energy [6.91256214970234775683112052929731796013]. Set energy to 0.
20.05.2024 04:23:19.817579000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:19.829750000 usim_creator.handle_overflow                       [637] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:23:19.853876000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-4.93015327939509174924916516517560668948] and current target energy [-6.91256214970234775683112052929731796013]. Set energy to 0.
20.05.2024 04:23:19.876943000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:19.891140000 usim_creator.handle_overflow                       [637] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:23:20.525836000 usim_process.process_queue                         Overflow for target space id [2024052004210261400000000000000000000000000000000000034] with energy [.6883494407632770464163268367292127324825] and current target energy [9.87433848422049799327900447374499279456]. Set energy to 0.
20.05.2024 04:23:20.542373000 usim_creator.handle_overflow                       [639] Not implemented. Handle overflow for [2024052004210261400000000000000000000000000000000000034] escape strategy [0].
20.05.2024 04:23:20.548948000 usim_process.process_queue                         Overflow for target space id [2024052004210264800000000000000000000000000000000000035] with energy [.6883494407632770464163268367292127324825] and current target energy [9.87433848422049799327900447374499279456]. Set energy to 0.
20.05.2024 04:23:20.577885000 usim_creator.handle_overflow                       [639] Not implemented. Handle overflow for [2024052004210264800000000000000000000000000000000000035] escape strategy [0].
20.05.2024 04:23:20.585732000 usim_process.process_queue                         Overflow for target space id [2024052004210269400000000000000000000000000000000000036] with energy [-.6883494407632770464163268367292127324825] and current target energy [-9.87433848422049799327900447374499279456]. Set energy to 0.
20.05.2024 04:23:20.610163000 usim_creator.handle_overflow                       [639] Not implemented. Handle overflow for [2024052004210269400000000000000000000000000000000000036] escape strategy [0].
20.05.2024 04:23:20.619095000 usim_process.process_queue                         Overflow for target space id [2024052004210273800000000000000000000000000000000000037] with energy [-.6883494407632770464163268367292127324825] and current target energy [-9.87433848422049799327900447374499279456]. Set energy to 0.
20.05.2024 04:23:20.636940000 usim_creator.handle_overflow                       [639] Not implemented. Handle overflow for [2024052004210273800000000000000000000000000000000000037] escape strategy [0].
20.05.2024 04:23:20.876103000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [3.62712517761928258405967540623249667026] and current target energy [9.24401282124817239094602332056372003188]. Set energy to 0.
20.05.2024 04:23:20.886181000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:20.886946000 usim_creator.handle_overflow                       [640] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:23:20.892799000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-3.62712517761928258405967540623249667026] and current target energy [-9.24401282124817239094602332056372003188]. Set energy to 0.
20.05.2024 04:23:20.902667000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:20.903608000 usim_creator.handle_overflow                       [640] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:23:21.288252000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [3.98925042914703647726943545574322880371] and current target energy [6.52955100161513176563137307284251235127]. Set energy to 0.
20.05.2024 04:23:21.306204000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:21.307476000 usim_creator.handle_overflow                       [642] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:23:21.324778000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-3.98925042914703647726943545574322880371] and current target energy [-6.52955100161513176563137307284251235127]. Set energy to 0.
20.05.2024 04:23:21.342308000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:21.346047000 usim_creator.handle_overflow                       [642] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:23:21.650478000 usim_process.process_queue                         Overflow for target space id [2024052004210931900000000000000000000000000000000000044] with energy [.693422457962289358518706243577652625985] and current target energy [9.52224973090869543480688079809124792717]. Set energy to 0.
20.05.2024 04:23:21.678010000 usim_creator.handle_overflow                       [643] Not implemented. Handle overflow for [2024052004210931900000000000000000000000000000000000044] escape strategy [0].
20.05.2024 04:23:21.687187000 usim_process.process_queue                         Overflow for target space id [2024052004210936800000000000000000000000000000000000045] with energy [.693422457962289358518706243577652625985] and current target energy [9.52224973090869543480688079809124792717]. Set energy to 0.
20.05.2024 04:23:21.706958000 usim_creator.handle_overflow                       [643] Not implemented. Handle overflow for [2024052004210936800000000000000000000000000000000000045] escape strategy [0].
20.05.2024 04:23:21.715982000 usim_process.process_queue                         Overflow for target space id [2024052004210941800000000000000000000000000000000000046] with energy [-.693422457962289358518706243577652625985] and current target energy [-9.52224973090869543480688079809124792717]. Set energy to 0.
20.05.2024 04:23:21.730041000 usim_creator.handle_overflow                       [643] Not implemented. Handle overflow for [2024052004210941800000000000000000000000000000000000046] escape strategy [0].
20.05.2024 04:23:21.747215000 usim_process.process_queue                         Overflow for target space id [2024052004210944800000000000000000000000000000000000047] with energy [-.693422457962289358518706243577652625985] and current target energy [-9.52224973090869543480688079809124792717]. Set energy to 0.
20.05.2024 04:23:21.769480000 usim_creator.handle_overflow                       [643] Not implemented. Handle overflow for [2024052004210944800000000000000000000000000000000000047] escape strategy [0].
20.05.2024 04:23:23.424262000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.76288683809753912821192506773651994692] and current target energy [8.48001694245455541660511991349117295498]. Set energy to 0.
20.05.2024 04:23:23.452834000 usim_creator.handle_overflow                       [648] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:23:23.473820000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.76288683809753912821192506773651994692] and current target energy [8.48001694245455541660511991349117295498]. Set energy to 0.
20.05.2024 04:23:23.498622000 usim_creator.handle_overflow                       [648] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:23:23.508439000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.76288683809753912821192506773651994692] and current target energy [-8.48001694245455541660511991349117295498]. Set energy to 0.
20.05.2024 04:23:23.528613000 usim_creator.handle_overflow                       [648] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:23:23.532511000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.76288683809753912821192506773651994692] and current target energy [-8.48001694245455541660511991349117295498]. Set energy to 0.
20.05.2024 04:23:23.548288000 usim_creator.handle_overflow                       [648] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:23:23.569817000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [1.41933384068795832310889248276038930026] and current target energy [9.86030655879018349849833033035121337896]. Set energy to 0.
20.05.2024 04:23:23.584660000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:23.592191000 usim_creator.handle_overflow                       [648] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:23:23.614544000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-1.41933384068795832310889248276038930026] and current target energy [-9.86030655879018349849833033035121337896]. Set energy to 0.
20.05.2024 04:23:23.630974000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:23.632017000 usim_creator.handle_overflow                       [648] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:23:23.947724000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [3.07806113825348172787639953715582650999] and current target energy [7.97850085829407295453887091148645760742]. Set energy to 0.
20.05.2024 04:23:23.984771000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:23.986241000 usim_creator.handle_overflow                       [649] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:23:24.006429000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-3.07806113825348172787639953715582650999] and current target energy [-7.97850085829407295453887091148645760742]. Set energy to 0.
20.05.2024 04:23:24.034754000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:24.035576000 usim_creator.handle_overflow                       [649] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:23:24.353736000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [1.12015078433614642281215968810821474737] and current target energy [9.22347761956136596122957730343370404784]. Set energy to 0.
20.05.2024 04:23:24.386241000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:24.387410000 usim_creator.handle_overflow                       [650] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:23:24.390619000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [1.12015078433614642281215968810821474737] and current target energy [9.22347761956136596122957730343370404784]. Set energy to 0.
20.05.2024 04:23:24.408352000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:24.409155000 usim_creator.handle_overflow                       [650] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:23:24.416321000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-1.12015078433614642281215968810821474737] and current target energy [-9.22347761956136596122957730343370404784]. Set energy to 0.
20.05.2024 04:23:24.425881000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:24.426325000 usim_creator.handle_overflow                       [650] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:23:24.431538000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-1.12015078433614642281215968810821474737] and current target energy [-9.22347761956136596122957730343370404784]. Set energy to 0.
20.05.2024 04:23:24.439560000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:24.440657000 usim_creator.handle_overflow                       [650] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:23:24.646193000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [3.07806113825348172787639953715582650999] and current target energy [7.52577367619507825642385013547303989383]. Set energy to 0.
20.05.2024 04:23:24.687890000 usim_creator.handle_overflow                       [651] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:23:24.704585000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-3.07806113825348172787639953715582650999] and current target energy [-7.52577367619507825642385013547303989383]. Set energy to 0.
20.05.2024 04:23:24.726275000 usim_creator.handle_overflow                       [651] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:23:25.077406000 usim_process.process_queue                         Overflow for target space id [2024052004221501800000000000000000000000000000000000092] with energy [2.15736709244482597982058575509887998503] and current target energy [8.62946836977930391928234302039551994009]. Set energy to 0.
20.05.2024 04:23:25.107856000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:25.111202000 usim_creator.handle_overflow                       [652] Not implemented. Handle overflow for [2024052004221501800000000000000000000000000000000000092] escape strategy [7].
20.05.2024 04:23:25.129144000 usim_process.process_queue                         Overflow for target space id [2024052004221505600000000000000000000000000000000000093] with energy [-2.15736709244482597982058575509887998503] and current target energy [-8.62946836977930391928234302039551994009]. Set energy to 0.
20.05.2024 04:23:25.145814000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:25.146930000 usim_creator.handle_overflow                       [652] Not implemented. Handle overflow for [2024052004221505600000000000000000000000000000000000093] escape strategy [7].
20.05.2024 04:23:26.088785000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [2.92110081869518519924010857465819876968] and current target energy [8.14822422220114356229465282279044029914]. Set energy to 0.
20.05.2024 04:23:26.110043000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:26.116255000 usim_creator.handle_overflow                       [656] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:23:26.135389000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-2.92110081869518519924010857465819876968] and current target energy [-8.14822422220114356229465282279044029914]. Set energy to 0.
20.05.2024 04:23:26.150469000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:26.152168000 usim_creator.handle_overflow                       [656] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:23:26.504309000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [3.76407131096437840575428978241086124914] and current target energy [9.24887556981208340675406854033660774238]. Set energy to 0.
20.05.2024 04:23:26.534758000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:26.546028000 usim_creator.handle_overflow                       [657] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:23:26.551549000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-3.76407131096437840575428978241086124914] and current target energy [-9.24887556981208340675406854033660774238]. Set energy to 0.
20.05.2024 04:23:26.577705000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:26.578907000 usim_creator.handle_overflow                       [657] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:23:27.457198000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [2.24111468890595261985958546703863568906] and current target energy [9.9605097284709005327092687423939363958]. Set energy to 0.
20.05.2024 04:23:27.483396000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:27.495732000 usim_creator.handle_overflow                       [660] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:23:27.499408000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [2.24111468890595261985958546703863568906] and current target energy [9.9605097284709005327092687423939363958]. Set energy to 0.
20.05.2024 04:23:27.520102000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:27.521229000 usim_creator.handle_overflow                       [660] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:23:27.532908000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-2.24111468890595261985958546703863568906] and current target energy [-9.9605097284709005327092687423939363958]. Set energy to 0.
20.05.2024 04:23:27.559926000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:27.566965000 usim_creator.handle_overflow                       [660] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:23:27.574516000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-2.24111468890595261985958546703863568906] and current target energy [-9.9605097284709005327092687423939363958]. Set energy to 0.
20.05.2024 04:23:27.592071000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:27.593276000 usim_creator.handle_overflow                       [660] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:23:28.208094000 usim_process.process_queue                         Overflow for target space id [2024052004211990800000000000000000000000000000000000070] with energy [1.97390227796918390560975609817852248144] and current target energy [9.95180677919714221523424133242720541988]. Set energy to 0.
20.05.2024 04:23:28.233821000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:28.235037000 usim_creator.handle_overflow                       [662] Not implemented. Handle overflow for [2024052004211990800000000000000000000000000000000000070] escape strategy [7].
20.05.2024 04:23:28.250093000 usim_process.process_queue                         Overflow for target space id [2024052004211994200000000000000000000000000000000000071] with energy [1.97390227796918390560975609817852248144] and current target energy [9.95180677919714221523424133242720541988]. Set energy to 0.
20.05.2024 04:23:28.272437000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:28.287151000 usim_creator.handle_overflow                       [662] Not implemented. Handle overflow for [2024052004211994200000000000000000000000000000000000071] escape strategy [7].
20.05.2024 04:23:28.307164000 usim_process.process_queue                         Overflow for target space id [2024052004211998600000000000000000000000000000000000072] with energy [-1.97390227796918390560975609817852248144] and current target energy [-9.95180677919714221523424133242720541988]. Set energy to 0.
20.05.2024 04:23:28.331414000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:28.333006000 usim_creator.handle_overflow                       [662] Not implemented. Handle overflow for [2024052004211998600000000000000000000000000000000000072] escape strategy [7].
20.05.2024 04:23:28.342985000 usim_process.process_queue                         Overflow for target space id [2024052004212000300000000000000000000000000000000000073] with energy [-1.97390227796918390560975609817852248144] and current target energy [-9.95180677919714221523424133242720541988]. Set energy to 0.
20.05.2024 04:23:28.378779000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:28.389702000 usim_creator.handle_overflow                       [662] Not implemented. Handle overflow for [2024052004212000300000000000000000000000000000000000073] escape strategy [7].
20.05.2024 04:23:28.633208000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.50483024459772534770632008286949987533] and current target energy [6.96275898184334670841000988283571538388]. Set energy to 0.
20.05.2024 04:23:28.650755000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:28.652282000 usim_creator.handle_overflow                       [663] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:23:28.678535000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.50483024459772534770632008286949987533] and current target energy [-6.96275898184334670841000988283571538388]. Set energy to 0.
20.05.2024 04:23:28.695779000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:28.707038000 usim_creator.handle_overflow                       [663] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:23:29.282056000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [1.53153666960108073475042253365476327006] and current target energy [9.03259255911014169202647509719887202887]. Set energy to 0.
20.05.2024 04:23:29.303188000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:29.305034000 usim_creator.handle_overflow                       [665] Not implemented. Handle overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [7].
20.05.2024 04:23:29.318144000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [1.53153666960108073475042253365476327006] and current target energy [9.03259255911014169202647509719887202887]. Set energy to 0.
20.05.2024 04:23:29.342161000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:29.352726000 usim_creator.handle_overflow                       [665] Not implemented. Handle overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [7].
20.05.2024 04:23:29.369808000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-1.53153666960108073475042253365476327006] and current target energy [-9.03259255911014169202647509719887202887]. Set energy to 0.
20.05.2024 04:23:29.385850000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:29.386949000 usim_creator.handle_overflow                       [665] Not implemented. Handle overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [7].
20.05.2024 04:23:29.399698000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-1.53153666960108073475042253365476327006] and current target energy [-9.03259255911014169202647509719887202887]. Set energy to 0.
20.05.2024 04:23:29.414454000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:29.415987000 usim_creator.handle_overflow                       [665] Not implemented. Handle overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [7].
20.05.2024 04:23:29.990046000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.02598756476859258584484150200792184146] and current target energy [9.22625506516506341096938407717518268397]. Set energy to 0.
20.05.2024 04:23:30.031315000 usim_creator.handle_overflow                       [667] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:23:30.043018000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.02598756476859258584484150200792184146] and current target energy [-9.22625506516506341096938407717518268397]. Set energy to 0.
20.05.2024 04:23:30.059802000 usim_creator.handle_overflow                       [667] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:23:30.072759000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [2.07189299583316555693443495629701146734] and current target energy [8.6457012197133571549441987622759711565]. Set energy to 0.
20.05.2024 04:23:30.098451000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:30.100013000 usim_creator.handle_overflow                       [667] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:23:30.111993000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [2.07189299583316555693443495629701146734] and current target energy [8.6457012197133571549441987622759711565]. Set energy to 0.
20.05.2024 04:23:30.133434000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:30.137085000 usim_creator.handle_overflow                       [667] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:23:30.148652000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-2.07189299583316555693443495629701146734] and current target energy [-8.6457012197133571549441987622759711565]. Set energy to 0.
20.05.2024 04:23:30.163340000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:30.165057000 usim_creator.handle_overflow                       [667] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:23:30.178162000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-2.07189299583316555693443495629701146734] and current target energy [-8.6457012197133571549441987622759711565]. Set energy to 0.
20.05.2024 04:23:30.193065000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:30.194388000 usim_creator.handle_overflow                       [667] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:23:30.532400000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [4.70909811347747340473979440260167205958] and current target energy [5.80425415100708458963210033058477128852]. Set energy to 0.
20.05.2024 04:23:30.550701000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:30.552016000 usim_creator.handle_overflow                       [668] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:23:30.564704000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-4.70909811347747340473979440260167205958] and current target energy [-5.80425415100708458963210033058477128852]. Set energy to 0.
20.05.2024 04:23:30.579271000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:30.580332000 usim_creator.handle_overflow                       [668] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:23:31.187118000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [1.26824968782083760648437135092445322207] and current target energy [9.00966048919545069541264016573899975065]. Set energy to 0.
20.05.2024 04:23:31.210331000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:31.221498000 usim_creator.handle_overflow                       [670] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:23:31.232733000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-1.26824968782083760648437135092445322207] and current target energy [-9.00966048919545069541264016573899975065]. Set energy to 0.
20.05.2024 04:23:31.268812000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:31.270039000 usim_creator.handle_overflow                       [670] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:23:31.273462000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [4.0783604770512238057756317265056673005] and current target energy [8.91021287149720114681048837090200801296]. Set energy to 0.
20.05.2024 04:23:31.290398000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:31.291978000 usim_creator.handle_overflow                       [670] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:23:31.306043000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-4.0783604770512238057756317265056673005] and current target energy [-8.91021287149720114681048837090200801296]. Set energy to 0.
20.05.2024 04:23:31.324173000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:31.325528000 usim_creator.handle_overflow                       [670] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:23:31.354282000 usim_process.process_queue                         Overflow for target space id [2024052004221223900000000000000000000000000000000000088] with energy [2.44760737031497558392354838281185817705] and current target energy [9.80084863633317681738278925988975739252]. Set energy to 0.
20.05.2024 04:23:31.378846000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:31.379975000 usim_creator.handle_overflow                       [670] Not implemented. Handle overflow for [2024052004221223900000000000000000000000000000000000088] escape strategy [7].
20.05.2024 04:23:31.391333000 usim_process.process_queue                         Overflow for target space id [2024052004221227000000000000000000000000000000000000089] with energy [2.44760737031497558392354838281185817705] and current target energy [9.80084863633317681738278925988975739252]. Set energy to 0.
20.05.2024 04:23:31.407067000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:31.409040000 usim_creator.handle_overflow                       [670] Not implemented. Handle overflow for [2024052004221227000000000000000000000000000000000000089] escape strategy [7].
20.05.2024 04:23:31.439250000 usim_process.process_queue                         Overflow for target space id [2024052004221231900000000000000000000000000000000000090] with energy [-2.44760737031497558392354838281185817705] and current target energy [-9.80084863633317681738278925988975739252]. Set energy to 0.
20.05.2024 04:23:31.461499000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:31.462918000 usim_creator.handle_overflow                       [670] Not implemented. Handle overflow for [2024052004221231900000000000000000000000000000000000090] escape strategy [7].
20.05.2024 04:23:31.489113000 usim_process.process_queue                         Overflow for target space id [2024052004221235100000000000000000000000000000000000091] with energy [-2.44760737031497558392354838281185817705] and current target energy [-9.80084863633317681738278925988975739252]. Set energy to 0.
20.05.2024 04:23:31.512220000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:31.519249000 usim_creator.handle_overflow                       [670] Not implemented. Handle overflow for [2024052004221235100000000000000000000000000000000000091] escape strategy [7].
20.05.2024 04:23:33.149727000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [3.3745632912332067410487869225742479728] and current target energy [7.39473701709064856776680894030713178879]. Set energy to 0.
20.05.2024 04:23:33.175890000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:33.176609000 usim_creator.handle_overflow                       [676] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:23:33.182441000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-3.3745632912332067410487869225742479728] and current target energy [-7.39473701709064856776680894030713178879]. Set energy to 0.
20.05.2024 04:23:33.192181000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:33.193141000 usim_creator.handle_overflow                       [676] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:23:33.207322000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.3745632912332067410487869225742479728] and current target energy [9.77079867135545856132057473155041500784]. Set energy to 0.
20.05.2024 04:23:33.216267000 usim_creator.handle_overflow                       [676] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:23:33.221408000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.3745632912332067410487869225742479728] and current target energy [9.77079867135545856132057473155041500784]. Set energy to 0.
20.05.2024 04:23:33.230440000 usim_creator.handle_overflow                       [676] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:23:33.235030000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.3745632912332067410487869225742479728] and current target energy [-9.77079867135545856132057473155041500784]. Set energy to 0.
20.05.2024 04:23:33.243674000 usim_creator.handle_overflow                       [676] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:23:33.249122000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.3745632912332067410487869225742479728] and current target energy [-9.77079867135545856132057473155041500784]. Set energy to 0.
20.05.2024 04:23:33.257149000 usim_creator.handle_overflow                       [676] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:23:33.494432000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.72860459230123849966154046084955486795] and current target energy [8.47773117476765198175911430599805081354]. Set energy to 0.
20.05.2024 04:23:33.531448000 usim_creator.handle_overflow                       [677] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:23:33.536613000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.72860459230123849966154046084955486795] and current target energy [-8.47773117476765198175911430599805081354]. Set energy to 0.
20.05.2024 04:23:33.545657000 usim_creator.handle_overflow                       [677] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:23:33.946830000 usim_process.process_queue                         Overflow for target space id [2024052004225249900000000000000000000000000000000000096] with energy [.534675296585611500641505469059191737475] and current target energy [9.79042948125990233569419353124743270818]. Set energy to 0.
20.05.2024 04:23:33.979691000 usim_creator.handle_overflow                       [679] Handle pos overflow for [2024052004225249900000000000000000000000000000000000096] escape strategy [3].
20.05.2024 04:23:34.006290000 usim_process.process_queue                         Overflow for target space id [2024052004225253800000000000000000000000000000000000097] with energy [.534675296585611500641505469059191737475] and current target energy [9.79042948125990233569419353124743270818]. Set energy to 0.
20.05.2024 04:23:34.019244000 usim_creator.handle_overflow                       [679] Handle pos overflow for [2024052004225253800000000000000000000000000000000000097] escape strategy [3].
20.05.2024 04:23:34.022898000 usim_process.process_queue                         Overflow for target space id [2024052004225256200000000000000000000000000000000000098] with energy [-.534675296585611500641505469059191737475] and current target energy [-9.79042948125990233569419353124743270818]. Set energy to 0.
20.05.2024 04:23:34.037953000 usim_creator.handle_overflow                       [679] Handle pos overflow for [2024052004225256200000000000000000000000000000000000098] escape strategy [3].
20.05.2024 04:23:34.058349000 usim_process.process_queue                         Overflow for target space id [2024052004225260100000000000000000000000000000000000099] with energy [-.534675296585611500641505469059191737475] and current target energy [-9.79042948125990233569419353124743270818]. Set energy to 0.
20.05.2024 04:23:34.093656000 usim_creator.handle_overflow                       [679] Handle pos overflow for [2024052004225260100000000000000000000000000000000000099] escape strategy [3].
20.05.2024 04:23:34.743755000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [2.3633303245358566687866000763129191228] and current target energy [9.41819622695494680947958880520334411916]. Set energy to 0.
20.05.2024 04:23:34.774324000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:34.779383000 usim_creator.handle_overflow                       [681] Not implemented. Handle overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [7].
20.05.2024 04:23:34.789845000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-2.3633303245358566687866000763129191228] and current target energy [-9.41819622695494680947958880520334411916]. Set energy to 0.
20.05.2024 04:23:34.806553000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:34.808320000 usim_creator.handle_overflow                       [681] Not implemented. Handle overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [7].
20.05.2024 04:23:35.691057000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [2.8763765520255110845809212464475155246] and current target energy [7.56781045965349782716138289116210640747]. Set energy to 0.
20.05.2024 04:23:35.709261000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:35.711032000 usim_creator.handle_overflow                       [684] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:23:35.729326000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [2.8763765520255110845809212464475155246] and current target energy [7.56781045965349782716138289116210640747]. Set energy to 0.
20.05.2024 04:23:35.744449000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:35.745976000 usim_creator.handle_overflow                       [684] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:23:35.759173000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-2.8763765520255110845809212464475155246] and current target energy [-7.56781045965349782716138289116210640747]. Set energy to 0.
20.05.2024 04:23:35.777590000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:35.778753000 usim_creator.handle_overflow                       [684] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:23:35.788173000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-2.8763765520255110845809212464475155246] and current target energy [-7.56781045965349782716138289116210640747]. Set energy to 0.
20.05.2024 04:23:35.803445000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:35.806637000 usim_creator.handle_overflow                       [684] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:23:35.846567000 usim_process.process_queue                         Overflow for target space id [2024052004221501800000000000000000000000000000000000092] with energy [4.483747297141575436112009892656579437] and current target energy [6.12856360707936589390120286350550099772]. Set energy to 0.
20.05.2024 04:23:35.876829000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:35.887265000 usim_creator.handle_overflow                       [684] Not implemented. Handle overflow for [2024052004221501800000000000000000000000000000000000092] escape strategy [7].
20.05.2024 04:23:35.891161000 usim_process.process_queue                         Overflow for target space id [2024052004221505600000000000000000000000000000000000093] with energy [-4.483747297141575436112009892656579437] and current target energy [-6.12856360707936589390120286350550099772]. Set energy to 0.
20.05.2024 04:23:35.925788000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:35.942543000 usim_creator.handle_overflow                       [684] Not implemented. Handle overflow for [2024052004221505600000000000000000000000000000000000093] escape strategy [7].
20.05.2024 04:23:36.292822000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [3.16941402825556095841623601698441153627] and current target energy [6.92490300897122166450310157504261509587]. Set energy to 0.
20.05.2024 04:23:36.312020000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:36.313198000 usim_creator.handle_overflow                       [685] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:23:36.325975000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-3.16941402825556095841623601698441153627] and current target energy [-6.92490300897122166450310157504261509587]. Set energy to 0.
20.05.2024 04:23:36.339864000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:36.341265000 usim_creator.handle_overflow                       [685] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:23:36.587110000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [.9697022900318247975046620190304812877725] and current target energy [9.28557390852751425395340656163958867883]. Set energy to 0.
20.05.2024 04:23:36.597818000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:36.598555000 usim_creator.handle_overflow                       [686] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:23:36.605241000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [.9697022900318247975046620190304812877725] and current target energy [9.28557390852751425395340656163958867883]. Set energy to 0.
20.05.2024 04:23:36.614264000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:36.615733000 usim_creator.handle_overflow                       [686] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:23:36.622485000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-.9697022900318247975046620190304812877725] and current target energy [-9.28557390852751425395340656163958867883]. Set energy to 0.
20.05.2024 04:23:36.632776000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:36.633841000 usim_creator.handle_overflow                       [686] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:23:36.634519000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-.9697022900318247975046620190304812877725] and current target energy [-9.28557390852751425395340656163958867883]. Set energy to 0.
20.05.2024 04:23:36.644969000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:36.655401000 usim_creator.handle_overflow                       [686] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:23:36.669123000 usim_process.process_queue                         Overflow for target space id [2024052004211700300000000000000000000000000000000000062] with energy [.9652244200217300050075661901723959936138] and current target energy [9.68934671368933164345517134607457922766]. Set energy to 0.
20.05.2024 04:23:36.696510000 usim_creator.handle_overflow                       [686] Not implemented. Handle overflow for [2024052004211700300000000000000000000000000000000000062] escape strategy [0].
20.05.2024 04:23:36.709539000 usim_process.process_queue                         Overflow for target space id [2024052004211706000000000000000000000000000000000000063] with energy [.9652244200217300050075661901723959936138] and current target energy [9.68934671368933164345517134607457922766]. Set energy to 0.
20.05.2024 04:23:36.728186000 usim_creator.handle_overflow                       [686] Not implemented. Handle overflow for [2024052004211706000000000000000000000000000000000000063] escape strategy [0].
20.05.2024 04:23:36.736622000 usim_process.process_queue                         Overflow for target space id [2024052004211711600000000000000000000000000000000000064] with energy [-.9652244200217300050075661901723959936138] and current target energy [-9.68934671368933164345517134607457922766]. Set energy to 0.
20.05.2024 04:23:36.755127000 usim_creator.handle_overflow                       [686] Not implemented. Handle overflow for [2024052004211711600000000000000000000000000000000000064] escape strategy [0].
20.05.2024 04:23:36.771537000 usim_process.process_queue                         Overflow for target space id [2024052004211716600000000000000000000000000000000000065] with energy [-.9652244200217300050075661901723959936138] and current target energy [-9.68934671368933164345517134607457922766]. Set energy to 0.
20.05.2024 04:23:36.791691000 usim_creator.handle_overflow                       [686] Not implemented. Handle overflow for [2024052004211716600000000000000000000000000000000000065] escape strategy [0].
20.05.2024 04:23:37.075658000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [2.3633303245358566687866000763129191228] and current target energy [9.45332129814342667514640030525167649117]. Set energy to 0.
20.05.2024 04:23:37.104934000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:37.108188000 usim_creator.handle_overflow                       [687] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:23:37.127350000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-2.3633303245358566687866000763129191228] and current target energy [-9.45332129814342667514640030525167649117]. Set energy to 0.
20.05.2024 04:23:37.148060000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:37.153280000 usim_creator.handle_overflow                       [687] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:23:38.144665000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.6196131788743715116389480347042054612788] and current target energy [9.85442839678761193777987148296158518614]. Set energy to 0.
20.05.2024 04:23:38.167712000 usim_creator.handle_overflow                       [691] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:23:38.185850000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.6196131788743715116389480347042054612788] and current target energy [-9.85442839678761193777987148296158518614]. Set energy to 0.
20.05.2024 04:23:38.209683000 usim_creator.handle_overflow                       [691] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:23:38.230497000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [4.04301130707825141327065086210122389402] and current target energy [6.48300172020489531797568426120170945084]. Set energy to 0.
20.05.2024 04:23:38.248200000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:38.248985000 usim_creator.handle_overflow                       [691] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:23:38.273509000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-4.04301130707825141327065086210122389402] and current target energy [-6.48300172020489531797568426120170945084]. Set energy to 0.
20.05.2024 04:23:38.296540000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:38.311767000 usim_creator.handle_overflow                       [691] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:23:38.878746000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [3.09862006226967271906857413149270360021] and current target energy [8.08602261415650282654130172420244778804]. Set energy to 0.
20.05.2024 04:23:38.887954000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:38.888712000 usim_creator.handle_overflow                       [694] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:23:38.895374000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-3.09862006226967271906857413149270360021] and current target energy [-8.08602261415650282654130172420244778804]. Set energy to 0.
20.05.2024 04:23:38.903458000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:38.904551000 usim_creator.handle_overflow                       [694] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:23:39.203256000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [3.09862006226967271906857413149270360021] and current target energy [7.5499584950246357087208369323692213382]. Set energy to 0.
20.05.2024 04:23:39.218175000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:39.219514000 usim_creator.handle_overflow                       [696] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:23:39.224520000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-3.09862006226967271906857413149270360021] and current target energy [-7.5499584950246357087208369323692213382]. Set energy to 0.
20.05.2024 04:23:39.232365000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:39.234593000 usim_creator.handle_overflow                       [696] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:23:39.608184000 usim_process.process_queue                         Overflow for target space id [2024052004205701200000000000000000000000000000000000015] with energy [1.20775008716548265960225906463564045701] and current target energy [9.65993630722308871731223137048686049857]. Set energy to 0.
20.05.2024 04:23:39.632104000 usim_creator.handle_overflow                       [697] Not implemented. Handle overflow for [2024052004205701200000000000000000000000000000000000015] escape strategy [0].
20.05.2024 04:23:39.651104000 usim_process.process_queue                         Overflow for target space id [2024052004205702800000000000000000000000000000000000017] with energy [1.20775008716548265960225906463564045701] and current target energy [9.65993630722308871731223137048686049857]. Set energy to 0.
20.05.2024 04:23:39.665580000 usim_creator.handle_overflow                       [697] Not implemented. Handle overflow for [2024052004205702800000000000000000000000000000000000017] escape strategy [0].
20.05.2024 04:23:39.669267000 usim_process.process_queue                         Overflow for target space id [2024052004205711900000000000000000000000000000000000019] with energy [-1.20775008716548265960225906463564045701] and current target energy [-9.65993630722308871731223137048686049857]. Set energy to 0.
20.05.2024 04:23:39.691869000 usim_creator.handle_overflow                       [697] Not implemented. Handle overflow for [2024052004205711900000000000000000000000000000000000019] escape strategy [0].
20.05.2024 04:23:39.695647000 usim_process.process_queue                         Overflow for target space id [2024052004205716200000000000000000000000000000000000021] with energy [-1.20775008716548265960225906463564045701] and current target energy [-9.65993630722308871731223137048686049857]. Set energy to 0.
20.05.2024 04:23:39.712589000 usim_creator.handle_overflow                       [697] Not implemented. Handle overflow for [2024052004205716200000000000000000000000000000000000021] escape strategy [0].
20.05.2024 04:23:39.738251000 usim_process.process_queue                         Overflow for target space id [2024052004213975700000000000000000000000000000000000082] with energy [1.48056103824980396003591290229175707109] and current target energy [9.08948004195539551090559297400625953709]. Set energy to 0.
20.05.2024 04:23:39.757495000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:39.758104000 usim_creator.handle_overflow                       [697] Not implemented. Handle overflow for [2024052004213975700000000000000000000000000000000000082] escape strategy [7].
20.05.2024 04:23:39.767513000 usim_process.process_queue                         Overflow for target space id [2024052004213980000000000000000000000000000000000000083] with energy [1.48056103824980396003591290229175707109] and current target energy [9.08948004195539551090559297400625953709]. Set energy to 0.
20.05.2024 04:23:39.792091000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:39.793992000 usim_creator.handle_overflow                       [697] Not implemented. Handle overflow for [2024052004213980000000000000000000000000000000000000083] escape strategy [7].
20.05.2024 04:23:39.814175000 usim_process.process_queue                         Overflow for target space id [2024052004213983100000000000000000000000000000000000084] with energy [-1.48056103824980396003591290229175707109] and current target energy [-9.08948004195539551090559297400625953709]. Set energy to 0.
20.05.2024 04:23:39.836573000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:39.838963000 usim_creator.handle_overflow                       [697] Not implemented. Handle overflow for [2024052004213983100000000000000000000000000000000000084] escape strategy [7].
20.05.2024 04:23:39.861054000 usim_process.process_queue                         Overflow for target space id [2024052004213986900000000000000000000000000000000000085] with energy [-1.48056103824980396003591290229175707109] and current target energy [-9.08948004195539551090559297400625953709]. Set energy to 0.
20.05.2024 04:23:39.877319000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:39.879026000 usim_creator.handle_overflow                       [697] Not implemented. Handle overflow for [2024052004213986900000000000000000000000000000000000085] escape strategy [7].
20.05.2024 04:23:41.114624000 usim_process.process_queue                         Overflow for target space id [2024052004211134000000000000000000000000000000000000052] with energy [.8064122268619101341032714153451216911213] and current target energy [9.75562383406318533259229472886744645145]. Set energy to 0.
20.05.2024 04:23:41.138547000 usim_creator.handle_overflow                       [702] Not implemented. Handle overflow for [2024052004211134000000000000000000000000000000000000052] escape strategy [0].
20.05.2024 04:23:41.146357000 usim_process.process_queue                         Overflow for target space id [2024052004211138700000000000000000000000000000000000053] with energy [.8064122268619101341032714153451216911213] and current target energy [9.75562383406318533259229472886744645145]. Set energy to 0.
20.05.2024 04:23:41.157495000 usim_creator.handle_overflow                       [702] Not implemented. Handle overflow for [2024052004211138700000000000000000000000000000000000053] escape strategy [0].
20.05.2024 04:23:41.162934000 usim_process.process_queue                         Overflow for target space id [2024052004211143900000000000000000000000000000000000054] with energy [-.8064122268619101341032714153451216911213] and current target energy [-9.75562383406318533259229472886744645145]. Set energy to 0.
20.05.2024 04:23:41.170927000 usim_creator.handle_overflow                       [702] Not implemented. Handle overflow for [2024052004211143900000000000000000000000000000000000054] escape strategy [0].
20.05.2024 04:23:41.176829000 usim_process.process_queue                         Overflow for target space id [2024052004211147900000000000000000000000000000000000055] with energy [-.8064122268619101341032714153451216911213] and current target energy [-9.75562383406318533259229472886744645145]. Set energy to 0.
20.05.2024 04:23:41.184739000 usim_creator.handle_overflow                       [702] Not implemented. Handle overflow for [2024052004211147900000000000000000000000000000000000055] escape strategy [0].
20.05.2024 04:23:42.325939000 usim_process.process_queue                         Overflow for target space id [2024052004205948300000000000000000000000000000000000024] with energy [1.09140720478145839439341592193168061338] and current target energy [9.74913380060306977064229958446540254904]. Set energy to 0.
20.05.2024 04:23:42.341388000 usim_creator.handle_overflow                       [706] Not implemented. Handle overflow for [2024052004205948300000000000000000000000000000000000024] escape strategy [0].
20.05.2024 04:23:42.344405000 usim_process.process_queue                         Overflow for target space id [2024052004205949500000000000000000000000000000000000025] with energy [1.09140720478145839439341592193168061338] and current target energy [9.74913380060306977064229958446540254904]. Set energy to 0.
20.05.2024 04:23:42.353282000 usim_creator.handle_overflow                       [706] Not implemented. Handle overflow for [2024052004205949500000000000000000000000000000000000025] escape strategy [0].
20.05.2024 04:23:42.356259000 usim_process.process_queue                         Overflow for target space id [2024052004205950700000000000000000000000000000000000026] with energy [-1.09140720478145839439341592193168061338] and current target energy [-9.74913380060306977064229958446540254904]. Set energy to 0.
20.05.2024 04:23:42.397288000 usim_creator.handle_overflow                       [706] Not implemented. Handle overflow for [2024052004205950700000000000000000000000000000000000026] escape strategy [0].
20.05.2024 04:23:42.400976000 usim_process.process_queue                         Overflow for target space id [2024052004205952100000000000000000000000000000000000027] with energy [-1.09140720478145839439341592193168061338] and current target energy [-9.74913380060306977064229958446540254904]. Set energy to 0.
20.05.2024 04:23:42.413101000 usim_creator.handle_overflow                       [706] Not implemented. Handle overflow for [2024052004205952100000000000000000000000000000000000027] escape strategy [0].
20.05.2024 04:23:42.678757000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [3.07968822888522480866634853554701407592] and current target energy [9.20379756538195551803251746213718826005]. Set energy to 0.
20.05.2024 04:23:42.696717000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:42.716509000 usim_creator.handle_overflow                       [707] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:23:42.732218000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-3.07968822888522480866634853554701407592] and current target energy [-9.20379756538195551803251746213718826005]. Set energy to 0.
20.05.2024 04:23:42.751350000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:42.760950000 usim_creator.handle_overflow                       [707] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:23:43.271212000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [4.53086390824924852189090745216141038921] and current target energy [5.80470271745609485289823566645758525318]. Set energy to 0.
20.05.2024 04:23:43.305822000 usim_creator.handle_overflow                       [709] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:23:43.328020000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-4.53086390824924852189090745216141038921] and current target energy [-5.80470271745609485289823566645758525318]. Set energy to 0.
20.05.2024 04:23:43.347784000 usim_creator.handle_overflow                       [709] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:23:44.276132000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [1.82000950341644715109249862393438327145] and current target energy [9.06172781649849704378181490432282077842]. Set energy to 0.
20.05.2024 04:23:44.303895000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:44.304240000 usim_creator.handle_overflow                       [712] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:23:44.318076000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-1.82000950341644715109249862393438327145] and current target energy [-9.06172781649849704378181490432282077842]. Set energy to 0.
20.05.2024 04:23:44.336087000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:44.343530000 usim_creator.handle_overflow                       [712] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:23:44.377708000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [1.82000950341644715109249862393438327145] and current target energy [9.50386756808169987170136751826814923161]. Set energy to 0.
20.05.2024 04:23:44.399866000 usim_creator.handle_overflow                       [712] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:23:44.412106000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [1.82000950341644715109249862393438327145] and current target energy [9.50386756808169987170136751826814923161]. Set energy to 0.
20.05.2024 04:23:44.428373000 usim_creator.handle_overflow                       [712] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:23:44.432221000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-1.82000950341644715109249862393438327145] and current target energy [-9.50386756808169987170136751826814923161]. Set energy to 0.
20.05.2024 04:23:44.452269000 usim_creator.handle_overflow                       [712] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:23:44.465494000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-1.82000950341644715109249862393438327145] and current target energy [-9.50386756808169987170136751826814923161]. Set energy to 0.
20.05.2024 04:23:44.487021000 usim_creator.handle_overflow                       [712] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:23:44.497438000 usim_process.process_queue                         Overflow for target space id [2024052004210570400000000000000000000000000000000000038] with energy [1.09508893968818472336715906153876215595] and current target energy [9.53760574775350684676876231037496258201]. Set energy to 0.
20.05.2024 04:23:44.522161000 usim_creator.handle_overflow                       [712] Not implemented. Handle overflow for [2024052004210570400000000000000000000000000000000000038] escape strategy [0].
20.05.2024 04:23:44.534420000 usim_process.process_queue                         Overflow for target space id [2024052004210571900000000000000000000000000000000000039] with energy [1.09508893968818472336715906153876215595] and current target energy [9.53760574775350684676876231037496258201]. Set energy to 0.
20.05.2024 04:23:44.550629000 usim_creator.handle_overflow                       [712] Not implemented. Handle overflow for [2024052004210571900000000000000000000000000000000000039] escape strategy [0].
20.05.2024 04:23:44.564476000 usim_process.process_queue                         Overflow for target space id [2024052004210573600000000000000000000000000000000000040] with energy [-1.09508893968818472336715906153876215595] and current target energy [-9.53760574775350684676876231037496258201]. Set energy to 0.
20.05.2024 04:23:44.591552000 usim_creator.handle_overflow                       [712] Not implemented. Handle overflow for [2024052004210573600000000000000000000000000000000000040] escape strategy [0].
20.05.2024 04:23:44.602574000 usim_process.process_queue                         Overflow for target space id [2024052004210575900000000000000000000000000000000000041] with energy [-1.09508893968818472336715906153876215595] and current target energy [-9.53760574775350684676876231037496258201]. Set energy to 0.
20.05.2024 04:23:44.630207000 usim_creator.handle_overflow                       [712] Not implemented. Handle overflow for [2024052004210575900000000000000000000000000000000000041] escape strategy [0].
20.05.2024 04:23:44.640485000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [4.91187528767694893575709019104399118933] and current target energy [8.25955666479847579491105449181118831563]. Set energy to 0.
20.05.2024 04:23:44.659727000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:44.661384000 usim_creator.handle_overflow                       [712] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:23:44.680023000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-4.91187528767694893575709019104399118933] and current target energy [-8.25955666479847579491105449181118831563]. Set energy to 0.
20.05.2024 04:23:44.694533000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:44.695894000 usim_creator.handle_overflow                       [712] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:23:45.658627000 usim_process.process_queue                         Overflow for target space id [2024052004223175000000000000000000000000000000000000094] with energy [4.52400919871958087916533049328994321702] and current target energy [9.63936469691967623089536585765641002283]. Set energy to 0.
20.05.2024 04:23:45.686955000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:45.689127000 usim_creator.handle_overflow                       [715] Not implemented. Handle overflow for [2024052004223175000000000000000000000000000000000000094] escape strategy [7].
20.05.2024 04:23:45.695314000 usim_process.process_queue                         Overflow for target space id [2024052004223178700000000000000000000000000000000000095] with energy [-4.52400919871958087916533049328994321702] and current target energy [-9.63936469691967623089536585765641002283]. Set energy to 0.
20.05.2024 04:23:45.718624000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:45.719958000 usim_creator.handle_overflow                       [715] Not implemented. Handle overflow for [2024052004223178700000000000000000000000000000000000095] escape strategy [7].
20.05.2024 04:23:45.955484000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [1.82000950341644715109249862393438327145] and current target energy [9.10004751708223575546249311967191635725]. Set energy to 0.
20.05.2024 04:23:45.965985000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:45.966681000 usim_creator.handle_overflow                       [716] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:23:45.973465000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [1.82000950341644715109249862393438327145] and current target energy [9.10004751708223575546249311967191635725]. Set energy to 0.
20.05.2024 04:23:45.982921000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:45.983641000 usim_creator.handle_overflow                       [716] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:23:45.988820000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-1.82000950341644715109249862393438327145] and current target energy [-9.10004751708223575546249311967191635725]. Set energy to 0.
20.05.2024 04:23:45.999588000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:46.000067000 usim_creator.handle_overflow                       [716] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:23:46.003113000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-1.82000950341644715109249862393438327145] and current target energy [-9.10004751708223575546249311967191635725]. Set energy to 0.
20.05.2024 04:23:46.013342000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:46.014322000 usim_creator.handle_overflow                       [716] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:23:46.228483000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [4.52400919871958087916533049328994321702] and current target energy [5.76919168741254585108057182613035824989]. Set energy to 0.
20.05.2024 04:23:46.239282000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:46.240006000 usim_creator.handle_overflow                       [717] Not implemented. Handle overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [7].
20.05.2024 04:23:46.246947000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-4.52400919871958087916533049328994321702] and current target energy [-5.76919168741254585108057182613035824989]. Set energy to 0.
20.05.2024 04:23:46.255148000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:46.255611000 usim_creator.handle_overflow                       [717] Not implemented. Handle overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [7].
20.05.2024 04:23:47.051527000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [4.91187528767694893575709019104399118933] and current target energy [8.79474379782736182092703256788409266131]. Set energy to 0.
20.05.2024 04:23:47.068692000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:47.070274000 usim_creator.handle_overflow                       [720] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:23:47.075227000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-4.91187528767694893575709019104399118933] and current target energy [-8.79474379782736182092703256788409266131]. Set energy to 0.
20.05.2024 04:23:47.084553000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:47.085642000 usim_creator.handle_overflow                       [720] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:23:47.355488000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [1.76612782029921219070905002192137253016] and current target energy [8.448693002807670436471087247133990668]. Set energy to 0.
20.05.2024 04:23:47.379969000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:47.381160000 usim_creator.handle_overflow                       [721] Not implemented. Handle overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [7].
20.05.2024 04:23:47.396358000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [1.76612782029921219070905002192137253016] and current target energy [8.448693002807670436471087247133990668]. Set energy to 0.
20.05.2024 04:23:47.411925000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:47.413616000 usim_creator.handle_overflow                       [721] Not implemented. Handle overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [7].
20.05.2024 04:23:47.438962000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-1.76612782029921219070905002192137253016] and current target energy [-8.448693002807670436471087247133990668]. Set energy to 0.
20.05.2024 04:23:47.460715000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:47.463852000 usim_creator.handle_overflow                       [721] Not implemented. Handle overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [7].
20.05.2024 04:23:47.479712000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-1.76612782029921219070905002192137253016] and current target energy [-8.448693002807670436471087247133990668]. Set energy to 0.
20.05.2024 04:23:47.495079000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:47.503870000 usim_creator.handle_overflow                       [721] Not implemented. Handle overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [7].
20.05.2024 04:23:48.122637000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [2.35180656641855887696106508749116826982] and current target energy [9.37085993790954698003224104911673183448]. Set energy to 0.
20.05.2024 04:23:48.147560000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:48.148930000 usim_creator.handle_overflow                       [723] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:23:48.170501000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [2.35180656641855887696106508749116826982] and current target energy [9.37085993790954698003224104911673183448]. Set energy to 0.
20.05.2024 04:23:48.190880000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:48.192212000 usim_creator.handle_overflow                       [723] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:23:48.218034000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-2.35180656641855887696106508749116826982] and current target energy [-9.37085993790954698003224104911673183448]. Set energy to 0.
20.05.2024 04:23:48.233216000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:48.235128000 usim_creator.handle_overflow                       [723] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:23:48.254467000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-2.35180656641855887696106508749116826982] and current target energy [-9.37085993790954698003224104911673183448]. Set energy to 0.
20.05.2024 04:23:48.274824000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:48.276039000 usim_creator.handle_overflow                       [723] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:23:48.304133000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [4.66842892509512782456817091695669666642] and current target energy [6.97670754305059042642285362866088171394]. Set energy to 0.
20.05.2024 04:23:48.328989000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:48.330223000 usim_creator.handle_overflow                       [723] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:23:48.345065000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-4.66842892509512782456817091695669666642] and current target energy [-6.97670754305059042642285362866088171394]. Set energy to 0.
20.05.2024 04:23:48.369465000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:48.375273000 usim_creator.handle_overflow                       [723] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:23:49.020788000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.00468701331587273290235538261278034966] and current target energy [9.87759356472319238343159809045525519715]. Set energy to 0.
20.05.2024 04:23:49.064890000 usim_creator.handle_overflow                       [725] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:23:49.076701000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.00468701331587273290235538261278034966] and current target energy [-9.87759356472319238343159809045525519715]. Set energy to 0.
20.05.2024 04:23:49.090258000 usim_creator.handle_overflow                       [725] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:23:49.405104000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [4.25527608205860568208142294965982983128] and current target energy [9.33685785019025564913634183391339333283]. Set energy to 0.
20.05.2024 04:23:49.428627000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:49.429826000 usim_creator.handle_overflow                       [726] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:23:49.446476000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-4.25527608205860568208142294965982983128] and current target energy [-9.33685785019025564913634183391339333283]. Set energy to 0.
20.05.2024 04:23:49.470781000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:49.477376000 usim_creator.handle_overflow                       [726] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:23:50.005263000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.25527608205860568208142294965982983128] and current target energy [9.35259074615301514130827815512198357778]. Set energy to 0.
20.05.2024 04:23:50.030553000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:50.035767000 usim_creator.handle_overflow                       [728] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:23:50.046368000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.25527608205860568208142294965982983128] and current target energy [-9.35259074615301514130827815512198357778]. Set energy to 0.
20.05.2024 04:23:50.065697000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:50.066958000 usim_creator.handle_overflow                       [728] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:23:50.120050000 usim_process.process_queue                         Overflow for target space id [2024052004221501800000000000000000000000000000000000092] with energy [1.22796882191923723393927254776099779734] and current target energy [9.04801839743916175833066098657988643404]. Set energy to 0.
20.05.2024 04:23:50.136351000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:50.139651000 usim_creator.handle_overflow                       [728] Not implemented. Handle overflow for [2024052004221501800000000000000000000000000000000000092] escape strategy [7].
20.05.2024 04:23:50.147876000 usim_process.process_queue                         Overflow for target space id [2024052004221505600000000000000000000000000000000000093] with energy [-1.22796882191923723393927254776099779734] and current target energy [-9.04801839743916175833066098657988643404]. Set energy to 0.
20.05.2024 04:23:50.165357000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:50.169149000 usim_creator.handle_overflow                       [728] Not implemented. Handle overflow for [2024052004221505600000000000000000000000000000000000093] escape strategy [7].
20.05.2024 04:23:50.686092000 usim_process.process_queue                         Overflow for target space id [2024052004211990800000000000000000000000000000000000070] with energy [1.68547116862528993986281046601527960352] and current target energy [8.47134022440617166064248134503958738333]. Set energy to 0.
20.05.2024 04:23:50.708011000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:50.712748000 usim_creator.handle_overflow                       [730] Not implemented. Handle overflow for [2024052004211990800000000000000000000000000000000000070] escape strategy [7].
20.05.2024 04:23:50.723691000 usim_process.process_queue                         Overflow for target space id [2024052004211994200000000000000000000000000000000000071] with energy [1.68547116862528993986281046601527960352] and current target energy [8.47134022440617166064248134503958738333]. Set energy to 0.
20.05.2024 04:23:50.738415000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:50.740183000 usim_creator.handle_overflow                       [730] Not implemented. Handle overflow for [2024052004211994200000000000000000000000000000000000071] escape strategy [7].
20.05.2024 04:23:50.754272000 usim_process.process_queue                         Overflow for target space id [2024052004211998600000000000000000000000000000000000072] with energy [-1.68547116862528993986281046601527960352] and current target energy [-8.47134022440617166064248134503958738333]. Set energy to 0.
20.05.2024 04:23:50.771085000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:50.772411000 usim_creator.handle_overflow                       [730] Not implemented. Handle overflow for [2024052004211998600000000000000000000000000000000000072] escape strategy [7].
20.05.2024 04:23:50.787810000 usim_process.process_queue                         Overflow for target space id [2024052004212000300000000000000000000000000000000000073] with energy [-1.68547116862528993986281046601527960352] and current target energy [-8.47134022440617166064248134503958738333]. Set energy to 0.
20.05.2024 04:23:50.803776000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:50.804891000 usim_creator.handle_overflow                       [730] Not implemented. Handle overflow for [2024052004212000300000000000000000000000000000000000073] escape strategy [7].
20.05.2024 04:23:51.424723000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [.60988700428907806335534996765524623296] and current target energy [9.75819206862524901368559948248393972737]. Set energy to 0.
20.05.2024 04:23:51.462464000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:51.464491000 usim_creator.handle_overflow                       [732] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:23:51.482197000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [.60988700428907806335534996765524623296] and current target energy [9.75819206862524901368559948248393972737]. Set energy to 0.
20.05.2024 04:23:51.514878000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:51.534648000 usim_creator.handle_overflow                       [732] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:23:51.555034000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-.60988700428907806335534996765524623296] and current target energy [-9.75819206862524901368559948248393972737]. Set energy to 0.
20.05.2024 04:23:51.577564000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:51.583367000 usim_creator.handle_overflow                       [732] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:23:51.588883000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-.60988700428907806335534996765524623296] and current target energy [-9.75819206862524901368559948248393972737]. Set energy to 0.
20.05.2024 04:23:51.607932000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:51.609339000 usim_creator.handle_overflow                       [732] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:23:52.029057000 usim_process.process_queue                         Overflow for target space id [2024052004211868000000000000000000000000000000000000066] with energy [.5955478567687793972604988455360891917875] and current target energy [9.57856645837801321611416771183327137466]. Set energy to 0.
20.05.2024 04:23:52.068600000 usim_creator.handle_overflow                       [733] Not implemented. Handle overflow for [2024052004211868000000000000000000000000000000000000066] escape strategy [0].
20.05.2024 04:23:52.085910000 usim_process.process_queue                         Overflow for target space id [2024052004211870600000000000000000000000000000000000067] with energy [.5955478567687793972604988455360891917875] and current target energy [9.57856645837801321611416771183327137466]. Set energy to 0.
20.05.2024 04:23:52.113236000 usim_creator.handle_overflow                       [733] Not implemented. Handle overflow for [2024052004211870600000000000000000000000000000000000067] escape strategy [0].
20.05.2024 04:23:52.129475000 usim_process.process_queue                         Overflow for target space id [2024052004211874300000000000000000000000000000000000068] with energy [-.5955478567687793972604988455360891917875] and current target energy [-9.57856645837801321611416771183327137466]. Set energy to 0.
20.05.2024 04:23:52.150840000 usim_creator.handle_overflow                       [733] Not implemented. Handle overflow for [2024052004211874300000000000000000000000000000000000068] escape strategy [0].
20.05.2024 04:23:52.166816000 usim_process.process_queue                         Overflow for target space id [2024052004211878000000000000000000000000000000000000069] with energy [-.5955478567687793972604988455360891917875] and current target energy [-9.57856645837801321611416771183327137466]. Set energy to 0.
20.05.2024 04:23:52.186902000 usim_creator.handle_overflow                       [733] Not implemented. Handle overflow for [2024052004211878000000000000000000000000000000000000069] escape strategy [0].
20.05.2024 04:23:52.206015000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [3.06992205479809308484818136940249449334] and current target energy [9.82375057535389787151418038208798237865]. Set energy to 0.
20.05.2024 04:23:52.230755000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:52.235113000 usim_creator.handle_overflow                       [733] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:23:52.253249000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-3.06992205479809308484818136940249449334] and current target energy [-9.82375057535389787151418038208798237865]. Set energy to 0.
20.05.2024 04:23:52.276619000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:52.278051000 usim_creator.handle_overflow                       [733] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:23:53.069518000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [2.47066350370407857736010346154999101121] and current target energy [8.53440233520019643195797545178339535063]. Set energy to 0.
20.05.2024 04:23:53.085277000 usim_creator.handle_overflow                       [736] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:23:53.096067000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [2.47066350370407857736010346154999101121] and current target energy [8.53440233520019643195797545178339535063]. Set energy to 0.
20.05.2024 04:23:53.113768000 usim_creator.handle_overflow                       [736] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:23:53.117640000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-2.47066350370407857736010346154999101121] and current target energy [-8.53440233520019643195797545178339535063]. Set energy to 0.
20.05.2024 04:23:53.135029000 usim_creator.handle_overflow                       [736] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:23:53.142774000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-2.47066350370407857736010346154999101121] and current target energy [-8.53440233520019643195797545178339535063]. Set energy to 0.
20.05.2024 04:23:53.157989000 usim_creator.handle_overflow                       [736] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:23:53.429703000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.1092705384678270441657171785943810072] and current target energy [8.28592929772802348756597583246935853523]. Set energy to 0.
20.05.2024 04:23:53.454891000 usim_creator.handle_overflow                       [737] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:23:53.462072000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.1092705384678270441657171785943810072] and current target energy [-8.28592929772802348756597583246935853523]. Set energy to 0.
20.05.2024 04:23:53.475279000 usim_creator.handle_overflow                       [737] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:23:53.496972000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [2.65954755128662855130088934353739364455] and current target energy [8.51055216411721136416284589931965966255]. Set energy to 0.
20.05.2024 04:23:53.512155000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:53.512748000 usim_creator.handle_overflow                       [737] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:23:53.523252000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-2.65954755128662855130088934353739364455] and current target energy [-8.51055216411721136416284589931965966255]. Set energy to 0.
20.05.2024 04:23:53.537175000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:53.538323000 usim_creator.handle_overflow                       [737] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:23:55.486679000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.03973256519470221771554085784927443839] and current target energy [9.68826675707473029350205996984710674231]. Set energy to 0.
20.05.2024 04:23:55.506618000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:55.516629000 usim_creator.handle_overflow                       [744] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:23:55.524603000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.03973256519470221771554085784927443839] and current target energy [9.68826675707473029350205996984710674231]. Set energy to 0.
20.05.2024 04:23:55.546599000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:55.547764000 usim_creator.handle_overflow                       [744] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:23:55.550805000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.03973256519470221771554085784927443839] and current target energy [-9.68826675707473029350205996984710674231]. Set energy to 0.
20.05.2024 04:23:55.569253000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:55.572843000 usim_creator.handle_overflow                       [744] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:23:55.587416000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.03973256519470221771554085784927443839] and current target energy [-9.68826675707473029350205996984710674231]. Set energy to 0.
20.05.2024 04:23:55.606799000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:55.607425000 usim_creator.handle_overflow                       [744] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:23:55.984650000 usim_process.process_queue                         Overflow for target space id [2024052004210261400000000000000000000000000000000000034] with energy [.5462935267623016866570252108038764495963] and current target energy [9.72207996198189276671754611542843030075]. Set energy to 0.
20.05.2024 04:23:56.009305000 usim_creator.handle_overflow                       [745] Not implemented. Handle overflow for [2024052004210261400000000000000000000000000000000000034] escape strategy [0].
20.05.2024 04:23:56.018047000 usim_process.process_queue                         Overflow for target space id [2024052004210264800000000000000000000000000000000000035] with energy [.5462935267623016866570252108038764495963] and current target energy [9.72207996198189276671754611542843030075]. Set energy to 0.
20.05.2024 04:23:56.036461000 usim_creator.handle_overflow                       [745] Not implemented. Handle overflow for [2024052004210264800000000000000000000000000000000000035] escape strategy [0].
20.05.2024 04:23:56.043185000 usim_process.process_queue                         Overflow for target space id [2024052004210269400000000000000000000000000000000000036] with energy [-.5462935267623016866570252108038764495963] and current target energy [-9.72207996198189276671754611542843030075]. Set energy to 0.
20.05.2024 04:23:56.063032000 usim_creator.handle_overflow                       [745] Not implemented. Handle overflow for [2024052004210269400000000000000000000000000000000000036] escape strategy [0].
20.05.2024 04:23:56.075443000 usim_process.process_queue                         Overflow for target space id [2024052004210273800000000000000000000000000000000000037] with energy [-.5462935267623016866570252108038764495963] and current target energy [-9.72207996198189276671754611542843030075]. Set energy to 0.
20.05.2024 04:23:56.092348000 usim_creator.handle_overflow                       [745] Not implemented. Handle overflow for [2024052004210273800000000000000000000000000000000000037] escape strategy [0].
20.05.2024 04:23:56.648642000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [3.75283048102474781909229063231828978241] and current target energy [6.97848924731580081040333890690809084619]. Set energy to 0.
20.05.2024 04:23:56.687928000 usim_creator.handle_overflow                       [747] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:23:56.701989000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-3.75283048102474781909229063231828978241] and current target energy [-6.97848924731580081040333890690809084619]. Set energy to 0.
20.05.2024 04:23:56.720329000 usim_creator.handle_overflow                       [747] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:23:57.684298000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [3.83536181226121965472836715036506030419] and current target energy [6.77684642588105382151031445768762116625]. Set energy to 0.
20.05.2024 04:23:57.700584000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:57.701848000 usim_creator.handle_overflow                       [750] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:23:57.713499000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-3.83536181226121965472836715036506030419] and current target energy [-6.77684642588105382151031445768762116625]. Set energy to 0.
20.05.2024 04:23:57.729617000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:57.735061000 usim_creator.handle_overflow                       [750] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:23:57.958676000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.90422055608118274979844340692937202416] and current target energy [7.74336026732617750531016452279291801282]. Set energy to 0.
20.05.2024 04:23:57.976150000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:57.980282000 usim_creator.handle_overflow                       [751] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:23:57.987912000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.90422055608118274979844340692937202416] and current target energy [-7.74336026732617750531016452279291801282]. Set energy to 0.
20.05.2024 04:23:58.004588000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:58.005761000 usim_creator.handle_overflow                       [751] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:23:58.366368000 usim_process.process_queue                         Overflow for target space id [2024052004221223900000000000000000000000000000000000088] with energy [2.49169292125382700894990432782234527703] and current target energy [8.33001100759929494689642591388168727563]. Set energy to 0.
20.05.2024 04:23:58.385413000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:58.391987000 usim_creator.handle_overflow                       [752] Not implemented. Handle overflow for [2024052004221223900000000000000000000000000000000000088] escape strategy [7].
20.05.2024 04:23:58.396771000 usim_process.process_queue                         Overflow for target space id [2024052004221227000000000000000000000000000000000000089] with energy [2.49169292125382700894990432782234527703] and current target energy [8.33001100759929494689642591388168727563]. Set energy to 0.
20.05.2024 04:23:58.411428000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:58.413081000 usim_creator.handle_overflow                       [752] Not implemented. Handle overflow for [2024052004221227000000000000000000000000000000000000089] escape strategy [7].
20.05.2024 04:23:58.418304000 usim_process.process_queue                         Overflow for target space id [2024052004221231900000000000000000000000000000000000090] with energy [-2.49169292125382700894990432782234527703] and current target energy [-8.33001100759929494689642591388168727563]. Set energy to 0.
20.05.2024 04:23:58.435974000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:58.437142000 usim_creator.handle_overflow                       [752] Not implemented. Handle overflow for [2024052004221231900000000000000000000000000000000000090] escape strategy [7].
20.05.2024 04:23:58.450707000 usim_process.process_queue                         Overflow for target space id [2024052004221235100000000000000000000000000000000000091] with energy [-2.49169292125382700894990432782234527703] and current target energy [-8.33001100759929494689642591388168727563]. Set energy to 0.
20.05.2024 04:23:58.473015000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:58.473683000 usim_creator.handle_overflow                       [752] Not implemented. Handle overflow for [2024052004221235100000000000000000000000000000000000091] escape strategy [7].
20.05.2024 04:23:59.056656000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [3.34426216049555517202324652413381894277] and current target energy [9.80844111216236549959688681385874404832]. Set energy to 0.
20.05.2024 04:23:59.085610000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:59.086758000 usim_creator.handle_overflow                       [754] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:23:59.096984000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-3.34426216049555517202324652413381894277] and current target energy [-9.80844111216236549959688681385874404832]. Set energy to 0.
20.05.2024 04:23:59.111803000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:59.112982000 usim_creator.handle_overflow                       [754] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:23:59.686567000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [2.87762272735603475640187754844858758422] and current target energy [7.84931729365956815915433147250851540217]. Set energy to 0.
20.05.2024 04:23:59.719832000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:59.721024000 usim_creator.handle_overflow                       [756] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:23:59.731550000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-2.87762272735603475640187754844858758422] and current target energy [-7.84931729365956815915433147250851540217]. Set energy to 0.
20.05.2024 04:23:59.747977000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:23:59.754306000 usim_creator.handle_overflow                       [756] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:24:00.088226000 usim_process.process_queue                         Overflow for target space id [2024052004211570000000000000000000000000000000000000058] with energy [.795862809941858964931111390461939133205] and current target energy [9.21895155146047267595429389707496372221]. Set energy to 0.
20.05.2024 04:24:00.105096000 usim_creator.handle_overflow                       [757] Not implemented. Handle overflow for [2024052004211570000000000000000000000000000000000000058] escape strategy [0].
20.05.2024 04:24:00.112646000 usim_process.process_queue                         Overflow for target space id [2024052004211574500000000000000000000000000000000000059] with energy [.795862809941858964931111390461939133205] and current target energy [9.21895155146047267595429389707496372221]. Set energy to 0.
20.05.2024 04:24:00.127022000 usim_creator.handle_overflow                       [757] Not implemented. Handle overflow for [2024052004211574500000000000000000000000000000000000059] escape strategy [0].
20.05.2024 04:24:00.134014000 usim_process.process_queue                         Overflow for target space id [2024052004211579500000000000000000000000000000000000060] with energy [-.795862809941858964931111390461939133205] and current target energy [-9.21895155146047267595429389707496372221]. Set energy to 0.
20.05.2024 04:24:00.148668000 usim_creator.handle_overflow                       [757] Not implemented. Handle overflow for [2024052004211579500000000000000000000000000000000000060] escape strategy [0].
20.05.2024 04:24:00.156751000 usim_process.process_queue                         Overflow for target space id [2024052004211584300000000000000000000000000000000000061] with energy [-.795862809941858964931111390461939133205] and current target energy [-9.21895155146047267595429389707496372221]. Set energy to 0.
20.05.2024 04:24:00.169265000 usim_creator.handle_overflow                       [757] Not implemented. Handle overflow for [2024052004211584300000000000000000000000000000000000061] escape strategy [0].
20.05.2024 04:24:00.198452000 usim_process.process_queue                         Overflow for target space id [2024052004213975700000000000000000000000000000000000082] with energy [.377413906007665262382160767583878971255] and current target energy [9.96677168501530803579961731128938110811]. Set energy to 0.
20.05.2024 04:24:00.231004000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:00.234520000 usim_creator.handle_overflow                       [757] Not implemented. Handle overflow for [2024052004213975700000000000000000000000000000000000082] escape strategy [7].
20.05.2024 04:24:00.253623000 usim_process.process_queue                         Overflow for target space id [2024052004213980000000000000000000000000000000000000083] with energy [.377413906007665262382160767583878971255] and current target energy [9.96677168501530803579961731128938110811]. Set energy to 0.
20.05.2024 04:24:00.269070000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:00.273394000 usim_creator.handle_overflow                       [757] Not implemented. Handle overflow for [2024052004213980000000000000000000000000000000000000083] escape strategy [7].
20.05.2024 04:24:00.283969000 usim_process.process_queue                         Overflow for target space id [2024052004213983100000000000000000000000000000000000084] with energy [-.377413906007665262382160767583878971255] and current target energy [-9.96677168501530803579961731128938110811]. Set energy to 0.
20.05.2024 04:24:00.300120000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:00.301213000 usim_creator.handle_overflow                       [757] Not implemented. Handle overflow for [2024052004213983100000000000000000000000000000000000084] escape strategy [7].
20.05.2024 04:24:00.314808000 usim_process.process_queue                         Overflow for target space id [2024052004213986900000000000000000000000000000000000085] with energy [-.377413906007665262382160767583878971255] and current target energy [-9.96677168501530803579961731128938110811]. Set energy to 0.
20.05.2024 04:24:00.329389000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:00.331063000 usim_creator.handle_overflow                       [757] Not implemented. Handle overflow for [2024052004213986900000000000000000000000000000000000085] escape strategy [7].
20.05.2024 04:24:01.136584000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.46419055442443592026002683240672082004] and current target energy [6.34627130827360465543259713583253294328]. Set energy to 0.
20.05.2024 04:24:01.157344000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:01.158467000 usim_creator.handle_overflow                       [760] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:24:01.161442000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.46419055442443592026002683240672082004] and current target energy [6.34627130827360465543259713583253294328]. Set energy to 0.
20.05.2024 04:24:01.179573000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:01.191248000 usim_creator.handle_overflow                       [760] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:24:01.198871000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.46419055442443592026002683240672082004] and current target energy [-6.34627130827360465543259713583253294328]. Set energy to 0.
20.05.2024 04:24:01.216597000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:01.217785000 usim_creator.handle_overflow                       [760] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:24:01.227851000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.46419055442443592026002683240672082004] and current target energy [-6.34627130827360465543259713583253294328]. Set energy to 0.
20.05.2024 04:24:01.246497000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:01.252093000 usim_creator.handle_overflow                       [760] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:24:01.258525000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.46419055442443592026002683240672082004] and current target energy [8.23156732935098325975724347076516916612]. Set energy to 0.
20.05.2024 04:24:01.273963000 usim_creator.handle_overflow                       [760] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:24:01.282329000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.46419055442443592026002683240672082004] and current target energy [8.23156732935098325975724347076516916612]. Set energy to 0.
20.05.2024 04:24:01.296853000 usim_creator.handle_overflow                       [760] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:24:01.306423000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.46419055442443592026002683240672082004] and current target energy [-8.23156732935098325975724347076516916612]. Set energy to 0.
20.05.2024 04:24:01.320719000 usim_creator.handle_overflow                       [760] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:24:01.330563000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.46419055442443592026002683240672082004] and current target energy [-8.23156732935098325975724347076516916612]. Set energy to 0.
20.05.2024 04:24:01.344693000 usim_creator.handle_overflow                       [760] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:24:01.677784000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.23209527721221796013001341620336041002] and current target energy [8.92838110884887184052005366481344164008]. Set energy to 0.
20.05.2024 04:24:01.706820000 usim_creator.handle_overflow                       [761] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:24:01.718341000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.23209527721221796013001341620336041002] and current target energy [-8.92838110884887184052005366481344164008]. Set energy to 0.
20.05.2024 04:24:01.731792000 usim_creator.handle_overflow                       [761] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:24:02.089900000 usim_process.process_queue                         Overflow for target space id [2024052004221501800000000000000000000000000000000000092] with energy [2.74439949101970161452202075372660913479] and current target energy [8.05541753568930576877123185272353345025]. Set energy to 0.
20.05.2024 04:24:02.111355000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:02.114710000 usim_creator.handle_overflow                       [762] Not implemented. Handle overflow for [2024052004221501800000000000000000000000000000000000092] escape strategy [7].
20.05.2024 04:24:02.122584000 usim_process.process_queue                         Overflow for target space id [2024052004221505600000000000000000000000000000000000093] with energy [-2.74439949101970161452202075372660913479] and current target energy [-8.05541753568930576877123185272353345025]. Set energy to 0.
20.05.2024 04:24:02.138711000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:02.139895000 usim_creator.handle_overflow                       [762] Not implemented. Handle overflow for [2024052004221505600000000000000000000000000000000000093] escape strategy [7].
20.05.2024 04:24:03.293309000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [3.93732393975665873876529572314794757196] and current target energy [6.52927374191989343109300511854697984065]. Set energy to 0.
20.05.2024 04:24:03.310337000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:03.313698000 usim_creator.handle_overflow                       [766] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:24:03.324288000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-3.93732393975665873876529572314794757196] and current target energy [-6.52927374191989343109300511854697984065]. Set energy to 0.
20.05.2024 04:24:03.338009000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:03.339185000 usim_creator.handle_overflow                       [766] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:24:04.811848000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [1.52518741372942313565594041056081583942] and current target energy [8.8351450119795973332744775157303290637]. Set energy to 0.
20.05.2024 04:24:04.828718000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:04.830008000 usim_creator.handle_overflow                       [771] Not implemented. Handle overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [7].
20.05.2024 04:24:04.840355000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [1.52518741372942313565594041056081583942] and current target energy [8.8351450119795973332744775157303290637]. Set energy to 0.
20.05.2024 04:24:04.855445000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:04.856967000 usim_creator.handle_overflow                       [771] Not implemented. Handle overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [7].
20.05.2024 04:24:04.873377000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-1.52518741372942313565594041056081583942] and current target energy [-8.8351450119795973332744775157303290637]. Set energy to 0.
20.05.2024 04:24:04.887393000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:04.888947000 usim_creator.handle_overflow                       [771] Not implemented. Handle overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [7].
20.05.2024 04:24:04.899430000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-1.52518741372942313565594041056081583942] and current target energy [-8.8351450119795973332744775157303290637]. Set energy to 0.
20.05.2024 04:24:04.917166000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:04.918291000 usim_creator.handle_overflow                       [771] Not implemented. Handle overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [7].
20.05.2024 04:24:05.482143000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.18979578568886071509585994726696221047] and current target energy [9.85027994953305373477607152293535961656]. Set energy to 0.
20.05.2024 04:24:05.511144000 usim_creator.handle_overflow                       [773] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:24:05.518638000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.18979578568886071509585994726696221047] and current target energy [-9.85027994953305373477607152293535961656]. Set energy to 0.
20.05.2024 04:24:05.532170000 usim_creator.handle_overflow                       [773] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:24:05.542164000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [2.41997599010297057346003177735339473973] and current target energy [9.5162615045336385399885161850624951595]. Set energy to 0.
20.05.2024 04:24:05.557320000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:05.558484000 usim_creator.handle_overflow                       [773] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:24:05.569514000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [2.41997599010297057346003177735339473973] and current target energy [9.5162615045336385399885161850624951595]. Set energy to 0.
20.05.2024 04:24:05.590486000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:05.591997000 usim_creator.handle_overflow                       [773] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:24:05.620056000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-2.41997599010297057346003177735339473973] and current target energy [-9.5162615045336385399885161850624951595]. Set energy to 0.
20.05.2024 04:24:05.649190000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:05.650797000 usim_creator.handle_overflow                       [773] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:24:05.659689000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-2.41997599010297057346003177735339473973] and current target energy [-9.5162615045336385399885161850624951595]. Set energy to 0.
20.05.2024 04:24:05.684122000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:05.685280000 usim_creator.handle_overflow                       [773] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:24:05.710822000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [4.43469188150067357677795314103471262283] and current target energy [7.24654814029416483407899640231847798805]. Set energy to 0.
20.05.2024 04:24:05.725815000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:05.726980000 usim_creator.handle_overflow                       [773] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:24:05.739806000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-4.43469188150067357677795314103471262283] and current target energy [-7.24654814029416483407899640231847798805]. Set energy to 0.
20.05.2024 04:24:05.756897000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:05.758014000 usim_creator.handle_overflow                       [773] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:24:06.634147000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [3.93732393975665873876529572314794757196] and current target energy [6.67201275196727091671237089851428172886]. Set energy to 0.
20.05.2024 04:24:06.644935000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:06.645292000 usim_creator.handle_overflow                       [776] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:24:06.648728000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-3.93732393975665873876529572314794757196] and current target energy [-6.67201275196727091671237089851428172886]. Set energy to 0.
20.05.2024 04:24:06.658760000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:06.659092000 usim_creator.handle_overflow                       [776] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:24:07.062179000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.65879121429483688731247181496023314818] and current target energy [8.26012410849631151290280274561701209324]. Set energy to 0.
20.05.2024 04:24:07.082565000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:07.083169000 usim_creator.handle_overflow                       [777] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:24:07.087834000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.65879121429483688731247181496023314818] and current target energy [-8.26012410849631151290280274561701209324]. Set energy to 0.
20.05.2024 04:24:07.102837000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:07.103323000 usim_creator.handle_overflow                       [777] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:24:07.108811000 usim_process.process_queue                         Overflow for target space id [2024052004210931900000000000000000000000000000000000044] with energy [.9235226899761903516803025849625182466763] and current target energy [9.80523214190869753528063264063885328395]. Set energy to 0.
20.05.2024 04:24:07.123477000 usim_creator.handle_overflow                       [777] Not implemented. Handle overflow for [2024052004210931900000000000000000000000000000000000044] escape strategy [0].
20.05.2024 04:24:07.129163000 usim_process.process_queue                         Overflow for target space id [2024052004210936800000000000000000000000000000000000045] with energy [.9235226899761903516803025849625182466763] and current target energy [9.80523214190869753528063264063885328395]. Set energy to 0.
20.05.2024 04:24:07.143583000 usim_creator.handle_overflow                       [777] Not implemented. Handle overflow for [2024052004210936800000000000000000000000000000000000045] escape strategy [0].
20.05.2024 04:24:07.149210000 usim_process.process_queue                         Overflow for target space id [2024052004210941800000000000000000000000000000000000046] with energy [-.9235226899761903516803025849625182466763] and current target energy [-9.80523214190869753528063264063885328395]. Set energy to 0.
20.05.2024 04:24:07.164763000 usim_creator.handle_overflow                       [777] Not implemented. Handle overflow for [2024052004210941800000000000000000000000000000000000046] escape strategy [0].
20.05.2024 04:24:07.170176000 usim_process.process_queue                         Overflow for target space id [2024052004210944800000000000000000000000000000000000047] with energy [-.9235226899761903516803025849625182466763] and current target energy [-9.80523214190869753528063264063885328395]. Set energy to 0.
20.05.2024 04:24:07.184120000 usim_creator.handle_overflow                       [777] Not implemented. Handle overflow for [2024052004210944800000000000000000000000000000000000047] escape strategy [0].
20.05.2024 04:24:08.202289000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.10836908533142130522150425490583590811] and current target energy [9.31758242858967377462494362992046629635]. Set energy to 0.
20.05.2024 04:24:08.225121000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:08.225829000 usim_creator.handle_overflow                       [780] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:24:08.231138000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.10836908533142130522150425490583590811] and current target energy [-9.31758242858967377462494362992046629635]. Set energy to 0.
20.05.2024 04:24:08.246104000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:08.247080000 usim_creator.handle_overflow                       [780] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:24:08.284047000 usim_process.process_queue                         Overflow for target space id [2024052004205948300000000000000000000000000000000000024] with energy [.7980486604351789311441974675579688565613] and current target energy [9.22614719211867388331438784591852222174]. Set energy to 0.
20.05.2024 04:24:08.302798000 usim_creator.handle_overflow                       [780] Not implemented. Handle overflow for [2024052004205948300000000000000000000000000000000000024] escape strategy [0].
20.05.2024 04:24:08.309903000 usim_process.process_queue                         Overflow for target space id [2024052004205949500000000000000000000000000000000000025] with energy [.7980486604351789311441974675579688565613] and current target energy [9.22614719211867388331438784591852222174]. Set energy to 0.
20.05.2024 04:24:08.322711000 usim_creator.handle_overflow                       [780] Not implemented. Handle overflow for [2024052004205949500000000000000000000000000000000000025] escape strategy [0].
20.05.2024 04:24:08.328077000 usim_process.process_queue                         Overflow for target space id [2024052004205950700000000000000000000000000000000000026] with energy [-.7980486604351789311441974675579688565613] and current target energy [-9.22614719211867388331438784591852222174]. Set energy to 0.
20.05.2024 04:24:08.343559000 usim_creator.handle_overflow                       [780] Not implemented. Handle overflow for [2024052004205950700000000000000000000000000000000000026] escape strategy [0].
20.05.2024 04:24:08.348855000 usim_process.process_queue                         Overflow for target space id [2024052004205952100000000000000000000000000000000000027] with energy [-.7980486604351789311441974675579688565613] and current target energy [-9.22614719211867388331438784591852222174]. Set energy to 0.
20.05.2024 04:24:08.361955000 usim_creator.handle_overflow                       [780] Not implemented. Handle overflow for [2024052004205952100000000000000000000000000000000000027] escape strategy [0].
20.05.2024 04:24:08.733121000 usim_process.process_queue                         Overflow for target space id [2024052004205701200000000000000000000000000000000000015] with energy [1.10272382816156980962209643202198661207] and current target energy [9.79603938689063018662646248275310027297]. Set energy to 0.
20.05.2024 04:24:08.750528000 usim_creator.handle_overflow                       [781] Not implemented. Handle overflow for [2024052004205701200000000000000000000000000000000000015] escape strategy [0].
20.05.2024 04:24:08.756914000 usim_process.process_queue                         Overflow for target space id [2024052004205702800000000000000000000000000000000000017] with energy [1.10272382816156980962209643202198661207] and current target energy [9.79603938689063018662646248275310027297]. Set energy to 0.
20.05.2024 04:24:08.768954000 usim_creator.handle_overflow                       [781] Not implemented. Handle overflow for [2024052004205702800000000000000000000000000000000000017] escape strategy [0].
20.05.2024 04:24:08.771973000 usim_process.process_queue                         Overflow for target space id [2024052004205711900000000000000000000000000000000000019] with energy [-1.10272382816156980962209643202198661207] and current target energy [-9.79603938689063018662646248275310027297]. Set energy to 0.
20.05.2024 04:24:08.786709000 usim_creator.handle_overflow                       [781] Not implemented. Handle overflow for [2024052004205711900000000000000000000000000000000000019] escape strategy [0].
20.05.2024 04:24:08.792110000 usim_process.process_queue                         Overflow for target space id [2024052004205716200000000000000000000000000000000000021] with energy [-1.10272382816156980962209643202198661207] and current target energy [-9.79603938689063018662646248275310027297]. Set energy to 0.
20.05.2024 04:24:08.806022000 usim_creator.handle_overflow                       [781] Not implemented. Handle overflow for [2024052004205716200000000000000000000000000000000000021] escape strategy [0].
20.05.2024 04:24:08.820730000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [4.1238822456363694992142403143601199356] and current target energy [8.80538400040485981425033579998980917824]. Set energy to 0.
20.05.2024 04:24:08.834125000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:08.834438000 usim_creator.handle_overflow                       [781] Not implemented. Handle overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [7].
20.05.2024 04:24:08.839714000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-4.1238822456363694992142403143601199356] and current target energy [-8.80538400040485981425033579998980917824]. Set energy to 0.
20.05.2024 04:24:08.863314000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:08.864624000 usim_creator.handle_overflow                       [781] Not implemented. Handle overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [7].
20.05.2024 04:24:09.559724000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.42980579719112708868230450838469514987] and current target energy [8.21673817066284261044300850981167181622]. Set energy to 0.
20.05.2024 04:24:09.579254000 usim_creator.handle_overflow                       [783] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:24:09.585004000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.42980579719112708868230450838469514987] and current target energy [-8.21673817066284261044300850981167181622]. Set energy to 0.
20.05.2024 04:24:09.599308000 usim_creator.handle_overflow                       [783] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:24:09.621462000 usim_process.process_queue                         Overflow for target space id [2024052004225249900000000000000000000000000000000000096] with energy [1.8520008950246250091972707203979018133] and current target energy [8.99351551673846450420591306399833966859]. Set energy to 0.
20.05.2024 04:24:09.638121000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:09.639618000 usim_creator.handle_overflow                       [783] Not implemented. Handle overflow for [2024052004225249900000000000000000000000000000000000096] escape strategy [7].
20.05.2024 04:24:09.645246000 usim_process.process_queue                         Overflow for target space id [2024052004225253800000000000000000000000000000000000097] with energy [1.8520008950246250091972707203979018133] and current target energy [8.99351551673846450420591306399833966859]. Set energy to 0.
20.05.2024 04:24:09.662223000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:09.663287000 usim_creator.handle_overflow                       [783] Not implemented. Handle overflow for [2024052004225253800000000000000000000000000000000000097] escape strategy [7].
20.05.2024 04:24:09.668517000 usim_process.process_queue                         Overflow for target space id [2024052004225256200000000000000000000000000000000000098] with energy [-1.8520008950246250091972707203979018133] and current target energy [-8.99351551673846450420591306399833966859]. Set energy to 0.
20.05.2024 04:24:09.688233000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:09.688776000 usim_creator.handle_overflow                       [783] Not implemented. Handle overflow for [2024052004225256200000000000000000000000000000000000098] escape strategy [7].
20.05.2024 04:24:09.694278000 usim_process.process_queue                         Overflow for target space id [2024052004225260100000000000000000000000000000000000099] with energy [-1.8520008950246250091972707203979018133] and current target energy [-8.99351551673846450420591306399833966859]. Set energy to 0.
20.05.2024 04:24:09.713636000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:09.714163000 usim_creator.handle_overflow                       [783] Not implemented. Handle overflow for [2024052004225260100000000000000000000000000000000000099] escape strategy [7].
20.05.2024 04:24:10.537911000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [.554336485187584197097244142629339077855] and current target energy [9.71922318876450835472921803353878059946]. Set energy to 0.
20.05.2024 04:24:10.556616000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:10.557552000 usim_creator.handle_overflow                       [786] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:24:10.562336000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [.554336485187584197097244142629339077855] and current target energy [9.71922318876450835472921803353878059946]. Set energy to 0.
20.05.2024 04:24:10.582032000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:10.583850000 usim_creator.handle_overflow                       [786] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:24:10.588969000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-.554336485187584197097244142629339077855] and current target energy [-9.71922318876450835472921803353878059946]. Set energy to 0.
20.05.2024 04:24:10.606426000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:10.606930000 usim_creator.handle_overflow                       [786] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:24:10.612190000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-.554336485187584197097244142629339077855] and current target energy [-9.71922318876450835472921803353878059946]. Set energy to 0.
20.05.2024 04:24:10.630192000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:10.631485000 usim_creator.handle_overflow                       [786] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:24:11.367142000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [.85167096067764418912427398956509584949] and current target energy [9.97735290683409747261409209623031951154]. Set energy to 0.
20.05.2024 04:24:11.389021000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:11.389537000 usim_creator.handle_overflow                       [788] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:24:11.395304000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [.85167096067764418912427398956509584949] and current target energy [9.97735290683409747261409209623031951154]. Set energy to 0.
20.05.2024 04:24:11.412688000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:11.418161000 usim_creator.handle_overflow                       [788] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:24:11.424326000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-.85167096067764418912427398956509584949] and current target energy [-9.97735290683409747261409209623031951154]. Set energy to 0.
20.05.2024 04:24:11.440205000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:11.441109000 usim_creator.handle_overflow                       [788] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:24:11.446706000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-.85167096067764418912427398956509584949] and current target energy [-9.97735290683409747261409209623031951154]. Set energy to 0.
20.05.2024 04:24:11.467878000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:11.468390000 usim_creator.handle_overflow                       [788] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:24:11.473070000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [2.91026654723481703476053174880403015874] and current target energy [9.85371474794051183824723021285641213865]. Set energy to 0.
20.05.2024 04:24:11.486967000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:11.488023000 usim_creator.handle_overflow                       [788] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:24:11.493063000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-2.91026654723481703476053174880403015874] and current target energy [-9.85371474794051183824723021285641213865]. Set energy to 0.
20.05.2024 04:24:11.508186000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:11.515216000 usim_creator.handle_overflow                       [788] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:24:11.806681000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [3.69254180584047569150921360357451874981] and current target energy [7.87464787951331747753059144629589514391]. Set energy to 0.
20.05.2024 04:24:11.852770000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:11.853759000 usim_creator.handle_overflow                       [789] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:24:11.860129000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-3.69254180584047569150921360357451874981] and current target energy [-7.87464787951331747753059144629589514391]. Set energy to 0.
20.05.2024 04:24:11.876542000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:11.877486000 usim_creator.handle_overflow                       [789] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:24:12.892300000 usim_process.process_queue                         Overflow for target space id [2024052004223175000000000000000000000000000000000000094] with energy [4.1238822456363694992142403143601199356] and current target energy [7.69014498214061818260662545745067056414]. Set energy to 0.
20.05.2024 04:24:12.907307000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:12.908293000 usim_creator.handle_overflow                       [793] Not implemented. Handle overflow for [2024052004223175000000000000000000000000000000000000094] escape strategy [7].
20.05.2024 04:24:12.923082000 usim_process.process_queue                         Overflow for target space id [2024052004223178700000000000000000000000000000000000095] with energy [-4.1238822456363694992142403143601199356] and current target energy [-7.69014498214061818260662545745067056414]. Set energy to 0.
20.05.2024 04:24:12.960813000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:12.961342000 usim_creator.handle_overflow                       [793] Not implemented. Handle overflow for [2024052004223178700000000000000000000000000000000000095] escape strategy [7].
20.05.2024 04:24:13.183689000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [2.18774146865017974944000075550829442723] and current target energy [9.37612711048014267407401559880523197439]. Set energy to 0.
20.05.2024 04:24:13.231501000 usim_creator.handle_overflow                       [794] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:24:13.235155000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [2.18774146865017974944000075550829442723] and current target energy [9.37612711048014267407401559880523197439]. Set energy to 0.
20.05.2024 04:24:13.249869000 usim_creator.handle_overflow                       [794] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:24:13.255179000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-2.18774146865017974944000075550829442723] and current target energy [-9.37612711048014267407401559880523197439]. Set energy to 0.
20.05.2024 04:24:13.270393000 usim_creator.handle_overflow                       [794] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:24:13.282954000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-2.18774146865017974944000075550829442723] and current target energy [-9.37612711048014267407401559880523197439]. Set energy to 0.
20.05.2024 04:24:13.292430000 usim_creator.handle_overflow                       [794] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:24:14.630031000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [2.18774146865017974944000075550829442723] and current target energy [7.86969044182291776968675321745901997525]. Set energy to 0.
20.05.2024 04:24:14.645790000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:14.646114000 usim_creator.handle_overflow                       [798] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:24:14.651942000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-2.18774146865017974944000075550829442723] and current target energy [-7.86969044182291776968675321745901997525]. Set energy to 0.
20.05.2024 04:24:14.678428000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:14.680887000 usim_creator.handle_overflow                       [798] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:24:15.181934000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.77243555951873787036545327523103568418] and current target energy [9.7553783153810929543644401063375703051]. Set energy to 0.
20.05.2024 04:24:15.196379000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:15.196849000 usim_creator.handle_overflow                       [799] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:24:15.200465000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.77243555951873787036545327523103568418] and current target energy [-9.7553783153810929543644401063375703051]. Set energy to 0.
20.05.2024 04:24:15.209426000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:15.209840000 usim_creator.handle_overflow                       [799] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:24:15.212615000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [3.95028444619274878521010362322202624579] and current target energy [9.33436392269385852709737299458657243159]. Set energy to 0.
20.05.2024 04:24:15.221066000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:15.221673000 usim_creator.handle_overflow                       [799] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:24:15.225141000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-3.95028444619274878521010362322202624579] and current target energy [-9.33436392269385852709737299458657243159]. Set energy to 0.
20.05.2024 04:24:15.234438000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:15.235051000 usim_creator.handle_overflow                       [799] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:24:17.164870000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [1.60524281285579385647883935106130497409] and current target energy [9.01773720552257073910877103886595571683]. Set energy to 0.
20.05.2024 04:24:17.183151000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:17.183692000 usim_creator.handle_overflow                       [804] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:24:17.187298000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [1.60524281285579385647883935106130497409] and current target energy [9.01773720552257073910877103886595571683]. Set energy to 0.
20.05.2024 04:24:17.212313000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:17.216781000 usim_creator.handle_overflow                       [804] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:24:17.221839000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-1.60524281285579385647883935106130497409] and current target energy [-9.01773720552257073910877103886595571683]. Set energy to 0.
20.05.2024 04:24:17.252280000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:17.252842000 usim_creator.handle_overflow                       [804] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:24:17.258271000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-1.60524281285579385647883935106130497409] and current target energy [-9.01773720552257073910877103886595571683]. Set energy to 0.
20.05.2024 04:24:17.272265000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:17.272805000 usim_creator.handle_overflow                       [804] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:24:17.296135000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [2.38621777975936893518272663761551784209] and current target energy [9.54487111903747574073090655046207136835]. Set energy to 0.
20.05.2024 04:24:17.319317000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:17.319854000 usim_creator.handle_overflow                       [804] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:24:17.322875000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-2.38621777975936893518272663761551784209] and current target energy [-9.54487111903747574073090655046207136835]. Set energy to 0.
20.05.2024 04:24:17.346818000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:17.347375000 usim_creator.handle_overflow                       [804] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:24:17.367166000 usim_process.process_queue                         Overflow for target space id [2024052004221501800000000000000000000000000000000000092] with energy [3.20008327947296108201060815920158198847] and current target energy [8.24776449127273899842848062872023987119]. Set energy to 0.
20.05.2024 04:24:17.382380000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:17.384769000 usim_creator.handle_overflow                       [804] Not implemented. Handle overflow for [2024052004221501800000000000000000000000000000000000092] escape strategy [7].
20.05.2024 04:24:17.390793000 usim_process.process_queue                         Overflow for target space id [2024052004221505600000000000000000000000000000000000093] with energy [-3.20008327947296108201060815920158198847] and current target energy [-8.24776449127273899842848062872023987119]. Set energy to 0.
20.05.2024 04:24:17.406144000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:17.406985000 usim_creator.handle_overflow                       [804] Not implemented. Handle overflow for [2024052004221505600000000000000000000000000000000000093] escape strategy [7].
20.05.2024 04:24:18.122970000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.7382291344307088138806194228553387661] and current target energy [6.15901022274365808841190279932871429014]. Set energy to 0.
20.05.2024 04:24:18.143560000 usim_creator.handle_overflow                       [806] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:24:18.152066000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.7382291344307088138806194228553387661] and current target energy [6.15901022274365808841190279932871429014]. Set energy to 0.
20.05.2024 04:24:18.169355000 usim_creator.handle_overflow                       [806] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:24:18.175586000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.7382291344307088138806194228553387661] and current target energy [-6.15901022274365808841190279932871429014]. Set energy to 0.
20.05.2024 04:24:18.194539000 usim_creator.handle_overflow                       [806] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:24:18.199679000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.7382291344307088138806194228553387661] and current target energy [-6.15901022274365808841190279932871429014]. Set energy to 0.
20.05.2024 04:24:18.227230000 usim_creator.handle_overflow                       [806] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:24:18.235334000 usim_process.process_queue                         Overflow for target space id [2024052004211990800000000000000000000000000000000000070] with energy [2.35375033974667806077276778813809017944] and current target energy [9.21789685980799615883041117182296164001]. Set energy to 0.
20.05.2024 04:24:18.244803000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:18.245123000 usim_creator.handle_overflow                       [806] Not implemented. Handle overflow for [2024052004211990800000000000000000000000000000000000070] escape strategy [7].
20.05.2024 04:24:18.248073000 usim_process.process_queue                         Overflow for target space id [2024052004211994200000000000000000000000000000000000071] with energy [2.35375033974667806077276778813809017944] and current target energy [9.21789685980799615883041117182296164001]. Set energy to 0.
20.05.2024 04:24:18.263191000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:18.263501000 usim_creator.handle_overflow                       [806] Not implemented. Handle overflow for [2024052004211994200000000000000000000000000000000000071] escape strategy [7].
20.05.2024 04:24:18.266509000 usim_process.process_queue                         Overflow for target space id [2024052004211998600000000000000000000000000000000000072] with energy [-2.35375033974667806077276778813809017944] and current target energy [-9.21789685980799615883041117182296164001]. Set energy to 0.
20.05.2024 04:24:18.283652000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:18.284174000 usim_creator.handle_overflow                       [806] Not implemented. Handle overflow for [2024052004211998600000000000000000000000000000000000072] escape strategy [7].
20.05.2024 04:24:18.290060000 usim_process.process_queue                         Overflow for target space id [2024052004212000300000000000000000000000000000000000073] with energy [-2.35375033974667806077276778813809017944] and current target energy [-9.21789685980799615883041117182296164001]. Set energy to 0.
20.05.2024 04:24:18.307629000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:18.308141000 usim_creator.handle_overflow                       [806] Not implemented. Handle overflow for [2024052004212000300000000000000000000000000000000000073] escape strategy [7].
20.05.2024 04:24:19.454135000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.7382291344307088138806194228553387661] and current target energy [8.52881244197527586498511496113960977898]. Set energy to 0.
20.05.2024 04:24:19.469376000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:19.470097000 usim_creator.handle_overflow                       [810] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:24:19.479578000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.7382291344307088138806194228553387661] and current target energy [-8.52881244197527586498511496113960977898]. Set energy to 0.
20.05.2024 04:24:19.494978000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:19.495498000 usim_creator.handle_overflow                       [810] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:24:19.498554000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [2.15972096580078159352819670937674361941] and current target energy [9.4764582688614176277612388457106775322]. Set energy to 0.
20.05.2024 04:24:19.511709000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:19.512215000 usim_creator.handle_overflow                       [810] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:24:19.518924000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [2.15972096580078159352819670937674361941] and current target energy [9.4764582688614176277612388457106775322]. Set energy to 0.
20.05.2024 04:24:19.535389000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:19.535899000 usim_creator.handle_overflow                       [810] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:24:19.539689000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-2.15972096580078159352819670937674361941] and current target energy [-9.4764582688614176277612388457106775322]. Set energy to 0.
20.05.2024 04:24:19.555285000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:19.555787000 usim_creator.handle_overflow                       [810] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:24:19.559642000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-2.15972096580078159352819670937674361941] and current target energy [-9.4764582688614176277612388457106775322]. Set energy to 0.
20.05.2024 04:24:19.576701000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:19.577232000 usim_creator.handle_overflow                       [810] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:24:19.598121000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [2.91926855738282367674429632268674345328] and current target energy [7.90056889238549757042020724644405249157]. Set energy to 0.
20.05.2024 04:24:19.625077000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:19.626942000 usim_creator.handle_overflow                       [810] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:24:19.634228000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-2.91926855738282367674429632268674345328] and current target energy [-7.90056889238549757042020724644405249157]. Set energy to 0.
20.05.2024 04:24:19.649633000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:19.650148000 usim_creator.handle_overflow                       [810] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:24:21.034817000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.18455728360767720347015485571383469153] and current target energy [9.4764582688614176277612388457106775322]. Set energy to 0.
20.05.2024 04:24:21.045521000 usim_creator.handle_overflow                       [815] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:24:21.049823000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.18455728360767720347015485571383469153] and current target energy [-9.4764582688614176277612388457106775322]. Set energy to 0.
20.05.2024 04:24:21.057553000 usim_creator.handle_overflow                       [815] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:24:21.070573000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.06665008094684422043727096444157634268] and current target energy [6.79014205492595925398784501205562783851]. Set energy to 0.
20.05.2024 04:24:21.080355000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:21.080943000 usim_creator.handle_overflow                       [815] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:24:21.083666000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.06665008094684422043727096444157634268] and current target energy [-6.79014205492595925398784501205562783851]. Set energy to 0.
20.05.2024 04:24:21.092303000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:21.092928000 usim_creator.handle_overflow                       [815] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:24:22.386852000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [2.0910682371759921687459700442148274639] and current target energy [8.85758096064787436582594378545589126525]. Set energy to 0.
20.05.2024 04:24:22.419607000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:22.421272000 usim_creator.handle_overflow                       [819] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:24:22.427494000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-2.0910682371759921687459700442148274639] and current target energy [-8.85758096064787436582594378545589126525]. Set energy to 0.
20.05.2024 04:24:22.443864000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:22.444853000 usim_creator.handle_overflow                       [819] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:24:22.783605000 usim_process.process_queue                         Overflow for target space id [2024052004221223900000000000000000000000000000000000088] with energy [2.45389002983309905317025098766392069731] and current target energy [7.59158526746007060729243840645735894831]. Set energy to 0.
20.05.2024 04:24:22.795525000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:22.796040000 usim_creator.handle_overflow                       [820] Not implemented. Handle overflow for [2024052004221223900000000000000000000000000000000000088] escape strategy [7].
20.05.2024 04:24:22.799951000 usim_process.process_queue                         Overflow for target space id [2024052004221227000000000000000000000000000000000000089] with energy [2.45389002983309905317025098766392069731] and current target energy [7.59158526746007060729243840645735894831]. Set energy to 0.
20.05.2024 04:24:22.809385000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:22.810179000 usim_creator.handle_overflow                       [820] Not implemented. Handle overflow for [2024052004221227000000000000000000000000000000000000089] escape strategy [7].
20.05.2024 04:24:22.813639000 usim_process.process_queue                         Overflow for target space id [2024052004221231900000000000000000000000000000000000090] with energy [-2.45389002983309905317025098766392069731] and current target energy [-7.59158526746007060729243840645735894831]. Set energy to 0.
20.05.2024 04:24:22.823804000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:22.823945000 usim_creator.handle_overflow                       [820] Not implemented. Handle overflow for [2024052004221231900000000000000000000000000000000000090] escape strategy [7].
20.05.2024 04:24:22.827228000 usim_process.process_queue                         Overflow for target space id [2024052004221235100000000000000000000000000000000000091] with energy [-2.45389002983309905317025098766392069731] and current target energy [-7.59158526746007060729243840645735894831]. Set energy to 0.
20.05.2024 04:24:22.836691000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:22.837232000 usim_creator.handle_overflow                       [820] Not implemented. Handle overflow for [2024052004221235100000000000000000000000000000000000091] escape strategy [7].
20.05.2024 04:24:23.111874000 usim_process.process_queue                         Overflow for target space id [2024052004211868000000000000000000000000000000000000066] with energy [1.17742723197567526173500181403743383639] and current target energy [9.03939629157744836637672664708818468064]. Set energy to 0.
20.05.2024 04:24:23.127968000 usim_creator.handle_overflow                       [821] Not implemented. Handle overflow for [2024052004211868000000000000000000000000000000000000066] escape strategy [0].
20.05.2024 04:24:23.133842000 usim_process.process_queue                         Overflow for target space id [2024052004211870600000000000000000000000000000000000067] with energy [1.17742723197567526173500181403743383639] and current target energy [9.03939629157744836637672664708818468064]. Set energy to 0.
20.05.2024 04:24:23.148480000 usim_creator.handle_overflow                       [821] Not implemented. Handle overflow for [2024052004211870600000000000000000000000000000000000067] escape strategy [0].
20.05.2024 04:24:23.156405000 usim_process.process_queue                         Overflow for target space id [2024052004211874300000000000000000000000000000000000068] with energy [-1.17742723197567526173500181403743383639] and current target energy [-9.03939629157744836637672664708818468064]. Set energy to 0.
20.05.2024 04:24:23.177221000 usim_creator.handle_overflow                       [821] Not implemented. Handle overflow for [2024052004211874300000000000000000000000000000000000068] escape strategy [0].
20.05.2024 04:24:23.189834000 usim_process.process_queue                         Overflow for target space id [2024052004211878000000000000000000000000000000000000069] with energy [-1.17742723197567526173500181403743383639] and current target energy [-9.03939629157744836637672664708818468064]. Set energy to 0.
20.05.2024 04:24:23.211148000 usim_creator.handle_overflow                       [821] Not implemented. Handle overflow for [2024052004211878000000000000000000000000000000000000069] escape strategy [0].
20.05.2024 04:24:23.218781000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [3.87632595304603320581228008364383503556] and current target energy [6.40016655894592216402121631840316397693]. Set energy to 0.
20.05.2024 04:24:23.236142000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:23.236659000 usim_creator.handle_overflow                       [821] Not implemented. Handle overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [7].
20.05.2024 04:24:23.242853000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-3.87632595304603320581228008364383503556] and current target energy [-6.40016655894592216402121631840316397693]. Set energy to 0.
20.05.2024 04:24:23.269386000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:23.269905000 usim_creator.handle_overflow                       [821] Not implemented. Handle overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [7].
20.05.2024 04:24:23.542234000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.467465809325651404695689515141023811] and current target energy [8.13330016189368844087454192888315268536]. Set energy to 0.
20.05.2024 04:24:23.553435000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:23.553735000 usim_creator.handle_overflow                       [822] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:24:23.557035000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.467465809325651404695689515141023811] and current target energy [-8.13330016189368844087454192888315268536]. Set energy to 0.
20.05.2024 04:24:23.565601000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:23.565898000 usim_creator.handle_overflow                       [822] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:24:23.593435000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.467465809325651404695689515141023811] and current target energy [9.99666788195641672805519341765120758501]. Set energy to 0.
20.05.2024 04:24:23.613615000 usim_creator.handle_overflow                       [822] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:24:23.632250000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.467465809325651404695689515141023811] and current target energy [9.99666788195641672805519341765120758501]. Set energy to 0.
20.05.2024 04:24:23.667238000 usim_creator.handle_overflow                       [822] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:24:23.682103000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.467465809325651404695689515141023811] and current target energy [-9.99666788195641672805519341765120758501]. Set energy to 0.
20.05.2024 04:24:23.733146000 usim_creator.handle_overflow                       [822] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:24:23.737152000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.467465809325651404695689515141023811] and current target energy [-9.99666788195641672805519341765120758501]. Set energy to 0.
20.05.2024 04:24:23.749952000 usim_creator.handle_overflow                       [822] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:24:24.098032000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [2.30142373593909005464407723449909064428] and current target energy [9.82344114681080357758294169322080916915]. Set energy to 0.
20.05.2024 04:24:24.118089000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:24.118887000 usim_creator.handle_overflow                       [823] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:24:24.122275000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [2.30142373593909005464407723449909064428] and current target energy [9.82344114681080357758294169322080916915]. Set energy to 0.
20.05.2024 04:24:24.148066000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:24.162004000 usim_creator.handle_overflow                       [823] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:24:24.168738000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-2.30142373593909005464407723449909064428] and current target energy [-9.82344114681080357758294169322080916915]. Set energy to 0.
20.05.2024 04:24:24.182962000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:24.183471000 usim_creator.handle_overflow                       [823] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:24:24.186999000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-2.30142373593909005464407723449909064428] and current target energy [-9.82344114681080357758294169322080916915]. Set energy to 0.
20.05.2024 04:24:24.202760000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:24.203804000 usim_creator.handle_overflow                       [823] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:24:24.685759000 usim_process.process_queue                         Overflow for target space id [2024052004211134000000000000000000000000000000000000052] with energy [.9119687760305875758516010145169413049538] and current target energy [9.19634439906972472021450944756554644785]. Set energy to 0.
20.05.2024 04:24:24.721375000 usim_creator.handle_overflow                       [824] Not implemented. Handle overflow for [2024052004211134000000000000000000000000000000000000052] escape strategy [0].
20.05.2024 04:24:24.725486000 usim_process.process_queue                         Overflow for target space id [2024052004211138700000000000000000000000000000000000053] with energy [.9119687760305875758516010145169413049538] and current target energy [9.19634439906972472021450944756554644785]. Set energy to 0.
20.05.2024 04:24:24.739437000 usim_creator.handle_overflow                       [824] Not implemented. Handle overflow for [2024052004211138700000000000000000000000000000000000053] escape strategy [0].
20.05.2024 04:24:24.746009000 usim_process.process_queue                         Overflow for target space id [2024052004211143900000000000000000000000000000000000054] with energy [-.9119687760305875758516010145169413049538] and current target energy [-9.19634439906972472021450944756554644785]. Set energy to 0.
20.05.2024 04:24:24.769353000 usim_creator.handle_overflow                       [824] Not implemented. Handle overflow for [2024052004211143900000000000000000000000000000000000054] escape strategy [0].
20.05.2024 04:24:24.772690000 usim_process.process_queue                         Overflow for target space id [2024052004211147900000000000000000000000000000000000055] with energy [-.9119687760305875758516010145169413049538] and current target energy [-9.19634439906972472021450944756554644785]. Set energy to 0.
20.05.2024 04:24:24.781288000 usim_creator.handle_overflow                       [824] Not implemented. Handle overflow for [2024052004211147900000000000000000000000000000000000055] escape strategy [0].
20.05.2024 04:24:25.191996000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.30142373593909005464407723449909064428] and current target energy [8.934931618651302809391379030282047622]. Set energy to 0.
20.05.2024 04:24:25.214893000 usim_creator.handle_overflow                       [825] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:24:25.222749000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.30142373593909005464407723449909064428] and current target energy [-8.934931618651302809391379030282047622]. Set energy to 0.
20.05.2024 04:24:25.247580000 usim_creator.handle_overflow                       [825] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:24:25.285665000 usim_process.process_queue                         Overflow for target space id [2024052004213975700000000000000000000000000000000000082] with energy [.3631746482457020120900557922135604867775] and current target energy [9.81556011933239621268100395065568278925]. Set energy to 0.
20.05.2024 04:24:25.300128000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:25.300635000 usim_creator.handle_overflow                       [825] Not implemented. Handle overflow for [2024052004213975700000000000000000000000000000000000082] escape strategy [7].
20.05.2024 04:24:25.305119000 usim_process.process_queue                         Overflow for target space id [2024052004213980000000000000000000000000000000000000083] with energy [.3631746482457020120900557922135604867775] and current target energy [9.81556011933239621268100395065568278925]. Set energy to 0.
20.05.2024 04:24:25.316960000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:25.317259000 usim_creator.handle_overflow                       [825] Not implemented. Handle overflow for [2024052004213980000000000000000000000000000000000000083] escape strategy [7].
20.05.2024 04:24:25.324222000 usim_process.process_queue                         Overflow for target space id [2024052004213983100000000000000000000000000000000000084] with energy [-.3631746482457020120900557922135604867775] and current target energy [-9.81556011933239621268100395065568278925]. Set energy to 0.
20.05.2024 04:24:25.333518000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:25.334147000 usim_creator.handle_overflow                       [825] Not implemented. Handle overflow for [2024052004213983100000000000000000000000000000000000084] escape strategy [7].
20.05.2024 04:24:25.337214000 usim_process.process_queue                         Overflow for target space id [2024052004213986900000000000000000000000000000000000085] with energy [-.3631746482457020120900557922135604867775] and current target energy [-9.81556011933239621268100395065568278925]. Set energy to 0.
20.05.2024 04:24:25.344051000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:25.344526000 usim_creator.handle_overflow                       [825] Not implemented. Handle overflow for [2024052004213986900000000000000000000000000000000000085] escape strategy [7].
20.05.2024 04:24:26.700519000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [3.06014972543750047019904006512578622279] and current target energy [8.36427294870396867498388017685930985558]. Set energy to 0.
20.05.2024 04:24:26.723617000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:26.724747000 usim_creator.handle_overflow                       [829] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:24:26.736805000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-3.06014972543750047019904006512578622279] and current target energy [-8.36427294870396867498388017685930985558]. Set energy to 0.
20.05.2024 04:24:26.768891000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:26.770377000 usim_creator.handle_overflow                       [829] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:24:27.109378000 usim_process.process_queue                         Overflow for target space id [2024052004210570400000000000000000000000000000000000038] with energy [1.16546701115350964981448714043862675643] and current target energy [9.82541985678757216680309669650832394161]. Set energy to 0.
20.05.2024 04:24:27.125110000 usim_creator.handle_overflow                       [830] Not implemented. Handle overflow for [2024052004210570400000000000000000000000000000000000038] escape strategy [0].
20.05.2024 04:24:27.130786000 usim_process.process_queue                         Overflow for target space id [2024052004210571900000000000000000000000000000000000039] with energy [1.16546701115350964981448714043862675643] and current target energy [9.82541985678757216680309669650832394161]. Set energy to 0.
20.05.2024 04:24:27.145133000 usim_creator.handle_overflow                       [830] Not implemented. Handle overflow for [2024052004210571900000000000000000000000000000000000039] escape strategy [0].
20.05.2024 04:24:27.149936000 usim_process.process_queue                         Overflow for target space id [2024052004210573600000000000000000000000000000000000040] with energy [-1.16546701115350964981448714043862675643] and current target energy [-9.82541985678757216680309669650832394161]. Set energy to 0.
20.05.2024 04:24:27.163084000 usim_creator.handle_overflow                       [830] Not implemented. Handle overflow for [2024052004210573600000000000000000000000000000000000040] escape strategy [0].
20.05.2024 04:24:27.169553000 usim_process.process_queue                         Overflow for target space id [2024052004210575900000000000000000000000000000000000041] with energy [-1.16546701115350964981448714043862675643] and current target energy [-9.82541985678757216680309669650832394161]. Set energy to 0.
20.05.2024 04:24:27.184220000 usim_creator.handle_overflow                       [830] Not implemented. Handle overflow for [2024052004210575900000000000000000000000000000000000041] escape strategy [0].
20.05.2024 04:24:28.527552000 usim_process.process_queue                         Overflow for target space id [2024052004211700300000000000000000000000000000000000062] with energy [.9184106045177170338766215547377738185138] and current target energy [9.85434465409940749406989779462620686786]. Set energy to 0.
20.05.2024 04:24:28.539033000 usim_creator.handle_overflow                       [834] Not implemented. Handle overflow for [2024052004211700300000000000000000000000000000000000062] escape strategy [0].
20.05.2024 04:24:28.543397000 usim_process.process_queue                         Overflow for target space id [2024052004211706000000000000000000000000000000000000063] with energy [.9184106045177170338766215547377738185138] and current target energy [9.85434465409940749406989779462620686786]. Set energy to 0.
20.05.2024 04:24:28.556940000 usim_creator.handle_overflow                       [834] Not implemented. Handle overflow for [2024052004211706000000000000000000000000000000000000063] escape strategy [0].
20.05.2024 04:24:28.574289000 usim_process.process_queue                         Overflow for target space id [2024052004211711600000000000000000000000000000000000064] with energy [-.9184106045177170338766215547377738185138] and current target energy [-9.85434465409940749406989779462620686786]. Set energy to 0.
20.05.2024 04:24:28.595435000 usim_creator.handle_overflow                       [834] Not implemented. Handle overflow for [2024052004211711600000000000000000000000000000000000064] escape strategy [0].
20.05.2024 04:24:28.602988000 usim_process.process_queue                         Overflow for target space id [2024052004211716600000000000000000000000000000000000065] with energy [-.9184106045177170338766215547377738185138] and current target energy [-9.85434465409940749406989779462620686786]. Set energy to 0.
20.05.2024 04:24:28.631595000 usim_creator.handle_overflow                       [834] Not implemented. Handle overflow for [2024052004211716600000000000000000000000000000000000065] escape strategy [0].
20.05.2024 04:24:29.148373000 usim_process.process_queue                         Overflow for target space id [2024052004233397700000000000000000000000000000000000100] with energy [1.55869326474322344959781993044594083487] and current target energy [8.73270089704963494738427229784423345866]. Set energy to 0.
20.05.2024 04:24:29.162241000 usim_creator.handle_overflow                       [836] Handle pos overflow for [2024052004233397700000000000000000000000000000000000100] escape strategy [3].
20.05.2024 04:24:29.166022000 usim_process.process_queue                         Overflow for target space id [2024052004233401700000000000000000000000000000000000101] with energy [1.55869326474322344959781993044594083487] and current target energy [8.73270089704963494738427229784423345866]. Set energy to 0.
20.05.2024 04:24:29.204156000 usim_creator.handle_overflow                       [836] Handle pos overflow for [2024052004233401700000000000000000000000000000000000101] escape strategy [3].
20.05.2024 04:24:29.210958000 usim_process.process_queue                         Overflow for target space id [2024052004233403400000000000000000000000000000000000102] with energy [-1.55869326474322344959781993044594083487] and current target energy [-8.73270089704963494738427229784423345866]. Set energy to 0.
20.05.2024 04:24:29.232130000 usim_creator.handle_overflow                       [836] Handle pos overflow for [2024052004233403400000000000000000000000000000000000102] escape strategy [3].
20.05.2024 04:24:29.245630000 usim_process.process_queue                         Overflow for target space id [2024052004233409100000000000000000000000000000000000103] with energy [-1.55869326474322344959781993044594083487] and current target energy [-8.73270089704963494738427229784423345866]. Set energy to 0.
20.05.2024 04:24:29.266007000 usim_creator.handle_overflow                       [836] Handle pos overflow for [2024052004233409100000000000000000000000000000000000103] escape strategy [3].
20.05.2024 04:24:30.676068000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.02416800727558977997757140600728375325] and current target energy [9.83942413244545502452156138078588022137]. Set energy to 0.
20.05.2024 04:24:30.686504000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:30.687397000 usim_creator.handle_overflow                       [840] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:24:30.694689000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.02416800727558977997757140600728375325] and current target energy [9.83942413244545502452156138078588022137]. Set energy to 0.
20.05.2024 04:24:30.703707000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:30.704521000 usim_creator.handle_overflow                       [840] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:24:30.707691000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.02416800727558977997757140600728375325] and current target energy [-9.83942413244545502452156138078588022137]. Set energy to 0.
20.05.2024 04:24:30.717985000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:30.718387000 usim_creator.handle_overflow                       [840] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:24:30.721311000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.02416800727558977997757140600728375325] and current target energy [-9.83942413244545502452156138078588022137]. Set energy to 0.
20.05.2024 04:24:30.732642000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:30.733223000 usim_creator.handle_overflow                       [840] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:24:31.641710000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [3.89529779326147691512709881563029637092] and current target energy [7.75265190609206641162456016728767007112]. Set energy to 0.
20.05.2024 04:24:31.663509000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:31.664061000 usim_creator.handle_overflow                       [842] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:24:31.669222000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-3.89529779326147691512709881563029637092] and current target energy [-7.75265190609206641162456016728767007112]. Set energy to 0.
20.05.2024 04:24:31.681332000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:31.681844000 usim_creator.handle_overflow                       [842] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:24:31.919882000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.274480757642846589761506694459547924665] and current target energy [9.72948551990975589632192651979236009795]. Set energy to 0.
20.05.2024 04:24:31.925773000 usim_creator.handle_overflow                       [843] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:24:31.930756000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.274480757642846589761506694459547924665] and current target energy [-9.72948551990975589632192651979236009795]. Set energy to 0.
20.05.2024 04:24:31.956439000 usim_creator.handle_overflow                       [843] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:24:32.018020000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [1.08452190973302979533499644741613863968] and current target energy [9.1568937662347122588058762935750233035]. Set energy to 0.
20.05.2024 04:24:32.061256000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:32.061879000 usim_creator.handle_overflow                       [843] Not implemented. Handle overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [7].
20.05.2024 04:24:32.066007000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [1.08452190973302979533499644741613863968] and current target energy [9.1568937662347122588058762935750233035]. Set energy to 0.
20.05.2024 04:24:32.076907000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:32.077803000 usim_creator.handle_overflow                       [843] Not implemented. Handle overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [7].
20.05.2024 04:24:32.080882000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-1.08452190973302979533499644741613863968] and current target energy [-9.1568937662347122588058762935750233035]. Set energy to 0.
20.05.2024 04:24:32.089418000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:32.090039000 usim_creator.handle_overflow                       [843] Not implemented. Handle overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [7].
20.05.2024 04:24:32.093577000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-1.08452190973302979533499644741613863968] and current target energy [-9.1568937662347122588058762935750233035]. Set energy to 0.
20.05.2024 04:24:32.103254000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:32.103857000 usim_creator.handle_overflow                       [843] Not implemented. Handle overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [7].
20.05.2024 04:24:32.941494000 usim_process.process_queue                         Overflow for target space id [2024052004210261400000000000000000000000000000000000034] with energy [.83138777899815866975095932239823377547] and current target energy [9.95050692297273546500260565084235130243]. Set energy to 0.
20.05.2024 04:24:32.956267000 usim_creator.handle_overflow                       [845] Not implemented. Handle overflow for [2024052004210261400000000000000000000000000000000000034] escape strategy [0].
20.05.2024 04:24:32.960114000 usim_process.process_queue                         Overflow for target space id [2024052004210264800000000000000000000000000000000000035] with energy [.83138777899815866975095932239823377547] and current target energy [9.95050692297273546500260565084235130243]. Set energy to 0.
20.05.2024 04:24:32.978347000 usim_creator.handle_overflow                       [845] Not implemented. Handle overflow for [2024052004210264800000000000000000000000000000000000035] escape strategy [0].
20.05.2024 04:24:32.983114000 usim_process.process_queue                         Overflow for target space id [2024052004210269400000000000000000000000000000000000036] with energy [-.83138777899815866975095932239823377547] and current target energy [-9.95050692297273546500260565084235130243]. Set energy to 0.
20.05.2024 04:24:32.995765000 usim_creator.handle_overflow                       [845] Not implemented. Handle overflow for [2024052004210269400000000000000000000000000000000000036] escape strategy [0].
20.05.2024 04:24:32.999477000 usim_process.process_queue                         Overflow for target space id [2024052004210273800000000000000000000000000000000000037] with energy [-.83138777899815866975095932239823377547] and current target energy [-9.95050692297273546500260565084235130243]. Set energy to 0.
20.05.2024 04:24:33.012324000 usim_creator.handle_overflow                       [845] Not implemented. Handle overflow for [2024052004210273800000000000000000000000000000000000037] escape strategy [0].
20.05.2024 04:24:33.279722000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [1.75339193007161920043065813290771570193] and current target energy [9.38957936143233910310807490327419235368]. Set energy to 0.
20.05.2024 04:24:33.290363000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:33.290980000 usim_creator.handle_overflow                       [846] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:24:33.293961000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [1.75339193007161920043065813290771570193] and current target energy [9.38957936143233910310807490327419235368]. Set energy to 0.
20.05.2024 04:24:33.302328000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:33.302743000 usim_creator.handle_overflow                       [846] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:24:33.305850000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-1.75339193007161920043065813290771570193] and current target energy [-9.38957936143233910310807490327419235368]. Set energy to 0.
20.05.2024 04:24:33.330137000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:33.330697000 usim_creator.handle_overflow                       [846] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:24:33.333782000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-1.75339193007161920043065813290771570193] and current target energy [-9.38957936143233910310807490327419235368]. Set energy to 0.
20.05.2024 04:24:33.343937000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:33.344941000 usim_creator.handle_overflow                       [846] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:24:34.177867000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [2.68372700862734655031362473372860861049] and current target energy [7.94220578339858482177307060322152230234]. Set energy to 0.
20.05.2024 04:24:34.209732000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:34.210892000 usim_creator.handle_overflow                       [848] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:24:34.219793000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-2.68372700862734655031362473372860861049] and current target energy [-7.94220578339858482177307060322152230234]. Set energy to 0.
20.05.2024 04:24:34.237058000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:34.237998000 usim_creator.handle_overflow                       [848] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:24:35.031007000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [3.89529779326147691512709881563029637092] and current target energy [7.82853926695384124888383509523351541254]. Set energy to 0.
20.05.2024 04:24:35.050195000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:35.050792000 usim_creator.handle_overflow                       [850] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:24:35.055391000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-3.89529779326147691512709881563029637092] and current target energy [-7.82853926695384124888383509523351541254]. Set energy to 0.
20.05.2024 04:24:35.071448000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:35.072015000 usim_creator.handle_overflow                       [850] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:24:35.400626000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.91635352762053965731998777087061815747] and current target energy [5.99949558185143616139391136362692889414]. Set energy to 0.
20.05.2024 04:24:35.421770000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:35.422304000 usim_creator.handle_overflow                       [851] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:24:35.425575000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.91635352762053965731998777087061815747] and current target energy [-5.99949558185143616139391136362692889414]. Set energy to 0.
20.05.2024 04:24:35.437873000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:35.438625000 usim_creator.handle_overflow                       [851] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:24:35.845208000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.62913951842702977765353761162030868778] and current target energy [9.20604939430396258175209762287038523994]. Set energy to 0.
20.05.2024 04:24:35.863357000 usim_creator.handle_overflow                       [852] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:24:35.869143000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.62913951842702977765353761162030868778] and current target energy [9.20604939430396258175209762287038523994]. Set energy to 0.
20.05.2024 04:24:35.882480000 usim_creator.handle_overflow                       [852] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:24:35.886135000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.62913951842702977765353761162030868778] and current target energy [-9.20604939430396258175209762287038523994]. Set energy to 0.
20.05.2024 04:24:35.902276000 usim_creator.handle_overflow                       [852] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:24:35.907368000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.62913951842702977765353761162030868778] and current target energy [-9.20604939430396258175209762287038523994]. Set energy to 0.
20.05.2024 04:24:35.921630000 usim_creator.handle_overflow                       [852] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:24:35.924892000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [1.70823981607884030848575496498194296697] and current target energy [9.83270705524107931463997554174123631494]. Set energy to 0.
20.05.2024 04:24:35.938524000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:35.939023000 usim_creator.handle_overflow                       [852] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:24:35.942536000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-1.70823981607884030848575496498194296697] and current target energy [-9.83270705524107931463997554174123631494]. Set energy to 0.
20.05.2024 04:24:35.958883000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:35.959990000 usim_creator.handle_overflow                       [852] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:24:37.258087000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.40683895876224801384554289407350475279] and current target energy [9.07284879606757444413384402905077171944]. Set energy to 0.
20.05.2024 04:24:37.286229000 usim_creator.handle_overflow                       [855] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:24:37.290168000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.40683895876224801384554289407350475279] and current target energy [-9.07284879606757444413384402905077171944]. Set energy to 0.
20.05.2024 04:24:37.311666000 usim_creator.handle_overflow                       [855] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:24:38.051834000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [2.40683895876224801384554289407350475279] and current target energy [8.86626510969291747347592981242764005695]. Set energy to 0.
20.05.2024 04:24:38.071874000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:38.072204000 usim_creator.handle_overflow                       [857] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:24:38.077811000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [2.40683895876224801384554289407350475279] and current target energy [8.86626510969291747347592981242764005695]. Set energy to 0.
20.05.2024 04:24:38.092747000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:38.093242000 usim_creator.handle_overflow                       [857] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:24:38.098917000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-2.40683895876224801384554289407350475279] and current target energy [-8.86626510969291747347592981242764005695]. Set energy to 0.
20.05.2024 04:24:38.120312000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:38.121263000 usim_creator.handle_overflow                       [857] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:24:38.127661000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-2.40683895876224801384554289407350475279] and current target energy [-8.86626510969291747347592981242764005695]. Set energy to 0.
20.05.2024 04:24:38.144716000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:38.145262000 usim_creator.handle_overflow                       [857] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:24:40.769715000 usim_process.process_queue                         Overflow for target space id [2024052004205701200000000000000000000000000000000000015] with energy [1.17938829250891632039076885694973965082] and current target energy [9.78168222745186527475844615338608384598]. Set energy to 0.
20.05.2024 04:24:40.784366000 usim_creator.handle_overflow                       [863] Not implemented. Handle overflow for [2024052004205701200000000000000000000000000000000000015] escape strategy [0].
20.05.2024 04:24:40.787224000 usim_process.process_queue                         Overflow for target space id [2024052004205702800000000000000000000000000000000000017] with energy [1.17938829250891632039076885694973965082] and current target energy [9.78168222745186527475844615338608384598]. Set energy to 0.
20.05.2024 04:24:40.799310000 usim_creator.handle_overflow                       [863] Not implemented. Handle overflow for [2024052004205702800000000000000000000000000000000000017] escape strategy [0].
20.05.2024 04:24:40.806924000 usim_process.process_queue                         Overflow for target space id [2024052004205711900000000000000000000000000000000000019] with energy [-1.17938829250891632039076885694973965082] and current target energy [-9.78168222745186527475844615338608384598]. Set energy to 0.
20.05.2024 04:24:40.824511000 usim_creator.handle_overflow                       [863] Not implemented. Handle overflow for [2024052004205711900000000000000000000000000000000000019] escape strategy [0].
20.05.2024 04:24:40.831205000 usim_process.process_queue                         Overflow for target space id [2024052004205716200000000000000000000000000000000000021] with energy [-1.17938829250891632039076885694973965082] and current target energy [-9.78168222745186527475844615338608384598]. Set energy to 0.
20.05.2024 04:24:40.846678000 usim_creator.handle_overflow                       [863] Not implemented. Handle overflow for [2024052004205716200000000000000000000000000000000000021] escape strategy [0].
20.05.2024 04:24:40.862303000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [2.87031569155391323704004447136282405919] and current target energy [8.64471549456237398449707511375156422532]. Set energy to 0.
20.05.2024 04:24:40.872030000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:40.872383000 usim_creator.handle_overflow                       [863] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:24:40.875730000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-2.87031569155391323704004447136282405919] and current target energy [-8.64471549456237398449707511375156422532]. Set energy to 0.
20.05.2024 04:24:40.901185000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:40.901727000 usim_creator.handle_overflow                       [863] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:24:41.156063000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [3.59765036324611715963810992288641854097] and current target energy [9.62735583504899205538217157629401901117]. Set energy to 0.
20.05.2024 04:24:41.181052000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:41.181593000 usim_creator.handle_overflow                       [864] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:24:41.185793000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [3.59765036324611715963810992288641854097] and current target energy [9.62735583504899205538217157629401901117]. Set energy to 0.
20.05.2024 04:24:41.205069000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:41.206992000 usim_creator.handle_overflow                       [864] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:24:41.212905000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-3.59765036324611715963810992288641854097] and current target energy [-9.62735583504899205538217157629401901117]. Set energy to 0.
20.05.2024 04:24:41.226516000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:41.227274000 usim_creator.handle_overflow                       [864] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:24:41.233921000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-3.59765036324611715963810992288641854097] and current target energy [-9.62735583504899205538217157629401901117]. Set energy to 0.
20.05.2024 04:24:41.263077000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:41.268959000 usim_creator.handle_overflow                       [864] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:24:42.847697000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.19784407753575665497377283483777599468] and current target energy [8.36089598118159374280837803813807369368]. Set energy to 0.
20.05.2024 04:24:42.870612000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:42.870959000 usim_creator.handle_overflow                       [868] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:24:42.875161000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.19784407753575665497377283483777599468] and current target energy [-8.36089598118159374280837803813807369368]. Set energy to 0.
20.05.2024 04:24:42.892156000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:42.893043000 usim_creator.handle_overflow                       [868] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:24:43.284631000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.05475843662629270881012990093501175843] and current target energy [9.45044659169780601875767557061056374779]. Set energy to 0.
20.05.2024 04:24:43.314123000 usim_creator.handle_overflow                       [869] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:24:43.320208000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.05475843662629270881012990093501175843] and current target energy [-9.45044659169780601875767557061056374779]. Set energy to 0.
20.05.2024 04:24:43.330419000 usim_creator.handle_overflow                       [869] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:24:43.374198000 usim_process.process_queue                         Overflow for target space id [2024052004225249900000000000000000000000000000000000096] with energy [1.17203388594365372355641001128016851272] and current target energy [9.5446764000202879071458915670887553803]. Set energy to 0.
20.05.2024 04:24:43.398453000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:43.399767000 usim_creator.handle_overflow                       [869] Not implemented. Handle overflow for [2024052004225249900000000000000000000000000000000000096] escape strategy [7].
20.05.2024 04:24:43.405488000 usim_process.process_queue                         Overflow for target space id [2024052004225253800000000000000000000000000000000000097] with energy [1.17203388594365372355641001128016851272] and current target energy [9.5446764000202879071458915670887553803]. Set energy to 0.
20.05.2024 04:24:43.421713000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:43.422724000 usim_creator.handle_overflow                       [869] Not implemented. Handle overflow for [2024052004225253800000000000000000000000000000000000097] escape strategy [7].
20.05.2024 04:24:43.429853000 usim_process.process_queue                         Overflow for target space id [2024052004225256200000000000000000000000000000000000098] with energy [-1.17203388594365372355641001128016851272] and current target energy [-9.5446764000202879071458915670887553803]. Set energy to 0.
20.05.2024 04:24:43.449617000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:43.450152000 usim_creator.handle_overflow                       [869] Not implemented. Handle overflow for [2024052004225256200000000000000000000000000000000000098] escape strategy [7].
20.05.2024 04:24:43.455077000 usim_process.process_queue                         Overflow for target space id [2024052004225260100000000000000000000000000000000000099] with energy [-1.17203388594365372355641001128016851272] and current target energy [-9.5446764000202879071458915670887553803]. Set energy to 0.
20.05.2024 04:24:43.483379000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:43.489724000 usim_creator.handle_overflow                       [869] Not implemented. Handle overflow for [2024052004225260100000000000000000000000000000000000099] escape strategy [7].
20.05.2024 04:24:45.565050000 usim_process.process_queue                         Overflow for target space id [2024052004205948300000000000000000000000000000000000024] with energy [.5387412261442770476514653923606999390563] and current target energy [9.57572186806903169777707392013617713821]. Set energy to 0.
20.05.2024 04:24:45.590086000 usim_creator.handle_overflow                       [874] Not implemented. Handle overflow for [2024052004205948300000000000000000000000000000000000024] escape strategy [0].
20.05.2024 04:24:45.593653000 usim_process.process_queue                         Overflow for target space id [2024052004205949500000000000000000000000000000000000025] with energy [.5387412261442770476514653923606999390563] and current target energy [9.57572186806903169777707392013617713821]. Set energy to 0.
20.05.2024 04:24:45.605875000 usim_creator.handle_overflow                       [874] Not implemented. Handle overflow for [2024052004205949500000000000000000000000000000000000025] escape strategy [0].
20.05.2024 04:24:45.610162000 usim_process.process_queue                         Overflow for target space id [2024052004205950700000000000000000000000000000000000026] with energy [-.5387412261442770476514653923606999390563] and current target energy [-9.57572186806903169777707392013617713821]. Set energy to 0.
20.05.2024 04:24:45.629001000 usim_creator.handle_overflow                       [874] Not implemented. Handle overflow for [2024052004205950700000000000000000000000000000000000026] escape strategy [0].
20.05.2024 04:24:45.636117000 usim_process.process_queue                         Overflow for target space id [2024052004205952100000000000000000000000000000000000027] with energy [-.5387412261442770476514653923606999390563] and current target energy [-9.57572186806903169777707392013617713821]. Set energy to 0.
20.05.2024 04:24:45.644723000 usim_creator.handle_overflow                       [874] Not implemented. Handle overflow for [2024052004205952100000000000000000000000000000000000027] escape strategy [0].
20.05.2024 04:24:45.660140000 usim_process.process_queue                         Overflow for target space id [2024052004212051500000000000000000000000000000000000074] with energy [.5711475105827514331236917835010101226725] and current target energy [9.93577118304551278306328935161765163637]. Set energy to 0.
20.05.2024 04:24:45.670435000 usim_creator.handle_overflow                       [874] Not implemented. Handle overflow for [2024052004212051500000000000000000000000000000000000074] escape strategy [0].
20.05.2024 04:24:45.673907000 usim_process.process_queue                         Overflow for target space id [2024052004212053400000000000000000000000000000000000075] with energy [.5711475105827514331236917835010101226725] and current target energy [9.93577118304551278306328935161765163637]. Set energy to 0.
20.05.2024 04:24:45.682738000 usim_creator.handle_overflow                       [874] Not implemented. Handle overflow for [2024052004212053400000000000000000000000000000000000075] escape strategy [0].
20.05.2024 04:24:45.686064000 usim_process.process_queue                         Overflow for target space id [2024052004212055400000000000000000000000000000000000076] with energy [-.5711475105827514331236917835010101226725] and current target energy [-9.93577118304551278306328935161765163637]. Set energy to 0.
20.05.2024 04:24:45.708000000 usim_creator.handle_overflow                       [874] Not implemented. Handle overflow for [2024052004212055400000000000000000000000000000000000076] escape strategy [0].
20.05.2024 04:24:45.714059000 usim_process.process_queue                         Overflow for target space id [2024052004212057200000000000000000000000000000000000077] with energy [-.5711475105827514331236917835010101226725] and current target energy [-9.93577118304551278306328935161765163637]. Set energy to 0.
20.05.2024 04:24:45.728354000 usim_creator.handle_overflow                       [874] Not implemented. Handle overflow for [2024052004212057200000000000000000000000000000000000077] escape strategy [0].
20.05.2024 04:24:46.474497000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [1.93100674768257038751209076959754567514] and current target energy [8.99939379185287261765907613044863562439]. Set energy to 0.
20.05.2024 04:24:46.489605000 usim_creator.handle_overflow                       [876] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:24:46.495175000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [1.93100674768257038751209076959754567514] and current target energy [8.99939379185287261765907613044863562439]. Set energy to 0.
20.05.2024 04:24:46.506751000 usim_creator.handle_overflow                       [876] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:24:46.511976000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-1.93100674768257038751209076959754567514] and current target energy [-8.99939379185287261765907613044863562439]. Set energy to 0.
20.05.2024 04:24:46.545860000 usim_creator.handle_overflow                       [876] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:24:46.555111000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-1.93100674768257038751209076959754567514] and current target energy [-8.99939379185287261765907613044863562439]. Set energy to 0.
20.05.2024 04:24:46.565998000 usim_creator.handle_overflow                       [876] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:24:46.603628000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [4.67858197737641004177068404090379044087] and current target energy [7.09319845118399621455578880567163921037]. Set energy to 0.
20.05.2024 04:24:46.631684000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:46.632935000 usim_creator.handle_overflow                       [876] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:24:46.639258000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-4.67858197737641004177068404090379044087] and current target energy [-7.09319845118399621455578880567163921037]. Set energy to 0.
20.05.2024 04:24:46.658912000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:46.659452000 usim_creator.handle_overflow                       [876] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:24:47.405968000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [4.51316430542544914840155395885671752923] and current target energy [6.26691474450915307123940312229837076902]. Set energy to 0.
20.05.2024 04:24:47.422736000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:47.430320000 usim_creator.handle_overflow                       [878] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:24:47.438097000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-4.51316430542544914840155395885671752923] and current target energy [-6.26691474450915307123940312229837076902]. Set energy to 0.
20.05.2024 04:24:47.453263000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:47.453923000 usim_creator.handle_overflow                       [878] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:24:47.813281000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [3.38141767019042435118924965736497772997] and current target energy [7.40405691245167730683408897360404280194]. Set energy to 0.
20.05.2024 04:24:47.833157000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:47.833685000 usim_creator.handle_overflow                       [879] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:24:47.836757000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-3.38141767019042435118924965736497772997] and current target energy [-7.40405691245167730683408897360404280194]. Set energy to 0.
20.05.2024 04:24:47.851918000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:47.861105000 usim_creator.handle_overflow                       [879] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:24:48.241104000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.51316430542544914840155395885671752923] and current target energy [8.62385371371592132193115914569535441584]. Set energy to 0.
20.05.2024 04:24:48.267077000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:48.267833000 usim_creator.handle_overflow                       [880] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:24:48.274997000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.51316430542544914840155395885671752923] and current target energy [-8.62385371371592132193115914569535441584]. Set energy to 0.
20.05.2024 04:24:48.288285000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:48.290600000 usim_creator.handle_overflow                       [880] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:24:49.189239000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [.886039113464565289716332602652870013715] and current target energy [9.6185573654172469159528537362695365612]. Set energy to 0.
20.05.2024 04:24:49.205107000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:49.205665000 usim_creator.handle_overflow                       [882] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:24:49.209262000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [.886039113464565289716332602652870013715] and current target energy [9.6185573654172469159528537362695365612]. Set energy to 0.
20.05.2024 04:24:49.225814000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:49.226329000 usim_creator.handle_overflow                       [882] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:24:49.231819000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-.886039113464565289716332602652870013715] and current target energy [-9.6185573654172469159528537362695365612]. Set energy to 0.
20.05.2024 04:24:49.246435000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:49.248697000 usim_creator.handle_overflow                       [882] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:24:49.258268000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-.886039113464565289716332602652870013715] and current target energy [-9.6185573654172469159528537362695365612]. Set energy to 0.
20.05.2024 04:24:49.272272000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:49.273914000 usim_creator.handle_overflow                       [882] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:24:49.649174000 usim_process.process_queue                         Overflow for target space id [2024052004211570000000000000000000000000000000000000058] with energy [.884743150918576980694044623118743384035] and current target energy [9.75657779758562224491883992044721631455]. Set energy to 0.
20.05.2024 04:24:49.681833000 usim_creator.handle_overflow                       [883] Not implemented. Handle overflow for [2024052004211570000000000000000000000000000000000000058] escape strategy [0].
20.05.2024 04:24:49.696703000 usim_process.process_queue                         Overflow for target space id [2024052004211574500000000000000000000000000000000000059] with energy [.884743150918576980694044623118743384035] and current target energy [9.75657779758562224491883992044721631455]. Set energy to 0.
20.05.2024 04:24:49.714317000 usim_creator.handle_overflow                       [883] Not implemented. Handle overflow for [2024052004211574500000000000000000000000000000000000059] escape strategy [0].
20.05.2024 04:24:49.720176000 usim_process.process_queue                         Overflow for target space id [2024052004211579500000000000000000000000000000000000060] with energy [-.884743150918576980694044623118743384035] and current target energy [-9.75657779758562224491883992044721631455]. Set energy to 0.
20.05.2024 04:24:49.735050000 usim_creator.handle_overflow                       [883] Not implemented. Handle overflow for [2024052004211579500000000000000000000000000000000000060] escape strategy [0].
20.05.2024 04:24:49.739891000 usim_process.process_queue                         Overflow for target space id [2024052004211584300000000000000000000000000000000000061] with energy [-.884743150918576980694044623118743384035] and current target energy [-9.75657779758562224491883992044721631455]. Set energy to 0.
20.05.2024 04:24:49.752308000 usim_creator.handle_overflow                       [883] Not implemented. Handle overflow for [2024052004211584300000000000000000000000000000000000061] escape strategy [0].
20.05.2024 04:24:50.120453000 usim_process.process_queue                         Overflow for target space id [2024052004221223900000000000000000000000000000000000088] with energy [.9879480095234793125961500483553472441825] and current target energy [9.79360288459452365586571092451421986524]. Set energy to 0.
20.05.2024 04:24:50.155566000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:50.156945000 usim_creator.handle_overflow                       [884] Not implemented. Handle overflow for [2024052004221223900000000000000000000000000000000000088] escape strategy [7].
20.05.2024 04:24:50.164270000 usim_process.process_queue                         Overflow for target space id [2024052004221227000000000000000000000000000000000000089] with energy [.9879480095234793125961500483553472441825] and current target energy [9.79360288459452365586571092451421986524]. Set energy to 0.
20.05.2024 04:24:50.179620000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:50.180129000 usim_creator.handle_overflow                       [884] Not implemented. Handle overflow for [2024052004221227000000000000000000000000000000000000089] escape strategy [7].
20.05.2024 04:24:50.184894000 usim_process.process_queue                         Overflow for target space id [2024052004221231900000000000000000000000000000000000090] with energy [-.9879480095234793125961500483553472441825] and current target energy [-9.79360288459452365586571092451421986524]. Set energy to 0.
20.05.2024 04:24:50.198910000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:50.199892000 usim_creator.handle_overflow                       [884] Not implemented. Handle overflow for [2024052004221231900000000000000000000000000000000000090] escape strategy [7].
20.05.2024 04:24:50.204536000 usim_process.process_queue                         Overflow for target space id [2024052004221235100000000000000000000000000000000000091] with energy [-.9879480095234793125961500483553472441825] and current target energy [-9.79360288459452365586571092451421986524]. Set energy to 0.
20.05.2024 04:24:50.222863000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:50.223794000 usim_creator.handle_overflow                       [884] Not implemented. Handle overflow for [2024052004221235100000000000000000000000000000000000091] escape strategy [7].
20.05.2024 04:24:50.649033000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [1.95104074006659695242513689164921841695] and current target energy [9.02632861085089829680310791771343505845]. Set energy to 0.
20.05.2024 04:24:50.665938000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:50.666493000 usim_creator.handle_overflow                       [885] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:24:50.671696000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-1.95104074006659695242513689164921841695] and current target energy [-9.02632861085089829680310791771343505845]. Set energy to 0.
20.05.2024 04:24:50.687627000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:50.688938000 usim_creator.handle_overflow                       [885] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:24:50.724833000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [1.52163795158569095803516234581423997849] and current target energy [9.35716395475282008354136808180758088174]. Set energy to 0.
20.05.2024 04:24:50.756619000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:50.759063000 usim_creator.handle_overflow                       [885] Not implemented. Handle overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [7].
20.05.2024 04:24:50.765787000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-1.52163795158569095803516234581423997849] and current target energy [-9.35716395475282008354136808180758088174]. Set energy to 0.
20.05.2024 04:24:50.780327000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:50.781334000 usim_creator.handle_overflow                       [885] Not implemented. Handle overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [7].
20.05.2024 04:24:51.186395000 usim_process.process_queue                         Overflow for target space id [2024052004211990800000000000000000000000000000000000070] with energy [2.44625879954281076076271851311780760383] and current target energy [8.62453520317661259312364309909921281011]. Set energy to 0.
20.05.2024 04:24:51.211959000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:51.212489000 usim_creator.handle_overflow                       [886] Not implemented. Handle overflow for [2024052004211990800000000000000000000000000000000000070] escape strategy [7].
20.05.2024 04:24:51.218035000 usim_process.process_queue                         Overflow for target space id [2024052004211994200000000000000000000000000000000000071] with energy [2.44625879954281076076271851311780760383] and current target energy [8.62453520317661259312364309909921281011]. Set energy to 0.
20.05.2024 04:24:51.235222000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:51.235740000 usim_creator.handle_overflow                       [886] Not implemented. Handle overflow for [2024052004211994200000000000000000000000000000000000071] escape strategy [7].
20.05.2024 04:24:51.240368000 usim_process.process_queue                         Overflow for target space id [2024052004211998600000000000000000000000000000000000072] with energy [-2.44625879954281076076271851311780760383] and current target energy [-8.62453520317661259312364309909921281011]. Set energy to 0.
20.05.2024 04:24:51.258981000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:51.259901000 usim_creator.handle_overflow                       [886] Not implemented. Handle overflow for [2024052004211998600000000000000000000000000000000000072] escape strategy [7].
20.05.2024 04:24:51.266060000 usim_process.process_queue                         Overflow for target space id [2024052004212000300000000000000000000000000000000000073] with energy [-2.44625879954281076076271851311780760383] and current target energy [-8.62453520317661259312364309909921281011]. Set energy to 0.
20.05.2024 04:24:51.292910000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:51.296238000 usim_creator.handle_overflow                       [886] Not implemented. Handle overflow for [2024052004212000300000000000000000000000000000000000073] escape strategy [7].
20.05.2024 04:24:52.450064000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.95104074006659695242513689164921841695] and current target energy [9.7107578299164985381807924518914962468]. Set energy to 0.
20.05.2024 04:24:52.478223000 usim_creator.handle_overflow                       [889] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:24:52.481617000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.95104074006659695242513689164921841695] and current target energy [-9.7107578299164985381807924518914962468]. Set energy to 0.
20.05.2024 04:24:52.502560000 usim_creator.handle_overflow                       [889] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:24:53.437567000 usim_process.process_queue                         Overflow for target space id [2024052004213975700000000000000000000000000000000000082] with energy [.28824721405176192355947467236977979427] and current target energy [9.7850351981712430430508740524712304153]. Set energy to 0.
20.05.2024 04:24:53.458771000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:53.460691000 usim_creator.handle_overflow                       [891] Not implemented. Handle overflow for [2024052004213975700000000000000000000000000000000000082] escape strategy [7].
20.05.2024 04:24:53.466081000 usim_process.process_queue                         Overflow for target space id [2024052004213980000000000000000000000000000000000000083] with energy [.28824721405176192355947467236977979427] and current target energy [9.7850351981712430430508740524712304153]. Set energy to 0.
20.05.2024 04:24:53.482598000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:53.483103000 usim_creator.handle_overflow                       [891] Not implemented. Handle overflow for [2024052004213980000000000000000000000000000000000000083] escape strategy [7].
20.05.2024 04:24:53.486319000 usim_process.process_queue                         Overflow for target space id [2024052004213983100000000000000000000000000000000000084] with energy [-.28824721405176192355947467236977979427] and current target energy [-9.7850351981712430430508740524712304153]. Set energy to 0.
20.05.2024 04:24:53.501668000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:53.503029000 usim_creator.handle_overflow                       [891] Not implemented. Handle overflow for [2024052004213983100000000000000000000000000000000000084] escape strategy [7].
20.05.2024 04:24:53.507258000 usim_process.process_queue                         Overflow for target space id [2024052004213986900000000000000000000000000000000000085] with energy [-.28824721405176192355947467236977979427] and current target energy [-9.7850351981712430430508740524712304153]. Set energy to 0.
20.05.2024 04:24:53.522806000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:53.523347000 usim_creator.handle_overflow                       [891] Not implemented. Handle overflow for [2024052004213986900000000000000000000000000000000000085] escape strategy [7].
20.05.2024 04:24:53.923940000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [4.35664291109772327547249977134389206962] and current target energy [6.76283534038084870237849931472995545993]. Set energy to 0.
20.05.2024 04:24:53.936920000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:53.937255000 usim_creator.handle_overflow                       [892] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:24:53.943680000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-4.35664291109772327547249977134389206962] and current target energy [-6.76283534038084870237849931472995545993]. Set energy to 0.
20.05.2024 04:24:53.958583000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:53.959446000 usim_creator.handle_overflow                       [892] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:24:56.126382000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.07988808731065968183102753747629515132] and current target energy [7.13241118744985824438527259225805222956]. Set energy to 0.
20.05.2024 04:24:56.141951000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:56.142473000 usim_creator.handle_overflow                       [898] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:24:56.146996000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.07988808731065968183102753747629515132] and current target energy [7.13241118744985824438527259225805222956]. Set energy to 0.
20.05.2024 04:24:56.164890000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:56.165862000 usim_creator.handle_overflow                       [898] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:24:56.170863000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.07988808731065968183102753747629515132] and current target energy [-7.13241118744985824438527259225805222956]. Set energy to 0.
20.05.2024 04:24:56.208928000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:56.209838000 usim_creator.handle_overflow                       [898] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:24:56.213871000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.07988808731065968183102753747629515132] and current target energy [-7.13241118744985824438527259225805222956]. Set energy to 0.
20.05.2024 04:24:56.232768000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:56.233285000 usim_creator.handle_overflow                       [898] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:24:56.237681000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.07988808731065968183102753747629515132] and current target energy [8.00937839198176465611913537840778391139]. Set energy to 0.
20.05.2024 04:24:56.256133000 usim_creator.handle_overflow                       [898] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:24:56.262253000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.07988808731065968183102753747629515132] and current target energy [8.00937839198176465611913537840778391139]. Set energy to 0.
20.05.2024 04:24:56.276282000 usim_creator.handle_overflow                       [898] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:24:56.283248000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.07988808731065968183102753747629515132] and current target energy [-8.00937839198176465611913537840778391139]. Set energy to 0.
20.05.2024 04:24:56.298163000 usim_creator.handle_overflow                       [898] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:24:56.301949000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.07988808731065968183102753747629515132] and current target energy [-8.00937839198176465611913537840778391139]. Set energy to 0.
20.05.2024 04:24:56.317638000 usim_creator.handle_overflow                       [898] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:24:58.930507000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.75212395865080439648889556123754668188] and current target energy [9.26234005311255783671029740591953157134]. Set energy to 0.
20.05.2024 04:24:58.962752000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:58.963069000 usim_creator.handle_overflow                       [906] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:24:58.966269000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.75212395865080439648889556123754668188] and current target energy [-9.26234005311255783671029740591953157134]. Set energy to 0.
20.05.2024 04:24:58.980577000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:58.985251000 usim_creator.handle_overflow                       [906] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:24:59.083459000 usim_process.process_queue                         Overflow for target space id [2024052004221501800000000000000000000000000000000000092] with energy [4.70320230691478328231937642228033570489] and current target energy [8.84076851413593408615350250893267397445]. Set energy to 0.
20.05.2024 04:24:59.120755000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:59.127179000 usim_creator.handle_overflow                       [906] Not implemented. Handle overflow for [2024052004221501800000000000000000000000000000000000092] escape strategy [7].
20.05.2024 04:24:59.132277000 usim_process.process_queue                         Overflow for target space id [2024052004221505600000000000000000000000000000000000093] with energy [-4.70320230691478328231937642228033570489] and current target energy [-8.84076851413593408615350250893267397445]. Set energy to 0.
20.05.2024 04:24:59.142711000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:59.143393000 usim_creator.handle_overflow                       [906] Not implemented. Handle overflow for [2024052004221505600000000000000000000000000000000000093] escape strategy [7].
20.05.2024 04:24:59.396924000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.80939986663691981281690533014232547931] and current target energy [9.94190203158749941911490303732702094148]. Set energy to 0.
20.05.2024 04:24:59.434196000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:59.435148000 usim_creator.handle_overflow                       [907] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:24:59.441154000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.80939986663691981281690533014232547931] and current target energy [9.94190203158749941911490303732702094148]. Set energy to 0.
20.05.2024 04:24:59.458095000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:59.458620000 usim_creator.handle_overflow                       [907] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:24:59.461700000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.80939986663691981281690533014232547931] and current target energy [-9.94190203158749941911490303732702094148]. Set energy to 0.
20.05.2024 04:24:59.471878000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:59.472231000 usim_creator.handle_overflow                       [907] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:24:59.475712000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.80939986663691981281690533014232547931] and current target energy [-9.94190203158749941911490303732702094148]. Set energy to 0.
20.05.2024 04:24:59.485719000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:24:59.486070000 usim_creator.handle_overflow                       [907] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:25:00.257518000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [1.44636679956042403047638034719430772212] and current target energy [9.40640461382956656463875284456067140978]. Set energy to 0.
20.05.2024 04:25:00.272188000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:00.272717000 usim_creator.handle_overflow                       [909] Not implemented. Handle overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [7].
20.05.2024 04:25:00.278888000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-1.44636679956042403047638034719430772212] and current target energy [-9.40640461382956656463875284456067140978]. Set energy to 0.
20.05.2024 04:25:00.297275000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:00.298176000 usim_creator.handle_overflow                       [909] Not implemented. Handle overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [7].
20.05.2024 04:25:00.594945000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.75212395865080439648889556123754668188] and current target energy [7.23759946654767925126762132056930191725]. Set energy to 0.
20.05.2024 04:25:00.616306000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:00.617849000 usim_creator.handle_overflow                       [910] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:25:00.623207000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.75212395865080439648889556123754668188] and current target energy [7.23759946654767925126762132056930191725]. Set energy to 0.
20.05.2024 04:25:00.636478000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:00.637726000 usim_creator.handle_overflow                       [910] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:25:00.642886000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.75212395865080439648889556123754668188] and current target energy [-7.23759946654767925126762132056930191725]. Set energy to 0.
20.05.2024 04:25:00.667391000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:00.678982000 usim_creator.handle_overflow                       [910] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:25:00.694456000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.75212395865080439648889556123754668188] and current target energy [-7.23759946654767925126762132056930191725]. Set energy to 0.
20.05.2024 04:25:00.727208000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:00.728180000 usim_creator.handle_overflow                       [910] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:25:01.167043000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.23889798402862710008541047423769939219] and current target energy [9.50424791730160879297779112247509336375]. Set energy to 0.
20.05.2024 04:25:01.190230000 usim_creator.handle_overflow                       [911] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:25:01.196704000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.23889798402862710008541047423769939219] and current target energy [-9.50424791730160879297779112247509336375]. Set energy to 0.
20.05.2024 04:25:01.214522000 usim_creator.handle_overflow                       [911] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:25:01.239456000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [4.98602035676159952156200159009433442255] and current target energy [9.437145363635667211030605722654040789]. Set energy to 0.
20.05.2024 04:25:01.249566000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:01.250482000 usim_creator.handle_overflow                       [911] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:25:01.253686000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-4.98602035676159952156200159009433442255] and current target energy [-9.437145363635667211030605722654040789]. Set energy to 0.
20.05.2024 04:25:01.264243000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:01.265096000 usim_creator.handle_overflow                       [911] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:25:01.586439000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [.5316637808228362642788143463554373711825] and current target energy [9.91118387222901680068328379390159513753]. Set energy to 0.
20.05.2024 04:25:01.602670000 usim_creator.handle_overflow                       [912] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:25:01.610127000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [.5316637808228362642788143463554373711825] and current target energy [9.91118387222901680068328379390159513753]. Set energy to 0.
20.05.2024 04:25:01.625307000 usim_creator.handle_overflow                       [912] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:25:01.630377000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-.5316637808228362642788143463554373711825] and current target energy [-9.91118387222901680068328379390159513753]. Set energy to 0.
20.05.2024 04:25:01.653550000 usim_creator.handle_overflow                       [912] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:25:01.659876000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-.5316637808228362642788143463554373711825] and current target energy [-9.91118387222901680068328379390159513753]. Set energy to 0.
20.05.2024 04:25:01.676264000 usim_creator.handle_overflow                       [912] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:25:02.344335000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [2.38402761181508730120442247204290395783] and current target energy [9.53611044726034920481768988817161583131]. Set energy to 0.
20.05.2024 04:25:02.364980000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:02.365512000 usim_creator.handle_overflow                       [914] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:25:02.367663000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-2.38402761181508730120442247204290395783] and current target energy [-9.53611044726034920481768988817161583131]. Set energy to 0.
20.05.2024 04:25:02.375503000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:02.376111000 usim_creator.handle_overflow                       [914] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:25:02.769995000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [3.31250240754450922734314822191054280697] and current target energy [9.56797297721908961665758865386813829886]. Set energy to 0.
20.05.2024 04:25:02.785940000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:02.792297000 usim_creator.handle_overflow                       [915] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:25:02.798659000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-3.31250240754450922734314822191054280697] and current target energy [-9.56797297721908961665758865386813829886]. Set energy to 0.
20.05.2024 04:25:02.814875000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:02.815837000 usim_creator.handle_overflow                       [915] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:25:03.151069000 usim_process.process_queue                         Overflow for target space id [2024052004233397700000000000000000000000000000000000100] with energy [1.76110530277360468988579449688456683084] and current target energy [9.76289886756308681261678611233001401979]. Set energy to 0.
20.05.2024 04:25:03.179449000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:03.179995000 usim_creator.handle_overflow                       [916] Not implemented. Handle overflow for [2024052004233397700000000000000000000000000000000000100] escape strategy [7].
20.05.2024 04:25:03.183315000 usim_process.process_queue                         Overflow for target space id [2024052004233401700000000000000000000000000000000000101] with energy [1.76110530277360468988579449688456683084] and current target energy [9.76289886756308681261678611233001401979]. Set energy to 0.
20.05.2024 04:25:03.203870000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:03.204966000 usim_creator.handle_overflow                       [916] Not implemented. Handle overflow for [2024052004233401700000000000000000000000000000000000101] escape strategy [7].
20.05.2024 04:25:03.216168000 usim_process.process_queue                         Overflow for target space id [2024052004233403400000000000000000000000000000000000102] with energy [-1.76110530277360468988579449688456683084] and current target energy [-9.76289886756308681261678611233001401979]. Set energy to 0.
20.05.2024 04:25:03.230746000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:03.231280000 usim_creator.handle_overflow                       [916] Not implemented. Handle overflow for [2024052004233403400000000000000000000000000000000000102] escape strategy [7].
20.05.2024 04:25:03.237665000 usim_process.process_queue                         Overflow for target space id [2024052004233409100000000000000000000000000000000000103] with energy [-1.76110530277360468988579449688456683084] and current target energy [-9.76289886756308681261678611233001401979]. Set energy to 0.
20.05.2024 04:25:03.252026000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:03.252530000 usim_creator.handle_overflow                       [916] Not implemented. Handle overflow for [2024052004233409100000000000000000000000000000000000103] escape strategy [7].
20.05.2024 04:25:03.602751000 usim_process.process_queue                         Overflow for target space id [2024052004210931900000000000000000000000000000000000044] with energy [1.07572137546249468787998183673715496945] and current target energy [9.43683462166133178323414938689031940061]. Set energy to 0.
20.05.2024 04:25:03.625995000 usim_creator.handle_overflow                       [917] Not implemented. Handle overflow for [2024052004210931900000000000000000000000000000000000044] escape strategy [0].
20.05.2024 04:25:03.641001000 usim_process.process_queue                         Overflow for target space id [2024052004210936800000000000000000000000000000000000045] with energy [1.07572137546249468787998183673715496945] and current target energy [9.43683462166133178323414938689031940061]. Set energy to 0.
20.05.2024 04:25:03.656987000 usim_creator.handle_overflow                       [917] Not implemented. Handle overflow for [2024052004210936800000000000000000000000000000000000045] escape strategy [0].
20.05.2024 04:25:03.662302000 usim_process.process_queue                         Overflow for target space id [2024052004210941800000000000000000000000000000000000046] with energy [-1.07572137546249468787998183673715496945] and current target energy [-9.43683462166133178323414938689031940061]. Set energy to 0.
20.05.2024 04:25:03.677104000 usim_creator.handle_overflow                       [917] Not implemented. Handle overflow for [2024052004210941800000000000000000000000000000000000046] escape strategy [0].
20.05.2024 04:25:03.682981000 usim_process.process_queue                         Overflow for target space id [2024052004210944800000000000000000000000000000000000047] with energy [-1.07572137546249468787998183673715496945] and current target energy [-9.43683462166133178323414938689031940061]. Set energy to 0.
20.05.2024 04:25:03.702128000 usim_creator.handle_overflow                       [917] Not implemented. Handle overflow for [2024052004210944800000000000000000000000000000000000047] escape strategy [0].
20.05.2024 04:25:05.012413000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [1.22840478506331189601420048020085658185] and current target energy [9.97204071352319904312400318018866884509]. Set energy to 0.
20.05.2024 04:25:05.035862000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:05.036403000 usim_creator.handle_overflow                       [920] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:25:05.042977000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-1.22840478506331189601420048020085658185] and current target energy [-9.97204071352319904312400318018866884509]. Set energy to 0.
20.05.2024 04:25:05.067986000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:05.073578000 usim_creator.handle_overflow                       [920] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:25:05.858614000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.93411444747127542802636441206977419345] and current target energy [5.84831773523388603576709887673024877155]. Set energy to 0.
20.05.2024 04:25:05.881222000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:05.883814000 usim_creator.handle_overflow                       [922] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:25:05.894108000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.93411444747127542802636441206977419345] and current target energy [5.84831773523388603576709887673024877155]. Set energy to 0.
20.05.2024 04:25:05.910695000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:05.911621000 usim_creator.handle_overflow                       [922] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:25:05.916497000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.93411444747127542802636441206977419345] and current target energy [-5.84831773523388603576709887673024877155]. Set energy to 0.
20.05.2024 04:25:05.932871000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:05.934052000 usim_creator.handle_overflow                       [922] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:25:05.943870000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.93411444747127542802636441206977419345] and current target energy [-5.84831773523388603576709887673024877155]. Set energy to 0.
20.05.2024 04:25:05.959428000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:05.959968000 usim_creator.handle_overflow                       [922] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:25:05.963080000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.93411444747127542802636441206977419345] and current target energy [6.32003160296664564183691529471156038403]. Set energy to 0.
20.05.2024 04:25:05.979056000 usim_creator.handle_overflow                       [922] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:25:05.985241000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.93411444747127542802636441206977419345] and current target energy [6.32003160296664564183691529471156038403]. Set energy to 0.
20.05.2024 04:25:05.999763000 usim_creator.handle_overflow                       [922] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:25:06.005832000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.93411444747127542802636441206977419345] and current target energy [-6.32003160296664564183691529471156038403]. Set energy to 0.
20.05.2024 04:25:06.019859000 usim_creator.handle_overflow                       [922] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:25:06.024965000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.93411444747127542802636441206977419345] and current target energy [-6.32003160296664564183691529471156038403]. Set energy to 0.
20.05.2024 04:25:06.037489000 usim_creator.handle_overflow                       [922] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:25:06.042195000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [2.47024142556597088029467157184136143423] and current target energy [9.27036956025435931322049146862591339542]. Set energy to 0.
20.05.2024 04:25:06.068979000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:06.070021000 usim_creator.handle_overflow                       [922] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:25:06.080678000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [2.47024142556597088029467157184136143423] and current target energy [9.27036956025435931322049146862591339542]. Set energy to 0.
20.05.2024 04:25:06.104728000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:06.111917000 usim_creator.handle_overflow                       [922] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:25:06.118926000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-2.47024142556597088029467157184136143423] and current target energy [-9.27036956025435931322049146862591339542]. Set energy to 0.
20.05.2024 04:25:06.137869000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:06.138391000 usim_creator.handle_overflow                       [922] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:25:06.144920000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-2.47024142556597088029467157184136143423] and current target energy [-9.27036956025435931322049146862591339542]. Set energy to 0.
20.05.2024 04:25:06.165130000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:06.165634000 usim_creator.handle_overflow                       [922] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:25:06.973781000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [2.06235071128790780156594110306360937746] and current target energy [8.24940284515163120626376441225443750981]. Set energy to 0.
20.05.2024 04:25:06.995206000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:06.996816000 usim_creator.handle_overflow                       [924] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:25:07.003294000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-2.06235071128790780156594110306360937746] and current target energy [-8.24940284515163120626376441225443750981]. Set energy to 0.
20.05.2024 04:25:07.020901000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:07.021852000 usim_creator.handle_overflow                       [924] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:25:08.289463000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [.7021191854264488793557526741075554056063] and current target energy [9.8682288949425508560527288241395483869]. Set energy to 0.
20.05.2024 04:25:08.299808000 usim_creator.handle_overflow                       [927] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:25:08.303514000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-.7021191854264488793557526741075554056063] and current target energy [-9.8682288949425508560527288241395483869]. Set energy to 0.
20.05.2024 04:25:08.321058000 usim_creator.handle_overflow                       [927] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:25:09.283843000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.96044206912237255662941432495106926988] and current target energy [6.59175864631145331714506441216210585164]. Set energy to 0.
20.05.2024 04:25:09.301179000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:09.301829000 usim_creator.handle_overflow                       [929] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:25:09.308242000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.96044206912237255662941432495106926988] and current target energy [-6.59175864631145331714506441216210585164]. Set energy to 0.
20.05.2024 04:25:09.327107000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:09.327650000 usim_creator.handle_overflow                       [929] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:25:09.349184000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [3.27440729384646436932124218682634097805] and current target energy [6.93180011474561252777117912174182605575]. Set energy to 0.
20.05.2024 04:25:09.390381000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:09.393938000 usim_creator.handle_overflow                       [929] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:25:09.399191000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-3.27440729384646436932124218682634097805] and current target energy [-6.93180011474561252777117912174182605575]. Set energy to 0.
20.05.2024 04:25:09.422153000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:09.423771000 usim_creator.handle_overflow                       [929] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:25:11.999139000 usim_process.process_queue                         Overflow for target space id [2024052004211050800000000000000000000000000000000000048] with energy [1.94832177390326452646633501846605372567] and current target energy [9.88096570226388352117868628736544573692]. Set energy to 0.
20.05.2024 04:25:12.013066000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:12.013245000 usim_creator.handle_overflow                       [935] Not implemented. Handle overflow for [2024052004211050800000000000000000000000000000000000048] escape strategy [7].
20.05.2024 04:25:12.015443000 usim_process.process_queue                         Overflow for target space id [2024052004211052100000000000000000000000000000000000049] with energy [1.94832177390326452646633501846605372567] and current target energy [9.88096570226388352117868628736544573692]. Set energy to 0.
20.05.2024 04:25:12.021389000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:12.022047000 usim_creator.handle_overflow                       [935] Not implemented. Handle overflow for [2024052004211052100000000000000000000000000000000000049] escape strategy [7].
20.05.2024 04:25:12.025921000 usim_process.process_queue                         Overflow for target space id [2024052004211053400000000000000000000000000000000000050] with energy [-1.94832177390326452646633501846605372567] and current target energy [-9.88096570226388352117868628736544573692]. Set energy to 0.
20.05.2024 04:25:12.034830000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:12.035500000 usim_creator.handle_overflow                       [935] Not implemented. Handle overflow for [2024052004211053400000000000000000000000000000000000050] escape strategy [7].
20.05.2024 04:25:12.039775000 usim_process.process_queue                         Overflow for target space id [2024052004211054800000000000000000000000000000000000051] with energy [-1.94832177390326452646633501846605372567] and current target energy [-9.88096570226388352117868628736544573692]. Set energy to 0.
20.05.2024 04:25:12.049982000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:12.050658000 usim_creator.handle_overflow                       [935] Not implemented. Handle overflow for [2024052004211054800000000000000000000000000000000000051] escape strategy [7].
20.05.2024 04:25:12.491508000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [1.94341452401050961786577347408206627114] and current target energy [9.92088413824474511325882864990213853976]. Set energy to 0.
20.05.2024 04:25:12.510530000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:12.512149000 usim_creator.handle_overflow                       [936] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:25:12.517855000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-1.94341452401050961786577347408206627114] and current target energy [-9.92088413824474511325882864990213853976]. Set energy to 0.
20.05.2024 04:25:12.529927000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:12.531015000 usim_creator.handle_overflow                       [936] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:25:12.802755000 usim_process.process_queue                         Overflow for target space id [2024052004223175000000000000000000000000000000000000094] with energy [4.75785874907727845360368325491835371395] and current target energy [7.23183399780212015238190173597153861059]. Set energy to 0.
20.05.2024 04:25:12.818103000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:12.818844000 usim_creator.handle_overflow                       [937] Not implemented. Handle overflow for [2024052004223175000000000000000000000000000000000000094] escape strategy [7].
20.05.2024 04:25:12.825039000 usim_process.process_queue                         Overflow for target space id [2024052004223178700000000000000000000000000000000000095] with energy [-4.75785874907727845360368325491835371395] and current target energy [-7.23183399780212015238190173597153861059]. Set energy to 0.
20.05.2024 04:25:12.847760000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:12.851952000 usim_creator.handle_overflow                       [937] Not implemented. Handle overflow for [2024052004223178700000000000000000000000000000000000095] escape strategy [7].
20.05.2024 04:25:13.120293000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.00414146672051310889098563769163648815] and current target energy [7.77365809604203847146309389632826508453]. Set energy to 0.
20.05.2024 04:25:13.143265000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:13.143980000 usim_creator.handle_overflow                       [938] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:25:13.149281000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.00414146672051310889098563769163648815] and current target energy [-7.77365809604203847146309389632826508453]. Set energy to 0.
20.05.2024 04:25:13.169289000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:13.178153000 usim_creator.handle_overflow                       [938] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:25:13.183839000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.00414146672051310889098563769163648815] and current target energy [9.26360379538253978915728300922268026192]. Set energy to 0.
20.05.2024 04:25:13.206136000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:13.206653000 usim_creator.handle_overflow                       [938] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:25:13.211337000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.00414146672051310889098563769163648815] and current target energy [9.26360379538253978915728300922268026192]. Set energy to 0.
20.05.2024 04:25:13.228575000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:13.229830000 usim_creator.handle_overflow                       [938] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:25:13.235138000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.00414146672051310889098563769163648815] and current target energy [-9.26360379538253978915728300922268026192]. Set energy to 0.
20.05.2024 04:25:13.258368000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:13.261845000 usim_creator.handle_overflow                       [938] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:25:13.267178000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.00414146672051310889098563769163648815] and current target energy [-9.26360379538253978915728300922268026192]. Set energy to 0.
20.05.2024 04:25:13.289227000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:13.292872000 usim_creator.handle_overflow                       [938] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:25:13.299196000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [4.00414146672051310889098563769163648815] and current target energy [9.31678254519800052363404922746516477658]. Set energy to 0.
20.05.2024 04:25:13.312770000 usim_creator.handle_overflow                       [938] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:25:13.319210000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [4.00414146672051310889098563769163648815] and current target energy [9.31678254519800052363404922746516477658]. Set energy to 0.
20.05.2024 04:25:13.334206000 usim_creator.handle_overflow                       [938] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:25:13.340824000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-4.00414146672051310889098563769163648815] and current target energy [-9.31678254519800052363404922746516477658]. Set energy to 0.
20.05.2024 04:25:13.359819000 usim_creator.handle_overflow                       [938] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:25:13.365728000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-4.00414146672051310889098563769163648815] and current target energy [-9.31678254519800052363404922746516477658]. Set energy to 0.
20.05.2024 04:25:13.385880000 usim_creator.handle_overflow                       [938] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:25:13.851337000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [4.75785874907727845360368325491835371395] and current target energy [6.0141338002652975401273098949246453567]. Set energy to 0.
20.05.2024 04:25:13.867112000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:13.867993000 usim_creator.handle_overflow                       [939] Not implemented. Handle overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [7].
20.05.2024 04:25:13.872116000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-4.75785874907727845360368325491835371395] and current target energy [-6.0141338002652975401273098949246453567]. Set energy to 0.
20.05.2024 04:25:13.886489000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:13.886838000 usim_creator.handle_overflow                       [939] Not implemented. Handle overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [7].
20.05.2024 04:25:14.529723000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [2.75980850125434347155545411373745298193] and current target energy [7.78490870600641981764996067376261955292]. Set energy to 0.
20.05.2024 04:25:14.544006000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:14.545087000 usim_creator.handle_overflow                       [941] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:25:14.551258000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-2.75980850125434347155545411373745298193] and current target energy [-7.78490870600641981764996067376261955292]. Set energy to 0.
20.05.2024 04:25:14.565127000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:14.565643000 usim_creator.handle_overflow                       [941] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:25:14.568761000 usim_process.process_queue                         Overflow for target space id [2024052004225249900000000000000000000000000000000000096] with energy [2.07388646444453296645464894305012153493] and current target energy [8.46855907878276778781299488149559493904]. Set energy to 0.
20.05.2024 04:25:14.592611000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:14.600689000 usim_creator.handle_overflow                       [941] Not implemented. Handle overflow for [2024052004225249900000000000000000000000000000000000096] escape strategy [7].
20.05.2024 04:25:14.606531000 usim_process.process_queue                         Overflow for target space id [2024052004225253800000000000000000000000000000000000097] with energy [2.07388646444453296645464894305012153493] and current target energy [8.46855907878276778781299488149559493904]. Set energy to 0.
20.05.2024 04:25:14.621623000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:14.625888000 usim_creator.handle_overflow                       [941] Not implemented. Handle overflow for [2024052004225253800000000000000000000000000000000000097] escape strategy [7].
20.05.2024 04:25:14.632173000 usim_process.process_queue                         Overflow for target space id [2024052004225256200000000000000000000000000000000000098] with energy [-2.07388646444453296645464894305012153493] and current target energy [-8.46855907878276778781299488149559493904]. Set energy to 0.
20.05.2024 04:25:14.646465000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:14.646992000 usim_creator.handle_overflow                       [941] Not implemented. Handle overflow for [2024052004225256200000000000000000000000000000000000098] escape strategy [7].
20.05.2024 04:25:14.650258000 usim_process.process_queue                         Overflow for target space id [2024052004225260100000000000000000000000000000000000099] with energy [-2.07388646444453296645464894305012153493] and current target energy [-8.46855907878276778781299488149559493904]. Set energy to 0.
20.05.2024 04:25:14.668768000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:14.669644000 usim_creator.handle_overflow                       [941] Not implemented. Handle overflow for [2024052004225260100000000000000000000000000000000000099] escape strategy [7].
20.05.2024 04:25:15.071372000 usim_process.process_queue                         Overflow for target space id [2024052004211134000000000000000000000000000000000000052] with energy [.8553904731206028368176351364263160767288] and current target energy [9.37387786010022806575378035930133288697]. Set energy to 0.
20.05.2024 04:25:15.087147000 usim_creator.handle_overflow                       [942] Not implemented. Handle overflow for [2024052004211134000000000000000000000000000000000000052] escape strategy [0].
20.05.2024 04:25:15.096812000 usim_process.process_queue                         Overflow for target space id [2024052004211138700000000000000000000000000000000000053] with energy [.8553904731206028368176351364263160767288] and current target energy [9.37387786010022806575378035930133288697]. Set energy to 0.
20.05.2024 04:25:15.110255000 usim_creator.handle_overflow                       [942] Not implemented. Handle overflow for [2024052004211138700000000000000000000000000000000000053] escape strategy [0].
20.05.2024 04:25:15.117681000 usim_process.process_queue                         Overflow for target space id [2024052004211143900000000000000000000000000000000000054] with energy [-.8553904731206028368176351364263160767288] and current target energy [-9.37387786010022806575378035930133288697]. Set energy to 0.
20.05.2024 04:25:15.135908000 usim_creator.handle_overflow                       [942] Not implemented. Handle overflow for [2024052004211143900000000000000000000000000000000000054] escape strategy [0].
20.05.2024 04:25:15.140939000 usim_process.process_queue                         Overflow for target space id [2024052004211147900000000000000000000000000000000000055] with energy [-.8553904731206028368176351364263160767288] and current target energy [-9.37387786010022806575378035930133288697]. Set energy to 0.
20.05.2024 04:25:15.157101000 usim_creator.handle_overflow                       [942] Not implemented. Handle overflow for [2024052004211147900000000000000000000000000000000000055] escape strategy [0].
20.05.2024 04:25:16.142731000 usim_process.process_queue                         Overflow for target space id [2024052004210570400000000000000000000000000000000000038] with energy [.2952654367016913083259132765985473082813] and current target energy [9.81837552550970697543058261960424215129]. Set energy to 0.
20.05.2024 04:25:16.174901000 usim_creator.handle_overflow                       [944] Not implemented. Handle overflow for [2024052004210570400000000000000000000000000000000000038] escape strategy [0].
20.05.2024 04:25:16.182944000 usim_process.process_queue                         Overflow for target space id [2024052004210571900000000000000000000000000000000000039] with energy [.2952654367016913083259132765985473082813] and current target energy [9.81837552550970697543058261960424215129]. Set energy to 0.
20.05.2024 04:25:16.204718000 usim_creator.handle_overflow                       [944] Not implemented. Handle overflow for [2024052004210571900000000000000000000000000000000000039] escape strategy [0].
20.05.2024 04:25:16.210904000 usim_process.process_queue                         Overflow for target space id [2024052004210573600000000000000000000000000000000000040] with energy [-.2952654367016913083259132765985473082813] and current target energy [-9.81837552550970697543058261960424215129]. Set energy to 0.
20.05.2024 04:25:16.223502000 usim_creator.handle_overflow                       [944] Not implemented. Handle overflow for [2024052004210573600000000000000000000000000000000000040] escape strategy [0].
20.05.2024 04:25:16.229080000 usim_process.process_queue                         Overflow for target space id [2024052004210575900000000000000000000000000000000000041] with energy [-.2952654367016913083259132765985473082813] and current target energy [-9.81837552550970697543058261960424215129]. Set energy to 0.
20.05.2024 04:25:16.261058000 usim_creator.handle_overflow                       [944] Not implemented. Handle overflow for [2024052004210575900000000000000000000000000000000000041] escape strategy [0].
20.05.2024 04:25:16.661133000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [1.58083031123561380817829788525454911561] and current target energy [9.00931830012115449500471768480618209833]. Set energy to 0.
20.05.2024 04:25:16.681804000 usim_creator.handle_overflow                       [945] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:25:16.689619000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-1.58083031123561380817829788525454911561] and current target energy [-9.00931830012115449500471768480618209833]. Set energy to 0.
20.05.2024 04:25:16.708798000 usim_creator.handle_overflow                       [945] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:25:16.749437000 usim_process.process_queue                         Overflow for target space id [2024052004210797700000000000000000000000000000000000042] with energy [3.84096491540767646382126246500628208794] and current target energy [9.4749598802494300651080100930151775654]. Set energy to 0.
20.05.2024 04:25:16.767034000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:16.768842000 usim_creator.handle_overflow                       [945] Not implemented. Handle overflow for [2024052004210797700000000000000000000000000000000000042] escape strategy [7].
20.05.2024 04:25:16.775654000 usim_process.process_queue                         Overflow for target space id [2024052004210803800000000000000000000000000000000000043] with energy [-3.84096491540767646382126246500628208794] and current target energy [-9.4749598802494300651080100930151775654]. Set energy to 0.
20.05.2024 04:25:16.788866000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:16.789404000 usim_creator.handle_overflow                       [945] Not implemented. Handle overflow for [2024052004210803800000000000000000000000000000000000043] escape strategy [7].
20.05.2024 04:25:17.506658000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.58083031123561380817829788525454911561] and current target energy [9.27671911288776849528882361330623989706]. Set energy to 0.
20.05.2024 04:25:17.519757000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:17.520557000 usim_creator.handle_overflow                       [947] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:25:17.524036000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.58083031123561380817829788525454911561] and current target energy [9.27671911288776849528882361330623989706]. Set energy to 0.
20.05.2024 04:25:17.534810000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:17.535482000 usim_creator.handle_overflow                       [947] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:25:17.539549000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.58083031123561380817829788525454911561] and current target energy [-9.27671911288776849528882361330623989706]. Set energy to 0.
20.05.2024 04:25:17.550113000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:17.550677000 usim_creator.handle_overflow                       [947] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:25:17.553764000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.58083031123561380817829788525454911561] and current target energy [-9.27671911288776849528882361330623989706]. Set energy to 0.
20.05.2024 04:25:17.561238000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:17.561324000 usim_creator.handle_overflow                       [947] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:25:17.567611000 usim_process.process_queue                         Overflow for target space id [2024052004210261400000000000000000000000000000000000034] with energy [1.10417874052255998875427458283852955206] and current target energy [9.39099713098133231901363059644838710693]. Set energy to 0.
20.05.2024 04:25:17.576354000 usim_creator.handle_overflow                       [947] Not implemented. Handle overflow for [2024052004210261400000000000000000000000000000000000034] escape strategy [0].
20.05.2024 04:25:17.579474000 usim_process.process_queue                         Overflow for target space id [2024052004210264800000000000000000000000000000000000035] with energy [1.10417874052255998875427458283852955206] and current target energy [9.39099713098133231901363059644838710693]. Set energy to 0.
20.05.2024 04:25:17.587661000 usim_creator.handle_overflow                       [947] Not implemented. Handle overflow for [2024052004210264800000000000000000000000000000000000035] escape strategy [0].
20.05.2024 04:25:17.590683000 usim_process.process_queue                         Overflow for target space id [2024052004210269400000000000000000000000000000000000036] with energy [-1.10417874052255998875427458283852955206] and current target energy [-9.39099713098133231901363059644838710693]. Set energy to 0.
20.05.2024 04:25:17.607170000 usim_creator.handle_overflow                       [947] Not implemented. Handle overflow for [2024052004210269400000000000000000000000000000000000036] escape strategy [0].
20.05.2024 04:25:17.610442000 usim_process.process_queue                         Overflow for target space id [2024052004210273800000000000000000000000000000000000037] with energy [-1.10417874052255998875427458283852955206] and current target energy [-9.39099713098133231901363059644838710693]. Set energy to 0.
20.05.2024 04:25:17.638827000 usim_creator.handle_overflow                       [947] Not implemented. Handle overflow for [2024052004210273800000000000000000000000000000000000037] escape strategy [0].
20.05.2024 04:25:18.116733000 usim_process.process_queue                         Overflow for target space id [2024052004211990800000000000000000000000000000000000070] with energy [2.37379664095987941855593246478820979231] and current target energy [8.01023851881464079707816306622750460353]. Set energy to 0.
20.05.2024 04:25:18.147390000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:18.148947000 usim_creator.handle_overflow                       [948] Not implemented. Handle overflow for [2024052004211990800000000000000000000000000000000000070] escape strategy [7].
20.05.2024 04:25:18.153804000 usim_process.process_queue                         Overflow for target space id [2024052004211994200000000000000000000000000000000000071] with energy [2.37379664095987941855593246478820979231] and current target energy [8.01023851881464079707816306622750460353]. Set energy to 0.
20.05.2024 04:25:18.170902000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:18.171492000 usim_creator.handle_overflow                       [948] Not implemented. Handle overflow for [2024052004211994200000000000000000000000000000000000071] escape strategy [7].
20.05.2024 04:25:18.177221000 usim_process.process_queue                         Overflow for target space id [2024052004211998600000000000000000000000000000000000072] with energy [-2.37379664095987941855593246478820979231] and current target energy [-8.01023851881464079707816306622750460353]. Set energy to 0.
20.05.2024 04:25:18.194270000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:18.197643000 usim_creator.handle_overflow                       [948] Not implemented. Handle overflow for [2024052004211998600000000000000000000000000000000000072] escape strategy [7].
20.05.2024 04:25:18.203103000 usim_process.process_queue                         Overflow for target space id [2024052004212000300000000000000000000000000000000000073] with energy [-2.37379664095987941855593246478820979231] and current target energy [-8.01023851881464079707816306622750460353]. Set energy to 0.
20.05.2024 04:25:18.224806000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:18.225987000 usim_creator.handle_overflow                       [948] Not implemented. Handle overflow for [2024052004212000300000000000000000000000000000000000073] escape strategy [7].
20.05.2024 04:25:18.956823000 usim_process.process_queue                         Overflow for target space id [2024052004211700300000000000000000000000000000000000062] with energy [.8602905860576831371771896172678353824213] and current target energy [9.42128626150746620935405247370480056859]. Set energy to 0.
20.05.2024 04:25:18.974231000 usim_creator.handle_overflow                       [950] Not implemented. Handle overflow for [2024052004211700300000000000000000000000000000000000062] escape strategy [0].
20.05.2024 04:25:18.978671000 usim_process.process_queue                         Overflow for target space id [2024052004211706000000000000000000000000000000000000063] with energy [.8602905860576831371771896172678353824213] and current target energy [9.42128626150746620935405247370480056859]. Set energy to 0.
20.05.2024 04:25:18.992392000 usim_creator.handle_overflow                       [950] Not implemented. Handle overflow for [2024052004211706000000000000000000000000000000000000063] escape strategy [0].
20.05.2024 04:25:18.999921000 usim_process.process_queue                         Overflow for target space id [2024052004211711600000000000000000000000000000000000064] with energy [-.8602905860576831371771896172678353824213] and current target energy [-9.42128626150746620935405247370480056859]. Set energy to 0.
20.05.2024 04:25:19.010090000 usim_creator.handle_overflow                       [950] Not implemented. Handle overflow for [2024052004211711600000000000000000000000000000000000064] escape strategy [0].
20.05.2024 04:25:19.017754000 usim_process.process_queue                         Overflow for target space id [2024052004211716600000000000000000000000000000000000065] with energy [-.8602905860576831371771896172678353824213] and current target energy [-9.42128626150746620935405247370480056859]. Set energy to 0.
20.05.2024 04:25:19.033223000 usim_creator.handle_overflow                       [950] Not implemented. Handle overflow for [2024052004211716600000000000000000000000000000000000065] escape strategy [0].
20.05.2024 04:25:19.036616000 usim_process.process_queue                         Overflow for target space id [2024052004221501800000000000000000000000000000000000092] with energy [1.94421897701805392433755152787674002791] and current target energy [9.51571749815455690720736650983670742789]. Set energy to 0.
20.05.2024 04:25:19.052243000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:19.060776000 usim_creator.handle_overflow                       [950] Not implemented. Handle overflow for [2024052004221501800000000000000000000000000000000000092] escape strategy [7].
20.05.2024 04:25:19.066217000 usim_process.process_queue                         Overflow for target space id [2024052004221505600000000000000000000000000000000000093] with energy [-1.94421897701805392433755152787674002791] and current target energy [-9.51571749815455690720736650983670742789]. Set energy to 0.
20.05.2024 04:25:19.089600000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:19.090177000 usim_creator.handle_overflow                       [950] Not implemented. Handle overflow for [2024052004221505600000000000000000000000000000000000093] escape strategy [7].
20.05.2024 04:25:19.410044000 usim_process.process_queue                         Overflow for target space id [2024052004205701200000000000000000000000000000000000015] with energy [.9759801925312406346061154055768900861013] and current target energy [9.58142039958323433777162041572220091453]. Set energy to 0.
20.05.2024 04:25:19.436731000 usim_creator.handle_overflow                       [951] Not implemented. Handle overflow for [2024052004205701200000000000000000000000000000000000015] escape strategy [0].
20.05.2024 04:25:19.443890000 usim_process.process_queue                         Overflow for target space id [2024052004205702800000000000000000000000000000000000017] with energy [.9759801925312406346061154055768900861013] and current target energy [9.58142039958323433777162041572220091453]. Set energy to 0.
20.05.2024 04:25:19.463292000 usim_creator.handle_overflow                       [951] Not implemented. Handle overflow for [2024052004205702800000000000000000000000000000000000017] escape strategy [0].
20.05.2024 04:25:19.471090000 usim_process.process_queue                         Overflow for target space id [2024052004205711900000000000000000000000000000000000019] with energy [-.9759801925312406346061154055768900861013] and current target energy [-9.58142039958323433777162041572220091453]. Set energy to 0.
20.05.2024 04:25:19.484593000 usim_creator.handle_overflow                       [951] Not implemented. Handle overflow for [2024052004205711900000000000000000000000000000000000019] escape strategy [0].
20.05.2024 04:25:19.492195000 usim_process.process_queue                         Overflow for target space id [2024052004205716200000000000000000000000000000000000021] with energy [-.9759801925312406346061154055768900861013] and current target energy [-9.58142039958323433777162041572220091453]. Set energy to 0.
20.05.2024 04:25:19.516661000 usim_creator.handle_overflow                       [951] Not implemented. Handle overflow for [2024052004205716200000000000000000000000000000000000021] escape strategy [0].
20.05.2024 04:25:20.231929000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [4.98998328730557346021289276864539373438] and current target energy [7.33081603511175424041007448003327601242]. Set energy to 0.
20.05.2024 04:25:20.249942000 usim_creator.handle_overflow                       [953] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:25:20.255704000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-4.98998328730557346021289276864539373438] and current target energy [-7.33081603511175424041007448003327601242]. Set energy to 0.
20.05.2024 04:25:20.275327000 usim_creator.handle_overflow                       [953] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:25:20.726402000 usim_process.process_queue                         Overflow for target space id [2024052004221223900000000000000000000000000000000000088] with energy [2.40176303535695843734508542864754010531] and current target energy [8.66270907079691093979263722504371953487]. Set energy to 0.
20.05.2024 04:25:20.739616000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:20.739974000 usim_creator.handle_overflow                       [954] Not implemented. Handle overflow for [2024052004221223900000000000000000000000000000000000088] escape strategy [7].
20.05.2024 04:25:20.743303000 usim_process.process_queue                         Overflow for target space id [2024052004221227000000000000000000000000000000000000089] with energy [2.40176303535695843734508542864754010531] and current target energy [8.66270907079691093979263722504371953487]. Set energy to 0.
20.05.2024 04:25:20.753088000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:20.753398000 usim_creator.handle_overflow                       [954] Not implemented. Handle overflow for [2024052004221227000000000000000000000000000000000000089] escape strategy [7].
20.05.2024 04:25:20.756843000 usim_process.process_queue                         Overflow for target space id [2024052004221231900000000000000000000000000000000000090] with energy [-2.40176303535695843734508542864754010531] and current target energy [-8.66270907079691093979263722504371953487]. Set energy to 0.
20.05.2024 04:25:20.773293000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:20.774258000 usim_creator.handle_overflow                       [954] Not implemented. Handle overflow for [2024052004221231900000000000000000000000000000000000090] escape strategy [7].
20.05.2024 04:25:20.780297000 usim_process.process_queue                         Overflow for target space id [2024052004221235100000000000000000000000000000000000091] with energy [-2.40176303535695843734508542864754010531] and current target energy [-8.66270907079691093979263722504371953487]. Set energy to 0.
20.05.2024 04:25:20.794331000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:20.795566000 usim_creator.handle_overflow                       [954] Not implemented. Handle overflow for [2024052004221235100000000000000000000000000000000000091] escape strategy [7].
20.05.2024 04:25:21.176871000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.98998328730557346021289276864539373438] and current target energy [8.70310645494947940031194602852427561658]. Set energy to 0.
20.05.2024 04:25:21.203305000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:21.203879000 usim_creator.handle_overflow                       [955] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:25:21.213830000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.98998328730557346021289276864539373438] and current target energy [-8.70310645494947940031194602852427561658]. Set energy to 0.
20.05.2024 04:25:21.231362000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:21.232254000 usim_creator.handle_overflow                       [955] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:25:21.723087000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [4.68753262683609615966123729387797918264] and current target energy [9.02903562225411501695719153612821659103]. Set energy to 0.
20.05.2024 04:25:21.738902000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:21.739444000 usim_creator.handle_overflow                       [956] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:25:21.746060000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-4.68753262683609615966123729387797918264] and current target energy [-9.02903562225411501695719153612821659103]. Set energy to 0.
20.05.2024 04:25:21.759180000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:21.759706000 usim_creator.handle_overflow                       [956] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:25:22.218851000 usim_process.process_queue                         Overflow for target space id [2024052004242916000000000000000000000000000000000000104] with energy [1.56044365532981106438967617458374192945] and current target energy [8.4551492981502708415614069285728044766]. Set energy to 0.
20.05.2024 04:25:22.243984000 usim_creator.handle_overflow                       [957] Handle pos overflow for [2024052004242916000000000000000000000000000000000000104] escape strategy [3].
20.05.2024 04:25:22.252178000 usim_process.process_queue                         Overflow for target space id [2024052004242920200000000000000000000000000000000000105] with energy [1.56044365532981106438967617458374192945] and current target energy [8.4551492981502708415614069285728044766]. Set energy to 0.
20.05.2024 04:25:22.271629000 usim_creator.handle_overflow                       [957] Handle pos overflow for [2024052004242920200000000000000000000000000000000000105] escape strategy [3].
20.05.2024 04:25:22.276962000 usim_process.process_queue                         Overflow for target space id [2024052004242923000000000000000000000000000000000000106] with energy [-1.56044365532981106438967617458374192945] and current target energy [-8.4551492981502708415614069285728044766]. Set energy to 0.
20.05.2024 04:25:22.300886000 usim_creator.handle_overflow                       [957] Handle pos overflow for [2024052004242923000000000000000000000000000000000000106] escape strategy [3].
20.05.2024 04:25:22.308013000 usim_process.process_queue                         Overflow for target space id [2024052004242926400000000000000000000000000000000000107] with energy [-1.56044365532981106438967617458374192945] and current target energy [-8.4551492981502708415614069285728044766]. Set energy to 0.
20.05.2024 04:25:22.342756000 usim_creator.handle_overflow                       [957] Handle pos overflow for [2024052004242926400000000000000000000000000000000000107] escape strategy [3].
20.05.2024 04:25:22.619707000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [.9759801925312406346061154055768900861] and current target energy [9.97996657461114692042578553729078746875]. Set energy to 0.
20.05.2024 04:25:22.646536000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:22.647238000 usim_creator.handle_overflow                       [958] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:25:22.653223000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-.9759801925312406346061154055768900861] and current target energy [-9.97996657461114692042578553729078746875]. Set energy to 0.
20.05.2024 04:25:22.666642000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:22.667151000 usim_creator.handle_overflow                       [958] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:25:22.670662000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [1.00319856073117120554671098423376596082] and current target energy [9.14052474109117266991095682429538942168]. Set energy to 0.
20.05.2024 04:25:22.695722000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:22.696283000 usim_creator.handle_overflow                       [958] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:25:22.702867000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [1.00319856073117120554671098423376596082] and current target energy [9.14052474109117266991095682429538942168]. Set energy to 0.
20.05.2024 04:25:22.731965000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:22.732633000 usim_creator.handle_overflow                       [958] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:25:22.738913000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-1.00319856073117120554671098423376596082] and current target energy [-9.14052474109117266991095682429538942168]. Set energy to 0.
20.05.2024 04:25:22.757345000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:22.760584000 usim_creator.handle_overflow                       [958] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:25:22.763941000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-1.00319856073117120554671098423376596082] and current target energy [-9.14052474109117266991095682429538942168]. Set energy to 0.
20.05.2024 04:25:22.773224000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:22.773533000 usim_creator.handle_overflow                       [958] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:25:24.109276000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [.960241228851919115955315616251570521985] and current target energy [9.37506525367219231932247458775595836528]. Set energy to 0.
20.05.2024 04:25:24.125611000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:24.126143000 usim_creator.handle_overflow                       [961] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:25:24.130966000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-.960241228851919115955315616251570521985] and current target energy [-9.37506525367219231932247458775595836528]. Set energy to 0.
20.05.2024 04:25:24.152281000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:24.152802000 usim_creator.handle_overflow                       [961] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:25:26.051926000 usim_process.process_queue                         Overflow for target space id [2024052004211868000000000000000000000000000000000000066] with energy [.69394501230781086993163617370313148758] and current target energy [9.47291414321181682666127766377601904496]. Set energy to 0.
20.05.2024 04:25:26.071074000 usim_creator.handle_overflow                       [965] Not implemented. Handle overflow for [2024052004211868000000000000000000000000000000000000066] escape strategy [0].
20.05.2024 04:25:26.092208000 usim_process.process_queue                         Overflow for target space id [2024052004211870600000000000000000000000000000000000067] with energy [.69394501230781086993163617370313148758] and current target energy [9.47291414321181682666127766377601904496]. Set energy to 0.
20.05.2024 04:25:26.115069000 usim_creator.handle_overflow                       [965] Not implemented. Handle overflow for [2024052004211870600000000000000000000000000000000000067] escape strategy [0].
20.05.2024 04:25:26.122005000 usim_process.process_queue                         Overflow for target space id [2024052004211874300000000000000000000000000000000000068] with energy [-.69394501230781086993163617370313148758] and current target energy [-9.47291414321181682666127766377601904496]. Set energy to 0.
20.05.2024 04:25:26.136973000 usim_creator.handle_overflow                       [965] Not implemented. Handle overflow for [2024052004211874300000000000000000000000000000000000068] escape strategy [0].
20.05.2024 04:25:26.142267000 usim_process.process_queue                         Overflow for target space id [2024052004211878000000000000000000000000000000000000069] with energy [-.69394501230781086993163617370313148758] and current target energy [-9.47291414321181682666127766377601904496]. Set energy to 0.
20.05.2024 04:25:26.157835000 usim_creator.handle_overflow                       [965] Not implemented. Handle overflow for [2024052004211878000000000000000000000000000000000000069] escape strategy [0].
20.05.2024 04:25:26.549945000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [2.21351783682247859768464265117176509093] and current target energy [9.90030115432990370462821796475900003866]. Set energy to 0.
20.05.2024 04:25:26.564820000 usim_creator.handle_overflow                       [966] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:25:26.570350000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [2.21351783682247859768464265117176509093] and current target energy [9.90030115432990370462821796475900003866]. Set energy to 0.
20.05.2024 04:25:26.585039000 usim_creator.handle_overflow                       [966] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:25:26.588935000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-2.21351783682247859768464265117176509093] and current target energy [-9.90030115432990370462821796475900003866]. Set energy to 0.
20.05.2024 04:25:26.605086000 usim_creator.handle_overflow                       [966] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:25:26.610944000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-2.21351783682247859768464265117176509093] and current target energy [-9.90030115432990370462821796475900003866]. Set energy to 0.
20.05.2024 04:25:26.627152000 usim_creator.handle_overflow                       [966] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:25:27.210468000 usim_process.process_queue                         Overflow for target space id [2024052004215286700000000000000000000000000000000000086] with energy [2.73405793643163833109968183607666566425] and current target energy [8.74898539658124265951898187544533012557]. Set energy to 0.
20.05.2024 04:25:27.245093000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:27.246061000 usim_creator.handle_overflow                       [967] Not implemented. Handle overflow for [2024052004215286700000000000000000000000000000000000086] escape strategy [7].
20.05.2024 04:25:27.253087000 usim_process.process_queue                         Overflow for target space id [2024052004215288300000000000000000000000000000000000087] with energy [-2.73405793643163833109968183607666566425] and current target energy [-8.74898539658124265951898187544533012557]. Set energy to 0.
20.05.2024 04:25:27.268701000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:27.269217000 usim_creator.handle_overflow                       [967] Not implemented. Handle overflow for [2024052004215288300000000000000000000000000000000000087] escape strategy [7].
20.05.2024 04:25:27.629096000 usim_process.process_queue                         Overflow for target space id [2024052004205948300000000000000000000000000000000000024] with energy [.4300310640294548756756611024205958712425] and current target energy [9.60571647896661802492811782036967843735]. Set energy to 0.
20.05.2024 04:25:27.640983000 usim_creator.handle_overflow                       [968] Not implemented. Handle overflow for [2024052004205948300000000000000000000000000000000000024] escape strategy [0].
20.05.2024 04:25:27.646408000 usim_process.process_queue                         Overflow for target space id [2024052004205949500000000000000000000000000000000000025] with energy [.4300310640294548756756611024205958712425] and current target energy [9.60571647896661802492811782036967843735]. Set energy to 0.
20.05.2024 04:25:27.661693000 usim_creator.handle_overflow                       [968] Not implemented. Handle overflow for [2024052004205949500000000000000000000000000000000000025] escape strategy [0].
20.05.2024 04:25:27.667141000 usim_process.process_queue                         Overflow for target space id [2024052004205950700000000000000000000000000000000000026] with energy [-.4300310640294548756756611024205958712425] and current target energy [-9.60571647896661802492811782036967843735]. Set energy to 0.
20.05.2024 04:25:27.687394000 usim_creator.handle_overflow                       [968] Not implemented. Handle overflow for [2024052004205950700000000000000000000000000000000000026] escape strategy [0].
20.05.2024 04:25:27.694046000 usim_process.process_queue                         Overflow for target space id [2024052004205952100000000000000000000000000000000000027] with energy [-.4300310640294548756756611024205958712425] and current target energy [-9.60571647896661802492811782036967843735]. Set energy to 0.
20.05.2024 04:25:27.708197000 usim_creator.handle_overflow                       [968] Not implemented. Handle overflow for [2024052004205952100000000000000000000000000000000000027] escape strategy [0].
20.05.2024 04:25:28.391117000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [4.96478668649925039385835451388980405466] and current target energy [7.81557736935336795240408939412350067787]. Set energy to 0.
20.05.2024 04:25:28.416119000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:28.416809000 usim_creator.handle_overflow                       [970] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:25:28.431472000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-4.96478668649925039385835451388980405466] and current target energy [-7.81557736935336795240408939412350067787]. Set energy to 0.
20.05.2024 04:25:28.448833000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:28.450086000 usim_creator.handle_overflow                       [970] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:25:28.941288000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [2.40541081289048256012990834808290075197] and current target energy [9.92957337299850078771670902777960810932]. Set energy to 0.
20.05.2024 04:25:28.958181000 usim_creator.handle_overflow                       [971] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:25:28.964750000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-2.40541081289048256012990834808290075197] and current target energy [-9.92957337299850078771670902777960810932]. Set energy to 0.
20.05.2024 04:25:28.978738000 usim_creator.handle_overflow                       [971] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:25:29.338119000 usim_process.process_queue                         Overflow for target space id [2024052004210175200000000000000000000000000000000000032] with energy [4.62607933999964872011333133737484550084] and current target energy [9.84640733665200131820468501390992774138]. Set energy to 0.
20.05.2024 04:25:29.353422000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:29.353993000 usim_creator.handle_overflow                       [972] Not implemented. Handle overflow for [2024052004210175200000000000000000000000000000000000032] escape strategy [7].
20.05.2024 04:25:29.357998000 usim_process.process_queue                         Overflow for target space id [2024052004210177300000000000000000000000000000000000033] with energy [-4.62607933999964872011333133737484550084] and current target energy [-9.84640733665200131820468501390992774138]. Set energy to 0.
20.05.2024 04:25:29.372801000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:29.373119000 usim_creator.handle_overflow                       [972] Not implemented. Handle overflow for [2024052004210177300000000000000000000000000000000000033] escape strategy [7].
20.05.2024 04:25:29.700261000 usim_process.process_queue                         Overflow for target space id [2024052004213975700000000000000000000000000000000000082] with energy [1.09514734461440742400349681837366691519] and current target energy [9.79637067314064170939820683871245264062]. Set energy to 0.
20.05.2024 04:25:29.724945000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:29.725515000 usim_creator.handle_overflow                       [973] Not implemented. Handle overflow for [2024052004213975700000000000000000000000000000000000082] escape strategy [7].
20.05.2024 04:25:29.730172000 usim_process.process_queue                         Overflow for target space id [2024052004213980000000000000000000000000000000000000083] with energy [1.09514734461440742400349681837366691519] and current target energy [9.79637067314064170939820683871245264062]. Set energy to 0.
20.05.2024 04:25:29.760067000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:29.761325000 usim_creator.handle_overflow                       [973] Not implemented. Handle overflow for [2024052004213980000000000000000000000000000000000000083] escape strategy [7].
20.05.2024 04:25:29.771250000 usim_process.process_queue                         Overflow for target space id [2024052004213983100000000000000000000000000000000000084] with energy [-1.09514734461440742400349681837366691519] and current target energy [-9.79637067314064170939820683871245264062]. Set energy to 0.
20.05.2024 04:25:29.818463000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:29.820260000 usim_creator.handle_overflow                       [973] Not implemented. Handle overflow for [2024052004213983100000000000000000000000000000000000084] escape strategy [7].
20.05.2024 04:25:29.841777000 usim_process.process_queue                         Overflow for target space id [2024052004213986900000000000000000000000000000000000085] with energy [-1.09514734461440742400349681837366691519] and current target energy [-9.79637067314064170939820683871245264062]. Set energy to 0.
20.05.2024 04:25:29.872519000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:29.875260000 usim_creator.handle_overflow                       [973] Not implemented. Handle overflow for [2024052004213986900000000000000000000000000000000000085] escape strategy [7].
20.05.2024 04:25:31.116911000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [2.35976477424799874481932783861648139874] and current target energy [9.62164325156193024051963339233160300786]. Set energy to 0.
20.05.2024 04:25:31.134839000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:31.135399000 usim_creator.handle_overflow                       [976] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:25:31.139147000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [2.35976477424799874481932783861648139874] and current target energy [9.62164325156193024051963339233160300786]. Set energy to 0.
20.05.2024 04:25:31.154891000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:31.156020000 usim_creator.handle_overflow                       [976] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:25:31.161766000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-2.35976477424799874481932783861648139874] and current target energy [-9.62164325156193024051963339233160300786]. Set energy to 0.
20.05.2024 04:25:31.178573000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:31.179098000 usim_creator.handle_overflow                       [976] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:25:31.182286000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-2.35976477424799874481932783861648139874] and current target energy [-9.62164325156193024051963339233160300786]. Set energy to 0.
20.05.2024 04:25:31.194477000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:31.195192000 usim_creator.handle_overflow                       [976] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:25:31.231045000 usim_process.process_queue                         Overflow for target space id [2024052004213750600000000000000000000000000000000000080] with energy [4.27000564162865372506602554370579344552] and current target energy [9.72109488509026962168775763938370013952]. Set energy to 0.
20.05.2024 04:25:31.244021000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:31.244340000 usim_creator.handle_overflow                       [976] Not implemented. Handle overflow for [2024052004213750600000000000000000000000000000000000080] escape strategy [7].
20.05.2024 04:25:31.247488000 usim_process.process_queue                         Overflow for target space id [2024052004213753200000000000000000000000000000000000081] with energy [-4.27000564162865372506602554370579344552] and current target energy [-9.72109488509026962168775763938370013952]. Set energy to 0.
20.05.2024 04:25:31.262341000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:31.262973000 usim_creator.handle_overflow                       [976] Not implemented. Handle overflow for [2024052004213753200000000000000000000000000000000000081] escape strategy [7].
20.05.2024 04:25:32.918432000 usim_process.process_queue                         Overflow for target space id [2024052004205984000000000000000000000000000000000000028] with energy [2.40251784098632105776415637303515271213] and current target energy [8.20899147813876801136169274536891117023]. Set energy to 0.
20.05.2024 04:25:32.951192000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:32.951854000 usim_creator.handle_overflow                       [980] Not implemented. Handle overflow for [2024052004205984000000000000000000000000000000000000028] escape strategy [7].
20.05.2024 04:25:32.955488000 usim_process.process_queue                         Overflow for target space id [2024052004205984900000000000000000000000000000000000029] with energy [2.40251784098632105776415637303515271213] and current target energy [8.20899147813876801136169274536891117023]. Set energy to 0.
20.05.2024 04:25:32.966666000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:32.967037000 usim_creator.handle_overflow                       [980] Not implemented. Handle overflow for [2024052004205984900000000000000000000000000000000000029] escape strategy [7].
20.05.2024 04:25:32.973819000 usim_process.process_queue                         Overflow for target space id [2024052004205985600000000000000000000000000000000000030] with energy [-2.40251784098632105776415637303515271213] and current target energy [-8.20899147813876801136169274536891117023]. Set energy to 0.
20.05.2024 04:25:32.997891000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:33.000664000 usim_creator.handle_overflow                       [980] Not implemented. Handle overflow for [2024052004205985600000000000000000000000000000000000030] escape strategy [7].
20.05.2024 04:25:33.005995000 usim_process.process_queue                         Overflow for target space id [2024052004205986700000000000000000000000000000000000031] with energy [-2.40251784098632105776415637303515271213] and current target energy [-8.20899147813876801136169274536891117023]. Set energy to 0.
20.05.2024 04:25:33.022067000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:33.022587000 usim_creator.handle_overflow                       [980] Not implemented. Handle overflow for [2024052004205986700000000000000000000000000000000000031] escape strategy [7].
20.05.2024 04:25:34.722390000 usim_process.process_queue                         Overflow for target space id [2024052004205700500000000000000000000000000000000000014] with energy [3.67218549439058238228520503283825419995] and current target energy [6.76967624548825691356095795815177449507]. Set energy to 0.
20.05.2024 04:25:34.737597000 usim_creator.handle_overflow                       [984] Not implemented. Handle overflow for [2024052004205700500000000000000000000000000000000000014] escape strategy [0].
20.05.2024 04:25:34.747139000 usim_process.process_queue                         Overflow for target space id [2024052004205702100000000000000000000000000000000000016] with energy [3.67218549439058238228520503283825419995] and current target energy [6.76967624548825691356095795815177449507]. Set energy to 0.
20.05.2024 04:25:34.765071000 usim_creator.handle_overflow                       [984] Not implemented. Handle overflow for [2024052004205702100000000000000000000000000000000000016] escape strategy [0].
20.05.2024 04:25:34.772696000 usim_process.process_queue                         Overflow for target space id [2024052004205707700000000000000000000000000000000000018] with energy [-3.67218549439058238228520503283825419995] and current target energy [-6.76967624548825691356095795815177449507]. Set energy to 0.
20.05.2024 04:25:34.789033000 usim_creator.handle_overflow                       [984] Not implemented. Handle overflow for [2024052004205707700000000000000000000000000000000000018] escape strategy [0].
20.05.2024 04:25:34.792215000 usim_process.process_queue                         Overflow for target space id [2024052004205714100000000000000000000000000000000000020] with energy [-3.67218549439058238228520503283825419995] and current target energy [-6.76967624548825691356095795815177449507]. Set energy to 0.
20.05.2024 04:25:34.801696000 usim_creator.handle_overflow                       [984] Not implemented. Handle overflow for [2024052004205714100000000000000000000000000000000000020] escape strategy [0].
20.05.2024 04:25:34.823438000 usim_process.process_queue                         Overflow for target space id [2024052004211506300000000000000000000000000000000000056] with energy [4.76555364260688817257784287649468909716] and current target energy [7.35892768142434527857634453543947364254]. Set energy to 0.
20.05.2024 04:25:34.852208000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:34.853877000 usim_creator.handle_overflow                       [984] Not implemented. Handle overflow for [2024052004211506300000000000000000000000000000000000056] escape strategy [7].
20.05.2024 04:25:34.860630000 usim_process.process_queue                         Overflow for target space id [2024052004211507700000000000000000000000000000000000057] with energy [-4.76555364260688817257784287649468909716] and current target energy [-7.35892768142434527857634453543947364254]. Set energy to 0.
20.05.2024 04:25:34.875110000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:34.875636000 usim_creator.handle_overflow                       [984] Not implemented. Handle overflow for [2024052004211507700000000000000000000000000000000000057] escape strategy [7].
20.05.2024 04:25:35.260790000 usim_process.process_queue                         Overflow for target space id [2024052004205624600000000000000000000000000000000000007] with energy [1.68968810079751511179165448914303698159] and current target energy [9.61007136394528423105662549214061084851]. Set energy to 0.
20.05.2024 04:25:35.280214000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:35.280951000 usim_creator.handle_overflow                       [985] Not implemented. Handle overflow for [2024052004205624600000000000000000000000000000000000007] escape strategy [7].
20.05.2024 04:25:35.286707000 usim_process.process_queue                         Overflow for target space id [2024052004205627000000000000000000000000000000000000009] with energy [1.68968810079751511179165448914303698159] and current target energy [9.61007136394528423105662549214061084851]. Set energy to 0.
20.05.2024 04:25:35.316442000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:35.317974000 usim_creator.handle_overflow                       [985] Not implemented. Handle overflow for [2024052004205627000000000000000000000000000000000000009] escape strategy [7].
20.05.2024 04:25:35.329200000 usim_process.process_queue                         Overflow for target space id [2024052004205631300000000000000000000000000000000000011] with energy [-1.68968810079751511179165448914303698159] and current target energy [-9.61007136394528423105662549214061084851]. Set energy to 0.
20.05.2024 04:25:35.345059000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:35.345677000 usim_creator.handle_overflow                       [985] Not implemented. Handle overflow for [2024052004205631300000000000000000000000000000000000011] escape strategy [7].
20.05.2024 04:25:35.349949000 usim_process.process_queue                         Overflow for target space id [2024052004205631500000000000000000000000000000000000013] with energy [-1.68968810079751511179165448914303698159] and current target energy [-9.61007136394528423105662549214061084851]. Set energy to 0.
20.05.2024 04:25:35.374553000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:35.379341000 usim_creator.handle_overflow                       [985] Not implemented. Handle overflow for [2024052004205631500000000000000000000000000000000000013] escape strategy [7].
20.05.2024 04:25:35.404984000 usim_process.process_queue                         Overflow for target space id [2024052004205866200000000000000000000000000000000000022] with energy [4.57666308457833868064755352929326298433] and current target energy [9.59418321390587594378529095009906150882]. Set energy to 0.
20.05.2024 04:25:35.420501000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:35.421080000 usim_creator.handle_overflow                       [985] Not implemented. Handle overflow for [2024052004205866200000000000000000000000000000000000022] escape strategy [7].
20.05.2024 04:25:35.426988000 usim_process.process_queue                         Overflow for target space id [2024052004205867200000000000000000000000000000000000023] with energy [-4.57666308457833868064755352929326298433] and current target energy [-9.59418321390587594378529095009906150882]. Set energy to 0.
20.05.2024 04:25:35.449502000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:35.450032000 usim_creator.handle_overflow                       [985] Not implemented. Handle overflow for [2024052004205867200000000000000000000000000000000000023] escape strategy [7].
20.05.2024 04:25:36.775115000 usim_process.process_queue                         Overflow for target space id [2024052004205403700000000000000000000000000000000000002] with energy [4.95268452238433113580302526592956392979] and current target energy [7.3443709887811647645704100656765083999]. Set energy to 0.
20.05.2024 04:25:36.794743000 usim_creator.handle_overflow                       [989] Not implemented. Handle overflow for [2024052004205403700000000000000000000000000000000000002] escape strategy [0].
20.05.2024 04:25:36.801813000 usim_process.process_queue                         Overflow for target space id [2024052004205410800000000000000000000000000000000000003] with energy [-4.95268452238433113580302526592956392979] and current target energy [-7.3443709887811647645704100656765083999]. Set energy to 0.
20.05.2024 04:25:36.815419000 usim_creator.handle_overflow                       [989] Not implemented. Handle overflow for [2024052004205410800000000000000000000000000000000000003] escape strategy [0].
20.05.2024 04:25:39.564434000 usim_process.process_queue                         Overflow for target space id [2024052004205411200000000000000000000000000000000000004] with energy [1.68968810079751511179165448914303698159] and current target energy [9.90536904476866227160605053185912785958]. Set energy to 0.
20.05.2024 04:25:39.577504000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:39.577876000 usim_creator.handle_overflow                       [996] Not implemented. Handle overflow for [2024052004205411200000000000000000000000000000000000004] escape strategy [7].
20.05.2024 04:25:39.581718000 usim_process.process_queue                         Overflow for target space id [2024052004205411300000000000000000000000000000000000005] with energy [-1.68968810079751511179165448914303698159] and current target energy [-9.90536904476866227160605053185912785958]. Set energy to 0.
20.05.2024 04:25:39.601467000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:39.602771000 usim_creator.handle_overflow                       [996] Not implemented. Handle overflow for [2024052004205411300000000000000000000000000000000000005] escape strategy [7].
20.05.2024 04:25:39.655748000 usim_process.process_queue                         Overflow for target space id [2024052004233397700000000000000000000000000000000000100] with energy [1.11892282930025633913726625886180402091] and current target energy [8.94839155359835716315323528000831921447]. Set energy to 0.
20.05.2024 04:25:39.665697000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:39.666766000 usim_creator.handle_overflow                       [996] Not implemented. Handle overflow for [2024052004233397700000000000000000000000000000000000100] escape strategy [7].
20.05.2024 04:25:39.670721000 usim_process.process_queue                         Overflow for target space id [2024052004233401700000000000000000000000000000000000101] with energy [1.11892282930025633913726625886180402091] and current target energy [8.94839155359835716315323528000831921447]. Set energy to 0.
20.05.2024 04:25:39.678765000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:39.679143000 usim_creator.handle_overflow                       [996] Not implemented. Handle overflow for [2024052004233401700000000000000000000000000000000000101] escape strategy [7].
20.05.2024 04:25:39.681604000 usim_process.process_queue                         Overflow for target space id [2024052004233403400000000000000000000000000000000000102] with energy [-1.11892282930025633913726625886180402091] and current target energy [-8.94839155359835716315323528000831921447]. Set energy to 0.
20.05.2024 04:25:39.689289000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:39.689906000 usim_creator.handle_overflow                       [996] Not implemented. Handle overflow for [2024052004233403400000000000000000000000000000000000102] escape strategy [7].
20.05.2024 04:25:39.693057000 usim_process.process_queue                         Overflow for target space id [2024052004233409100000000000000000000000000000000000103] with energy [-1.11892282930025633913726625886180402091] and current target energy [-8.94839155359835716315323528000831921447]. Set energy to 0.
20.05.2024 04:25:39.701203000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:39.701606000 usim_creator.handle_overflow                       [996] Not implemented. Handle overflow for [2024052004233409100000000000000000000000000000000000103] escape strategy [7].
20.05.2024 04:25:40.147474000 usim_process.process_queue                         Overflow for target space id [2024052004212681100000000000000000000000000000000000078] with energy [2.28365533113048108555391569646117770929] and current target energy [9.53110728521377634515568575298937819432]. Set energy to 0.
20.05.2024 04:25:40.179774000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:40.181110000 usim_creator.handle_overflow                       [997] Not implemented. Handle overflow for [2024052004212681100000000000000000000000000000000000078] escape strategy [7].
20.05.2024 04:25:40.189215000 usim_process.process_queue                         Overflow for target space id [2024052004212685600000000000000000000000000000000000079] with energy [-2.28365533113048108555391569646117770929] and current target energy [-9.53110728521377634515568575298937819432]. Set energy to 0.
20.05.2024 04:25:40.215431000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:40.219023000 usim_creator.handle_overflow                       [997] Not implemented. Handle overflow for [2024052004212685600000000000000000000000000000000000079] escape strategy [7].
20.05.2024 04:25:41.359578000 usim_process.process_queue                         Overflow for target space id [2024052004205623900000000000000000000000000000000000006] with energy [4.22479647114228938378292920720544404843] and current target energy [8.97646803548679903139316447357238396471]. Set energy to 0.
20.05.2024 04:25:41.373019000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:41.375107000 usim_creator.handle_overflow                       [1000] Not implemented. Handle overflow for [2024052004205623900000000000000000000000000000000000006] escape strategy [7].
20.05.2024 04:25:41.381839000 usim_process.process_queue                         Overflow for target space id [2024052004205625800000000000000000000000000000000000008] with energy [4.22479647114228938378292920720544404843] and current target energy [8.97646803548679903139316447357238396471]. Set energy to 0.
20.05.2024 04:25:41.398508000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:41.399051000 usim_creator.handle_overflow                       [1000] Not implemented. Handle overflow for [2024052004205625800000000000000000000000000000000000008] escape strategy [7].
20.05.2024 04:25:41.405875000 usim_process.process_queue                         Overflow for target space id [2024052004205630900000000000000000000000000000000000010] with energy [-4.22479647114228938378292920720544404843] and current target energy [-8.97646803548679903139316447357238396471]. Set energy to 0.
20.05.2024 04:25:41.426924000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:41.427472000 usim_creator.handle_overflow                       [1000] Not implemented. Handle overflow for [2024052004205630900000000000000000000000000000000000010] escape strategy [7].
20.05.2024 04:25:41.433201000 usim_process.process_queue                         Overflow for target space id [2024052004205631400000000000000000000000000000000000012] with energy [-4.22479647114228938378292920720544404843] and current target energy [-8.97646803548679903139316447357238396471]. Set energy to 0.
20.05.2024 04:25:41.448722000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:41.449408000 usim_creator.handle_overflow                       [1000] Not implemented. Handle overflow for [2024052004205631400000000000000000000000000000000000012] escape strategy [7].
20.05.2024 04:25:41.526750000 usim_process.process_queue                         Overflow for target space id [2024052004221501800000000000000000000000000000000000092] with energy [2.47774000489117223755908666394447825823] and current target energy [7.92876801565175116018907732462233042632]. Set energy to 0.
20.05.2024 04:25:41.547216000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:41.548268000 usim_creator.handle_overflow                       [1000] Not implemented. Handle overflow for [2024052004221501800000000000000000000000000000000000092] escape strategy [7].
20.05.2024 04:25:41.553983000 usim_process.process_queue                         Overflow for target space id [2024052004221505600000000000000000000000000000000000093] with energy [-2.47774000489117223755908666394447825823] and current target energy [-7.92876801565175116018907732462233042632]. Set energy to 0.
20.05.2024 04:25:41.569295000 usim_creator.handle_overflow_between               Not implemented yet.
20.05.2024 04:25:41.569811000 usim_creator.handle_overflow                       [1000] Not implemented. Handle overflow for [2024052004221505600000000000000000000000000000000000093] escape strategy [7].
20.05.2024 04:25:41.800780000 basic_test_data_setup                              Samples run exit without error.

4’224 Zeilen ausgewählt.

SQL>
SQL> SPOOL OFF
