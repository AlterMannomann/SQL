SQL> -- get system information roughly formatted
SQL> @@../UTIL/SYSTEM_INFO.sql
SQL> SELECT TO_CHAR(SYSDATE, 'DD.MM.YYYY HH24:MI:SS') AS exec_date
  2  	  , SUBSTR(SYS_CONTEXT('USERENV', 'DB_NAME'), 1, 30) AS db_name
  3  	  , SUBSTR(SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'), 1, 30) AS db_schema
  4  	  , SUBSTR(SYS_CONTEXT('USERENV', 'OS_USER'), 1, 60) AS os_user
  5    FROM dual
  6  ;

EXEC_DATE           DB_NAME                                                                                                                  DB_SCHEMA                                                                                                                OS_USER
------------------- ------------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
04.06.2024 22:39:25 FREEPDB1                                                                                                                 USIM_TEST                                                                                                                oracle

1 row selected.

SQL> 
SQL> -- Check user
SQL> SELECT 'Check USIM user/schema' AS info FROM dual;

INFO
----------------------
Check USIM user/schema

1 row selected.

SQL> -- USIM_LIVE
SQL> SELECT CASE
  2  	      WHEN USER = 'USIM_TEST'
  3  		OR SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') = 'USIM_TEST'
  4  	      THEN '../UTIL/CHECK_SUCCESSFUL.sql "Acting on schema USIM_TEST."'
  5  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Wrong user or schema, USIM_TEST required."'
  6  	    END AS SCRIPTFILE
  7    FROM dual
  8  ;

SCRIPTFILE
------------------------------------------------------------------------------
../UTIL/CHECK_SUCCESSFUL.sql "Acting on schema USIM_TEST."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Check successful. ' || NVL('&1', 'No further information available.') AS info FROM dual;
old   1: SELECT 'Check successful. ' || NVL('&1', 'No further information available.') AS info FROM dual
new   1: SELECT 'Check successful. ' || NVL('Acting on schema USIM_TEST.', 'No further information available.') AS info FROM dual

INFO
---------------------------------------------
Check successful. Acting on schema USIM_TEST.

1 row selected.

SQL> -- delete model
SQL> @@USIM_DROP.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> SELECT 'Remove all USIM objects if needed.' AS info FROM dual;

INFO
----------------------------------
Remove all USIM objects if needed.

1 row selected.

SQL> --== basic packages start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_STATIC_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_STATIC does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_STATIC'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_STATIC does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_STATIC does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Package body USIM_STATIC does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_STATIC_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_STATIC does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_STATIC'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_STATIC does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_STATIC does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------------
Nothing to do. Package header USIM_STATIC does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_MATHS_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_MATHS does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MATHS'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_MATHS does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_MATHS does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package body USIM_MATHS does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_MATHS_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_MATHS does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MATHS'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_MATHS does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_MATHS does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------------
Nothing to do. Package header USIM_MATHS does not exist.

1 row selected.

SQL> --== basic packages end ==--
SQL> 
SQL> --== sequences start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../SEQUENCES/DROP/DROP_USIM_DLG_ID_SEQ.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_DLG_ID_SEQ does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DLG_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_DLG_ID_SEQ does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Sequence USIM_DLG_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_DLG_ID_SEQ does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../SEQUENCES/DROP/DROP_USIM_ERL_TICK_SEQ.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_ERL_TICK_SEQ does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_ERL_TICK_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_ERL_TICK_SEQ does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Sequence USIM_ERL_TICK_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------------
Nothing to do. Sequence USIM_ERL_TICK_SEQ does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../SEQUENCES/DROP/DROP_USIM_MLV_ID_SEQ.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_MLV_ID_SEQ does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MLV_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_MLV_ID_SEQ does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Sequence USIM_MLV_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_MLV_ID_SEQ does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../SEQUENCES/DROP/DROP_USIM_PLANCK_TIME_SEQ.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_PLANCK_TIME_SEQ does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_PLANCK_TIME_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_PLANCK_TIME_SEQ does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Sequence USIM_PLANCK_TIME_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------------
Nothing to do. Sequence USIM_PLANCK_TIME_SEQ does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../SEQUENCES/DROP/DROP_USIM_PLANCK_AEON_SEQ.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_PLANCK_AEON_SEQ does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_PLANCK_AEON_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_PLANCK_AEON_SEQ does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Sequence USIM_PLANCK_AEON_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------------
Nothing to do. Sequence USIM_PLANCK_AEON_SEQ does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../SEQUENCES/DROP/DROP_USIM_DIM_ID_SEQ.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_DIM_ID_SEQ does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DIM_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_DIM_ID_SEQ does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Sequence USIM_DIM_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_DIM_ID_SEQ does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../SEQUENCES/DROP/DROP_USIM_TSU_ID_SEQ.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_TSU_ID_SEQ does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TSU_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_TSU_ID_SEQ does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Sequence USIM_TSU_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_TSU_ID_SEQ does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../SEQUENCES/DROP/DROP_USIM_POS_ID_SEQ.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_POS_ID_SEQ does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_POS_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_POS_ID_SEQ does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Sequence USIM_POS_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_POS_ID_SEQ does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../SEQUENCES/DROP/DROP_USIM_NOD_ID_SEQ.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_NOD_ID_SEQ does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_NOD_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_NOD_ID_SEQ does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Sequence USIM_NOD_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_NOD_ID_SEQ does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../SEQUENCES/DROP/DROP_USIM_RMD_ID_SEQ.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_RMD_ID_SEQ does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_RMD_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_RMD_ID_SEQ does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Sequence USIM_RMD_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_RMD_ID_SEQ does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../SEQUENCES/DROP/DROP_USIM_SPC_ID_SEQ.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_SPC_ID_SEQ does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_SPC_ID_SEQ does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Sequence USIM_SPC_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_SPC_ID_SEQ does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../SEQUENCES/DROP/DROP_USIM_SPR_ID_SEQ.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Sequence USIM_SPR_ID_SEQ does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPR_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Sequence USIM_SPR_ID_SEQ does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Sequence USIM_SPR_ID_SEQ does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Sequence USIM_SPR_ID_SEQ does not exist.

1 row selected.

SQL> --== sequences end ==--
SQL> --== foreign keys drop for easy delete start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_RMD_MLV_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RMD_MLV_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_REL_MLV_DIM'
  9  	AND constraint_name  = 'USIM_RMD_MLV_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RMD_MLV_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_RMD_MLV_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_RMD_MLV_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_RMD_DIM_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RMD_DIM_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_REL_MLV_DIM'
  9  	AND constraint_name  = 'USIM_RMD_DIM_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RMD_DIM_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_RMD_DIM_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_RMD_DIM_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_RCHI_PARENT_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RCHI_PARENT_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_RMD_CHILD'
  9  	AND constraint_name  = 'USIM_RCHI_PARENT_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RCHI_PARENT_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_RCHI_PARENT_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------------------
Nothing to do. Foreign key USIM_RCHI_PARENT_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_RCHI_CHILD_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RCHI_CHILD_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_RMD_CHILD'
  9  	AND constraint_name  = 'USIM_RCHI_CHILD_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_RCHI_CHILD_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_RCHI_CHILD_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------------
Nothing to do. Foreign key USIM_RCHI_CHILD_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_SPC_POS_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_POS_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_SPACE'
  9  	AND constraint_name  = 'USIM_SPC_POS_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_POS_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPC_POS_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPC_POS_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_SPC_NOD_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_NOD_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_SPACE'
  9  	AND constraint_name  = 'USIM_SPC_NOD_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_NOD_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPC_NOD_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPC_NOD_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_SPC_RMD_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_RMD_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_SPACE'
  9  	AND constraint_name  = 'USIM_SPC_RMD_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPC_RMD_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPC_RMD_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPC_RMD_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_CHI_PARENT_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_CHI_PARENT_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_SPC_CHILD'
  9  	AND constraint_name  = 'USIM_CHI_PARENT_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_CHI_PARENT_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_CHI_PARENT_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------------
Nothing to do. Foreign key USIM_CHI_PARENT_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_CHI_CHILD_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_CHI_CHILD_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_SPC_CHILD'
  9  	AND constraint_name  = 'USIM_CHI_CHILD_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_CHI_CHILD_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_CHI_CHILD_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------------
Nothing to do. Foreign key USIM_CHI_CHILD_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_SPO_SPC_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_SPC_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_SPC_POS'
  9  	AND constraint_name  = 'USIM_SPO_SPC_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_SPC_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPO_SPC_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPO_SPC_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_SPO_RMD_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_RMD_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_SPC_POS'
  9  	AND constraint_name  = 'USIM_SPO_RMD_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_RMD_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPO_RMD_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPO_RMD_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_SPO_POS_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_POS_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_SPC_POS'
  9  	AND constraint_name  = 'USIM_SPO_POS_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPO_POS_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPO_POS_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPO_POS_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_SPR_SRC_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPR_SRC_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_SPC_PROCESS'
  9  	AND constraint_name  = 'USIM_SPR_SRC_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPR_SRC_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPR_SRC_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPR_SRC_FK does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../FK/DROP/DROP_USIM_SPR_TGT_FK.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPR_TGT_FK does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_constraints
  7   WHERE constraint_type  = 'R'
  8  	AND table_name	     = 'USIM_SPC_PROCESS'
  9  	AND constraint_name  = 'USIM_SPR_TGT_FK'
 10  	AND owner	     = '&USIM_SCHEMA'
 11  ;
old  10:    AND owner            = '&USIM_SCHEMA'
new  10:    AND owner            = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Foreign key USIM_SPR_TGT_FK does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Foreign key USIM_SPR_TGT_FK does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Foreign key USIM_SPR_TGT_FK does not exist.

1 row selected.

SQL> --== foreign keys drop for easy delete end ==--
SQL> --== drop views start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../VIEW/DROP/DROP_USIM_RMD_V.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_RMD_V does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8  	AND object_name = 'USIM_RMD_V'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_RMD_V does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('View USIM_RMD_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------
Nothing to do. View USIM_RMD_V does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../VIEW/DROP/DROP_USIM_SPC_CHI_V.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPC_CHI_V does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8  	AND object_name = 'USIM_SPC_CHI_V'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPC_CHI_V does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('View USIM_SPC_CHI_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------
Nothing to do. View USIM_SPC_CHI_V does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../VIEW/DROP/DROP_USIM_SPC_V.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPC_V does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8  	AND object_name = 'USIM_SPC_V'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPC_V does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('View USIM_SPC_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------
Nothing to do. View USIM_SPC_V does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../VIEW/DROP/DROP_USIM_CHI_V.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_CHI_V does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8  	AND object_name = 'USIM_CHI_V'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_CHI_V does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('View USIM_CHI_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------
Nothing to do. View USIM_CHI_V does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../VIEW/DROP/DROP_USIM_SPO_V.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_V does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8  	AND object_name = 'USIM_SPO_V'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_V does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('View USIM_SPO_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------
Nothing to do. View USIM_SPO_V does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../VIEW/DROP/DROP_USIM_SPO_XYZ_V.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_XYZ_V does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8  	AND object_name = 'USIM_SPO_XYZ_V'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_XYZ_V does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('View USIM_SPO_XYZ_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------
Nothing to do. View USIM_SPO_XYZ_V does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../VIEW/DROP/DROP_USIM_SPO_BASE3D_V.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_BASE3D_V does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8  	AND object_name = 'USIM_SPO_BASE3D_V'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_BASE3D_V does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('View USIM_SPO_BASE3D_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. View USIM_SPO_BASE3D_V does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../VIEW/DROP/DROP_USIM_SPO_ZERO3D_V.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_ZERO3D_V does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8  	AND object_name = 'USIM_SPO_ZERO3D_V'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPO_ZERO3D_V does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('View USIM_SPO_ZERO3D_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. View USIM_SPO_ZERO3D_V does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../VIEW/DROP/DROP_USIM_SPR_V.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_SPR_V does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8  	AND object_name = 'USIM_SPR_V'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_SPR_V does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('View USIM_SPR_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------
Nothing to do. View USIM_SPR_V does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../VIEW/DROP/DROP_USIM_MLV_STATE_V.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "View USIM_MLV_STATE_V does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_type = 'VIEW'
  8  	AND object_name = 'USIM_MLV_STATE_V'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "View USIM_MLV_STATE_V does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('View USIM_MLV_STATE_V does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. View USIM_MLV_STATE_V does not exist.

1 row selected.

SQL> --== drop views end ==--
SQL> --== debug tables start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_DEBUG_LOG_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_DEBUG_LOG does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DEBUG_LOG'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_DEBUG_LOG does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_DEBUG_LOG does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------
Nothing to do. Table USIM_DEBUG_LOG does not exist.

1 row selected.

SQL> --== debug tables end ==--
SQL> --== debug package start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_DEBUG_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_DEBUG does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DEBUG'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_DEBUG does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_DEBUG does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package body USIM_DEBUG does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_DEBUG_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_DEBUG does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DEBUG'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_DEBUG does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_DEBUG does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------------
Nothing to do. Package header USIM_DEBUG does not exist.

1 row selected.

SQL> --== debug package end ==--
SQL> --== test tables start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_TEST_SUMMARY_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_TEST_SUMMARY does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TEST_SUMMARY'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_TEST_SUMMARY does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_TEST_SUMMARY does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Table USIM_TEST_SUMMARY does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_TEST_ERRORS_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_TEST_ERRORS does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TEST_ERRORS'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_TEST_ERRORS does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_TEST_ERRORS does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Table USIM_TEST_ERRORS does not exist.

1 row selected.

SQL> --== test tables end ==--
SQL> --== test package start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_TEST_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_TEST does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TEST'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_TEST does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_TEST does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Package body USIM_TEST does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_TEST_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_TEST does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TEST'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_TEST does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_TEST does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Package header USIM_TEST does not exist.

1 row selected.

SQL> --== test package end ==--
SQL> --== packages depending on tables start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_APEX_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_APEX does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_APEX'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_APEX does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_APEX does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Package body USIM_APEX does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_APEX_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package USIM_APEX does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_APEX'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package USIM_APEX does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package USIM_APEX does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------
Nothing to do. Package USIM_APEX does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_ERL_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_ERL does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_ERL'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_ERL does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_ERL does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_ERL does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_ERL_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_ERL does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_ERL'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_ERL does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_ERL does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_ERL does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_BASE_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_BASE does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_BASE'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_BASE does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_BASE does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Package body USIM_BASE does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_BASE_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_BASE does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_BASE'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_BASE does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_BASE does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Package header USIM_BASE does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_MLV_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_MLV does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MLV'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_MLV does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_MLV does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_MLV does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_MLV_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_MLV does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MLV'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_MLV does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_MLV does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_MLV does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_DIM_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_DIM does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DIM'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_DIM does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_DIM does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_DIM does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_DIM_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_DIM does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DIM'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_DIM does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_DIM does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_DIM does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_POS_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_POS does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_POS'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_POS does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_POS does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_POS does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_POS_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_POS does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_POS'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_POS does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_POS does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_POS does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_NOD_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_NOD does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_NOD'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_NOD does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_NOD does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_NOD does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_NOD_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_NOD does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_NOD'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_NOD does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_NOD does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_NOD does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_RMD_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_RMD does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_RMD'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_RMD does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_RMD does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_RMD does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_RMD_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_RMD does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_RMD'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_RMD does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_RMD does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_RMD does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_SPC_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPC does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPC does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_SPC does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_SPC does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_SPC_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPC does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPC does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_SPC does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_SPC does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_CHI_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_CHI does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_CHI'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_CHI does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_CHI does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_CHI does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_CHI_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_CHI does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_CHI'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_CHI does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_CHI does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_CHI does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_SPO_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPO does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPO'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPO does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_SPO does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_SPO does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_SPO_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPO does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPO'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPO does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_SPO does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_SPO does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_SPR_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPR does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPR'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_SPR does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_SPR does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Package body USIM_SPR does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_SPR_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPR does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPR'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_SPR does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_SPR does not exist.', 'No further information available.')  AS info FROM dual

INFO
------------------------------------------------------
Nothing to do. Package header USIM_SPR does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_CREATOR_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_CREATOR does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_CREATOR'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_CREATOR does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_CREATOR does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------------
Nothing to do. Package body USIM_CREATOR does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_CREATOR_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_CREATOR does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_CREATOR'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_CREATOR does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_CREATOR does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Package header USIM_CREATOR does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_PROCESS_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_PROCESS does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_PROCESS'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_PROCESS does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_PROCESS does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------------
Nothing to do. Package body USIM_PROCESS does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_PROCESS_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_PROCESS does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_PROCESS'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_PROCESS does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_PROCESS does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------------
Nothing to do. Package header USIM_PROCESS does not exist.

1 row selected.

SQL> 
SQL> 
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_DBIF_PKB.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package body USIM_DBIF does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DBIF'
  8  	AND object_type = 'PACKAGE BODY'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package body USIM_DBIF does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package body USIM_DBIF does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Package body USIM_DBIF does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../PACKAGES/DROP/DROP_USIM_DBIF_PKS.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Package header USIM_DBIF does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DBIF'
  8  	AND object_type = 'PACKAGE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Package header USIM_DBIF does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Package header USIM_DBIF does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------------
Nothing to do. Package header USIM_DBIF does not exist.

1 row selected.

SQL> --== packages depending on tables end ==--
SQL> --== base data start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_BASEDATA_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_BASEDATA does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_BASEDATA'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_BASEDATA does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_BASEDATA does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------
Nothing to do. Table USIM_BASEDATA does not exist.

1 row selected.

SQL> --== base data end ==--
SQL> --== base tables start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_ERROR_LOG_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_ERROR_LOG does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_ERROR_LOG'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_ERROR_LOG does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_ERROR_LOG does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------
Nothing to do. Table USIM_ERROR_LOG does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_MULTIVERSE_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_MULTIVERSE does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MULTIVERSE'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_MULTIVERSE does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_MULTIVERSE does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------------
Nothing to do. Table USIM_MULTIVERSE does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_DIMENSION_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_DIMENSION does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DIMENSION'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_DIMENSION does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_DIMENSION does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------
Nothing to do. Table USIM_DIMENSION does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_POSITION_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_POSITION does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_POSITION'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_POSITION does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_POSITION does not exist.', 'No further information available.')  AS info FROM dual

INFO
--------------------------------------------------
Nothing to do. Table USIM_POSITION does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_NODE_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_NODE does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_NODE'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_NODE does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_NODE does not exist.', 'No further information available.')  AS info FROM dual

INFO
----------------------------------------------
Nothing to do. Table USIM_NODE does not exist.

1 row selected.

SQL> --== base tables end ==--
SQL> --== relation tables start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_REL_MLV_DIM_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_REL_MLV_DIM does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_REL_MLV_DIM'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_REL_MLV_DIM does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_REL_MLV_DIM does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Table USIM_REL_MLV_DIM does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_RMD_CHILD_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_RMD_CHILD does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_RMD_CHILD'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_RMD_CHILD does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_RMD_CHILD does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------
Nothing to do. Table USIM_RMD_CHILD does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_SPACE_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPACE does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPACE'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_SPACE does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_SPACE does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------
Nothing to do. Table USIM_SPACE does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_SPC_CHILD_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_CHILD does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_CHILD'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_CHILD does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_SPC_CHILD does not exist.', 'No further information available.')  AS info FROM dual

INFO
---------------------------------------------------
Nothing to do. Table USIM_SPC_CHILD does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_SPC_POS_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_POS does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_POS'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_POS does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_SPC_POS does not exist.', 'No further information available.')  AS info FROM dual

INFO
-------------------------------------------------
Nothing to do. Table USIM_SPC_POS does not exist.

1 row selected.

SQL> SELECT CASE
  2  	      WHEN COUNT(*) > 0
  3  	      THEN '../TABLES/DROP/DROP_USIM_SPC_PROCESS_TBL.sql'
  4  	      ELSE '../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_PROCESS does not exist."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_PROCESS'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../UTIL/NOTHING_TO_DO.sql "Table USIM_SPC_PROCESS does not exist."

1 row selected.

SQL> @@&SCRIPTFILE
SQL> SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual;
old   1: SELECT 'Nothing to do. ' || NVL('&1', 'No further information available.')  AS info FROM dual
new   1: SELECT 'Nothing to do. ' || NVL('Table USIM_SPC_PROCESS does not exist.', 'No further information available.')  AS info FROM dual

INFO
-----------------------------------------------------
Nothing to do. Table USIM_SPC_PROCESS does not exist.

1 row selected.

SQL> --== relation tables end ==--
SQL> --== log tables start ==--
SQL> --== log tables end ==--
SQL> -- empty recycle bin
SQL> PURGE recyclebin;

Recyclebin purged.

SQL> @@../UTIL/VERIFY_DROP.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> SELECT COUNT(*) AS objects_after_cleanup
  2    FROM all_objects
  3   WHERE owner = '&USIM_SCHEMA'
  4  ;
old   3:  WHERE owner = '&USIM_SCHEMA'
new   3:  WHERE owner = 'USIM_TEST'

OBJECTS_AFTER_CLEANUP
---------------------
                    0

1 row selected.

SQL> -- overview remaining objects after cleanup
SQL> SELECT object_type
  2  	  , COUNT(*) AS object_cnt
  3    FROM all_objects
  4   WHERE owner = '&USIM_SCHEMA'
  5   GROUP BY object_type
  6  ;
old   4:  WHERE owner = '&USIM_SCHEMA'
new   4:  WHERE owner = 'USIM_TEST'

no rows selected

SQL> -- build model
SQL> @@USIM_MODEL.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> SELECT 'Create or recreate USIM objects.' AS info FROM dual;

INFO
--------------------------------
Create or recreate USIM objects.

1 row selected.

SQL> --== error logging start ==--
SQL> -- USIM_ERL_TICK_SEQ
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../SEQUENCES/USIM_ERL_TICK_SEQ.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_ERL_TICK_SEQ still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_ERL_TICK_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------------
../SEQUENCES/USIM_ERL_TICK_SEQ.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_ERROR_LOG (erl) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_erl_tick_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
old   1: CREATE SEQUENCE &USIM_SCHEMA..usim_erl_tick_seq
new   1: CREATE SEQUENCE USIM_TEST.usim_erl_tick_seq

Sequence created.

SQL> -- USIM_ERROR_LOG (erl)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_ERROR_LOG_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_ERROR_LOG still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_ERROR_LOG'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../TABLES/USIM_ERROR_LOG_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_ERROR_LOG (erl)
SQL> CREATE TABLE &USIM_SCHEMA..usim_error_log
  2    ( usim_timestamp    TIMESTAMP	   DEFAULT SYSTIMESTAMP  NOT NULL ENABLE
  3    , usim_tick	   NUMBER				 NOT NULL ENABLE
  4    , usim_err_object   VARCHAR2(200)			 NOT NULL ENABLE
  5    , usim_err_info	   VARCHAR2(4000)			 NOT NULL ENABLE
  6    )
  7  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_error_log
new   1: CREATE TABLE USIM_TEST.usim_error_log

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_error_log IS 'Used by package functions returning NULL to report the error condition. Will use the alias erl.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_error_log IS 'Used by package functions returning NULL to report the error condition. Will use the alias erl.'
new   1: COMMENT ON TABLE USIM_TEST.usim_error_log IS 'Used by package functions returning NULL to report the error condition. Will use the alias erl.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_error_log.usim_timestamp IS 'The timestamp of the error logging action.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_error_log.usim_timestamp IS 'The timestamp of the error logging action.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_error_log.usim_timestamp IS 'The timestamp of the error logging action.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_error_log.usim_err_object IS 'The object description in form of package.function.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_error_log.usim_err_object IS 'The object description in form of package.function.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_error_log.usim_err_object IS 'The object description in form of package.function.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_error_log.usim_err_info IS 'The short details on the error, e.g. used parameters.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_error_log.usim_err_info IS 'The short details on the error, e.g. used parameters.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_error_log.usim_err_info IS 'The short details on the error, e.g. used parameters.'

Comment created.

SQL> 
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_erl_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_error_log
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   :NEW.usim_tick := usim_erl_tick_seq.NEXTVAL;
  6  	 END;
  7  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_erl_ins_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_erl_ins_trg
old   2:   BEFORE INSERT ON &USIM_SCHEMA..usim_error_log
new   2:   BEFORE INSERT ON USIM_TEST.usim_error_log

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_erl_ins_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_erl_ins_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_erl_ins_trg ENABLE

Trigger altered.

SQL> -- USIM_DLG_ID_SEQ
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../SEQUENCES/USIM_DLG_ID_SEQ.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_DLG_ID_SEQ still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DLG_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_DLG_ID_SEQ.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_DEBUG_LOG (dlg) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_dlg_id_seq
  2    MINVALUE 1
  3    INCREMENT BY 1
  4    START WITH 1
  5    CACHE 20
  6    NOORDER
  7    NOCYCLE
  8    NOKEEP
  9    NOSCALE
 10    GLOBAL
 11  ;
old   1: CREATE SEQUENCE &USIM_SCHEMA..usim_dlg_id_seq
new   1: CREATE SEQUENCE USIM_TEST.usim_dlg_id_seq

Sequence created.

SQL> -- USIM_DEBUG_LOG (dlg)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_DEBUG_LOG_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_DEBUG_LOG still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DEBUG_LOG'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../TABLES/USIM_DEBUG_LOG_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_DEBUG_LOG (dlg)
SQL> CREATE TABLE &USIM_SCHEMA..usim_debug_log
  2    ( usim_id_dlg	     NUMBER(38, 0)
  3    , usim_timestamp      TIMESTAMP
  4    , usim_status	     NUMBER(1, 0)
  5    , usim_log_object     VARCHAR2(1000)
  6    , usim_log_content    CLOB
  7    )
  8  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_debug_log
new   1: CREATE TABLE USIM_TEST.usim_debug_log

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_debug_log IS 'A table for logging temporary debug results. Will use the alias dlg.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_debug_log IS 'A table for logging temporary debug results. Will use the alias dlg.'
new   1: COMMENT ON TABLE USIM_TEST.usim_debug_log IS 'A table for logging temporary debug results. Will use the alias dlg.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_id_dlg IS 'The id for debug log action.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_id_dlg IS 'The id for debug log action.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_debug_log.usim_id_dlg IS 'The id for debug log action.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_timestamp IS 'The timestamp for a debug log action.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_timestamp IS 'The timestamp for a debug log action.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_debug_log.usim_timestamp IS 'The timestamp for a debug log action.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_status IS 'Status of debug action -1 = ERROR, 0 = WARNING, 1 = SUCCESS, 2 = INFO.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_status IS 'Status of debug action -1 = ERROR, 0 = WARNING, 1 = SUCCESS, 2 = INFO.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_debug_log.usim_status IS 'Status of debug action -1 = ERROR, 0 = WARNING, 1 = SUCCESS, 2 = INFO.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_log_object IS 'The object of a debug log action.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_log_object IS 'The object of a debug log action.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_debug_log.usim_log_object IS 'The object of a debug log action.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_log_content IS 'The debug information content of a debug log action.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_debug_log.usim_log_content IS 'The debug information content of a debug log action.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_debug_log.usim_log_content IS 'The debug information content of a debug log action.'

Comment created.

SQL> 
SQL> -- idx
SQL> CREATE INDEX &USIM_SCHEMA..usim_dlg_idx
  2  	 ON &USIM_SCHEMA..usim_debug_log
  3  	    (usim_id_dlg)
  4  ;
old   1: CREATE INDEX &USIM_SCHEMA..usim_dlg_idx
new   1: CREATE INDEX USIM_TEST.usim_dlg_idx
old   2:     ON &USIM_SCHEMA..usim_debug_log
new   2:     ON USIM_TEST.usim_debug_log

Index created.

SQL> -- error logging package
SQL> @@../PACKAGES/USIM_ERL.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_erl
  2  IS
  3    /**A package for actions on table usim_error_log.*/
  4  
  5    /**
  6    * Writes given possible error informations to usim_error_log as an autonomous transaction.
  7    * Package functions returning NULL state in most cases an inproper use of functions, if not
  8    * handled in the calling code explicitly, except for testing. Purge log after testing.
  9    * Will cut strings to meet the size of the table columns.
 10    */
 11    PROCEDURE log_error( p_usim_err_object  IN VARCHAR2
 12  			  , p_usim_err_info    IN VARCHAR2
 13  			  )
 14    ;
 15  
 16    /**
 17    * Purges all current saved informations from the usim_error_log table.
 18    */
 19    PROCEDURE purge_log;
 20  
 21  END usim_erl;
 22  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_erl
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_erl

Package created.

SQL> @@../PACKAGES/USIM_ERL.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_erl
  2  IS
  3    -- see header for documentation
  4    PROCEDURE log_error( p_usim_err_object  IN VARCHAR2
  5  			  , p_usim_err_info    IN VARCHAR2
  6  			  )
  7    IS
  8  	 PRAGMA AUTONOMOUS_TRANSACTION;
  9    BEGIN
 10  	 INSERT INTO usim_error_log
 11  	   ( usim_timestamp
 12  	   , usim_err_object
 13  	   , usim_err_info
 14  	   )
 15  	   VALUES
 16  	   ( SYSTIMESTAMP
 17  	   , NVL(SUBSTR(p_usim_err_object, 1, 200), 'ERROR MISSING object definition')
 18  	   , NVL(SUBSTR(p_usim_err_info, 1, 4000), 'ERROR MISSING error description')
 19  	   )
 20  	 ;
 21  	 COMMIT;
 22    END log_error
 23    ;
 24  
 25    PROCEDURE purge_log
 26    IS
 27  	 PRAGMA AUTONOMOUS_TRANSACTION;
 28    BEGIN
 29  	 DELETE usim_error_log;
 30  	 COMMIT;
 31    END purge_log
 32    ;
 33  
 34  END usim_erl;
 35  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_erl
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_erl

Package body created.

SQL> @@../PACKAGES/USIM_DEBUG.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_debug
  2  IS
  3    /** A package for debugging purposes.
  4    *
  5    * Package is session dependend. Debug mode is
  6    * disabled by default and if set only valid in the
  7    * the current session.
  8    */
  9  
 10    /**
 11    * Check debug state in PL/SQL Code.
 12    * @return TRUE if debug is enabled for this session, otherwise FALSE.
 13    */
 14    FUNCTION is_debug_on
 15  	 RETURN BOOLEAN
 16    ;
 17  
 18    /**
 19    * Check debug state in SQL.
 20    * @return "TRUE" if debug is enabled for this session, otherwise "FALSE".
 21    */
 22    FUNCTION is_debug
 23  	 RETURN VARCHAR2
 24    ;
 25  
 26    /**
 27    * Activate debug state and intialize an internal debug id which can be used
 28    * for the whole session.
 29    */
 30    PROCEDURE set_debug_on;
 31  
 32    /**
 33    * Deactivate debug state.
 34    */
 35    PROCEDURE set_debug_off;
 36  
 37    /**
 38    * Starts a debug session, if debug state is on for this session and user wants to control
 39    * the debug ids.
 40    * @return A new debug id or NULL if debug state is not set.
 41    */
 42    FUNCTION start_debug
 43  	 RETURN usim_debug_log.usim_id_dlg%TYPE
 44    ;
 45  
 46    /**
 47    * Returns a text representation of supported status values.
 48    * @param p_usim_status The status value to get the text representation for.
 49    * @return The text for the given status value or UNKNOWN.
 50    */
 51    FUNCTION debug_status_txt(p_usim_status IN usim_debug_log.usim_status%TYPE)
 52  	 RETURN VARCHAR2
 53  	 DETERMINISTIC
 54  	 PARALLEL_ENABLE
 55    ;
 56  
 57    /**
 58    * Delete all entries of the current debug log.
 59    */
 60    PROCEDURE purge_log;
 61  
 62    /**
 63    * Creates a debug log entry in USIM_DEBUG_LOG if debug state
 64    * is set. Requires a valid id from START_DEBUG.
 65    * @param p_usim_id_dlg The debug ID to use.
 66    * @param p_usim_status The debug status for this debug entry.
 67    * @param p_usim_log_object The function or procedure name, e.g. USIM_DEBUG.DEBUG_LOG.
 68    * @param p_usim_log_content The debug message to use limited to VARCHAR2 size.
 69    */
 70    PROCEDURE debug_log( p_usim_id_dlg	 IN usim_debug_log.usim_id_dlg%TYPE
 71  			  , p_usim_status	 IN usim_debug_log.usim_status%TYPE
 72  			  , p_usim_log_object	 IN usim_debug_log.usim_log_object%TYPE
 73  			  , p_usim_log_content	 IN VARCHAR2
 74  			  )
 75    ;
 76  
 77    /**
 78    * Creates a debug log entry in USIM_DEBUG_LOG if debug state
 79    * is set. Requires a valid id from START_DEBUG.
 80    * @param p_usim_id_dlg The debug ID to use.
 81    * @param p_usim_status The debug status for this debug entry.
 82    * @param p_usim_log_object The function or procedure name, e.g. USIM_DEBUG.DEBUG_LOG.
 83    * @param p_usim_log_content The debug message to use limited to CLOB size.
 84    */
 85    PROCEDURE debug_log( p_usim_id_dlg	 IN usim_debug_log.usim_id_dlg%TYPE
 86  			  , p_usim_status	 IN usim_debug_log.usim_status%TYPE
 87  			  , p_usim_log_object	 IN usim_debug_log.usim_log_object%TYPE
 88  			  , p_usim_log_content	 IN usim_debug_log.usim_log_content%TYPE
 89  			  )
 90    ;
 91  
 92    /**
 93    * Creates a debug log entry in USIM_DEBUG_LOG if debug state
 94    * is set. Uses internal session debug id.
 95    * @param p_usim_log_object The function or procedure name, e.g. USIM_DEBUG.DEBUG_LOG.
 96    * @param p_usim_log_content The debug message to use limited to CLOB size.
 97    * @param p_usim_status The debug status for this debug entry. Default 2 INFO.
 98    */
 99    PROCEDURE debug_log( p_usim_log_object	 IN usim_debug_log.usim_log_object%TYPE
100  			  , p_usim_log_content	 IN usim_debug_log.usim_log_content%TYPE
101  			  , p_usim_status	 IN usim_debug_log.usim_status%TYPE	 DEFAULT 2
102  			  )
103    ;
104  
105  END usim_debug;
106  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_debug
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_debug

Package created.

SQL> @@../PACKAGES/USIM_DEBUG.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_debug
  2  IS
  3    -- package variables
  4    debug_status  BOOLEAN;
  5    debug_id      usim_debug_log.usim_id_dlg%TYPE;
  6  
  7    -- functions and procedures
  8    FUNCTION is_debug_on
  9  	 RETURN BOOLEAN
 10    IS
 11    BEGIN
 12  	 RETURN debug_status;
 13    END is_debug_on
 14    ;
 15  
 16    FUNCTION is_debug
 17  	 RETURN VARCHAR2
 18    IS
 19    BEGIN
 20  	 RETURN CASE WHEN debug_status THEN 'TRUE' ELSE 'FALSE' END;
 21    END is_debug
 22    ;
 23  
 24    PROCEDURE set_debug_on
 25    IS
 26    BEGIN
 27  	 debug_status := TRUE;
 28  	 debug_id     := usim_dlg_id_seq.NEXTVAL;
 29    END set_debug_on
 30    ;
 31  
 32    PROCEDURE set_debug_off
 33    IS
 34    BEGIN
 35  	 debug_status := FALSE;
 36    END set_debug_off
 37    ;
 38  
 39    FUNCTION start_debug
 40  	 RETURN usim_debug_log.usim_id_dlg%TYPE
 41    IS
 42    BEGIN
 43  	 IF debug_status
 44  	 THEN
 45  	   RETURN usim_dlg_id_seq.NEXTVAL;
 46  	 ELSE
 47  	   RETURN NULL;
 48  	 END IF;
 49    END start_debug
 50    ;
 51  
 52    FUNCTION debug_status_txt(p_usim_status IN usim_debug_log.usim_status%TYPE)
 53  	 RETURN VARCHAR2
 54  	 DETERMINISTIC
 55  	 PARALLEL_ENABLE
 56    IS
 57    BEGIN
 58  	 IF p_usim_status = -1
 59  	 THEN
 60  	   RETURN 'ERROR';
 61  	 ELSIF p_usim_status = 0
 62  	 THEN
 63  	   RETURN 'WARNING';
 64  	 ELSIF p_usim_status = 1
 65  	 THEN
 66  	   RETURN 'SUCCESS';
 67  	 ELSIF p_usim_status = 2
 68  	 THEN
 69  	   RETURN 'INFO';
 70  	 ELSE
 71  	   RETURN 'UNKNOWN';
 72  	 END IF;
 73    END debug_status_txt
 74    ;
 75  
 76    PROCEDURE purge_log
 77    IS
 78  	 PRAGMA AUTONOMOUS_TRANSACTION;
 79    BEGIN
 80  	 DELETE usim_debug_log;
 81  	 COMMIT;
 82    END purge_log
 83    ;
 84  
 85    PROCEDURE debug_log( p_usim_id_dlg	 IN usim_debug_log.usim_id_dlg%TYPE
 86  			  , p_usim_status	 IN usim_debug_log.usim_status%TYPE
 87  			  , p_usim_log_object	 IN usim_debug_log.usim_log_object%TYPE
 88  			  , p_usim_log_content	 IN VARCHAR2
 89  			  )
 90    IS
 91  	 l_usim_log_content  CLOB;
 92    BEGIN
 93  	 IF debug_status AND p_usim_id_dlg IS NOT NULL
 94  	 THEN
 95  	   l_usim_log_content := p_usim_log_content;
 96  	   debug_log(p_usim_id_dlg, p_usim_status, p_usim_log_object, l_usim_log_content);
 97  	 END IF;
 98    END debug_log
 99    ;
100  
101    PROCEDURE debug_log( p_usim_id_dlg	 IN usim_debug_log.usim_id_dlg%TYPE
102  			  , p_usim_status	 IN usim_debug_log.usim_status%TYPE
103  			  , p_usim_log_object	 IN usim_debug_log.usim_log_object%TYPE
104  			  , p_usim_log_content	 IN usim_debug_log.usim_log_content%TYPE
105  			  )
106    IS
107  	 PRAGMA AUTONOMOUS_TRANSACTION;
108    BEGIN
109  	 IF debug_status AND p_usim_id_dlg IS NOT NULL
110  	 THEN
111  	   INSERT INTO usim_debug_log
112  	     ( usim_id_dlg
113  	     , usim_timestamp
114  	     , usim_status
115  	     , usim_log_object
116  	     , usim_log_content
117  	     )
118  	     VALUES
119  	     ( p_usim_id_dlg
120  	     , SYSTIMESTAMP
121  	     , p_usim_status
122  	     , p_usim_log_object
123  	     , p_usim_log_content
124  	     )
125  	   ;
126  	   COMMIT;
127  	 END IF;
128    END debug_log
129    ;
130  
131    PROCEDURE debug_log( p_usim_log_object	 IN usim_debug_log.usim_log_object%TYPE
132  			  , p_usim_log_content	 IN usim_debug_log.usim_log_content%TYPE
133  			  , p_usim_status	 IN usim_debug_log.usim_status%TYPE	 DEFAULT 2
134  			  )
135    IS
136  	 PRAGMA AUTONOMOUS_TRANSACTION;
137    BEGIN
138  	 IF debug_status
139  	 THEN
140  	   INSERT INTO usim_debug_log
141  	     ( usim_id_dlg
142  	     , usim_timestamp
143  	     , usim_status
144  	     , usim_log_object
145  	     , usim_log_content
146  	     )
147  	     VALUES
148  	     ( debug_id
149  	     , SYSTIMESTAMP
150  	     , p_usim_status
151  	     , p_usim_log_object
152  	     , p_usim_log_content
153  	     )
154  	   ;
155  	   COMMIT;
156  	 END IF;
157    END debug_log
158    ;
159  
160  BEGIN
161    -- init debug state for the current session
162    debug_status := FALSE;
163    debug_id     := NULL;
164  END usim_debug;
165  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_debug
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_debug

Package body created.

SQL> --== error logging end ==--
SQL> --== basic packages start ==--
SQL> @@../PACKAGES/USIM_STATIC.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_static
  2  IS
  3    /** A Package containing static values and SQL functions for retrieving this values to be used with the application. Changing values
  4    * in this package may break the application.
  5    *
  6    * Package constants:
  7    * <b>usim_max_childs_per_dimension</b> - a constant value for the allowed amount of child nodes within a given dimension. Application relies on this value.
  8    * <b>usim_max_seeds</b> - a constant value for the maximum seeds a universe can have, means the maximum of points with dimension and position without a parent. Application relies on this value.
  9    * <b>usim_planck_time_seq_name</b> - a constant for the sequence name responsible for planck time ticks.
 10    * <b>usim_planck_aeon_seq_name</b> - a constant for the sequence name responsible for planck aeons.
 11    * <b>usim_not_available</b> - a constant name for filled char fields which are not Null, but have no usable content.
 12    * <b>usim_side_from</b> - a constant name for the from side of a volume in space.
 13    * <b>usim_side_to</b> - a constant name for the to side of a volume in space.
 14    * <b>usim_side_both</b> - a constant name for basic space universe nodes in dimension 0, position 0 and sign 0 which are parents to base and mirror at the same time.
 15    * <b>usim_status_success</b> - a constant for debug success.
 16    * <b>usim_status_error</b> - a constant for debug error.
 17    * <b>usim_status_warning</b> - a constant for debug warning.
 18    * <b>usim_multiverse_status_active</b> - a constant for the active status of a multiverse.
 19    * <b>usim_multiverse_status_inactive</b> - a constant for the inactive status of a multiverse (all energy equals NULL).
 20    * <b>usim_multiverse_status_dead</b> - a constant for the dead status of a multiverse (all energy equals 0).
 21    * <b>usim_multiverse_status_crashed</b> - a constant for the crashed status of a multiverse (energy not equilibrated between universe and mirror).
 22    * <b>PI</b> - a constant for PI definition with Oracle precision.
 23    * <b>PI_DOUBLE</b> - a constant for 2 * PI definition with Oracle precision.
 24    * <b>PI_QUARTER</b> - a constant for PI / 4 definition with Oracle precision.
 25    */
 26    usim_max_childs_per_dimension   CONSTANT INTEGER      := 1;
 27    usim_max_seeds		       CONSTANT INTEGER      := 1;
 28    usim_planck_time_seq_name       CONSTANT CHAR(20)     := 'USIM_PLANCK_TIME_SEQ';
 29    usim_planck_aeon_seq_name       CONSTANT CHAR(20)     := 'USIM_PLANCK_AEON_SEQ';
 30    usim_not_available	       CONSTANT CHAR(3)      := 'N/A';
 31    usim_side_from		       CONSTANT CHAR(1)      := 'F';
 32    usim_side_to		       CONSTANT CHAR(1)      := 'T';
 33    usim_side_both		       CONSTANT CHAR(1)      := 'B';
 34    usim_status_success	       CONSTANT NUMBER	     := 1;
 35    usim_status_error	       CONSTANT NUMBER	     := -1;
 36    usim_status_warning	       CONSTANT NUMBER	     := 0;
 37    usim_multiverse_status_active   CONSTANT NUMBER	     := 1;
 38    usim_multiverse_status_inactive CONSTANT NUMBER	     := 0;
 39    usim_multiverse_status_dead     CONSTANT NUMBER	     := -1;
 40    usim_multiverse_status_crashed  CONSTANT NUMBER	     := -2;
 41    PI			       CONSTANT NUMBER	     := ACOS(-1);
 42    PI_DOUBLE		       CONSTANT NUMBER	     := ACOS(-1) * 2;
 43    PI_QUARTER		       CONSTANT NUMBER	     := ACOS(-1) / 4;
 44  
 45    /**
 46    * Types
 47    */
 48    SUBTYPE usim_id IS CHAR(55);
 49    TYPE usim_ids_type IS TABLE OF usim_id INDEX BY PLS_INTEGER;
 50  
 51    /**
 52    * Get the maximum of childs a node within a dimension can have.
 53    * @return USIM_STATIC.USIM_MAX_CHILDS_PER_DIMENSION
 54    */
 55    FUNCTION get_max_childs_per_dimension
 56  	 RETURN NUMBER
 57  	 DETERMINISTIC
 58  	 PARALLEL_ENABLE
 59    ;
 60  
 61    /**
 62    * Get the maximum of seeds a universe can have.
 63    * @return USIM_STATIC.USIM_MAX_SEEDS
 64    */
 65    FUNCTION get_max_seeds
 66  	 RETURN NUMBER
 67  	 DETERMINISTIC
 68  	 PARALLEL_ENABLE
 69    ;
 70  
 71    /**
 72    * Get the static PI value.
 73    * @return USIM_STATIC.PI
 74    */
 75    FUNCTION get_pi
 76  	 RETURN NUMBER
 77  	 DETERMINISTIC
 78  	 PARALLEL_ENABLE
 79    ;
 80  
 81    /**
 82    * Get the static PI_DOUBLE (2 * PI) value.
 83    * @return USIM_STATIC.PI_DOUBLE
 84    */
 85    FUNCTION get_pi_double
 86  	 RETURN NUMBER
 87  	 DETERMINISTIC
 88  	 PARALLEL_ENABLE
 89    ;
 90  
 91    /**
 92    * Get the static PI_QUARTER (PI / 4) value.
 93    * @return USIM_STATIC.PI_QUARTER
 94    */
 95    FUNCTION get_pi_quarter
 96  	 RETURN NUMBER
 97  	 DETERMINISTIC
 98  	 PARALLEL_ENABLE
 99    ;
100  
101    /**
102    * Get the static name of the planck time sequence.
103    * @return USIM_STATIC.USIM_PLANCK_TIME_SEQ_NAME
104    */
105    FUNCTION get_planck_time_seq_name
106  	 RETURN VARCHAR2
107  	 DETERMINISTIC
108  	 PARALLEL_ENABLE
109    ;
110  
111    /**
112    * Get the static name of the planck time sequence.
113    * @return USIM_STATIC.USIM_PLANCK_AEON_SEQ_NAME
114    */
115    FUNCTION get_planck_aeon_seq_name
116  	 RETURN VARCHAR2
117  	 DETERMINISTIC
118  	 PARALLEL_ENABLE
119    ;
120  
121    /**
122    * Get the static name for not available.
123    * @return USIM_STATIC.USIM_NOT_AVAILABLE
124    */
125    FUNCTION get_not_available
126  	 RETURN VARCHAR2
127  	 DETERMINISTIC
128  	 PARALLEL_ENABLE
129    ;
130  
131    /**
132    * Get the static name for volume side from.
133    * @return USIM_STATIC.USIM_SIDE_FROM
134    */
135    FUNCTION get_side_from
136  	 RETURN VARCHAR2
137  	 DETERMINISTIC
138  	 PARALLEL_ENABLE
139    ;
140  
141    /**
142    * Get the static name for volume side to.
143    * @return USIM_STATIC.USIM_SIDE_TO
144    */
145    FUNCTION get_side_to
146  	 RETURN VARCHAR2
147  	 DETERMINISTIC
148  	 PARALLEL_ENABLE
149    ;
150  
151    /**
152    * Get the static name for volume side both.
153    * @return USIM_STATIC.USIM_SIDE_BOTH
154    */
155    FUNCTION get_side_both
156  	 RETURN VARCHAR2
157  	 DETERMINISTIC
158  	 PARALLEL_ENABLE
159    ;
160  
161    /**
162    * Get the identifier number for success of debug operations.
163    * @return USIM_STATIC.USIM_STATUS_SUCCESS
164    */
165    FUNCTION get_debug_success
166  	 RETURN NUMBER
167  	 DETERMINISTIC
168  	 PARALLEL_ENABLE
169    ;
170  
171    /**
172    * Get the identifier number for error of debug operations.
173    * @return USIM_STATIC.USIM_STATUS_ERROR
174    */
175    FUNCTION get_debug_error
176  	 RETURN NUMBER
177  	 DETERMINISTIC
178  	 PARALLEL_ENABLE
179    ;
180  
181    /**
182    * Get the identifier number for warning of debug operations.
183    * @return USIM_STATIC.USIM_STATUS_WARNING
184    */
185    FUNCTION get_debug_warning
186  	 RETURN NUMBER
187  	 DETERMINISTIC
188  	 PARALLEL_ENABLE
189    ;
190  
191    /**
192    * Get the active status of a multiverse.
193    * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_ACTIVE
194    */
195    FUNCTION get_multiverse_active
196  	 RETURN NUMBER
197  	 DETERMINISTIC
198  	 PARALLEL_ENABLE
199    ;
200  
201    /**
202    * Get the inactive status of a multiverse.
203    * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_INACTIVE
204    */
205    FUNCTION get_multiverse_inactive
206  	 RETURN NUMBER
207  	 DETERMINISTIC
208  	 PARALLEL_ENABLE
209    ;
210  
211    /**
212    * Get the dead status of a multiverse.
213    * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_DEAD
214    */
215    FUNCTION get_multiverse_dead
216  	 RETURN NUMBER
217  	 DETERMINISTIC
218  	 PARALLEL_ENABLE
219    ;
220  
221    /**
222    * Get the crashed status of a multiverse.
223    * @return USIM_STATIC.USIM_MULTIVERSE_STATUS_CRASHED
224    */
225    FUNCTION get_multiverse_crashed
226  	 RETURN NUMBER
227  	 DETERMINISTIC
228  	 PARALLEL_ENABLE
229    ;
230  
231    /**
232    * Get a text representation of the status of a multiverse.
233    * @return ACTIVE, INACTIVE, DEAD, CRASHED or UNKOWN status of universe by number identifier.
234    */
235    FUNCTION get_multiverse_status(p_status IN NUMBER)
236  	 RETURN VARCHAR2
237  	 DETERMINISTIC
238  	 PARALLEL_ENABLE
239    ;
240  
241    /**
242    * Get the identifier text for status of debug operations.
243    * @param p_status - the debug status to get the text for.
244    * @return SUCCESS, WARNING or ERROR
245    */
246    FUNCTION get_debug_status(p_status IN NUMBER)
247  	 RETURN VARCHAR2
248  	 DETERMINISTIC
249  	 PARALLEL_ENABLE
250    ;
251  
252    /**
253    * Get a text representation of a boolean value. Only for use in PL/SQL. Won't work with SQL statements.
254    * @param p_boolean - the boolean expression or variable.
255    * @return "TRUE" or "FALSE"
256    */
257    FUNCTION get_bool_str(p_boolean IN BOOLEAN)
258  	 RETURN VARCHAR2
259  	 DETERMINISTIC
260  	 PARALLEL_ENABLE
261    ;
262  
263    /**
264    * Returns a VARCHAR2 of length 55 using current timestamp
265    * and the number from a cycling sequence to build a generic
266    * primary key which does not cause number overflows or end of
267    * available sequence numbers.
268    * @param p_sequence_number - the cycling sequence number to add to the key.
269    * @return New primary key in format TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISSFF3') || LPAD([sequence], 38, '0').
270    */
271    FUNCTION get_big_pk(p_sequence_number IN NUMBER)
272  	 RETURN VARCHAR2
273    ;
274  
275    /**
276    * Returns the date value of a big primary key.
277    * @param p_primary_key - the primary key to get the date from.
278    * @return Normal DATE including seconds of the given primary key.
279    */
280    FUNCTION get_big_pk_date(p_primary_key IN VARCHAR2)
281  	 RETURN DATE
282    ;
283  
284    /**
285    * Returns the number value of a big primary key.
286    * @param p_primary_key - the primary key to get the number value from.
287    * @return Number value of the given primary key.
288    */
289    FUNCTION get_big_pk_number(p_primary_key IN VARCHAR2)
290  	 RETURN NUMBER
291    ;
292  
293    /**
294    * Returns the next number based on given number and sign.
295    * Adds 1 for sign +1 and subtract 1 for sign -1.
296    * @param p_number The number to get the next number for.
297    * @param p_sign The sign for the number to use. Only used if number is 0, otherwise sign is retrieved from given number. Sign 0 is interpreted positive.
298    * @return The next number based on (given) sign of the number.
299    */
300    FUNCTION get_next_number( p_number IN NUMBER
301  			       , p_sign   IN NUMBER DEFAULT 1
302  			       )
303  	 RETURN NUMBER
304    ;
305  
306    /**
307    * Calculates the nodes defining a volume by dimension.
308    * Uses 2<sup>dimension</sup>.
309    * @param p_dimension The dimension to calculate the amount of nodes. Must be >= 0, values < 0 are interpreted as 0.
310    * @return The amount of nodes that define a volume for a given dimension.
311    */
312    FUNCTION nodes_per_dimension(p_dimension IN NUMBER)
313  	 RETURN NUMBER
314  	 DETERMINISTIC
315  	 PARALLEL_ENABLE
316    ;
317  
318    /**
319    * Calculates the nodes missing for a given dimension, supposing that former dimensions and nodes already exist.
320    * Uses nodes_per_dimension(dimension) - nodes_per_dimension(dimension - 1) with special case dimension 0 and 1.
321    * @param p_dimension The dimension to calculate the amount of missing nodes. Must be >= 0, values < 0 are interpreted as 0.
322    * @return The amount of missing nodes for a volume and a given dimension.
323    */
324    FUNCTION missing_nodes_per_dimension(p_dimension IN NUMBER)
325  	 RETURN NUMBER
326  	 DETERMINISTIC
327  	 PARALLEL_ENABLE
328    ;
329  
330    /**
331    * Checks if a given side is an allowed side.
332    * @param p_side The side symbol to check.
333    * @return Returns 1 if side symbol equals usim_side_from, usim_side_to or usim_side_both, otherwise 0.
334    */
335    FUNCTION is_allowed_side(p_side IN VARCHAR2)
336  	 RETURN NUMBER
337  	 DETERMINISTIC
338  	 PARALLEL_ENABLE
339    ;
340  
341    /**
342    * Checks if a given side is an allowed from or to side.
343    * @param p_side The side symbol to check.
344    * @return Returns 1 if side symbol equals usim_side_from or usim_side_to, otherwise 0.
345    */
346    FUNCTION is_allowed_fromto_side(p_side IN VARCHAR2)
347  	 RETURN NUMBER
348  	 DETERMINISTIC
349  	 PARALLEL_ENABLE
350    ;
351  
352  END usim_static;
353  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_static
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_static

Package created.

SQL> @@../PACKAGES/USIM_STATIC.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_static
  2  IS
  3    -- decription see header
  4    FUNCTION get_max_childs_per_dimension
  5  	 RETURN NUMBER
  6  	 DETERMINISTIC
  7  	 PARALLEL_ENABLE
  8    IS
  9    BEGIN
 10  	 RETURN usim_static.usim_max_childs_per_dimension;
 11    END get_max_childs_per_dimension
 12    ;
 13  
 14    FUNCTION get_max_seeds
 15  	 RETURN NUMBER
 16  	 DETERMINISTIC
 17  	 PARALLEL_ENABLE
 18    IS
 19    BEGIN
 20  	 RETURN usim_static.usim_max_seeds;
 21    END get_max_seeds
 22    ;
 23  
 24    FUNCTION get_pi
 25  	 RETURN NUMBER
 26  	 DETERMINISTIC
 27  	 PARALLEL_ENABLE
 28    IS
 29    BEGIN
 30  	 RETURN usim_static.PI;
 31    END get_pi
 32    ;
 33  
 34    FUNCTION get_pi_double
 35  	 RETURN NUMBER
 36  	 DETERMINISTIC
 37  	 PARALLEL_ENABLE
 38    IS
 39    BEGIN
 40  	 RETURN usim_static.PI_DOUBLE;
 41    END get_pi_double
 42    ;
 43  
 44    FUNCTION get_pi_quarter
 45  	 RETURN NUMBER
 46  	 DETERMINISTIC
 47  	 PARALLEL_ENABLE
 48    IS
 49    BEGIN
 50  	 RETURN usim_static.PI_QUARTER;
 51    END get_pi_quarter
 52    ;
 53  
 54    FUNCTION get_planck_time_seq_name
 55  	 RETURN VARCHAR2
 56  	 DETERMINISTIC
 57  	 PARALLEL_ENABLE
 58    IS
 59    BEGIN
 60  	 RETURN usim_static.usim_planck_time_seq_name;
 61    END get_planck_time_seq_name
 62    ;
 63  
 64    FUNCTION get_planck_aeon_seq_name
 65  	 RETURN VARCHAR2
 66  	 DETERMINISTIC
 67  	 PARALLEL_ENABLE
 68    IS
 69    BEGIN
 70  	 RETURN usim_static.usim_planck_aeon_seq_name;
 71    END get_planck_aeon_seq_name
 72    ;
 73  
 74    FUNCTION get_not_available
 75  	 RETURN VARCHAR2
 76  	 DETERMINISTIC
 77  	 PARALLEL_ENABLE
 78    IS
 79    BEGIN
 80  	 RETURN usim_static.usim_not_available;
 81    END get_not_available
 82    ;
 83  
 84    FUNCTION get_side_from
 85  	 RETURN VARCHAR2
 86  	 DETERMINISTIC
 87  	 PARALLEL_ENABLE
 88    IS
 89    BEGIN
 90  	 RETURN usim_static.usim_side_from;
 91    END get_side_from
 92    ;
 93  
 94    FUNCTION get_side_to
 95  	 RETURN VARCHAR2
 96  	 DETERMINISTIC
 97  	 PARALLEL_ENABLE
 98    IS
 99    BEGIN
100  	 RETURN usim_static.usim_side_to;
101    END get_side_to
102    ;
103  
104    FUNCTION get_side_both
105  	 RETURN VARCHAR2
106  	 DETERMINISTIC
107  	 PARALLEL_ENABLE
108    IS
109    BEGIN
110  	 RETURN usim_static.usim_side_both;
111    END get_side_both
112    ;
113  
114    FUNCTION get_debug_success
115  	 RETURN NUMBER
116  	 DETERMINISTIC
117  	 PARALLEL_ENABLE
118    IS
119    BEGIN
120  	 RETURN usim_static.usim_status_success;
121    END get_debug_success
122    ;
123  
124    FUNCTION get_debug_error
125  	 RETURN NUMBER
126  	 DETERMINISTIC
127  	 PARALLEL_ENABLE
128    IS
129    BEGIN
130  	 RETURN usim_static.usim_status_error;
131    END get_debug_error
132    ;
133  
134    FUNCTION get_debug_warning
135  	 RETURN NUMBER
136  	 DETERMINISTIC
137  	 PARALLEL_ENABLE
138    IS
139    BEGIN
140  	 RETURN usim_static.usim_status_warning;
141    END get_debug_warning
142    ;
143  
144    FUNCTION get_multiverse_active
145  	 RETURN NUMBER
146  	 DETERMINISTIC
147  	 PARALLEL_ENABLE
148    IS
149    BEGIN
150  	 RETURN usim_static.usim_multiverse_status_active;
151    END get_multiverse_active
152    ;
153  
154    FUNCTION get_multiverse_inactive
155  	 RETURN NUMBER
156  	 DETERMINISTIC
157  	 PARALLEL_ENABLE
158    IS
159    BEGIN
160  	 RETURN usim_static.usim_multiverse_status_inactive;
161    END get_multiverse_inactive
162    ;
163  
164    FUNCTION get_multiverse_dead
165  	 RETURN NUMBER
166  	 DETERMINISTIC
167  	 PARALLEL_ENABLE
168    IS
169    BEGIN
170  	 RETURN usim_static.usim_multiverse_status_dead;
171    END get_multiverse_dead
172    ;
173  
174    FUNCTION get_multiverse_crashed
175  	 RETURN NUMBER
176  	 DETERMINISTIC
177  	 PARALLEL_ENABLE
178    IS
179    BEGIN
180  	 RETURN usim_static.usim_multiverse_status_crashed;
181    END get_multiverse_crashed
182    ;
183  
184    FUNCTION get_multiverse_status(p_status IN NUMBER)
185  	 RETURN VARCHAR2
186  	 DETERMINISTIC
187  	 PARALLEL_ENABLE
188    IS
189    BEGIN
190  	 RETURN CASE
191  		  WHEN p_status = usim_multiverse_status_active
192  		  THEN 'ACTIVE'
193  		  WHEN p_status = usim_multiverse_status_inactive
194  		  THEN 'INACTIVE'
195  		  WHEN p_status = usim_multiverse_status_dead
196  		  THEN 'DEAD'
197  		  WHEN p_status = usim_multiverse_status_crashed
198  		  THEN 'CRASHED'
199  		  ELSE 'UNKNOWN'
200  	       END
201  	 ;
202    END get_multiverse_status
203    ;
204  
205    FUNCTION get_debug_status(p_status  IN NUMBER)
206  	 RETURN VARCHAR2
207  	 DETERMINISTIC
208  	 PARALLEL_ENABLE
209    IS
210    BEGIN
211  	 RETURN CASE
212  		  WHEN p_status = usim_status_success
213  		  THEN 'SUCCESS'
214  		  WHEN p_status = usim_status_error
215  		  THEN 'ERROR'
216  		  WHEN p_status = usim_status_warning
217  		  THEN 'WARNING'
218  		  ELSE 'UNKNOWN'
219  	       END
220  	 ;
221    END get_debug_status
222    ;
223  
224    FUNCTION get_bool_str(p_boolean IN BOOLEAN)
225  	 RETURN VARCHAR2
226  	 DETERMINISTIC
227  	 PARALLEL_ENABLE
228    IS
229    BEGIN
230  	 IF p_boolean
231  	 THEN
232  	   RETURN 'TRUE';
233  	 ELSE
234  	   RETURN 'FALSE';
235  	 END IF;
236    END get_bool_str
237    ;
238  
239    FUNCTION get_big_pk(p_sequence_number IN NUMBER)
240  	 RETURN VARCHAR2
241    IS
242    BEGIN
243  	 RETURN TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISSFF3') || LPAD(TRIM(TO_CHAR(p_sequence_number)), 38, '0');
244    END get_big_pk
245    ;
246  
247    FUNCTION get_big_pk_date(p_primary_key IN VARCHAR2)
248  	 RETURN DATE
249    IS
250    BEGIN
251  	 RETURN TO_DATE(SUBSTR(p_primary_key, 1, 14), 'YYYYMMDDHH24MISS');
252    END get_big_pk_date
253    ;
254  
255    FUNCTION get_big_pk_number(p_primary_key IN VARCHAR2)
256  	 RETURN NUMBER
257    IS
258    BEGIN
259  	 RETURN TO_NUMBER(SUBSTR(p_primary_key, 18));
260    END get_big_pk_number
261    ;
262  
263    FUNCTION get_next_number( p_number IN NUMBER
264  			       , p_sign   IN NUMBER DEFAULT 1
265  			       )
266  	 RETURN NUMBER
267    IS
268  	 l_sign    NUMBER;
269  	 l_result  NUMBER;
270  	 l_number  NUMBER;
271    BEGIN
272  	 IF NVL(p_number, 0) = 0
273  	 THEN
274  	   l_sign    := SIGN(NVL(p_sign, 0));
275  	   l_number  := NVL(p_number, 0);
276  	 ELSE
277  	   l_sign    := SIGN(p_number);
278  	   l_number  := p_number;
279  	 END IF;
280  	 IF l_sign >= 0
281  	 THEN
282  	   l_result := l_number + 1;
283  	 ELSE
284  	   l_result := l_number - 1;
285  	 END IF;
286  	 RETURN l_result;
287    END get_next_number
288    ;
289  
290    FUNCTION nodes_per_dimension(p_dimension IN NUMBER)
291  	 RETURN NUMBER
292  	 DETERMINISTIC
293  	 PARALLEL_ENABLE
294    IS
295  	 l_dimension NUMBER;
296    BEGIN
297  	 IF p_dimension < 0
298  	 THEN
299  	   l_dimension := 0;
300  	 ELSE
301  	   l_dimension := p_dimension;
302  	 END IF;
303  	 RETURN POWER(2, l_dimension);
304    END nodes_per_dimension
305    ;
306  
307    FUNCTION missing_nodes_per_dimension(p_dimension IN NUMBER)
308  	 RETURN NUMBER
309  	 DETERMINISTIC
310  	 PARALLEL_ENABLE
311    IS
312  	 l_dimension NUMBER;
313  	 l_result    NUMBER;
314    BEGIN
315  	 IF p_dimension < 0
316  	 THEN
317  	   l_dimension := 0;
318  	 ELSE
319  	   l_dimension := p_dimension;
320  	 END IF;
321  	 IF l_dimension <= 1
322  	 THEN
323  	   l_result := CASE WHEN l_dimension = 0 THEN 1 ELSE 2 END;
324  	 ELSE
325  	   l_result := usim_static.nodes_per_dimension(l_dimension) - usim_static.nodes_per_dimension(l_dimension - 1);
326  	 END IF;
327  	 RETURN l_result;
328    END missing_nodes_per_dimension
329    ;
330  
331    FUNCTION is_allowed_side(p_side IN VARCHAR2)
332  	 RETURN NUMBER
333  	 DETERMINISTIC
334  	 PARALLEL_ENABLE
335    IS
336    BEGIN
337  	 IF p_side IN (usim_static.usim_side_from, usim_static.usim_side_to, usim_side_both)
338  	 THEN
339  	   RETURN 1;
340  	 ELSE
341  	   RETURN 0;
342  	 END IF;
343    END is_allowed_side
344    ;
345  
346    FUNCTION is_allowed_fromto_side(p_side IN VARCHAR2)
347  	 RETURN NUMBER
348  	 DETERMINISTIC
349  	 PARALLEL_ENABLE
350    IS
351    BEGIN
352  	 IF p_side IN (usim_static.usim_side_from, usim_static.usim_side_to)
353  	 THEN
354  	   RETURN 1;
355  	 ELSE
356  	   RETURN 0;
357  	 END IF;
358    END is_allowed_fromto_side
359    ;
360  
361  END usim_static;
362  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_static
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_static

Package body created.

SQL> @@../PACKAGES/USIM_MATHS.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_maths
  2  IS
  3    /** A package for all mathematical calculations in this multiverse which will not use any database access.
  4    * The universes itself don't care about units, their units are always based on 1, like the planck units. Units like seconds do only
  5    * make sense for an observer inside a universe, but not from the universe perspective.
  6    * There is a difference between, so called "outside planck units" and "inside planck units". Inside, every planck unit equals 1, outside
  7    * it is defined by the start parameters of an universe.
  8    * <b>Technical:</b> Oracle cuts numbers too large but still supported by PL/SQL. Calculations may raise number overflow/underflow. Using this
  9    * library should include to check numbers for "overflow" before to get reliable results. Exception handling is minimalistic, if something
 10    * fails, defaults are used. Exceptions itself are not checked or differentiated. Testing should proove that it works with numbers in range.
 11    */
 12  
 13    /**
 14    * Calculates the planck speed c, which is an instantaneous velocity v by given planck length(minimal displacement) and planck time(minimal time frame). Using:</br>
 15    * v = delta x / delta t</br>
 16    " In this special case delta x equals the given outside planck length and delta t equals the outside planck time.
 17    * @param p_planck_length The outside planck definition for minimal displacement in a specific universe.
 18    * @param p_planck_time The outside planck definition for minimal time frames in a specific universe.
 19    * @return The planck speed for given time and displacement or 1 (default) if any of the parameters equals NULL/0.
 20    */
 21    FUNCTION init_planck_speed( p_planck_length IN NUMBER
 22  				 , p_planck_time   IN NUMBER
 23  				 )
 24  	 RETURN NUMBER
 25    ;
 26  
 27    /**
 28    * Calculates the planck time by given planck length(minimal displacement) and planck speed(minimal speed). Using:</br>
 29    * t = delta x / delta v</br>
 30    " In this special case delta x equals the given outside planck length and delta v equals the outside planck speed.
 31    * @param p_planck_length The outside planck definition for minimal displacement in a specific universe.
 32    * @param p_planck_speed The outside planck definition for minimal speed in a specific universe.
 33    * @return The planck time for given speed and displacement or 1 (default) if any of the parameters equals NULL/0.
 34    */
 35    FUNCTION init_planck_time( p_planck_length  IN NUMBER
 36  				, p_planck_speed   IN NUMBER
 37  				)
 38  	 RETURN NUMBER
 39    ;
 40  
 41    /**
 42    * Calculates the planck length by given planck speed(minimal speed) and planck time(minimal time frame). Using:</br>
 43    * x = delta t x delta v</br>
 44    " In this special case delta t equals the outside planck time and delta v equals the outside planck speed.
 45    * @param p_planck_speed The outside planck definition for minimal speed in a specific universe.
 46    * @param p_planck_time The outside planck definition for minimal time frames in a specific universe.
 47    * @return The planck length for given speed and time or 1 (default) if any of the parameters equals NULL/0.
 48    */
 49    FUNCTION init_planck_length( p_planck_speed IN NUMBER
 50  				  , p_planck_time  IN NUMBER
 51  				  )
 52  	 RETURN NUMBER
 53    ;
 54  
 55    /**
 56    * Applies a universe specific outside planck definition like speed, length or time. Using:</br>
 57    * value x factor
 58    * @param p_value The value to apply a planck factor. NULL values are interpreted as 0.
 59    * @param p_planck_factor The outside planck attribute definition like speed, time and length to be used as a factor. NULL values are interpreted as 0.
 60    * @return The value multiplied by the given factor.
 61    */
 62    FUNCTION apply_planck( p_value	      IN NUMBER
 63  			    , p_planck_factor IN NUMBER
 64  			    )
 65  	 RETURN NUMBER
 66    ;
 67  
 68    /**
 69    * Calculate acceleration / hit energy for extending space based on source space node attributes.
 70    * Uses classical mechanics to calculate the acceleration that will hit a target space node from gravitational laws in a very reduced sense.
 71    * Uses a<sub>2</sub> = G * m<sub>1</sub> / r<sup>2</sup>. Only valid for extending space itself.
 72    * Extending space sees mass = energy as there exists no mass currently. Energy moving in internal planck steps r = 1 with c = 1 and t = 1.
 73    * As we have no mass yet and nodes can't move, acceleration transports the energy of one node to the next node. Acceleration is seen as the
 74    * energy that hits and reacts with another space nodes energy. Energy will travel until it reaches its defined borders and then travel back.
 75    * The reaction of a target space node is therefore not immediate. Once hit it will first emit the received energy as acceleration to the target
 76    * nodes within r = 1 until a border is reached. The same law is applied on the travel back, but now with the new energy levels of the target
 77    * nodes. If a node is not initialized yet (energy = NULL), it is treated as 1 leaving incoming acceleration and energy unchanged.
 78    * @param p_m1 The "mass" of the source space node represented by its energy value. NULL is interpreted as 0.
 79    * @param p_r The radius / distance between source and target space node. Internally always 1, but external values may differ. NULL is interpreted as 1.
 80    * @param p_G The gravitational constant used by the source space node to expand its energy. Use calc_dim_G with the dimension of the source space node to get the correct value. NULL is interpreted as 1.
 81    * @return The acceleration / hit energy for a target space node by source attributes. Overflow/underflow or any error has to be handled by caller.
 82    */
 83    FUNCTION calc_planck_a2( p_m1 IN NUMBER
 84  			      , p_r  IN NUMBER
 85  			      , p_G  IN NUMBER
 86  			      )
 87  	 RETURN NUMBER
 88    ;
 89  
 90    /**
 91    * Calculates the gravitational constant G for a given dimension for extending space in planck units using G = 1 / 8PI as a base,
 92    * but considers the current dimension instead of static 8 for 3 dimension. This G is not static. It is only valid in the given dimension.
 93    * The number for the PI multiplier is derived from maximum binary tree nodes per dimension. Formula:</br>
 94    * dn = nodes per dimension n = 2<sup>n</sup></br>
 95    * G<sub>dim</sub> = 1 / (dn * PI)</br>
 96    * Only valid for extending space itself.
 97    * @param p_dimension The n dimension to calculate G<sub>dim</sub> for. NULL values are interpreted as 0. Uses the absolute of the number, ignores negative dimensions and cuts any floating point decimals.
 98    * @return The calculated G<sub>dim</sub> for the given dimension.
 99    */
100    FUNCTION calc_dim_G(p_dimension IN NUMBER)
101  	 RETURN NUMBER
102    ;
103  
104  END usim_maths;
105  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_maths
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_maths

Package created.

SQL> @@../PACKAGES/USIM_MATHS.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_maths
  2  IS
  3    -- see header for documentation
  4    FUNCTION init_planck_speed( p_planck_length IN NUMBER
  5  				 , p_planck_time   IN NUMBER
  6  				 )
  7  	 RETURN NUMBER
  8    IS
  9    BEGIN
 10  	 IF    NVL(p_planck_length, 0) = 0
 11  	    OR NVL(p_planck_time, 0)   = 0
 12  	 THEN
 13  	   -- fallback default value
 14  	   RETURN 1;
 15  	 ELSE
 16  	   RETURN (p_planck_length / p_planck_time);
 17  	 END IF;
 18    END init_planck_speed
 19    ;
 20  
 21    FUNCTION init_planck_time( p_planck_length  IN NUMBER
 22  				, p_planck_speed   IN NUMBER
 23  				)
 24  	 RETURN NUMBER
 25    IS
 26    BEGIN
 27  	 IF    NVL(p_planck_length, 0) = 0
 28  	    OR NVL(p_planck_speed, 0)  = 0
 29  	 THEN
 30  	   -- fallback default value
 31  	   RETURN 1;
 32  	 ELSE
 33  	   RETURN (p_planck_length / p_planck_speed);
 34  	 END IF;
 35    END init_planck_time
 36    ;
 37  
 38    FUNCTION init_planck_length( p_planck_speed IN NUMBER
 39  				  , p_planck_time  IN NUMBER
 40  				  )
 41  	 RETURN NUMBER
 42    IS
 43    BEGIN
 44  	 IF    NVL(p_planck_time, 0)   = 0
 45  	    OR NVL(p_planck_speed, 0)  = 0
 46  	 THEN
 47  	   -- fallback default value
 48  	   RETURN 1;
 49  	 ELSE
 50  	   RETURN (p_planck_speed * p_planck_time);
 51  	 END IF;
 52    END init_planck_length
 53    ;
 54  
 55    FUNCTION apply_planck( p_value	      IN NUMBER
 56  			    , p_planck_factor IN NUMBER
 57  			    )
 58  	 RETURN NUMBER
 59    IS
 60    BEGIN
 61  	 RETURN (NVL(p_value, 0) * NVL(p_planck_factor, 0));
 62    END apply_planck
 63    ;
 64  
 65    FUNCTION calc_dim_G(p_dimension IN NUMBER)
 66  	 RETURN NUMBER
 67    IS
 68  	 l_result NUMBER;
 69    BEGIN
 70  	 l_result := 1 / usim_static.nodes_per_dimension(NVL(ABS(FLOOR(p_dimension)), 0));
 71  	 RETURN l_result;
 72    END calc_dim_G
 73    ;
 74  
 75    FUNCTION calc_planck_a2( p_m1 IN NUMBER
 76  			      , p_r  IN NUMBER
 77  			      , p_G  IN NUMBER
 78  			      )
 79  	 RETURN NUMBER
 80    IS
 81  	 l_result NUMBER;
 82    BEGIN
 83  	 l_result := NVL(p_G, 1) * (NVL(p_m1, 0) / POWER(NVL(p_r, 1), 2));
 84  	 RETURN l_result;
 85    END calc_planck_a2
 86    ;
 87  
 88  END usim_maths;
 89  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_maths
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_maths

Package body created.

SQL> --== basic packages end ==--
SQL> --== sequences start ==--
SQL> -- USIM_MULTIVERSE (mlv) sequence
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../SEQUENCES/USIM_MLV_ID_SEQ.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_MLV_ID_SEQ still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MLV_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_MLV_ID_SEQ.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_MULTIVERSE (mlv) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_mlv_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    ORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
old   1: CREATE SEQUENCE &USIM_SCHEMA..usim_mlv_id_seq
new   1: CREATE SEQUENCE USIM_TEST.usim_mlv_id_seq

Sequence created.

SQL> -- USIM_PLANCK_TIME_SEQ
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../SEQUENCES/USIM_PLANCK_TIME_SEQ.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_PLANCK_TIME_SEQ still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_PLANCK_TIME_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------------------
../SEQUENCES/USIM_PLANCK_TIME_SEQ.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_planck_time_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    ORDER
  8    CYCLE
  9    KEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
old   1: CREATE SEQUENCE &USIM_SCHEMA..usim_planck_time_seq
new   1: CREATE SEQUENCE USIM_TEST.usim_planck_time_seq

Sequence created.

SQL> -- USIM_PLANCK_AEON_SEQ
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../SEQUENCES/USIM_PLANCK_AEON_SEQ.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_PLANCK_AEON_SEQ still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_PLANCK_AEON_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
--------------------------------------------------------------------------------
../SEQUENCES/USIM_PLANCK_AEON_SEQ.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_planck_aeon_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    ORDER
  8    CYCLE
  9    KEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
old   1: CREATE SEQUENCE &USIM_SCHEMA..usim_planck_aeon_seq
new   1: CREATE SEQUENCE USIM_TEST.usim_planck_aeon_seq

Sequence created.

SQL> -- USIM_DIMENSION (dim) sequence
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../SEQUENCES/USIM_DIM_ID_SEQ.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_DIM_ID_SEQ still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DIM_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_DIM_ID_SEQ.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_DIMENSION (dim)
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_dim_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
old   1: CREATE SEQUENCE &USIM_SCHEMA..usim_dim_id_seq
new   1: CREATE SEQUENCE USIM_TEST.usim_dim_id_seq

Sequence created.

SQL> -- USIM_POSITION (pos) sequence
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../SEQUENCES/USIM_POS_ID_SEQ.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_POS_ID_SEQ still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_POS_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_POS_ID_SEQ.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_POSITION (pos) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_pos_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
old   1: CREATE SEQUENCE &USIM_SCHEMA..usim_pos_id_seq
new   1: CREATE SEQUENCE USIM_TEST.usim_pos_id_seq

Sequence created.

SQL> -- USIM_NODE (nod) sequence
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../SEQUENCES/USIM_NOD_ID_SEQ.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_NOD_ID_SEQ still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_NOD_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_NOD_ID_SEQ.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_NODE (nod) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_nod_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
old   1: CREATE SEQUENCE &USIM_SCHEMA..usim_nod_id_seq
new   1: CREATE SEQUENCE USIM_TEST.usim_nod_id_seq

Sequence created.

SQL> -- USIM_REL_MLV_DIM (rmd) sequence
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../SEQUENCES/USIM_RMD_ID_SEQ.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_RMD_ID_SEQ still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_RMD_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_RMD_ID_SEQ.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_REL_MLV_DIM (rmd) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_rmd_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
old   1: CREATE SEQUENCE &USIM_SCHEMA..usim_rmd_id_seq
new   1: CREATE SEQUENCE USIM_TEST.usim_rmd_id_seq

Sequence created.

SQL> -- USIM_SPACE (spc)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../SEQUENCES/USIM_SPC_ID_SEQ.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_SPC_ID_SEQ still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_SPC_ID_SEQ.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_SPACE (spc) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_spc_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
old   1: CREATE SEQUENCE &USIM_SCHEMA..usim_spc_id_seq
new   1: CREATE SEQUENCE USIM_TEST.usim_spc_id_seq

Sequence created.

SQL> -- USIM_SPC_PROCESS (spr)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../SEQUENCES/USIM_SPR_ID_SEQ.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_SPR_ID_SEQ still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPR_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_SPR_ID_SEQ.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_SPC_PROCESS (spr) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_spr_id_seq
  2    MINVALUE 1
  3    MAXVALUE 99999999999999999999999999999999999999
  4    INCREMENT BY 1
  5    START WITH 1
  6    NOCACHE
  7    NOORDER
  8    CYCLE
  9    NOKEEP
 10    NOSCALE
 11    GLOBAL
 12  ;
old   1: CREATE SEQUENCE &USIM_SCHEMA..usim_spr_id_seq
new   1: CREATE SEQUENCE USIM_TEST.usim_spr_id_seq

Sequence created.

SQL> --== sequences end ==--
SQL> --== base data start ==--
SQL> -- USIM_BASEDATA (bda)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_BASEDATA_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_BASEDATA still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_BASEDATA'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------------
../TABLES/USIM_BASEDATA_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_BASEDATA (bda)
SQL> CREATE TABLE &USIM_SCHEMA..usim_basedata
  2    ( usim_id_bda		     NUMBER(1)	     DEFAULT 1					     NOT NULL ENABLE
  3    , usim_max_dimension	     NUMBER(2, 0)    DEFAULT 42 				     NOT NULL ENABLE
  4    , usim_abs_max_number	     NUMBER(38, 0)   DEFAULT 99999999999999999999999999999999999999  NOT NULL ENABLE
  5    , usim_overflow_node_seed     NUMBER(1, 0)    DEFAULT 0					     NOT NULL ENABLE
  6    , usim_planck_time_seq_last   NUMBER	     DEFAULT -1 				     NOT NULL ENABLE
  7    , usim_planck_time_seq_curr   NUMBER	     DEFAULT -1 				     NOT NULL ENABLE
  8    , usim_planck_aeon_seq_last   CHAR(55)	     DEFAULT 'N/A'				     NOT NULL ENABLE
  9    , usim_planck_aeon_seq_curr   CHAR(55)	     DEFAULT 'N/A'				     NOT NULL ENABLE
 10    , usim_created		     DATE	     DEFAULT SYSDATE				     NOT NULL ENABLE
 11    , usim_updated		     DATE	     DEFAULT SYSDATE				     NOT NULL ENABLE
 12    , usim_created_by	     VARCHAR2(128)   DEFAULT 'N/A'				     NOT NULL ENABLE
 13    , usim_updated_by	     VARCHAR2(128)   DEFAULT 'N/A'				     NOT NULL ENABLE
 14    )
 15  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_basedata
new   1: CREATE TABLE USIM_TEST.usim_basedata

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_basedata IS 'Holds the basic data used by the multiverse simulation that belong to all universes. Will use the alias bda.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_basedata IS 'Holds the basic data used by the multiverse simulation that belong to all universes. Will use the alias bda.'
new   1: COMMENT ON TABLE USIM_TEST.usim_basedata IS 'Holds the basic data used by the multiverse simulation that belong to all universes. Will use the alias bda.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_id_bda IS 'The unique id of the base data. Can only have the value 1 ensured by primary key and check constraint.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_id_bda IS 'The unique id of the base data. Can only have the value 1 ensured by primary key and check constraint.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_id_bda IS 'The unique id of the base data. Can only have the value 1 ensured by primary key and check constraint.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_max_dimension IS 'The maximum dimension supported for any universe in this multiverse. Must be set on insert, ignored on update.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_max_dimension IS 'The maximum dimension supported for any universe in this multiverse. Must be set on insert, ignored on update.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_max_dimension IS 'The maximum dimension supported for any universe in this multiverse. Must be set on insert, ignored on update.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_abs_max_number IS 'The absolute maximum number possible on the used system. Must be set on insert, ignored on update.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_abs_max_number IS 'The absolute maximum number possible on the used system. Must be set on insert, ignored on update.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_abs_max_number IS 'The absolute maximum number possible on the used system. Must be set on insert, ignored on update.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_overflow_node_seed IS 'Set to 1 if all new structures should start with parent in dimension n = 0. Set to 0, if new structures should use standard overflow handling. Must be set on insert, ignored on update.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_overflow_node_seed IS 'Set to 1 if all new structures should start with parent in dimension n = 0. Set to 0, if new structures should use standard overflow handling. Must be set on insert, ignored on update.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_overflow_node_seed IS 'Set to 1 if all new structures should start with parent in dimension n = 0. Set to 0, if new structures should use standard overflow handling. Must be set on insert, ignored on update.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_time_seq_last IS 'The last planck time tick or -1 if not known yet. Package usim_static holds the name of the used sequence.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_time_seq_last IS 'The last planck time tick or -1 if not known yet. Package usim_static holds the name of the used sequence.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_planck_time_seq_last IS 'The last planck time tick or -1 if not known yet. Package usim_static holds the name of the used sequence.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_time_seq_curr IS 'The current planck time tick or -1 if not known yet. Package usim_static holds the name of the used sequence.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_time_seq_curr IS 'The current planck time tick or -1 if not known yet. Package usim_static holds the name of the used sequence.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_planck_time_seq_curr IS 'The current planck time tick or -1 if not known yet. Package usim_static holds the name of the used sequence.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_aeon_seq_last IS 'The last planck aeon big id or N/A if not known yet. Package usim_static holds the name of the used sequence.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_aeon_seq_last IS 'The last planck aeon big id or N/A if not known yet. Package usim_static holds the name of the used sequence.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_planck_aeon_seq_last IS 'The last planck aeon big id or N/A if not known yet. Package usim_static holds the name of the used sequence.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_aeon_seq_curr IS 'The current planck aeon big id or N/A if not known yet. Package usim_static holds the name of the used sequence.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_planck_aeon_seq_curr IS 'The current planck aeon big id or N/A if not known yet. Package usim_static holds the name of the used sequence.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_planck_aeon_seq_curr IS 'The current planck aeon big id or N/A if not known yet. Package usim_static holds the name of the used sequence.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_created IS 'Date of record creation. Automatically set, ignored on update';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_created IS 'Date of record creation. Automatically set, ignored on update'
new   1: COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_created IS 'Date of record creation. Automatically set, ignored on update'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_updated IS 'Date of record update. Automatically set, ignored on update';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_updated IS 'Date of record update. Automatically set, ignored on update'
new   1: COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_updated IS 'Date of record update. Automatically set, ignored on update'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_created_by IS 'OS user responsible for record creation. Automatically set, ignored on update';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_created_by IS 'OS user responsible for record creation. Automatically set, ignored on update'
new   1: COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_created_by IS 'OS user responsible for record creation. Automatically set, ignored on update'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_updated IS 'OS user, schema owner or user (depending on situation of update) responsible for record update.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_basedata.usim_updated IS 'OS user, schema owner or user (depending on situation of update) responsible for record update.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_basedata.usim_updated IS 'OS user, schema owner or user (depending on situation of update) responsible for record update.'

Comment created.

SQL> 
SQL> -- pk (only to ensure not more than one entry)
SQL> ALTER TABLE &USIM_SCHEMA..usim_basedata
  2    ADD CONSTRAINT usim_bda_pk
  3    PRIMARY KEY (usim_id_bda)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_basedata
new   1: ALTER TABLE USIM_TEST.usim_basedata

Table altered.

SQL> 
SQL> -- check id, means we limit records inserted to one record with id = 1 as we have a primary key unique constraint
SQL> ALTER TABLE &USIM_SCHEMA..usim_basedata
  2    ADD CONSTRAINT usim_id_bda_chk
  3    CHECK (usim_id_bda = 1)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_basedata
new   1: ALTER TABLE USIM_TEST.usim_basedata

Table altered.

SQL> 
SQL> -- check overflow setting
SQL> ALTER TABLE &USIM_SCHEMA..usim_basedata
  2    ADD CONSTRAINT usim_ovr_bda_chk
  3    CHECK (usim_overflow_node_seed IN (0, 1))
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_basedata
new   1: ALTER TABLE USIM_TEST.usim_basedata

Table altered.

SQL> 
SQL> -- max dimensions >= 0
SQL> ALTER TABLE &USIM_SCHEMA..usim_basedata
  2    ADD CONSTRAINT usim_dim_bda_chk
  3    CHECK (usim_max_dimension >= 0)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_basedata
new   1: ALTER TABLE USIM_TEST.usim_basedata

Table altered.

SQL> 
SQL> -- absolute max >= 0
SQL> ALTER TABLE &USIM_SCHEMA..usim_basedata
  2    ADD CONSTRAINT usim_maxn_bda_chk
  3    CHECK (usim_abs_max_number >= 0)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_basedata
new   1: ALTER TABLE USIM_TEST.usim_basedata

Table altered.

SQL> 
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_bda_ins_trg
  2    -- check insert values and ensure default values where needed
  3    BEFORE INSERT ON &USIM_SCHEMA..usim_basedata
  4  	 FOR EACH ROW
  5  	 BEGIN
  6  	   IF :NEW.usim_id_bda IS NULL
  7  	   THEN
  8  	     -- ensure correct id
  9  	     :NEW.usim_id_bda := 1;
 10  	   END IF;
 11  	   -- we ignore input values which should not be set on insert and initialize them to the default
 12  	   :NEW.usim_planck_time_seq_last  := -1;
 13  	   :NEW.usim_planck_time_seq_curr  := -1;
 14  	   :NEW.usim_planck_aeon_seq_last  := usim_static.usim_not_available;
 15  	   :NEW.usim_planck_aeon_seq_curr  := usim_static.usim_not_available;
 16  	   -- set os user for create, ignore given values if any
 17  	   :NEW.usim_created		   := SYSDATE;
 18  	   :NEW.usim_updated		   := SYSDATE;
 19  	   :NEW.usim_created_by 	   := SYS_CONTEXT('USERENV', 'OS_USER');
 20  	   :NEW.usim_updated_by 	   := SYS_CONTEXT('USERENV', 'OS_USER');
 21  	 END;
 22  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_bda_ins_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_bda_ins_trg
old   3:   BEFORE INSERT ON &USIM_SCHEMA..usim_basedata
new   3:   BEFORE INSERT ON USIM_TEST.usim_basedata

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_bda_ins_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_bda_ins_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_bda_ins_trg ENABLE

Trigger altered.

SQL> 
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_bda_upd_trg
  2    -- check update values and ensure consistency
  3    BEFORE UPDATE ON &USIM_SCHEMA..usim_basedata
  4  	 FOR EACH ROW
  5  	 BEGIN
  6  	   -- check big sequences
  7  	   -- only allow updates on current sequences
  8  	   IF :NEW.usim_planck_time_seq_last IS NOT NULL
  9  	   THEN
 10  	     :NEW.usim_planck_time_seq_last := :OLD.usim_planck_time_seq_last;
 11  	   END IF;
 12  	   IF :NEW.usim_planck_aeon_seq_last IS NOT NULL
 13  	   THEN
 14  	     :NEW.usim_planck_aeon_seq_last := :OLD.usim_planck_aeon_seq_last;
 15  	   END IF;
 16  	   -- update current and last sequences if current is given
 17  	   IF :NEW.usim_planck_time_seq_curr IS NOT NULL
 18  	   THEN
 19  	     IF :NEW.usim_planck_time_seq_curr != :OLD.usim_planck_time_seq_curr
 20  	     THEN
 21  	       :NEW.usim_planck_time_seq_last := :OLD.usim_planck_time_seq_curr;
 22  	     END IF;
 23  	   END IF;
 24  	   IF :NEW.usim_planck_aeon_seq_curr IS NOT NULL
 25  	   THEN
 26  	     IF :NEW.usim_planck_aeon_seq_curr != :OLD.usim_planck_aeon_seq_curr
 27  	     THEN
 28  	       :NEW.usim_planck_aeon_seq_last := :OLD.usim_planck_aeon_seq_curr;
 29  	     END IF;
 30  	   END IF;
 31  	   -- no updates on basic design values
 32  	   IF :NEW.usim_overflow_node_seed IS NOT NULL
 33  	   THEN
 34  	     :NEW.usim_overflow_node_seed := :OLD.usim_overflow_node_seed;
 35  	   END IF;
 36  	   IF :NEW.usim_max_dimension IS NOT NULL
 37  	   THEN
 38  	     :NEW.usim_max_dimension := :OLD.usim_max_dimension;
 39  	   END IF;
 40  	   IF :NEW.usim_abs_max_number IS NOT NULL
 41  	   THEN
 42  	     :NEW.usim_abs_max_number := :OLD.usim_abs_max_number;
 43  	   END IF;
 44  	   -- no update of created only on updated
 45  	   IF :NEW.usim_created IS NOT NULL
 46  	   THEN
 47  	     :NEW.usim_created := :OLD.usim_created;
 48  	   END IF;
 49  	   IF :NEW.usim_created_by IS NOT NULL
 50  	   THEN
 51  	     :NEW.usim_created_by := :OLD.usim_created_by;
 52  	   END IF;
 53  	   :NEW.usim_updated	 := SYSDATE;
 54  	   -- allow user override, if system updates the table, otherwise use OS user
 55  	   -- limit allowed users to either OS user or current schema owner
 56  	   IF :NEW.usim_updated_by NOT IN (SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'), SYS_CONTEXT('USERENV', 'OS_USER'))
 57  	   THEN
 58  	     :NEW.usim_updated_by  := SYS_CONTEXT('USERENV', 'OS_USER');
 59  	   END IF;
 60  	 END;
 61  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_bda_upd_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_bda_upd_trg
old   3:   BEFORE UPDATE ON &USIM_SCHEMA..usim_basedata
new   3:   BEFORE UPDATE ON USIM_TEST.usim_basedata

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_bda_upd_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_bda_upd_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_bda_upd_trg ENABLE

Trigger altered.

SQL> -- base data package
SQL> @@../PACKAGES/USIM_BASE.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_base
  2  IS
  3    /** A package for getting/setting values of USIM_BASEDATA table.
  4    */
  5  
  6    /**
  7    * Checks if usim_basedata has already data.
  8    * @return Returns 1 if base data are available, otherwise 0.
  9    */
 10    FUNCTION has_basedata
 11  	 RETURN NUMBER
 12    ;
 13  
 14    /**
 15    * Initializes the base data with the attributes that have to be set on insert if no base data
 16    * exist, otherwise do nothing. As this procedure mimics the constraints, adjusting the constraints needs package adjustment.
 17    * @param p_max_dimension The maximum dimensions possible for this multiverse.
 18    * @param p_usim_abs_max_number The absolute maximum number available for this multiverse.
 19    * @param p_usim_overflow_node_seed Defines the overflow behaviour, default 0 means standard overflow behaviour. If set to 1, all new nodes are created with the universe seed at coordinate 0 as the parent.
 20    */
 21    PROCEDURE init_basedata( p_max_dimension 	   IN NUMBER DEFAULT 42
 22  			      , p_usim_abs_max_number	   IN NUMBER DEFAULT 99999999999999999999999999999999999999
 23  			      , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
 24  			      )
 25    ;
 26  
 27    /**
 28    * Retrieves the current maximum dimension.
 29    * @return The current value from column usim_max_dimension or NULL if not initialized.
 30    */
 31    FUNCTION get_max_dimension
 32  	 RETURN NUMBER
 33    ;
 34  
 35    /**
 36    * Retrieves the current absolute maximum number allowed.
 37    * @return The current value from column usim_abs_max_number or NULL if not initialized.
 38    */
 39    FUNCTION get_abs_max_number
 40  	 RETURN NUMBER
 41    ;
 42  
 43    /**
 44    * Retrieves the current minimum number allowed.
 45    * @return The current value from column usim_abs_max_number * -1 or NULL if not initialized.
 46    */
 47    FUNCTION get_min_number
 48  	 RETURN NUMBER
 49    ;
 50  
 51    /**
 52    * Retrieves the current positive number for underflow situation (too close to zero).
 53    * @return The current positive underflow value derived from usim_abs_max_number length, symetric in scientific notation (e.g. 1E+1 / 1E-1) or NULL if not initialized.
 54    */
 55    FUNCTION get_max_underflow
 56  	 RETURN NUMBER
 57    ;
 58  
 59    /**
 60    * Retrieves the current negative number for underflow situation (too close to zero).
 61    * @return The current negative underflow value derived from usim_abs_max_number length, symetric in scientific notation (e.g. 1E+1 / 1E-1) or NULL if not initialized.
 62    */
 63    FUNCTION get_min_underflow
 64  	 RETURN NUMBER
 65    ;
 66  
 67    /**
 68    * Checks if given number if it has an overflow or underflow situation based on the maximum absolute number defined in base.
 69    * Infinity is always an overflow situation. Exceptions have to be checked on a higher level.
 70    * @param p_check_number The number to verify.
 71    * @return Returns 1 if overflow, 0 if not or NULL if base data not initialized.
 72    */
 73    FUNCTION num_has_overflow(p_check_number IN NUMBER)
 74  	 RETURN NUMBER
 75    ;
 76  
 77    /**
 78    * Checks if a given number addition would cause an overflow or underflow situation based on the maximum absolute number defined in base.
 79    * Infinity is always an overflow situation. Exceptions have to be checked on a higher level.
 80    * @param p_check_number The first number of the addition.
 81    * @param p_add_number The second number of the addition.
 82    * @return Returns 1 if overflow, 0 if not or NULL if base data not initialized.
 83    */
 84    FUNCTION num_add_has_overflow( p_check_number IN NUMBER
 85  				    , p_add_number   IN NUMBER
 86  				    )
 87  	 RETURN NUMBER
 88    ;
 89  
 90    /**
 91    * Retrieves the current setting for overflow behavior.
 92    * @return The current value from column usim_overflow_node_seed or NULL if not initialized.
 93    */
 94    FUNCTION get_overflow_node_seed
 95  	 RETURN NUMBER
 96    ;
 97  
 98    /**
 99    * Checks if the defined planck time sequence exists.
100    * @return TRUE if the sequence exists, otherwise FALSE.
101    */
102    FUNCTION planck_time_seq_exists
103  	 RETURN BOOLEAN
104    ;
105  
106    /**
107    * Retrieves the current planck time tick.
108    * @return The current value from column usim_planck_time_seq_curr or NULL if not initialized.
109    */
110    FUNCTION get_planck_time_current
111  	 RETURN NUMBER
112    ;
113  
114    /**
115    * Retrieves the last planck time tick.
116    * @return The current value from column usim_planck_time_seq_last or NULL if not initialized.
117    */
118    FUNCTION get_planck_time_last
119  	 RETURN NUMBER
120    ;
121  
122    /**
123    * Retrieves the next planck time tick. Will update current and last planck time as well as planck
124    * aeon if planck time sequence will cycle. If planck aeon is not set, it will be initialized.
125    * @return The next planck time tick number or NULL if not initialized/sequence does not exist.
126    */
127    FUNCTION get_planck_time_next
128  	 RETURN NUMBER
129    ;
130  
131    /**
132    * CHecks if the defined planck aeon sequence exists.
133    * @return TRUE if the sequence exists, otherwise FALSE.
134    */
135    FUNCTION planck_aeon_seq_exists
136  	 RETURN BOOLEAN
137    ;
138  
139    /**
140    * Retrieves the current planck aeon sequence big id.
141    * @return The current value from column usim_planck_aeon_seq_curr or usim_static.usim_not_available if not initialized.
142    */
143    FUNCTION get_planck_aeon_seq_current
144  	 RETURN VARCHAR2
145    ;
146  
147    /**
148    * Retrieves the last planck aeon sequence big id before current.
149    * @return The current value from column usim_planck_aeon_seq_last or usim_static.usim_not_available if not initialized.
150    */
151    FUNCTION get_planck_aeon_seq_last
152  	 RETURN VARCHAR2
153    ;
154  
155    /**
156    * Retrieves the next planck aeon sequence big id. Will update current and last planck aeon sequence.
157    * @return The next planck aeon sequence as a big id or NULL if not initialized/sequence does not exist.
158    */
159    FUNCTION get_planck_aeon_seq_next
160  	 RETURN VARCHAR2
161    ;
162  
163  END usim_base;
164  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_base
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_base

Package created.

SQL> @@../PACKAGES/USIM_BASE.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_base
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_basedata
  5  	 RETURN NUMBER
  6    IS
  7  	 l_result  NUMBER;
  8    BEGIN
  9  	 SELECT COUNT(*) INTO l_result FROM usim_basedata;
 10  	 RETURN l_result;
 11    END has_basedata
 12    ;
 13  
 14    PROCEDURE init_basedata( p_max_dimension 	   IN NUMBER DEFAULT 42
 15  			      , p_usim_abs_max_number	   IN NUMBER DEFAULT 99999999999999999999999999999999999999
 16  			      , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
 17  			      )
 18    IS
 19  	 l_max_dimension	   NUMBER := 42;
 20  	 l_usim_abs_max_number	   NUMBER := 99999999999999999999999999999999999999;
 21  	 l_usim_overflow_node_seed NUMBER := 0;
 22    BEGIN
 23  	 IF usim_base.has_basedata = 0
 24  	 THEN
 25  	   IF	   p_max_dimension IS NOT NULL
 26  	      AND  p_max_dimension >= 0
 27  	   THEN
 28  	     l_max_dimension := p_max_dimension;
 29  	   END IF;
 30  	   IF	   p_usim_abs_max_number IS NOT NULL
 31  	      AND  p_usim_abs_max_number >= 0
 32  	   THEN
 33  	     l_usim_abs_max_number := p_usim_abs_max_number;
 34  	   END IF;
 35  	   IF p_usim_overflow_node_seed IN (0, 1)
 36  	   THEN
 37  	     l_usim_overflow_node_seed := p_usim_overflow_node_seed;
 38  	   END IF;
 39  	   INSERT INTO usim_basedata
 40  	     ( usim_max_dimension
 41  	     , usim_abs_max_number
 42  	     , usim_overflow_node_seed
 43  	     )
 44  	     VALUES
 45  	     ( l_max_dimension
 46  	     , l_usim_abs_max_number
 47  	     , l_usim_overflow_node_seed
 48  	     )
 49  	   ;
 50  	   COMMIT;
 51  	 END IF;
 52    END init_basedata
 53    ;
 54  
 55    FUNCTION get_max_dimension
 56  	 RETURN NUMBER
 57    IS
 58  	 l_result  NUMBER;
 59    BEGIN
 60  	 IF usim_base.has_basedata = 1
 61  	 THEN
 62  	   SELECT usim_max_dimension INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
 63  	 ELSE
 64  	   usim_erl.log_error('usim_base.get_max_dimension', 'Used without initializing base data');
 65  	 END IF;
 66  	 RETURN l_result;
 67    END get_max_dimension
 68    ;
 69  
 70    FUNCTION get_abs_max_number
 71  	 RETURN NUMBER
 72    IS
 73  	 l_result  NUMBER;
 74    BEGIN
 75  	 IF usim_base.has_basedata = 1
 76  	 THEN
 77  	   SELECT usim_abs_max_number INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
 78  	 ELSE
 79  	   usim_erl.log_error('usim_base.get_abs_max_number', 'Used without initializing base data');
 80  	 END IF;
 81  	 RETURN l_result;
 82    END get_abs_max_number
 83    ;
 84  
 85    FUNCTION get_min_number
 86  	 RETURN NUMBER
 87    IS
 88    BEGIN
 89  	 RETURN usim_base.get_abs_max_number * -1;
 90    END get_min_number
 91    ;
 92  
 93    FUNCTION get_max_underflow
 94  	 RETURN NUMBER
 95    IS
 96  	 l_result    NUMBER;
 97  	 l_decimals  INTEGER;
 98    BEGIN
 99  	 IF usim_base.has_basedata = 1
100  	 THEN
101  	   -- build number by number of digits
102  	   l_decimals := LENGTH(TRIM(TO_CHAR(usim_base.get_abs_max_number)));
103  	   l_result := TO_NUMBER(RPAD('0.', 1 + l_decimals, '0') || '1');
104  	   RETURN l_result;
105  	 ELSE
106  	   usim_erl.log_error('usim_base.get_max_underflow', 'Used without initializing base data');
107  	   RETURN NULL;
108  	 END IF;
109    END get_max_underflow
110    ;
111  
112    FUNCTION get_min_underflow
113  	 RETURN NUMBER
114    IS
115  	 l_result NUMBER;
116    BEGIN
117  	 RETURN usim_base.get_max_underflow * -1;
118    END get_min_underflow
119    ;
120  
121    FUNCTION num_has_overflow(p_check_number IN NUMBER)
122  	 RETURN NUMBER
123    IS
124    BEGIN
125  	 IF usim_base.has_basedata = 0
126  	 THEN
127  	   usim_erl.log_error('usim_base.num_has_overflow', 'Used without initializing base data');
128  	   RETURN NULL;
129  	 END IF;
130  	 IF p_check_number IS INFINITE
131  	 THEN
132  	   RETURN 0;
133  	 END IF;
134  	 IF ABS(p_check_number) >= 1
135  	 THEN
136  	   -- overflow
137  	   IF ABS(p_check_number) > usim_base.get_abs_max_number
138  	   THEN
139  	     RETURN 1;
140  	   ELSE
141  	     RETURN 0;
142  	   END IF;
143  	 ELSE
144  	   -- underflow
145  	   IF p_check_number > 0
146  	   THEN
147  	     IF p_check_number < usim_base.get_max_underflow
148  	     THEN
149  	       RETURN 1;
150  	     ELSE
151  	       RETURN 0;
152  	     END IF;
153  	   ELSIF p_check_number < 0
154  	   THEN
155  	     IF p_check_number > usim_base.get_min_underflow
156  	     THEN
157  	       RETURN 1;
158  	     ELSE
159  	       RETURN 0;
160  	     END IF;
161  	   ELSE
162  	     RETURN 0;
163  	   END IF;
164  	 END IF;
165    END num_has_overflow
166    ;
167  
168    FUNCTION num_add_has_overflow( p_check_number IN NUMBER
169  				    , p_add_number   IN NUMBER
170  				    )
171  	 RETURN NUMBER
172    IS
173  	 l_result NUMBER;
174    BEGIN
175  	 l_result := p_check_number + p_add_number;
176  	 RETURN num_has_overflow(l_result);
177    END num_add_has_overflow
178    ;
179  
180    FUNCTION get_overflow_node_seed
181  	 RETURN NUMBER
182    IS
183  	 l_result  NUMBER;
184    BEGIN
185  	 IF usim_base.has_basedata = 1
186  	 THEN
187  	   SELECT usim_overflow_node_seed INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
188  	 ELSE
189  	   usim_erl.log_error('usim_base.get_overflow_node_seed', 'Used without initializing base data');
190  	 END IF;
191  	 RETURN l_result;
192    END get_overflow_node_seed
193    ;
194  
195    FUNCTION planck_time_seq_exists
196  	 RETURN BOOLEAN
197    IS
198  	 l_result  NUMBER;
199    BEGIN
200  	 SELECT COUNT(*)
201  	   INTO l_result
202  	   FROM user_sequences
203  	  WHERE sequence_name = usim_static.get_planck_time_seq_name
204  	 ;
205  	 RETURN (l_result = 1);
206    END planck_time_seq_exists
207    ;
208  
209    FUNCTION get_planck_time_current
210  	 RETURN NUMBER
211    IS
212  	 l_result  NUMBER;
213    BEGIN
214  	 IF usim_base.has_basedata = 1
215  	 THEN
216  	   SELECT usim_planck_time_seq_curr INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
217  	 ELSE
218  	   usim_erl.log_error('usim_base.get_planck_time_current', 'Used without initializing base data');
219  	 END IF;
220  	 RETURN l_result;
221    END get_planck_time_current
222    ;
223  
224    FUNCTION get_planck_time_last
225  	 RETURN NUMBER
226    IS
227  	 l_result NUMBER;
228    BEGIN
229  	 IF usim_base.has_basedata = 1
230  	 THEN
231  	   SELECT usim_planck_time_seq_last INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
232  	 ELSE
233  	   usim_erl.log_error('usim_base.get_planck_time_last', 'Used without initializing base data');
234  	 END IF;
235  	 RETURN l_result;
236    END get_planck_time_last
237    ;
238  
239    FUNCTION get_planck_time_next
240  	 RETURN NUMBER
241    IS
242  	 PRAGMA AUTONOMOUS_TRANSACTION;
243  	 l_result      VARCHAR2(55);
244  	 l_statement	 VARCHAR2(1000);
245  	 l_seq_number	 NUMBER;
246  	 l_max_value	 NUMBER;
247  	 l_current_tick  NUMBER;
248  	 l_current_aeon  CHAR(55);
249  	 l_update_aeon	 BOOLEAN;
250    BEGIN
251  	 IF	usim_base.planck_time_seq_exists
252  	    AND usim_base.has_basedata = 1
253  	 THEN
254  	   -- if aeon and time initialized
255  	   l_current_aeon := usim_base.get_planck_aeon_seq_current;
256  	   IF l_current_aeon = usim_static.usim_not_available
257  	   THEN
258  	     -- initialize aeon by update
259  	     l_update_aeon := TRUE;
260  	   END IF;
261  	   l_current_tick := usim_base.get_planck_time_current;
262  	   IF l_current_tick IS NOT NULL
263  	   THEN
264  	     -- check tick overflow
265  	     SELECT max_value
266  	       INTO l_max_value
267  	       FROM user_sequences
268  	      WHERE sequence_name = usim_static.get_planck_time_seq_name
269  	     ;
270  	     IF l_current_tick = l_max_value
271  	     THEN
272  	       l_update_aeon := TRUE;
273  	     END IF;
274  	   ELSE
275  	     l_update_aeon := FALSE;
276  	   END IF;
277  	   -- get sequence
278  	   l_statement := 'SELECT ' || usim_static.get_planck_time_seq_name || '.NEXTVAL FROM dual';
279  	   EXECUTE IMMEDIATE l_statement INTO l_seq_number;
280  	   -- update base data
281  	   UPDATE usim_basedata
282  	      SET usim_planck_time_seq_curr  = l_seq_number
283  		, usim_updated_by	     = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')
284  	    WHERE usim_id_bda = 1
285  	   ;
286  	   COMMIT;
287  	   IF l_update_aeon
288  	   THEN
289  	     l_current_aeon := usim_base.get_planck_aeon_seq_next;
290  	   END IF;
291  	   -- return new current value
292  	   RETURN usim_base.get_planck_time_current;
293  	 ELSE
294  	   usim_erl.log_error('usim_base.get_planck_time_next', 'Used without initializing base data or planck time sequence does not exist.');
295  	   RETURN NULL;
296  	 END IF;
297    END get_planck_time_next
298    ;
299  
300    FUNCTION planck_aeon_seq_exists
301  	 RETURN BOOLEAN
302    IS
303  	 l_result  NUMBER;
304    BEGIN
305  	 SELECT COUNT(*)
306  	   INTO l_result
307  	   FROM user_sequences
308  	  WHERE sequence_name = usim_static.get_planck_aeon_seq_name
309  	 ;
310  	 RETURN (l_result = 1);
311    END planck_aeon_seq_exists
312    ;
313  
314    FUNCTION get_planck_aeon_seq_current
315  	 RETURN VARCHAR2
316    IS
317  	 l_result  VARCHAR2(55);
318    BEGIN
319  	 IF usim_base.has_basedata = 1
320  	 THEN
321  	   SELECT TRIM(usim_planck_aeon_seq_curr) INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
322  	 ELSE
323  	   usim_erl.log_error('usim_base.get_planck_aeon_seq_current', 'Used without initializing base data.');
324  	 END IF;
325  	 RETURN l_result;
326    END get_planck_aeon_seq_current
327    ;
328  
329    FUNCTION get_planck_aeon_seq_last
330  	 RETURN VARCHAR2
331    IS
332  	 l_result  VARCHAR2(55);
333    BEGIN
334  	 IF usim_base.has_basedata = 1
335  	 THEN
336  	   SELECT TRIM(usim_planck_aeon_seq_last) INTO l_result FROM usim_basedata WHERE usim_id_bda = 1;
337  	 ELSE
338  	   usim_erl.log_error('usim_base.get_planck_aeon_seq_last', 'Used without initializing base data.');
339  	 END IF;
340  	 RETURN l_result;
341    END get_planck_aeon_seq_last
342    ;
343  
344    FUNCTION get_planck_aeon_seq_next
345  	 RETURN VARCHAR2
346    IS
347  	 PRAGMA AUTONOMOUS_TRANSACTION;
348  	 l_result      VARCHAR2(55);
349  	 l_statement   VARCHAR2(1000);
350  	 l_seq_number  NUMBER;
351    BEGIN
352  	 IF	usim_base.planck_aeon_seq_exists
353  	    AND usim_base.has_basedata = 1
354  	 THEN
355  	   -- get sequence
356  	   l_statement := 'SELECT ' || usim_static.get_planck_aeon_seq_name || '.NEXTVAL FROM dual';
357  	   EXECUTE IMMEDIATE l_statement INTO l_seq_number;
358  	   -- build big planck time id
359  	   l_result := usim_static.get_big_pk(l_seq_number);
360  	   -- update base data
361  	   UPDATE usim_basedata
362  	      SET usim_planck_aeon_seq_curr = l_result
363  		, usim_updated_by	    = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')
364  	    WHERE usim_id_bda = 1
365  	   ;
366  	   COMMIT;
367  	   -- return new current value
368  	   RETURN usim_base.get_planck_aeon_seq_current;
369  	 ELSE
370  	   usim_erl.log_error('usim_base.get_planck_aeon_seq_next', 'Used without initializing base data or planck aeon sequence does not exist.');
371  	   RETURN NULL;
372  	 END IF;
373    END get_planck_aeon_seq_next
374    ;
375  
376  END usim_base;
377  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_base
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_base

Package body created.

SQL> --== base data end =
SQL> --== base tables start ==--
SQL> -- USIM_MULTIVERSE (mlv)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_MULTIVERSE_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_MULTIVERSE still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_MULTIVERSE'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------------
../TABLES/USIM_MULTIVERSE_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_MULTIVERSE (mlv)
SQL> CREATE TABLE &USIM_SCHEMA..usim_multiverse
  2    ( usim_id_mlv		 CHAR(55)		   NOT NULL ENABLE
  3    , usim_universe_status	 NUMBER(1, 0)  DEFAULT 0   NOT NULL ENABLE
  4    , usim_is_base_universe	 NUMBER(1, 0)  DEFAULT 0   NOT NULL ENABLE
  5    , usim_energy_start_value NUMBER
  6    , usim_planck_aeon	 CHAR(55)
  7    , usim_planck_time	 NUMBER
  8    , usim_planck_time_unit	 NUMBER        DEFAULT 1   NOT NULL ENABLE
  9    , usim_planck_length_unit NUMBER        DEFAULT 1   NOT NULL ENABLE
 10    , usim_planck_speed_unit  NUMBER        DEFAULT 1   NOT NULL ENABLE
 11    , usim_planck_stable	 NUMBER(1, 0)  DEFAULT 1   NOT NULL ENABLE
 12    , usim_ultimate_border	 NUMBER(1, 0)  DEFAULT 1   NOT NULL ENABLE
 13    )
 14  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_multiverse
new   1: CREATE TABLE USIM_TEST.usim_multiverse

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_multiverse IS 'A table to manage existing universes. Will use the alias mlv.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_multiverse IS 'A table to manage existing universes. Will use the alias mlv.'
new   1: COMMENT ON TABLE USIM_TEST.usim_multiverse IS 'A table to manage existing universes. Will use the alias mlv.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_id_mlv IS 'The unique id for a universe in the multiverse. Automatically set on insert, update ignored.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_id_mlv IS 'The unique id for a universe in the multiverse. Automatically set on insert, update ignored.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_id_mlv IS 'The unique id for a universe in the multiverse. Automatically set on insert, update ignored.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_universe_status IS 'The current state of the associated universe at usim_planck_time. Either INACTIVE, ACTIVE, DEAD, CRASHED or UNKNOWN. Calculated, set to INACTIVE on insert, update ignored.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_universe_status IS 'The current state of the associated universe at usim_planck_time. Either INACTIVE, ACTIVE, DEAD, CRASHED or UNKNOWN. Calculated, set to INACTIVE on insert, update ignored.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_universe_status IS 'The current state of the associated universe at usim_planck_time. Either INACTIVE, ACTIVE, DEAD, CRASHED or UNKNOWN. Calculated, set to INACTIVE on insert, update ignored.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_is_base_universe IS 'Defines if the universe the base universe for the multiverse. 1 means base universe, 0 depending universe. Only one base allowed by application. Must be set on insert, update ignored';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_is_base_universe IS 'Defines if the universe the base universe for the multiverse. 1 means base universe, 0 depending universe. Only one base allowed by application. Must be set on insert, update ignored'
new   1: COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_is_base_universe IS 'Defines if the universe the base universe for the multiverse. 1 means base universe, 0 depending universe. Only one base allowed by application. Must be set on insert, update ignored'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_energy_start_value IS 'The energy start value for the associated universe. Must be set on insert, update ignored.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_energy_start_value IS 'The energy start value for the associated universe. Must be set on insert, update ignored.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_energy_start_value IS 'The energy start value for the associated universe. Must be set on insert, update ignored.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_aeon IS 'The planck aeon big id at insert or update of energy and universe state. Automatically set, insert and update ignored.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_aeon IS 'The planck aeon big id at insert or update of energy and universe state. Automatically set, insert and update ignored.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_planck_aeon IS 'The planck aeon big id at insert or update of energy and universe state. Automatically set, insert and update ignored.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_time IS 'The planck time tick at insert or update of energy and universe state. Automatically set, insert and update ignored.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_time IS 'The planck time tick at insert or update of energy and universe state. Automatically set, insert and update ignored.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_planck_time IS 'The planck time tick at insert or update of energy and universe state. Automatically set, insert and update ignored.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_time_unit IS 'The relative time unit of planck time for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_time_unit IS 'The relative time unit of planck time for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_planck_time_unit IS 'The relative time unit of planck time for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_length_unit IS 'The relative length unit of planck length for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_length_unit IS 'The relative length unit of planck length for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_planck_length_unit IS 'The relative length unit of planck length for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_speed_unit IS 'The relative speed (c) unit of planck speed for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_speed_unit IS 'The relative speed (c) unit of planck speed for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_planck_speed_unit IS 'The relative speed (c) unit of planck speed for this universe. Inside always 1, but from outside it may have different values. Value 0 ignored. Update only allowed if usim_planck_stable = 0.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_stable IS 'The indicator if planck values may change over time (0) or are constant (1). Must be set on insert, ignored on update.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_planck_stable IS 'The indicator if planck values may change over time (0) or are constant (1). Must be set on insert, ignored on update.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_planck_stable IS 'The indicator if planck values may change over time (0) or are constant (1). Must be set on insert, ignored on update.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_ultimate_border IS 'The indicator if energy flow is returned on any dimension border (0) or at the ultimate border, where no child connections are available (1). Must be set on insert, ignored on update.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_multiverse.usim_ultimate_border IS 'The indicator if energy flow is returned on any dimension border (0) or at the ultimate border, where no child connections are available (1). Must be set on insert, ignored on update.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_multiverse.usim_ultimate_border IS 'The indicator if energy flow is returned on any dimension border (0) or at the ultimate border, where no child connections are available (1). Must be set on insert, ignored on update.'

Comment created.

SQL> 
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_multiverse
  2    ADD CONSTRAINT usim_mlv_pk
  3    PRIMARY KEY (usim_id_mlv)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_multiverse
new   1: ALTER TABLE USIM_TEST.usim_multiverse

Table altered.

SQL> 
SQL> -- chk planck stable
SQL> ALTER TABLE &USIM_SCHEMA..usim_multiverse
  2    ADD CONSTRAINT usim_mlv_planck_chk
  3    CHECK (usim_planck_stable IN (0, 1))
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_multiverse
new   1: ALTER TABLE USIM_TEST.usim_multiverse

Table altered.

SQL> 
SQL> -- chk base universe values
SQL> ALTER TABLE &USIM_SCHEMA..usim_multiverse
  2    ADD CONSTRAINT usim_mlv_base_chk
  3    CHECK (usim_is_base_universe IN (0, 1))
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_multiverse
new   1: ALTER TABLE USIM_TEST.usim_multiverse

Table altered.

SQL> 
SQL> -- check sign setting
SQL> ALTER TABLE &USIM_SCHEMA..usim_multiverse
  2    ADD CONSTRAINT usim_border_mlv_chk
  3    CHECK (usim_ultimate_border IN (0, 1))
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_multiverse
new   1: ALTER TABLE USIM_TEST.usim_multiverse

Table altered.

SQL> 
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_mlv_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_multiverse
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   IF usim_base.has_basedata = 0
  6  	   THEN
  7  	     RAISE_APPLICATION_ERROR( num => -20000
  8  				    , msg => 'Insert requirement not fulfilled. Base data must exist before inserting a universe.'
  9  				    )
 10  	     ;
 11  	   END IF;
 12  	   -- always set this values on insert, do not care about input
 13  	   :NEW.usim_id_mlv := usim_static.get_big_pk(usim_mlv_id_seq.NEXTVAL);
 14  	   -- inherit current values from base data
 15  	   :NEW.usim_planck_time := usim_base.get_planck_time_current;
 16  	   :NEW.usim_planck_aeon := usim_base.get_planck_aeon_seq_current;
 17  	   -- set default status INACTIVE on insert
 18  	   :NEW.usim_universe_status := usim_static.usim_multiverse_status_inactive;
 19  	   -- if not given, set to 1 as default
 20  	   IF :NEW.usim_energy_start_value IS NULL
 21  	   THEN
 22  	     :NEW.usim_energy_start_value := 1;
 23  	   END IF;
 24  	   IF :NEW.usim_planck_stable IS NULL
 25  	   THEN
 26  	     :NEW.usim_planck_stable := 1;
 27  	   END IF;
 28  	   IF :NEW.usim_ultimate_border IS NULL
 29  	   THEN
 30  	     :NEW.usim_ultimate_border := 1;
 31  	   END IF;
 32  	 END;
 33  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_mlv_ins_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_mlv_ins_trg
old   2:   BEFORE INSERT ON &USIM_SCHEMA..usim_multiverse
new   2:   BEFORE INSERT ON USIM_TEST.usim_multiverse

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_mlv_ins_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_mlv_ins_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_mlv_ins_trg ENABLE

Trigger altered.

SQL> 
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_mlv_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_multiverse
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   -- handle values that should not be updated
  6  	   IF :NEW.usim_id_mlv != :OLD.usim_id_mlv
  7  	   THEN
  8  	     :NEW.usim_id_mlv := :OLD.usim_id_mlv;
  9  	   END IF;
 10  	   -- not allowed, must be set on insert
 11  	   IF :NEW.usim_energy_start_value != :OLD.usim_energy_start_value
 12  	   THEN
 13  	     :NEW.usim_energy_start_value := :OLD.usim_energy_start_value;
 14  	   END IF;
 15  	   -- not allowed, must be set on insert
 16  	   IF :NEW.usim_is_base_universe != :OLD.usim_is_base_universe
 17  	   THEN
 18  	     :NEW.usim_is_base_universe := :OLD.usim_is_base_universe;
 19  	   END IF;
 20  	   IF :NEW.usim_ultimate_border != :OLD.usim_ultimate_border
 21  	   THEN
 22  	     :NEW.usim_ultimate_border := :OLD.usim_ultimate_border;
 23  	   END IF;
 24  	   IF :NEW.usim_planck_stable != :OLD.usim_planck_stable
 25  	   THEN
 26  	     :NEW.usim_planck_stable := :OLD.usim_planck_stable;
 27  	   END IF;
 28  	   -- ignore input for planck time
 29  	   :NEW.usim_planck_time := usim_base.get_planck_time_current;
 30  	   :NEW.usim_planck_aeon := usim_base.get_planck_aeon_seq_current;
 31  	   -- avoid set status if invalid
 32  	   IF :NEW.usim_universe_status != :OLD.usim_universe_status
 33  	   THEN
 34  	     IF :NEW.usim_universe_status NOT IN (usim_static.usim_multiverse_status_dead
 35  						 , usim_static.usim_multiverse_status_crashed
 36  						 , usim_static.usim_multiverse_status_active
 37  						 , usim_static.usim_multiverse_status_inactive
 38  						 )
 39  	     THEN
 40  	       :NEW.usim_universe_status := :OLD.usim_universe_status;
 41  	     END IF;
 42  	   END IF;
 43  	   -- set planck values only, if they differ from 0 and usim_planck_stable = 0
 44  	   IF	 :NEW.usim_planck_time_unit = 0
 45  	      OR :OLD.usim_planck_stable = 1
 46  	   THEN
 47  	     :NEW.usim_planck_time_unit := :OLD.usim_planck_time_unit;
 48  	   END IF;
 49  	   IF	 :NEW.usim_planck_speed_unit = 0
 50  	      OR :OLD.usim_planck_stable = 1
 51  	   THEN
 52  	     :NEW.usim_planck_speed_unit := :OLD.usim_planck_speed_unit;
 53  	   END IF;
 54  	   IF	 :NEW.usim_planck_length_unit = 0
 55  	      OR :OLD.usim_planck_stable = 1
 56  	   THEN
 57  	     :NEW.usim_planck_length_unit := :OLD.usim_planck_length_unit;
 58  	   END IF;
 59  	 END;
 60  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_mlv_upd_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_mlv_upd_trg
old   2:   BEFORE UPDATE ON &USIM_SCHEMA..usim_multiverse
new   2:   BEFORE UPDATE ON USIM_TEST.usim_multiverse

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_mlv_upd_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_mlv_upd_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_mlv_upd_trg ENABLE

Trigger altered.

SQL> -- usim_multiverse package
SQL> @@../PACKAGES/USIM_MLV.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_mlv
  2  IS
  3    /**A low level package for actions on table usim_multiverse and its associated
  4    * view. No other dependencies apart from USIM_STATIC. Package may throw exceptions
  5    * from constraints, triggers and foreign keys. Caller is responsible to handle
  6    * possible exceptions.
  7    */
  8  
  9    /**
 10    * Checks if usim_multiverse has already data.
 11    * @return Returns 1 if data are available, otherwise 0.
 12    */
 13    FUNCTION has_data
 14  	 RETURN NUMBER
 15    ;
 16  
 17    /**
 18    * Checks if a given usim_multiverse id exists.
 19    * @param p_usim_id_mlv The id of the universe to check.
 20    * @return Returns 1 if universe exists, otherwise 0.
 21    */
 22   FUNCTION has_data(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 23  	 RETURN NUMBER
 24    ;
 25  
 26    /**
 27    * Determines if a base universe already exists in usim_multiverse.
 28    * @return Returns 1 if a base universe exists, otherwise 0.
 29    */
 30    FUNCTION has_base
 31  	 RETURN NUMBER
 32    ;
 33  
 34    /**
 35    * Checks if a given universe is a base universe.
 36    * @param p_usim_id_mlv The id of the universe to get usim_planck_stable from.
 37    * @return Returns 1 if universe is base, otherwise 0 or NULL, if universe does not exist.
 38    */
 39    FUNCTION is_base(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 40  	 RETURN NUMBER
 41    ;
 42  
 43    /**
 44    * Gets the current state of the universe. See USIM_STATIC for allowed state.
 45    * @param p_usim_id_mlv The id of the universe to get usim_planck_stable from.
 46    * @return Returns the current state of the universe or NULL, if universe does not exist.
 47    */
 48    FUNCTION get_state(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 49  	 RETURN usim_multiverse.usim_universe_status%TYPE
 50    ;
 51  
 52    /**
 53    * Gets the current value of usim_planck_stable for the given universe.
 54    * @param p_usim_id_mlv The id of the universe to get usim_planck_stable from.
 55    * @return Returns usim_planck_stable if given universe exists, otherwise -1.
 56    */
 57    FUNCTION get_planck_stable(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 58  	 RETURN NUMBER
 59    ;
 60  
 61    /**
 62    * Gets the rule for ultimate or any border for a given universe.
 63    * @param p_usim_id_mlv The id of the universe to get usim_ultimate_border from.
 64    * @return Returns 1, rule for ultimate border or 0, rule for any border if given universe exists, otherwise -1.
 65    */
 66    FUNCTION get_ultimate_border(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 67  	 RETURN usim_multiverse.usim_ultimate_border%TYPE
 68    ;
 69  
 70    /**
 71    * Inserts a new universe with the given values. Does not check if a base universe already exists. USIM_UNIVERSE_STATUS is automatically set
 72    * to inactive on insert. USIM_IS_BASE_UNIVERSE is determined by existance of data. If no base universe exist, the universe gets the base universe, otherwise
 73    * the universe will be a sub-universe of the existing base universe.
 74    * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used or default if NULL or 0.
 75    * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value or default if NULL or 0.
 76    * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value or default if NULL or 0.
 77    * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value or default if NULL or 0.
 78    * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct.
 79    * @param p_usim_ultimate_border The ultimate border rule for this universe. 1 is ultimate border reached, no childs left, 0 is any border at dimensions axis even with childs left.
 80    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 81    * @return The new universe big id or NULL if insert failed.
 82    */
 83    FUNCTION insert_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
 84  			       , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
 85  			       , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
 86  			       , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
 87  			       , p_usim_planck_stable	   IN usim_multiverse.usim_planck_stable%TYPE	   DEFAULT 1
 88  			       , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
 89  			       , p_do_commit		   IN BOOLEAN					   DEFAULT TRUE
 90  			       )
 91  	 RETURN usim_multiverse.usim_id_mlv%TYPE
 92    ;
 93  
 94    /**
 95    * Updates the universe state for the given universe id.
 96    * @param p_usim_id_mlv The id of the universe, that should update its state.
 97    * @param p_usim_universe_status The new state of the universe. Must match usim_static's usim_multiverse_status_dead, usim_multiverse_status_crashed, usim_multiverse_status_active or usim_multiverse_status_inactive.
 98    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 99    * @return Returns the new state or NULL on errors.
100    */
101    FUNCTION update_state( p_usim_id_mlv	     IN usim_multiverse.usim_id_mlv%TYPE
102  			    , p_usim_universe_status IN usim_multiverse.usim_universe_status%TYPE
103  			    , p_do_commit	     IN BOOLEAN 				  DEFAULT TRUE
104  			    )
105  	 RETURN usim_multiverse.usim_universe_status%TYPE
106    ;
107  
108    /**
109    * Updates all planck units by new time and speed unit if usim_planck_stable = 0 for the given universe and the universe exists.
110    * @param p_usim_id_mlv The id of the universe, that should update planck units.
111    * @param p_usim_planck_time_unit The new planck time unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
112    * @param p_usim_planck_speed_unit The new planck speed unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
113    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
114    * @return Returns 1 if update was possible, otherwise 0.
115    */
116    FUNCTION update_planck_unit_time_speed( p_usim_id_mlv		 IN usim_multiverse.usim_id_mlv%TYPE
117  					     , p_usim_planck_time_unit	 IN usim_multiverse.usim_planck_time_unit%TYPE
118  					     , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
119  					     , p_do_commit		 IN BOOLEAN					 DEFAULT TRUE
120  					     )
121  	 RETURN NUMBER
122    ;
123  
124    /**
125    * Updates all planck units by new time and length unit if usim_planck_stable = 0 for the given universe and the universe exists.
126    * @param p_usim_id_mlv The id of the universe, that should update planck units.
127    * @param p_usim_planck_time_unit The new planck time unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
128    * @param p_usim_planck_length_unit The new planck length unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
129    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
130    * @return Returns 1 if update was possible, otherwise 0.
131    */
132    FUNCTION update_planck_unit_time_length( p_usim_id_mlv		  IN usim_multiverse.usim_id_mlv%TYPE
133  					      , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
134  					      , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
135  					      , p_do_commit		  IN BOOLEAN					  DEFAULT TRUE
136  					      )
137  	 RETURN NUMBER
138    ;
139  
140    /**
141    * Updates all planck units by new speed and length unit if usim_planck_stable = 0 for the given universe and the universe exists.
142    * @param p_usim_id_mlv The id of the universe, that should update planck units.
143    * @param p_usim_planck_speed_unit The new planck speed unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
144    * @param p_usim_planck_length_unit The new planck length unit for the given universe. Will replace existing values with absolute values. If NULL/0 default 1 is used.
145    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
146    * @return Returns 1 if update was possible, otherwise 0.
147    */
148    FUNCTION update_planck_unit_speed_length( p_usim_id_mlv		   IN usim_multiverse.usim_id_mlv%TYPE
149  					       , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
150  					       , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
151  					       , p_do_commit		   IN BOOLEAN					   DEFAULT TRUE
152  					      )
153  	 RETURN NUMBER
154    ;
155  
156  END usim_mlv;
157  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_mlv
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_mlv

Package created.

SQL> @@../PACKAGES/USIM_MLV.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_mlv
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_data
  5  	 RETURN NUMBER
  6    IS
  7  	 l_result  NUMBER;
  8    BEGIN
  9  	 SELECT COUNT(*) INTO l_result FROM usim_multiverse;
 10  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 11    END has_data
 12    ;
 13  
 14    FUNCTION has_data(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 15  	 RETURN NUMBER
 16    IS
 17  	 l_result  NUMBER;
 18    BEGIN
 19  	 SELECT COUNT(*) INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
 20  	 RETURN l_result;
 21    END has_data
 22    ;
 23  
 24    FUNCTION has_base
 25  	 RETURN NUMBER
 26    IS
 27  	 l_result  NUMBER;
 28    BEGIN
 29  	 SELECT COUNT(*) INTO l_result FROM usim_multiverse WHERE usim_is_base_universe = 1;
 30  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 31    END has_base
 32    ;
 33  
 34    FUNCTION is_base(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 35  	 RETURN NUMBER
 36    IS
 37  	 l_result NUMBER;
 38    BEGIN
 39  	 IF usim_mlv.has_data(p_usim_id_mlv) = 1
 40  	 THEN
 41  	   SELECT usim_is_base_universe INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
 42  	   RETURN l_result;
 43  	 ELSE
 44  	   usim_erl.log_error('usim_mlv.is_base', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
 45  	   RETURN NULL;
 46  	 END IF;
 47    END is_base
 48    ;
 49  
 50    FUNCTION get_state(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 51  	 RETURN usim_multiverse.usim_universe_status%TYPE
 52    IS
 53  	 l_result usim_multiverse.usim_universe_status%TYPE;
 54    BEGIN
 55  	 IF usim_mlv.has_data(p_usim_id_mlv) = 1
 56  	 THEN
 57  	   SELECT usim_universe_status INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
 58  	   RETURN l_result;
 59  	 ELSE
 60  	   usim_erl.log_error('usim_mlv.get_state', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
 61  	   RETURN NULL;
 62  	 END IF;
 63    END get_state
 64    ;
 65  
 66    FUNCTION get_planck_stable(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 67  	 RETURN NUMBER
 68    IS
 69  	 l_result usim_multiverse.usim_planck_stable%TYPE;
 70    BEGIN
 71  	 l_result := -1;
 72  	 IF usim_mlv.has_data(p_usim_id_mlv) = 1
 73  	 THEN
 74  	   SELECT usim_planck_stable INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
 75  	 ELSE
 76  	   usim_erl.log_error('usim_mlv.get_planck_stable', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
 77  	 END IF;
 78  	 RETURN l_result;
 79    END get_planck_stable
 80    ;
 81  
 82    FUNCTION get_ultimate_border(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 83  	 RETURN usim_multiverse.usim_ultimate_border%TYPE
 84    IS
 85  	 l_result usim_multiverse.usim_ultimate_border%TYPE;
 86    BEGIN
 87  	 l_result := -1;
 88  	 IF usim_mlv.has_data(p_usim_id_mlv) = 1
 89  	 THEN
 90  	   SELECT usim_ultimate_border INTO l_result FROM usim_multiverse WHERE usim_id_mlv = p_usim_id_mlv;
 91  	 ELSE
 92  	   usim_erl.log_error('usim_mlv.get_ultimate_border', 'Used with not existing universe id [' || p_usim_id_mlv || '].');
 93  	 END IF;
 94  	 RETURN l_result;
 95    END get_ultimate_border
 96    ;
 97  
 98    FUNCTION insert_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
 99  			       , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
100  			       , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
101  			       , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
102  			       , p_usim_planck_stable	   IN usim_multiverse.usim_planck_stable%TYPE	   DEFAULT 1
103  			       , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
104  			       , p_do_commit		   IN BOOLEAN					   DEFAULT TRUE
105  			       )
106  	 RETURN usim_multiverse.usim_id_mlv%TYPE
107    IS
108  	 l_usim_energy_start_value usim_multiverse.usim_energy_start_value%TYPE;
109  	 l_usim_planck_time_unit   usim_multiverse.usim_planck_time_unit%TYPE;
110  	 l_usim_planck_length_unit usim_multiverse.usim_planck_length_unit%TYPE;
111  	 l_usim_planck_speed_unit  usim_multiverse.usim_planck_speed_unit%TYPE;
112  	 l_usim_planck_stable	   usim_multiverse.usim_planck_stable%TYPE;
113  	 l_usim_ultimate_border    usim_multiverse.usim_ultimate_border%TYPE;
114  	 l_usim_is_base_universe   usim_multiverse.usim_is_base_universe%TYPE;
115  	 l_usim_id_mlv		   usim_multiverse.usim_id_mlv%TYPE;
116    BEGIN
117  	 l_usim_id_mlv := NULL;
118  	 -- check value constraints and set defaults
119  	 IF usim_mlv.has_base = 1
120  	 THEN
121  	   l_usim_is_base_universe := 0;
122  	 ELSE
123  	   l_usim_is_base_universe := 1;
124  	 END IF;
125  	 IF p_usim_ultimate_border IN (0, 1)
126  	 THEN
127  	   l_usim_ultimate_border := p_usim_ultimate_border;
128  	 ELSE
129  	   l_usim_ultimate_border := 1;
130  	 END IF;
131  	 IF p_usim_planck_stable IN (0, 1)
132  	 THEN
133  	   l_usim_planck_stable := p_usim_planck_stable;
134  	 ELSE
135  	   l_usim_planck_stable := 1;
136  	 END IF;
137  	 IF NVL(p_usim_planck_time_unit, 0) = 0
138  	 THEN
139  	   l_usim_planck_time_unit := 1;
140  	 ELSE
141  	   l_usim_planck_time_unit := ABS(p_usim_planck_time_unit);
142  	 END IF;
143  	 IF NVL(p_usim_planck_length_unit, 0) = 0
144  	 THEN
145  	   l_usim_planck_length_unit := 1;
146  	 ELSE
147  	   l_usim_planck_length_unit := ABS(p_usim_planck_length_unit);
148  	 END IF;
149  	 IF NVL(p_usim_planck_speed_unit, 0) = 0
150  	 THEN
151  	   l_usim_planck_speed_unit := 1;
152  	 ELSE
153  	   l_usim_planck_speed_unit := ABS(p_usim_planck_speed_unit);
154  	 END IF;
155  	 IF NVL(p_usim_energy_start_value, 0) = 0
156  	 THEN
157  	   l_usim_energy_start_value := 1;
158  	 ELSE
159  	   l_usim_energy_start_value := ABS(p_usim_energy_start_value);
160  	 END IF;
161  	 -- insert the found values
162  	 INSERT INTO usim_multiverse
163  	   ( usim_is_base_universe
164  	   , usim_energy_start_value
165  	   , usim_planck_time_unit
166  	   , usim_planck_length_unit
167  	   , usim_planck_speed_unit
168  	   , usim_planck_stable
169  	   , usim_ultimate_border
170  	   )
171  	   VALUES
172  	   ( l_usim_is_base_universe
173  	   , l_usim_energy_start_value
174  	   , l_usim_planck_time_unit
175  	   , l_usim_planck_length_unit
176  	   , l_usim_planck_speed_unit
177  	   , l_usim_planck_stable
178  	   , l_usim_ultimate_border
179  	   )
180  	   RETURNING usim_id_mlv INTO l_usim_id_mlv
181  	 ;
182  	 IF p_do_commit
183  	 THEN
184  	   COMMIT;
185  	 END IF;
186  	 RETURN l_usim_id_mlv;
187    END insert_universe
188    ;
189  
190    FUNCTION update_state( p_usim_id_mlv	     IN usim_multiverse.usim_id_mlv%TYPE
191  			    , p_usim_universe_status IN usim_multiverse.usim_universe_status%TYPE
192  			    , p_do_commit	     IN BOOLEAN 				  DEFAULT TRUE
193  			    )
194  	 RETURN usim_multiverse.usim_universe_status%TYPE
195    IS
196    BEGIN
197  	 IF	usim_mlv.has_data(p_usim_id_mlv)  = 1
198  	    AND p_usim_universe_status		 IN ( usim_static.usim_multiverse_status_dead
199  						    , usim_static.usim_multiverse_status_crashed
200  						    , usim_static.usim_multiverse_status_active
201  						    , usim_static.usim_multiverse_status_inactive
202  						    )
203  	 THEN
204  	   UPDATE usim_multiverse
205  	      SET usim_universe_status = p_usim_universe_status
206  	    WHERE usim_id_mlv = p_usim_id_mlv
207  	   ;
208  	   IF p_do_commit
209  	   THEN
210  	     COMMIT;
211  	   END IF;
212  	   RETURN p_usim_universe_status;
213  	 ELSE
214  	   usim_erl.log_error('usim_mlv.update_state', 'Used with not existing universe id [' || p_usim_id_mlv || '] or wrong state [' || p_usim_universe_status || '].');
215  	   RETURN NULL;
216  	 END IF;
217    END update_state
218    ;
219  
220    FUNCTION update_planck_unit_time_speed( p_usim_id_mlv		 IN usim_multiverse.usim_id_mlv%TYPE
221  					     , p_usim_planck_time_unit	 IN usim_multiverse.usim_planck_time_unit%TYPE
222  					     , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
223  					     , p_do_commit		 IN BOOLEAN					 DEFAULT TRUE
224  					     )
225  	 RETURN NUMBER
226    IS
227  	 l_velocity  NUMBER;
228  	 l_length    NUMBER;
229  	 l_time      NUMBER;
230    BEGIN
231  	 IF	usim_mlv.has_data(p_usim_id_mlv)   = 1
232  	    AND usim_mlv.get_planck_stable(p_usim_id_mlv) = 0
233  	 THEN
234  	   IF NVL(p_usim_planck_time_unit, 0) = 0
235  	   THEN
236  	     l_time := 1;
237  	   ELSE
238  	     l_time := ABS(p_usim_planck_time_unit);
239  	   END IF;
240  	   IF NVL(p_usim_planck_speed_unit, 0) = 0
241  	   THEN
242  	     l_velocity := 1;
243  	   ELSE
244  	     l_velocity := ABS(p_usim_planck_speed_unit);
245  	   END IF;
246  	   l_length := l_velocity * l_time;
247  	   UPDATE usim_multiverse
248  	      SET usim_planck_time_unit    = l_time
249  		, usim_planck_length_unit  = l_length
250  		, usim_planck_speed_unit   = l_velocity
251  	    WHERE usim_id_mlv = p_usim_id_mlv
252  	   ;
253  	   IF p_do_commit
254  	   THEN
255  	     COMMIT;
256  	   END IF;
257  	   RETURN 1;
258  	 ELSE
259  	   usim_erl.log_error('usim_mlv.update_planck_unit_time_speed', 'Used with not existing universe id [' || p_usim_id_mlv || '] or planck stable is set.');
260  	   RETURN 0;
261  	 END IF;
262    END update_planck_unit_time_speed
263    ;
264  
265    FUNCTION update_planck_unit_time_length( p_usim_id_mlv		  IN usim_multiverse.usim_id_mlv%TYPE
266  					      , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE
267  					      , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
268  					      , p_do_commit		  IN BOOLEAN					  DEFAULT TRUE
269  					      )
270  	 RETURN NUMBER
271    IS
272  	 l_velocity  NUMBER;
273  	 l_length    NUMBER;
274  	 l_time      NUMBER;
275    BEGIN
276  	 IF	usim_mlv.has_data(p_usim_id_mlv)   = 1
277  	    AND usim_mlv.get_planck_stable(p_usim_id_mlv) = 0
278  	 THEN
279  	   IF NVL(p_usim_planck_time_unit, 0) = 0
280  	   THEN
281  	     l_time := 1;
282  	   ELSE
283  	     l_time := ABS(p_usim_planck_time_unit);
284  	   END IF;
285  	   IF NVL(p_usim_planck_length_unit, 0) = 0
286  	   THEN
287  	     l_length := 1;
288  	   ELSE
289  	     l_length := ABS(p_usim_planck_length_unit);
290  	   END IF;
291  	   l_velocity := l_length / l_time;
292  	   UPDATE usim_multiverse
293  	      SET usim_planck_time_unit    = l_time
294  		, usim_planck_length_unit  = l_length
295  		, usim_planck_speed_unit   = l_velocity
296  	    WHERE usim_id_mlv = p_usim_id_mlv
297  	   ;
298  	   IF p_do_commit
299  	   THEN
300  	     COMMIT;
301  	   END IF;
302  	   RETURN 1;
303  	 ELSE
304  	   usim_erl.log_error('usim_mlv.update_planck_unit_time_length', 'Used with not existing universe id [' || p_usim_id_mlv || '] or planck stable is set.');
305  	   RETURN 0;
306  	 END IF;
307    END update_planck_unit_time_length
308    ;
309  
310    FUNCTION update_planck_unit_speed_length( p_usim_id_mlv		   IN usim_multiverse.usim_id_mlv%TYPE
311  					       , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE
312  					       , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE
313  					       , p_do_commit		   IN BOOLEAN					   DEFAULT TRUE
314  					      )
315  	 RETURN NUMBER
316    IS
317  	 l_velocity  NUMBER;
318  	 l_length    NUMBER;
319  	 l_time      NUMBER;
320    BEGIN
321  	 IF	usim_mlv.has_data(p_usim_id_mlv)   = 1
322  	    AND usim_mlv.get_planck_stable(p_usim_id_mlv) = 0
323  	 THEN
324  	   IF NVL(p_usim_planck_speed_unit, 0) = 0
325  	   THEN
326  	     l_velocity := 1;
327  	   ELSE
328  	     l_velocity := ABS(p_usim_planck_speed_unit);
329  	   END IF;
330  	   IF NVL(p_usim_planck_length_unit, 0) = 0
331  	   THEN
332  	     l_length := 1;
333  	   ELSE
334  	     l_length := ABS(p_usim_planck_length_unit);
335  	   END IF;
336  	   l_time := l_length / l_velocity;
337  	   UPDATE usim_multiverse
338  	      SET usim_planck_time_unit    = l_time
339  		, usim_planck_length_unit  = l_length
340  		, usim_planck_speed_unit   = l_velocity
341  	    WHERE usim_id_mlv = p_usim_id_mlv
342  	   ;
343  	   IF p_do_commit
344  	   THEN
345  	     COMMIT;
346  	   END IF;
347  	   RETURN 1;
348  	 ELSE
349  	   usim_erl.log_error('usim_mlv.update_planck_unit_speed_length', 'Used with not existing universe id [' || p_usim_id_mlv || '] or planck stable is set.');
350  	   RETURN 0;
351  	 END IF;
352    END update_planck_unit_speed_length
353    ;
354  
355  END usim_mlv;
356  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_mlv
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_mlv

Package body created.

SQL> -- USIM_POSITION (pos)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_POSITION_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_POSITION still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_POSITION'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------------
../TABLES/USIM_POSITION_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_POSITION (pos)
SQL> CREATE TABLE &USIM_SCHEMA..usim_position
  2    ( usim_id_pos	 CHAR(55)      NOT NULL ENABLE
  3    , usim_coordinate NUMBER        NOT NULL ENABLE
  4    )
  5  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_position
new   1: CREATE TABLE USIM_TEST.usim_position

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_position IS 'A table holding the possible coordinates for reuse by different universes. Will use the alias pos.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_position IS 'A table holding the possible coordinates for reuse by different universes. Will use the alias pos.'
new   1: COMMENT ON TABLE USIM_TEST.usim_position IS 'A table holding the possible coordinates for reuse by different universes. Will use the alias pos.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_position.usim_id_pos IS 'The unique id of the coordinate. Automatically set, update not allowed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_position.usim_id_pos IS 'The unique id of the coordinate. Automatically set, update not allowed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_position.usim_id_pos IS 'The unique id of the coordinate. Automatically set, update not allowed.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_position.usim_coordinate IS 'The coordinate value between -max and +max of available number space. Must be set on insert, update not allowed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_position.usim_coordinate IS 'The coordinate value between -max and +max of available number space. Must be set on insert, update not allowed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_position.usim_coordinate IS 'The coordinate value between -max and +max of available number space. Must be set on insert, update not allowed.'

Comment created.

SQL> 
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_position
  2    ADD CONSTRAINT usim_pos_pk
  3    PRIMARY KEY (usim_id_pos)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_position
new   1: ALTER TABLE USIM_TEST.usim_position

Table altered.

SQL> 
SQL> -- uk
SQL> ALTER TABLE &USIM_SCHEMA..usim_position
  2    ADD CONSTRAINT usim_pos_uk
  3    UNIQUE (usim_coordinate)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_position
new   1: ALTER TABLE USIM_TEST.usim_position

Table altered.

SQL> 
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_pos_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_position
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   -- verify insert value
  6  	   IF ABS(:NEW.usim_coordinate) > usim_base.get_abs_max_number
  7  	   THEN
  8  	     RAISE_APPLICATION_ERROR( num => -20000
  9  				    , msg => 'Insert requirement not fulfilled. Absolute coordinate must be >= 0 and <= usim_base.get_abs_max_number.'
 10  				    )
 11  	     ;
 12  	   END IF;
 13  	   -- ignore input on pk
 14  	   :NEW.usim_id_pos := usim_static.get_big_pk(usim_pos_id_seq.NEXTVAL);
 15  	 END;
 16  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_pos_ins_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_pos_ins_trg
old   2:   BEFORE INSERT ON &USIM_SCHEMA..usim_position
new   2:   BEFORE INSERT ON USIM_TEST.usim_position

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_pos_ins_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_pos_ins_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_pos_ins_trg ENABLE

Trigger altered.

SQL> 
SQL> -- update trigger to prevent updates
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_pos_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_position
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   RAISE_APPLICATION_ERROR( num => -20001
  6  				  , msg => 'Update requirement not fulfilled. No update allowed.'
  7  				  )
  8  	   ;
  9  	 END;
 10  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_pos_upd_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_pos_upd_trg
old   2:   BEFORE UPDATE ON &USIM_SCHEMA..usim_position
new   2:   BEFORE UPDATE ON USIM_TEST.usim_position

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_pos_upd_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_pos_upd_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_pos_upd_trg ENABLE

Trigger altered.

SQL> -- usim_position package
SQL> @@../PACKAGES/USIM_POS.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_pos
  2  IS
  3    /**A low level package for actions on table usim_position and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9  
 10    /**
 11    * Checks if usim_position has already data.
 12    * @return Returns 1 if data are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15  	 RETURN NUMBER
 16    ;
 17  
 18    /**
 19    * Checks if usim_position has the given position id.
 20    * @param p_usim_id_pos The position id to verify.
 21    * @return Returns 1 if position id exists, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 24  	 RETURN NUMBER
 25    ;
 26  
 27    /**
 28    * Checks if usim_position has the given position.
 29    * @param p_usim_coordinate The position coordinate to verify.
 30    * @return Returns 1 if position exists, otherwise 0.
 31    */
 32    FUNCTION has_data(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
 33  	 RETURN NUMBER
 34    ;
 35  
 36    /**
 37    * Checks if usim_position has all coordinates for a dimension axis volume (line). For a given position the next position with
 38    * distance 1 must be available in positive and negative number space, e.g. +1, +2, -1, -2.
 39    * Coordinates are calculated by given ABS(coordinate).
 40    * @param p_usim_coordinate The coordinate for the start value with a positive sign of a volume. Always interpreted as positive value.
 41    * @return Returns 1 if dimension axis volume positions exist, otherwise 0.
 42    */
 43    FUNCTION has_dim_pair(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
 44  	 RETURN NUMBER
 45    ;
 46  
 47    /**
 48    * Checks if usim_position has all coordinates for a dimension axis volume (line). For a given position the next position with
 49    * distance 1 must be available in positive and negative number space, e.g. +1, +2, -1, -2.
 50    * Coordinates are calculated by given ABS(coordinate).
 51    * @param p_usim_id_pos The coordinate id for the from value with a positive sign of a volume. Always interpreted as positive coordinate value.
 52    * @return Returns 1 if dimension axis volume positions exist, otherwise 0.
 53    */
 54    FUNCTION has_dim_pair(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 55  	 RETURN NUMBER
 56    ;
 57  
 58    /**
 59    * Gets the maximum coordinate for a given sign.
 60    * @param p_sign The sign of the max coordinate (1, -1). Position 0 is always included in both number spaces.
 61    * @return Returns max usim_coordinate for given sign or NULL if no coordinates exists or wrong sign.
 62    */
 63    FUNCTION get_max_coordinate(p_sign IN NUMBER DEFAULT 1)
 64  	 RETURN usim_position.usim_coordinate%TYPE
 65    ;
 66  
 67    /**
 68    * Gets the coordinate for a given position id.
 69    * @param p_usim_id_pos The position id to get the coordinate for.
 70    * @return Returns usim_coordinate for given id or NULL if position id does not exists.
 71    */
 72    FUNCTION get_coordinate(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 73  	 RETURN usim_position.usim_coordinate%TYPE
 74    ;
 75  
 76    /**
 77    * Gets the sign of the coordinate for a given position id.
 78    * @param p_usim_id_pos The position id to get the sign of the coordinate for.
 79    * @return Returns the sign of the coordinate for a given id or NULL if position id does not exists.
 80    */
 81    FUNCTION get_coord_sign(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 82  	 RETURN NUMBER
 83    ;
 84  
 85    /**
 86    * Gets the position id for a given coordinate.
 87    * @param p_usim_coordinate The coordinate to get the position id for.
 88    * @return Returns usim_id_pos for given coordinate or NULL if coordinate with sign does not exists.
 89    */
 90    FUNCTION get_id_pos(p_usim_coordinate  IN usim_position.usim_coordinate%TYPE)
 91  	 RETURN usim_position.usim_id_pos%TYPE
 92    ;
 93  
 94    /**
 95    * Retrieve the related to position id with the same sign for a given from position id, if the dimension axis volume to position
 96    * exists. Special situation 0, with sign zero which has two possible relations.
 97    * @param p_usim_id_pos The supposed from coordinate id.
 98    * @param p_zero_sign Only used for coordinate zero to decide, which relation to retrieve. Only -1 or +1 allowed if used. Default 1.
 99    * @return Returns the dimension axis volume to position id with the same sign, if it exists, otherwise NULL.
100    */
101    FUNCTION get_dim_pos_rel( p_usim_id_pos IN usim_position.usim_id_pos%TYPE
102  			       , p_zero_sign   IN NUMBER			 DEFAULT 1
103  			       )
104  	 RETURN usim_position.usim_id_pos%TYPE
105    ;
106  
107    /**
108    * Retrieve the position id with the opposite sign for a given position id, if the position
109    * exists. Special situation 0, as the opposite of zero is 0.
110    * @param p_usim_id_pos The coordinate id to get the mirror for.
111    * @return Returns the mirror position id with the opposite sign, if it exists, otherwise NULL.
112    */
113    FUNCTION get_pos_mirror(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
114  	 RETURN usim_position.usim_id_pos%TYPE
115    ;
116  
117    /**
118    * Inserts a new coordinate if it does not exist.
119    * @param p_usim_coordinate The coordinate to insert.
120    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use). Should be given to avoid signature conflicts.
121    * @return Returns the new/existing position id for the coordinate or NULL if insert fails.
122    */
123    FUNCTION insert_position( p_usim_coordinate IN usim_position.usim_coordinate%TYPE
124  			       , p_do_commit	   IN BOOLEAN				 DEFAULT TRUE
125  			       )
126  	 RETURN usim_position.usim_id_pos%TYPE
127    ;
128  
129    /**
130    * Creates all coordinates including given max coordinate. Inserts positive and negative coordinates.
131    * Can be used to initialize the available positions for a multiverse.
132    * @param p_max_coordinate The maximum coordinate to insert. Valid for positive and negative numbers.
133    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
134    * @return Returns 1 one success 0 on errors.
135    */
136    FUNCTION init_positions( p_max_coordinate IN usim_position.usim_coordinate%TYPE
137  			      , p_do_commit	 IN BOOLEAN			       DEFAULT TRUE
138  			      )
139  	 RETURN NUMBER
140    ;
141  
142  END usim_pos;
143  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_pos
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_pos

Package created.

SQL> @@../PACKAGES/USIM_POS.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_pos
  2  IS
  3    -- see header for documentation
  4  
  5    FUNCTION has_data
  6  	 RETURN NUMBER
  7    IS
  8  	 l_result NUMBER;
  9    BEGIN
 10  	 SELECT COUNT(*) INTO l_result FROM usim_position;
 11  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 12    END has_data
 13    ;
 14  
 15    FUNCTION has_data(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 16  	 RETURN NUMBER
 17    IS
 18  	 l_result NUMBER;
 19    BEGIN
 20  	 SELECT COUNT(*) INTO l_result FROM usim_position WHERE usim_id_pos = p_usim_id_pos;
 21  	 RETURN l_result;
 22    END has_data
 23    ;
 24  
 25    FUNCTION has_data(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
 26  	 RETURN NUMBER
 27    IS
 28  	 l_result NUMBER;
 29    BEGIN
 30  	 SELECT COUNT(*) INTO l_result FROM usim_position WHERE usim_coordinate = p_usim_coordinate;
 31  	 RETURN l_result;
 32    END has_data
 33    ;
 34  
 35    FUNCTION has_dim_pair(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
 36  	 RETURN NUMBER
 37    IS
 38    BEGIN
 39  	 IF	 usim_pos.has_data(ABS(p_usim_coordinate))	      = 1
 40  	    AND  usim_pos.has_data(ABS(p_usim_coordinate) + 1)	      = 1
 41  	    AND  usim_pos.has_data(ABS(p_usim_coordinate) * -1)       = 1
 42  	    AND  usim_pos.has_data((ABS(p_usim_coordinate) + 1) * -1) = 1
 43  	 THEN
 44  	   RETURN 1;
 45  	 ELSE
 46  	   RETURN 0;
 47  	 END IF;
 48    END has_dim_pair
 49    ;
 50  
 51    FUNCTION has_dim_pair(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 52  	 RETURN NUMBER
 53    IS
 54    BEGIN
 55  	 RETURN usim_pos.has_dim_pair(usim_pos.get_coordinate(p_usim_id_pos));
 56    END has_dim_pair
 57    ;
 58  
 59    FUNCTION get_max_coordinate(p_sign IN NUMBER DEFAULT 1)
 60  	 RETURN usim_position.usim_coordinate%TYPE
 61    IS
 62  	 l_result  usim_position.usim_coordinate%TYPE;
 63    BEGIN
 64  	 IF	usim_pos.has_data = 1
 65  	    AND p_sign		 IN (1, -1)
 66  	 THEN
 67  	   IF p_sign > 0
 68  	   THEN
 69  	     SELECT MAX(usim_coordinate) INTO l_result FROM usim_position WHERE SIGN(usim_coordinate) IN (0, 1);
 70  	   ELSE
 71  	     SELECT MIN(usim_coordinate) INTO l_result FROM usim_position WHERE SIGN(usim_coordinate) IN (0, -1);
 72  	   END IF;
 73  	   RETURN l_result;
 74  	 ELSE
 75  	   usim_erl.log_error('usim_pos.get_max_coordinate', 'Used without position data or wrong sign [' || p_sign || '].');
 76  	   RETURN NULL;
 77  	 END IF;
 78    END get_max_coordinate
 79    ;
 80  
 81    FUNCTION get_coordinate(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 82  	 RETURN usim_position.usim_coordinate%TYPE
 83    IS
 84  	 l_result usim_position.usim_coordinate%TYPE;
 85    BEGIN
 86  	 IF usim_pos.has_data(p_usim_id_pos) = 1
 87  	 THEN
 88  	   SELECT usim_coordinate INTO l_result FROM usim_position WHERE usim_id_pos = p_usim_id_pos;
 89  	   RETURN l_result;
 90  	 ELSE
 91  	   usim_erl.log_error('usim_pos.get_coordinate', 'Used with not existing pos id [' || p_usim_id_pos || '].');
 92  	   RETURN NULL;
 93  	 END IF;
 94    END get_coordinate
 95    ;
 96  
 97    FUNCTION get_coord_sign(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
 98  	 RETURN NUMBER
 99    IS
100  	 l_result INTEGER;
101    BEGIN
102  	 IF usim_pos.has_data(p_usim_id_pos) = 1
103  	 THEN
104  	   SELECT SIGN(usim_coordinate) INTO l_result FROM usim_position WHERE usim_id_pos = p_usim_id_pos;
105  	   RETURN l_result;
106  	 ELSE
107  	   usim_erl.log_error('usim_pos.get_coord_sign', 'Used with not existing pos id [' || p_usim_id_pos || '].');
108  	   RETURN NULL;
109  	 END IF;
110    END get_coord_sign
111    ;
112  
113    FUNCTION get_id_pos(p_usim_coordinate  IN usim_position.usim_coordinate%TYPE)
114  	 RETURN usim_position.usim_id_pos%TYPE
115    IS
116  	 l_result  usim_position.usim_id_pos%TYPE;
117    BEGIN
118  	 IF usim_pos.has_data(p_usim_coordinate) = 1
119  	 THEN
120  	   SELECT usim_id_pos INTO l_result FROM usim_position WHERE usim_coordinate = p_usim_coordinate;
121  	   RETURN l_result;
122  	 ELSE
123  	   usim_erl.log_error('usim_pos.get_id_pos', 'Used with not existing coordinate [' || p_usim_coordinate || '].');
124  	   RETURN NULL;
125  	 END IF;
126    END get_id_pos
127    ;
128  
129    FUNCTION get_dim_pos_rel( p_usim_id_pos IN usim_position.usim_id_pos%TYPE
130  			       , p_zero_sign   IN NUMBER			 DEFAULT 1
131  			       )
132  	 RETURN usim_position.usim_id_pos%TYPE
133    IS
134  	 l_sign   NUMBER;
135  	 l_coord  usim_position.usim_coordinate%TYPE;
136  	 l_result usim_position.usim_id_pos%TYPE;
137    BEGIN
138  	 IF	 usim_pos.has_dim_pair(p_usim_id_pos) = 1
139  	    AND  p_zero_sign			     IN (1, -1)
140  	 THEN
141  	   l_sign  := usim_pos.get_coord_sign(p_usim_id_pos);
142  	   l_coord := usim_pos.get_coordinate(p_usim_id_pos);
143  	   -- handle sign by position
144  	   IF l_sign = 1
145  	   THEN
146  	     l_result := usim_pos.get_id_pos(l_coord + 1);
147  	   ELSIF l_sign = -1
148  	   THEN
149  	     l_result := usim_pos.get_id_pos(l_coord - 1);
150  	   ELSE
151  	     -- zero case
152  	     l_result := usim_pos.get_id_pos(p_zero_sign);
153  	   END IF;
154  	   RETURN l_result;
155  	 ELSE
156  	   usim_erl.log_error('usim_pos.get_vol_pos_rel', 'Position id has no dimension axis volume to position [' || p_usim_id_pos || '] or wrong zero sign [' || p_zero_sign || '].');
157  	   RETURN NULL;
158  	 END IF;
159    END get_dim_pos_rel
160    ;
161  
162    FUNCTION get_pos_mirror(p_usim_id_pos IN usim_position.usim_id_pos%TYPE)
163  	 RETURN usim_position.usim_id_pos%TYPE
164    IS
165  	 l_coord  usim_position.usim_coordinate%TYPE;
166  	 l_result usim_position.usim_id_pos%TYPE;
167    BEGIN
168  	 IF usim_pos.has_data(p_usim_id_pos) = 1
169  	 THEN
170  	   l_coord  := usim_pos.get_coordinate(p_usim_id_pos) * -1;
171  	   IF usim_pos.has_data(l_coord) = 1
172  	   THEN
173  	     l_result := usim_pos.get_id_pos(l_coord);
174  	     RETURN l_result;
175  	   ELSE
176  	     usim_erl.log_error('usim_pos.get_pos_mirror', 'Position id does not exist for coordinate [' || l_coord || '].');
177  	     RETURN NULL;
178  	   END IF;
179  	 ELSE
180  	   usim_erl.log_error('usim_pos.get_pos_mirror', 'Position id does not exist [' || p_usim_id_pos || '].');
181  	   RETURN NULL;
182  	 END IF;
183    END get_pos_mirror
184    ;
185  
186    FUNCTION insert_position( p_usim_coordinate IN usim_position.usim_coordinate%TYPE
187  			       , p_do_commit	   IN BOOLEAN				 DEFAULT TRUE
188  			       )
189  	 RETURN usim_position.usim_id_pos%TYPE
190    IS
191  	 l_result	   usim_position.usim_id_pos%TYPE;
192    BEGIN
193  	 IF usim_pos.has_data(p_usim_coordinate) = 1
194  	 THEN
195  	   RETURN usim_pos.get_id_pos(p_usim_coordinate);
196  	 ELSIF p_usim_coordinate IS NOT NULL
197  	 THEN
198  	   INSERT INTO usim_position (usim_coordinate) VALUES (p_usim_coordinate) RETURNING usim_id_pos INTO l_result;
199  	   IF p_do_commit
200  	   THEN
201  	     COMMIT;
202  	   END IF;
203  	   RETURN l_result;
204  	 ELSE
205  	   usim_erl.log_error('usim_pos.insert_position', 'Used with invalid position coordinate [' || p_usim_coordinate || '].');
206  	   RETURN NULL;
207  	 END IF;
208    END insert_position
209    ;
210  
211    FUNCTION init_positions( p_max_coordinate IN usim_position.usim_coordinate%TYPE
212  			      , p_do_commit	 IN BOOLEAN			       DEFAULT TRUE
213  			      )
214  	 RETURN NUMBER
215    IS
216  	 l_usim_id_pos usim_position.usim_id_pos%TYPE;
217    BEGIN
218  	 IF p_max_coordinate IS NULL
219  	 THEN
220  	   usim_erl.log_error('usim_dim.init_positions', 'Used with invalid max position [' || p_max_coordinate || '].');
221  	   RETURN 0;
222  	 END IF;
223  	 FOR l_pos IN 0..ABS(p_max_coordinate)
224  	 LOOP
225  	   l_usim_id_pos := usim_pos.insert_position(l_pos, p_do_commit);
226  	   IF l_usim_id_pos IS NULL
227  	   THEN
228  	     usim_erl.log_error('usim_dim.init_positions', 'Error inserting position [' || l_pos || '].');
229  	     RETURN 0;
230  	   END IF;
231  	   IF l_pos != 0
232  	   THEN
233  	     -- insert negative value
234  	     l_usim_id_pos := usim_pos.insert_position(-l_pos, p_do_commit);
235  	     IF l_usim_id_pos IS NULL
236  	     THEN
237  	       usim_erl.log_error('usim_dim.init_positions', 'Error inserting position [' || -l_pos || '].');
238  	       RETURN 0;
239  	     END IF;
240  	   END IF;
241  	 END LOOP;
242  	 RETURN 1;
243    END init_positions
244    ;
245  
246  END usim_pos;
247  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_pos
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_pos

Package body created.

SQL> -- USIM_DIMENSION (dim)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_DIMENSION_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_DIMENSION still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_DIMENSION'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../TABLES/USIM_DIMENSION_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE TABLE &USIM_SCHEMA..usim_dimension
  2    ( usim_id_dim	   CHAR(55)	NOT NULL ENABLE
  3    , usim_n_dimension  NUMBER(2, 0) NOT NULL ENABLE
  4    )
  5  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_dimension
new   1: CREATE TABLE USIM_TEST.usim_dimension

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_dimension IS 'Contains the dimensions available for the multiverse. Will use the alias dim.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_dimension IS 'Contains the dimensions available for the multiverse. Will use the alias dim.'
new   1: COMMENT ON TABLE USIM_TEST.usim_dimension IS 'Contains the dimensions available for the multiverse. Will use the alias dim.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_dimension.usim_id_dim IS 'The unique id for the associated dimension. Update not allowed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_dimension.usim_id_dim IS 'The unique id for the associated dimension. Update not allowed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_dimension.usim_id_dim IS 'The unique id for the associated dimension. Update not allowed.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_dimension.usim_n_dimension IS 'The n-sphere supported dimension for space simulation. Must be >= 0 and <= usim_basedata.usim_max_dimension. Must be set on insert. Update not allowed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_dimension.usim_n_dimension IS 'The n-sphere supported dimension for space simulation. Must be >= 0 and <= usim_basedata.usim_max_dimension. Must be set on insert. Update not allowed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_dimension.usim_n_dimension IS 'The n-sphere supported dimension for space simulation. Must be >= 0 and <= usim_basedata.usim_max_dimension. Must be set on insert. Update not allowed.'

Comment created.

SQL> 
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_dimension
  2    ADD CONSTRAINT usim_dim_pk
  3    PRIMARY KEY (usim_id_dim)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_dimension
new   1: ALTER TABLE USIM_TEST.usim_dimension

Table altered.

SQL> 
SQL> -- uk
SQL> ALTER TABLE &USIM_SCHEMA..usim_dimension
  2    ADD CONSTRAINT usim_dim_uk
  3    UNIQUE (usim_n_dimension)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_dimension
new   1: ALTER TABLE USIM_TEST.usim_dimension

Table altered.

SQL> 
SQL> -- chk
SQL> ALTER TABLE &USIM_SCHEMA..usim_dimension
  2    ADD CONSTRAINT usim_dim_dimension_chk
  3    CHECK (usim_n_dimension >= 0)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_dimension
new   1: ALTER TABLE USIM_TEST.usim_dimension

Table altered.

SQL> 
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_dim_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_dimension
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   -- verify insert value
  6  	   IF :NEW.usim_n_dimension > usim_base.get_max_dimension
  7  	   THEN
  8  	     RAISE_APPLICATION_ERROR( num => -20000
  9  				    , msg => 'Insert requirement not fulfilled. Dimension must be >= 0 and <= usim_base.get_max_dimension.'
 10  				    )
 11  	     ;
 12  	   END IF;
 13  	   -- ignore input on pk
 14  	   :NEW.usim_id_dim := usim_static.get_big_pk(usim_dim_id_seq.NEXTVAL);
 15  	 END;
 16  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_dim_ins_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_dim_ins_trg
old   2:   BEFORE INSERT ON &USIM_SCHEMA..usim_dimension
new   2:   BEFORE INSERT ON USIM_TEST.usim_dimension

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_dim_ins_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_dim_ins_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_dim_ins_trg ENABLE

Trigger altered.

SQL> 
SQL> -- update trigger to prevent updates
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_dim_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_dimension
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   RAISE_APPLICATION_ERROR( num => -20001
  6  				  , msg => 'Update requirement not fulfilled. No update allowed.'
  7  				  )
  8  	   ;
  9  	 END;
 10  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_dim_upd_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_dim_upd_trg
old   2:   BEFORE UPDATE ON &USIM_SCHEMA..usim_dimension
new   2:   BEFORE UPDATE ON USIM_TEST.usim_dimension

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_dim_upd_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_dim_upd_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_dim_upd_trg ENABLE

Trigger altered.

SQL> -- usim_dimension package
SQL> @@../PACKAGES/USIM_DIM.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_dim
  2  IS
  3    /**A low level package for actions on table usim_dimension and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9  
 10    /**
 11    * Checks if usim_dimension has already data.
 12    * @return Returns 1 if dimensions are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15  	 RETURN NUMBER
 16    ;
 17  
 18    /**
 19    * Checks if given dimension id exists.
 20    * @param p_usim_id_dim The id of the dimension.
 21    * @return Returns 1 if id exists, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
 24  	 RETURN NUMBER
 25    ;
 26  
 27    /**
 28    * Checks if given dimension exists.
 29    * @param p_usim_n_dimension The dimension to verify.
 30    * @return Returns 1 if id exists, otherwise 0.
 31    */
 32    FUNCTION has_data(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
 33  	 RETURN NUMBER
 34    ;
 35  
 36    /**
 37    * Gets the maximum dimension available.
 38    * @return Returns max usim_n_dimension or -1 if no dimension exists.
 39    */
 40    FUNCTION get_max_dimension
 41  	 RETURN usim_dimension.usim_n_dimension%TYPE
 42    ;
 43  
 44    /**
 45    * Gets the dimension id for a given dimension.
 46    * @param p_usim_n_dimension The dimension to get the dimension id for.
 47    * @return Returns related usim_id_dim or NULL if it does not exist.
 48    */
 49    FUNCTION get_id_dim(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
 50  	 RETURN usim_dimension.usim_id_dim%TYPE
 51    ;
 52  
 53    /**
 54    * Gets the dimension for a given dimension id.
 55    * @param p_usim_id_dim The id of the dimension.
 56    * @return Returns usim_n_dimension for given dimension id or -1 if dimension id does not exist.
 57    */
 58    FUNCTION get_dimension(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
 59  	 RETURN usim_dimension.usim_n_dimension%TYPE
 60    ;
 61  
 62    /**
 63    * Inserts a dimension into usim_dimension.
 64    * @param p_usim_n_dimension The dimension to insert. Always absolute value is used, no negative dimensions possible.
 65    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 66    * @return Returns the new/existing dimension id or NULL on errors.
 67    */
 68    FUNCTION insert_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 69  				, p_do_commit	     IN BOOLEAN 			     DEFAULT TRUE
 70  				)
 71  	 RETURN usim_dimension.usim_id_dim%TYPE
 72    ;
 73  
 74    /**
 75    * Creates all dimensions including given max dimension. Can be used to initialize the available
 76    * dimensions in a multiverse.
 77    * @param p_max_dimension The maximum dimensions to insert. Always absolute value is used, no negative dimensions possible.
 78    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 79    * @return Returns 1 one success 0 on errors.
 80    */
 81    FUNCTION init_dimensions( p_max_dimension IN usim_dimension.usim_n_dimension%TYPE
 82  			       , p_do_commit	 IN BOOLEAN				 DEFAULT TRUE
 83  			       )
 84  	 RETURN NUMBER
 85    ;
 86  
 87  END usim_dim;
 88  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_dim
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_dim

Package created.

SQL> @@../PACKAGES/USIM_DIM.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_dim
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_data
  5  	 RETURN NUMBER
  6    IS
  7  	 l_result  NUMBER;
  8    BEGIN
  9  	 SELECT COUNT(*) INTO l_result FROM usim_dimension;
 10  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 11    END has_data
 12    ;
 13  
 14    FUNCTION has_data(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
 15  	 RETURN NUMBER
 16    IS
 17  	 l_result  NUMBER;
 18    BEGIN
 19  	 SELECT COUNT(*) INTO l_result FROM usim_dimension WHERE usim_id_dim = p_usim_id_dim;
 20  	 RETURN l_result;
 21    END has_data
 22    ;
 23  
 24    FUNCTION has_data(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
 25  	 RETURN NUMBER
 26    IS
 27  	 l_result  NUMBER;
 28    BEGIN
 29  	 SELECT COUNT(*) INTO l_result FROM usim_dimension WHERE usim_n_dimension = p_usim_n_dimension;
 30  	 RETURN l_result;
 31    END has_data
 32    ;
 33  
 34    FUNCTION get_max_dimension
 35  	 RETURN usim_dimension.usim_n_dimension%TYPE
 36    IS
 37  	 l_result  NUMBER;
 38    BEGIN
 39  	 IF usim_dim.has_data = 1
 40  	 THEN
 41  	   SELECT MAX(usim_n_dimension) INTO l_result FROM usim_dimension;
 42  	   RETURN l_result;
 43  	 ELSE
 44  	   RETURN -1;
 45  	 END IF;
 46    END get_max_dimension
 47    ;
 48  
 49    FUNCTION get_id_dim(p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE)
 50  	 RETURN usim_dimension.usim_id_dim%TYPE
 51    IS
 52  	 l_usim_id_dim	 usim_dimension.usim_id_dim%TYPE;
 53    BEGIN
 54  	 IF usim_dim.has_data(p_usim_n_dimension) = 1
 55  	 THEN
 56  	   SELECT usim_id_dim INTO l_usim_id_dim FROM usim_dimension WHERE usim_n_dimension = p_usim_n_dimension;
 57  	   RETURN l_usim_id_dim;
 58  	 ELSE
 59  	   usim_erl.log_error('usim_dim.get_id_dim', 'Used with not existing dimension [' || p_usim_n_dimension || '].');
 60  	   RETURN NULL;
 61  	 END IF;
 62    END get_id_dim
 63    ;
 64  
 65    FUNCTION get_dimension(p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE)
 66  	 RETURN usim_dimension.usim_n_dimension%TYPE
 67    IS
 68  	 l_result usim_dimension.usim_n_dimension%TYPE;
 69    BEGIN
 70  	 IF usim_dim.has_data(p_usim_id_dim) = 1
 71  	 THEN
 72  	   SELECT usim_n_dimension INTO l_result FROM usim_dimension WHERE usim_id_dim = p_usim_id_dim;
 73  	   RETURN l_result;
 74  	 ELSE
 75  	   RETURN -1;
 76  	 END IF;
 77    END get_dimension
 78    ;
 79  
 80    FUNCTION insert_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 81  				, p_do_commit	     IN BOOLEAN 			     DEFAULT TRUE
 82  				)
 83  	 RETURN usim_dimension.usim_id_dim%TYPE
 84    IS
 85  	 l_new_dimension NUMBER;
 86  	 l_result	 usim_dimension.usim_id_dim%TYPE;
 87    BEGIN
 88  	 IF usim_dim.has_data(p_usim_n_dimension) = 1
 89  	 THEN
 90  	   RETURN usim_dim.get_id_dim(p_usim_n_dimension);
 91  	 ELSIF p_usim_n_dimension IS NOT NULL
 92  	 THEN
 93  	   INSERT INTO usim_dimension (usim_n_dimension) VALUES (ABS(p_usim_n_dimension))
 94  	     RETURNING usim_id_dim INTO l_result
 95  	   ;
 96  	   IF p_do_commit
 97  	   THEN
 98  	     COMMIT;
 99  	   END IF;
100  	   RETURN l_result;
101  	 ELSE
102  	   usim_erl.log_error('usim_dim.insert_dimension', 'Used with invalid dimension [' || p_usim_n_dimension || '].');
103  	   RETURN NULL;
104  	 END IF;
105    END insert_dimension
106    ;
107  
108    FUNCTION init_dimensions( p_max_dimension IN usim_dimension.usim_n_dimension%TYPE
109  			       , p_do_commit	 IN BOOLEAN				 DEFAULT TRUE
110  			       )
111  	 RETURN NUMBER
112    IS
113  	 l_usim_id_dim usim_dimension.usim_id_dim%TYPE;
114    BEGIN
115  	 IF p_max_dimension IS NULL
116  	 THEN
117  	   usim_erl.log_error('usim_dim.init_dimensions', 'Used with invalid max dimension [' || p_max_dimension || '].');
118  	   RETURN 0;
119  	 END IF;
120  	 FOR l_dim IN 0..ABS(p_max_dimension)
121  	 LOOP
122  	   l_usim_id_dim := usim_dim.insert_dimension(l_dim, p_do_commit);
123  	   IF l_usim_id_dim IS NULL
124  	   THEN
125  	     usim_erl.log_error('usim_dim.init_dimensions', 'Error inserting dimension [' || l_dim || '].');
126  	     RETURN 0;
127  	   END IF;
128  	 END LOOP;
129  	 RETURN 1;
130    END init_dimensions
131    ;
132  
133  END usim_dim;
134  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_dim
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_dim

Package body created.

SQL> -- USIM_NODE (nod)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_NODE_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_NODE still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_NODE'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
------------------------------------------------------------------
../TABLES/USIM_NODE_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_NODE (nod)
SQL> CREATE TABLE &USIM_SCHEMA..usim_node
  2    ( usim_id_nod	 CHAR(55)  NOT NULL ENABLE
  3    , usim_energy	 NUMBER
  4    )
  5  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_node
new   1: CREATE TABLE USIM_TEST.usim_node

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_node IS 'Contains all nodes of all universes that form volumes holding a potential energy. Will use the alias nod.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_node IS 'Contains all nodes of all universes that form volumes holding a potential energy. Will use the alias nod.'
new   1: COMMENT ON TABLE USIM_TEST.usim_node IS 'Contains all nodes of all universes that form volumes holding a potential energy. Will use the alias nod.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_node.usim_id_nod IS 'The unique id for this node. Automatically set, update ignored.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_node.usim_id_nod IS 'The unique id for this node. Automatically set, update ignored.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_node.usim_id_nod IS 'The unique id for this node. Automatically set, update ignored.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_node.usim_id_nod IS 'The potential energy of the node. Set to NULL on insert. Only updates allowed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_node.usim_id_nod IS 'The potential energy of the node. Set to NULL on insert. Only updates allowed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_node.usim_id_nod IS 'The potential energy of the node. Set to NULL on insert. Only updates allowed.'

Comment created.

SQL> 
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_node
  2    ADD CONSTRAINT usim_nod_pk
  3    PRIMARY KEY (usim_id_nod)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_node
new   1: ALTER TABLE USIM_TEST.usim_node

Table altered.

SQL> 
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_node_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_node
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   -- ignore input on pk and energy
  6  	   :NEW.usim_id_nod := usim_static.get_big_pk(usim_nod_id_seq.NEXTVAL);
  7  	   :NEW.usim_energy := NULL;
  8  	 END;
  9  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_node_ins_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_node_ins_trg
old   2:   BEFORE INSERT ON &USIM_SCHEMA..usim_node
new   2:   BEFORE INSERT ON USIM_TEST.usim_node

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_node_ins_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_node_ins_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_node_ins_trg ENABLE

Trigger altered.

SQL> 
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_node_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_node
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   -- ignore update on pk
  6  	   :NEW.usim_id_nod := :OLD.usim_id_nod;
  7  	 END;
  8  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_node_upd_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_node_upd_trg
old   2:   BEFORE UPDATE ON &USIM_SCHEMA..usim_node
new   2:   BEFORE UPDATE ON USIM_TEST.usim_node

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_node_upd_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_node_upd_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_node_upd_trg ENABLE

Trigger altered.

SQL> -- usim_node packages
SQL> @@../PACKAGES/USIM_NOD.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_nod
  2  IS
  3    /**A low level package for actions on table usim_node and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9  
 10    /**
 11    * Checks if usim_node has already data.
 12    * @return Returns 1 if data are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15  	 RETURN NUMBER
 16    ;
 17  
 18    /**
 19    * Checks if usim_node has the given node id.
 20    * @param p_usim_id_nod The node id to verify.
 21    * @return Returns 1 if node id exists, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
 24  	 RETURN NUMBER
 25    ;
 26  
 27    /**
 28    * Retrieves the energy of a given node, which can be NULL. Use
 29    * has_data to verify, if a node id exists.
 30    * @param p_usim_id_nod The node id to get the energy for.
 31    * @return Returns usim_energy if node id exists, otherwise NULL. Using NUMBER not TYPE as calculations behave different if TYPE is used and max is reached.
 32    */
 33    FUNCTION get_energy(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
 34  	 RETURN NUMBER
 35    ;
 36  
 37    /**
 38    * Inserts a new node. Energy is set to NULL on insert and can only
 39    * be changed by update. As a node is a very simple structure, it may
 40    * be difficult to identify a specific node, if it is not assigned
 41    * to a universe, dimension, position, node structure after creating it.
 42    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 43    * @return Returns the new created node id with energy default NULL.
 44    */
 45    FUNCTION insert_node(p_do_commit  IN BOOLEAN  DEFAULT TRUE)
 46  	 RETURN usim_node.usim_id_nod%TYPE
 47    ;
 48  
 49    /**
 50    * Updates the energy of a given node.
 51    * @param p_usim_energy The the energy to set on the node.
 52    * @param p_usim_id_pos The node id to update the energy.
 53    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 54    * @return Returns current usim_energy after update or NULL if node does not exist.
 55    */
 56    FUNCTION update_energy( p_usim_energy  IN usim_node.usim_energy%TYPE
 57  			     , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
 58  			     , p_do_commit    IN BOOLEAN		    DEFAULT TRUE
 59  			     )
 60  	 RETURN usim_node.usim_energy%TYPE
 61    ;
 62  
 63    /**
 64    * Updates the energy of a given node by adding the given energy value to the existing energy value.
 65    * @param p_usim_energy The the energy to add to the node. Using NUMBER not TYPE as calculations behave different if TYPE is used and max is reached.
 66    * @param p_usim_id_pos The node id to update the energy.
 67    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 68    * @return Returns current usim_energy after update.
 69    */
 70    FUNCTION add_energy( p_usim_energy  IN NUMBER
 71  			  , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
 72  			  , p_do_commit    IN BOOLEAN			 DEFAULT TRUE
 73  			  )
 74  	 RETURN usim_node.usim_energy%TYPE
 75    ;
 76  
 77  END usim_nod;
 78  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_nod
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_nod

Package created.

SQL> @@../PACKAGES/USIM_NOD.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_nod
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_data
  5  	 RETURN NUMBER
  6    IS
  7  	 l_result NUMBER;
  8    BEGIN
  9  	 SELECT COUNT(*) INTO l_result FROM usim_node;
 10  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 11    END has_data
 12    ;
 13  
 14    FUNCTION has_data(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
 15  	 RETURN NUMBER
 16    IS
 17  	 l_result NUMBER;
 18    BEGIN
 19  	 SELECT COUNT(*) INTO l_result FROM usim_node WHERE usim_id_nod = p_usim_id_nod;
 20  	 RETURN l_result;
 21    END has_data
 22    ;
 23  
 24    FUNCTION get_energy(p_usim_id_nod IN usim_node.usim_id_nod%TYPE)
 25  	 RETURN NUMBER
 26    IS
 27  	 l_result NUMBER;
 28    BEGIN
 29  	 IF usim_nod.has_data(p_usim_id_nod) = 1
 30  	 THEN
 31  	   SELECT usim_energy INTO l_result FROM usim_node WHERE usim_id_nod = p_usim_id_nod;
 32  	   RETURN l_result;
 33  	 ELSE
 34  	   usim_erl.log_error('usim_nod.get_energy', 'Used with not existing node id [' || p_usim_id_nod || '].');
 35  	   RETURN NULL;
 36  	 END IF;
 37    END get_energy
 38    ;
 39  
 40    FUNCTION insert_node(p_do_commit  IN BOOLEAN  DEFAULT TRUE)
 41  	 RETURN usim_node.usim_id_nod%TYPE
 42    IS
 43  	 l_result usim_node.usim_id_nod%TYPE;
 44    BEGIN
 45  	 INSERT INTO usim_node (usim_energy) VALUES (NULL) RETURNING usim_id_nod INTO l_result;
 46  	 IF p_do_commit
 47  	 THEN
 48  	   COMMIT;
 49  	 END IF;
 50  	 RETURN l_result;
 51    END insert_node
 52    ;
 53  
 54    FUNCTION update_energy( p_usim_energy  IN usim_node.usim_energy%TYPE
 55  			     , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
 56  			     , p_do_commit    IN BOOLEAN		    DEFAULT TRUE
 57  			     )
 58  	 RETURN usim_node.usim_energy%TYPE
 59    IS
 60  	 l_result usim_node.usim_energy%TYPE;
 61    BEGIN
 62  	 IF usim_nod.has_data(p_usim_id_nod) = 1
 63  	 THEN
 64  	   UPDATE usim_node SET usim_energy = p_usim_energy WHERE usim_id_nod = p_usim_id_nod RETURNING usim_energy INTO l_result;
 65  	   IF p_do_commit
 66  	   THEN
 67  	     COMMIT;
 68  	   END IF;
 69  	   RETURN l_result;
 70  	 ELSE
 71  	   usim_erl.log_error('usim_nod.update_energy', 'Used with not existing node id [' || p_usim_id_nod || '].');
 72  	   RETURN NULL;
 73  	 END IF;
 74    END update_energy
 75    ;
 76  
 77    FUNCTION add_energy( p_usim_energy  IN NUMBER
 78  			  , p_usim_id_nod  IN usim_node.usim_id_nod%TYPE
 79  			  , p_do_commit    IN BOOLEAN			 DEFAULT TRUE
 80  			  )
 81  	 RETURN usim_node.usim_energy%TYPE
 82    IS
 83  	 l_energy NUMBER;
 84    BEGIN
 85  	 l_energy := NVL(p_usim_energy, 0) + NVL(usim_nod.get_energy(p_usim_id_nod), 0);
 86  	 RETURN usim_nod.update_energy(l_energy, p_usim_id_nod, p_do_commit);
 87    END add_energy
 88    ;
 89  
 90  END usim_nod;
 91  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_nod
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_nod

Package body created.

SQL> --== base tables end ==--
SQL> --== relation tables start ==--
SQL> -- USIM_REL_MLV_DIM (rmd)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_REL_MLV_DIM_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_REL_MLV_DIM still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_REL_MLV_DIM'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------------
../TABLES/USIM_REL_MLV_DIM_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_REL_MLV_DIM (rmd)
SQL> CREATE TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  2    ( usim_id_rmd  CHAR(55)	    NOT NULL ENABLE
  3    , usim_id_mlv  CHAR(55)	    NOT NULL ENABLE
  4    , usim_id_dim  CHAR(55)	    NOT NULL ENABLE
  5    , usim_sign    NUMBER(1, 0)  NOT NULL ENABLE
  6    , usim_n1_sign NUMBER(1, 0)
  7    )
  8  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_rel_mlv_dim
new   1: CREATE TABLE USIM_TEST.usim_rel_mlv_dim

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_rel_mlv_dim IS 'A table describing the relation between dimension and a specific universe. Will use the alias rmd.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_rel_mlv_dim IS 'A table describing the relation between dimension and a specific universe. Will use the alias rmd.'
new   1: COMMENT ON TABLE USIM_TEST.usim_rel_mlv_dim IS 'A table describing the relation between dimension and a specific universe. Will use the alias rmd.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_id_rmd IS 'The unique id of the relation between universe and dimension. Automatically set, ignored on update';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_id_rmd IS 'The unique id of the relation between universe and dimension. Automatically set, ignored on update'
new   1: COMMENT ON COLUMN USIM_TEST.usim_rel_mlv_dim.usim_id_rmd IS 'The unique id of the relation between universe and dimension. Automatically set, ignored on update'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_id_mlv IS 'The universe id to relate to a dimension. Must be set on insert, ignored on update.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_id_mlv IS 'The universe id to relate to a dimension. Must be set on insert, ignored on update.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_rel_mlv_dim.usim_id_mlv IS 'The universe id to relate to a dimension. Must be set on insert, ignored on update.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_id_dim IS 'The dimension id to relate to a universe. Must be set on insert, ignored on update.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_id_dim IS 'The dimension id to relate to a universe. Must be set on insert, ignored on update.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_rel_mlv_dim.usim_id_dim IS 'The dimension id to relate to a universe. Must be set on insert, ignored on update.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_sign IS 'The sign of the dimension axis to relate to a universe. Only 0, 1 and -1 allowed. Must be set on insert, ignored on update.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_sign IS 'The sign of the dimension axis to relate to a universe. Only 0, 1 and -1 allowed. Must be set on insert, ignored on update.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_rel_mlv_dim.usim_sign IS 'The sign of the dimension axis to relate to a universe. Only 0, 1 and -1 allowed. Must be set on insert, ignored on update.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_n1_sign IS 'The sign of the ancestor dimension axis at n = 1. NULL, 1 and -1 allowed. Must be set on insert, ignored on update.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_rel_mlv_dim.usim_n1_sign IS 'The sign of the ancestor dimension axis at n = 1. NULL, 1 and -1 allowed. Must be set on insert, ignored on update.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_rel_mlv_dim.usim_n1_sign IS 'The sign of the ancestor dimension axis at n = 1. NULL, 1 and -1 allowed. Must be set on insert, ignored on update.'

Comment created.

SQL> 
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  2    ADD CONSTRAINT usim_rmd_pk
  3    PRIMARY KEY (usim_id_rmd)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
new   1: ALTER TABLE USIM_TEST.usim_rel_mlv_dim

Table altered.

SQL> 
SQL> -- uk universe/dim/sign/n1 sign is unique
SQL> ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  2    ADD CONSTRAINT usim_rmd_uk
  3    UNIQUE (usim_id_mlv, usim_id_dim, usim_sign, usim_n1_sign)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
new   1: ALTER TABLE USIM_TEST.usim_rel_mlv_dim

Table altered.

SQL> 
SQL> -- uk universe/dim/sign is unique
SQL> ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  2    ADD CONSTRAINT usim_rmd_chk_sign
  3    CHECK (usim_sign IN (0, 1, -1))
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
new   1: ALTER TABLE USIM_TEST.usim_rel_mlv_dim

Table altered.

SQL> 
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rmd_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_rel_mlv_dim
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   -- ignore input on pk
  6  	   :NEW.usim_id_rmd := usim_static.get_big_pk(usim_rmd_id_seq.NEXTVAL);
  7  	   -- check sign
  8  	   IF usim_dim.get_dimension(:NEW.usim_id_dim) = 0
  9  	   THEN
 10  	     IF :NEW.usim_sign != 0
 11  	     THEN
 12  	       RAISE_APPLICATION_ERROR( num => -20000
 13  				     , msg => 'Insert requirement not fulfilled. USIM_SIGN must be 0 for dimension 0.'
 14  				     )
 15  	       ;
 16  	     END IF;
 17  	   ELSE
 18  	     IF     usim_dim.get_dimension(:NEW.usim_id_dim) > 1
 19  		AND :NEW.usim_n1_sign NOT IN (1, -1)
 20  	     THEN
 21  	       RAISE_APPLICATION_ERROR( num => -20000
 22  				     , msg => 'Insert requirement not fulfilled. USIM_N1_SIGN must be 1 or -1 for dimension > 1.'
 23  				     )
 24  	       ;
 25  	     END IF;
 26  	     IF :NEW.usim_sign NOT IN (1, -1)
 27  	     THEN
 28  	       RAISE_APPLICATION_ERROR( num => -20000
 29  				     , msg => 'Insert requirement not fulfilled. USIM_SIGN must be +1 or -1 for dimension > 0.'
 30  				     )
 31  	       ;
 32  	     END IF;
 33  	   END IF;
 34  	 END;
 35  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rmd_ins_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_rmd_ins_trg
old   2:   BEFORE INSERT ON &USIM_SCHEMA..usim_rel_mlv_dim
new   2:   BEFORE INSERT ON USIM_TEST.usim_rel_mlv_dim

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_rmd_ins_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_rmd_ins_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_rmd_ins_trg ENABLE

Trigger altered.

SQL> 
SQL> -- update trigger to prevent updates
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rmd_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_rel_mlv_dim
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   RAISE_APPLICATION_ERROR( num => -20001
  6  				  , msg => 'Update requirement not fulfilled. No update allowed.'
  7  				  )
  8  	   ;
  9  	 END;
 10  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rmd_upd_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_rmd_upd_trg
old   2:   BEFORE UPDATE ON &USIM_SCHEMA..usim_rel_mlv_dim
new   2:   BEFORE UPDATE ON USIM_TEST.usim_rel_mlv_dim

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_rmd_upd_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_rmd_upd_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_rmd_upd_trg ENABLE

Trigger altered.

SQL> -- foreign keys
SQL> @@../FK/USIM_RMD_MLV_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk relation universe/dimension for universe (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  2    ADD CONSTRAINT usim_rmd_mlv_fk
  3    FOREIGN KEY (usim_id_mlv) REFERENCES usim_multiverse (usim_id_mlv) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
new   1: ALTER TABLE USIM_TEST.usim_rel_mlv_dim

Table altered.

SQL> @@../FK/USIM_RMD_DIM_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk relation universe/dimension for dimensions (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
  2    ADD CONSTRAINT usim_rmd_dim_fk
  3    FOREIGN KEY (usim_id_dim) REFERENCES usim_dimension (usim_id_dim) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_rel_mlv_dim
new   1: ALTER TABLE USIM_TEST.usim_rel_mlv_dim

Table altered.

SQL> -- views
SQL> @@../VIEW/USIM_RMD_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_RMD_V (rmdv)
SQL> -- minimal joining to get universe basics and dimension for the relation table usim_rel_mlv_dim
SQL> CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_rmd_v AS
  2    SELECT rmd.usim_id_rmd
  3  	    , rmd.usim_id_mlv
  4  	    , rmd.usim_id_dim
  5  	    , rmd.usim_sign
  6  	    , rmd.usim_n1_sign
  7  	    , dim.usim_n_dimension
  8  	    , mlv.usim_universe_status
  9  	    , mlv.usim_is_base_universe
 10  	    , CASE
 11  		WHEN dim.usim_n_dimension = 0
 12  		THEN mlv.usim_energy_start_value
 13  		ELSE NULL
 14  	      END AS usim_energy_start_value
 15  	    , mlv.usim_ultimate_border
 16  	 FROM usim_rel_mlv_dim rmd
 17  	INNER JOIN usim_dimension dim
 18  	   ON rmd.usim_id_dim = dim.usim_id_dim
 19  	INNER JOIN usim_multiverse mlv
 20  	   ON rmd.usim_id_mlv = mlv.usim_id_mlv
 21  ;
old   1: CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_rmd_v AS
new   1: CREATE OR REPLACE FORCE VIEW USIM_TEST.usim_rmd_v AS

View created.

SQL> -- usim_rel_mlv_dim package
SQL> @@../PACKAGES/USIM_RMD.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_rmd
  2  IS
  3    /**A low level package for actions on table usim_rel_mlv_dim and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9  
 10    /**
 11    * Checks if usim_rel_mlv_dim has already data.
 12    * @return Returns 1 if data are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15  	 RETURN NUMBER
 16    ;
 17  
 18    /**
 19    * Checks if usim_rel_mlv_dim has already data for a given relation id.
 20    * @param p_usim_id_rmd The relation id of universe/dimension.
 21    * @return Returns 1 if data are available, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 24  	 RETURN NUMBER
 25    ;
 26  
 27    /**
 28    * Checks if usim_rel_mlv_dim has already data for a dimension axis and universe.
 29    * @param p_usim_id_mlv The universe id of the relation.
 30    * @param p_usim_id_dim The dimension id of the relation.
 31    * @param p_usim_sign The sign of the dimension axis.
 32    * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
 33    * @return Returns 1 if data are available, otherwise 0.
 34    */
 35    FUNCTION has_data( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
 36  			, p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
 37  			, p_usim_sign	 IN usim_rel_mlv_dim.usim_sign%TYPE
 38  			, p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
 39  			)
 40  	 RETURN NUMBER
 41    ;
 42  
 43    /**
 44    * Checks if usim_rel_mlv_dim has already data for a dimension axis and universe.
 45    * @param p_usim_id_mlv The universe id of the relation.
 46    * @param p_usim_n_dimension The dimension of the relation.
 47    * @param p_usim_sign The sign of the dimension axis.
 48    * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
 49    * @return Returns 1 if data are available, otherwise 0.
 50    */
 51    FUNCTION has_data( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
 52  			, p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 53  			, p_usim_sign	     IN usim_rel_mlv_dim.usim_sign%TYPE
 54  			, p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
 55  			)
 56  	 RETURN NUMBER
 57    ;
 58  
 59    /**
 60    * Retrieves the maximum dimension for a given universe.
 61    * @return Returns usim_n_dimension or -1 if no dimension for this universe exist.
 62    */
 63    FUNCTION get_max_dimension(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 64  	 RETURN usim_dimension.usim_n_dimension%TYPE
 65    ;
 66  
 67    /**
 68    * Retrieve the dimension for a given universe/dimension relation.
 69    * @param p_usim_id_rmd The universe/dimension id.
 70    * @return The related dimension for the given id or NULL if id does not exist.
 71    */
 72    FUNCTION get_dimension(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 73  	 RETURN usim_dimension.usim_n_dimension%TYPE
 74    ;
 75  
 76    /**
 77    * Retrieve the dimension sign for a given universe/dimension relation.
 78    * @param p_usim_id_rmd The universe/dimension id.
 79    * @return The related dimension sign for the given id or NULL if id does not exist.
 80    */
 81    FUNCTION get_dim_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 82  	 RETURN usim_rel_mlv_dim.usim_sign%TYPE
 83    ;
 84  
 85    /**
 86    * Retrieve the dimension sign of the n=1 ancestor for a given universe/dimension relation.
 87    * @param p_usim_id_rmd The universe/dimension id.
 88    * @return The related dimension sign of the n=1 ancestor for the given id or 0 if id does not exist (NULL is a valid return value).
 89    */
 90    FUNCTION get_dim_n1_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 91  	 RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
 92    ;
 93  
 94    /**
 95    * Retrieve the universe id for a given universe/dimension relation.
 96    * @param p_usim_id_rmd The universe/dimension id.
 97    * @return The related universe id for the given id or NULL if id does not exist.
 98    */
 99    FUNCTION get_id_mlv(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
100  	 RETURN usim_multiverse.usim_id_mlv%TYPE
101    ;
102  
103    /**
104    * Retrieve the dimension id for a given universe/dimension relation.
105    * @param p_usim_id_rmd The universe/dimension id.
106    * @return The related dimension id for the given id or NULL if id does not exist.
107    */
108    FUNCTION get_id_dim(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
109  	 RETURN usim_dimension.usim_id_dim%TYPE
110    ;
111  
112    /**
113    * Retrieve details a given universe/dimension relation without the universe id.
114    * @param p_usim_id_rmd The universe/dimension id.
115    * @param p_usim_id_dim Return the related dimension id.
116    * @param p_usim_sign Return the related dimension sign.
117    * @param p_usim_n1_sign Return the related n=1 dimension ancestor sign.
118    * @return Return 1 if data could be fetched otherwise 0.
119    */
120    FUNCTION get_rmd_details( p_usim_id_rmd	IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
121  			       , p_usim_id_dim	OUT usim_dimension.usim_id_dim%TYPE
122  			       , p_usim_sign	OUT usim_rel_mlv_dim.usim_sign%TYPE
123  			       , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
124  			       )
125  	 RETURN NUMBER
126    ;
127  
128    /**
129    * Retrieve details a given universe/dimension relation without the universe id.
130    * @param p_usim_id_rmd The universe/dimension id.
131    * @param p_usim_n_dimension Return the related dimension.
132    * @param p_usim_sign Return the related dimension sign.
133    * @param p_usim_n1_sign Return the related n=1 dimension ancestor sign.
134    * @return Return 1 if data could be fetched otherwise 0.
135    */
136    FUNCTION get_rmd_details( p_usim_id_rmd	     IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
137  			       , p_usim_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
138  			       , p_usim_sign	     OUT usim_rel_mlv_dim.usim_sign%TYPE
139  			       , p_usim_n1_sign      OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
140  			       )
141  	 RETURN NUMBER
142    ;
143  
144    /**
145    * Retrieve details a given universe/dimension relation.
146    * @param p_usim_id_rmd The universe/dimension id.
147    * @param p_usim_id_mlv Return the related universe id.
148    * @param p_usim_id_dim Return the related dimension id.
149    * @param p_usim_sign Return the related dimension sign.
150    * @param p_usim_n1_sign Return the related n=1 dimension ancestor sign.
151    * @return The related dimension id for the given id or NULL if id does not exist.
152    */
153    FUNCTION get_rmd_details( p_usim_id_rmd	IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
154  			       , p_usim_id_mlv	OUT usim_multiverse.usim_id_mlv%TYPE
155  			       , p_usim_id_dim	OUT usim_dimension.usim_id_dim%TYPE
156  			       , p_usim_sign	OUT usim_rel_mlv_dim.usim_sign%TYPE
157  			       , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
158  			       )
159  	 RETURN NUMBER
160    ;
161  
162    /**
163    * Retrieve the rule for ulimate or any border of the associated dimension.
164    * @param p_usim_id_rmd The universe/dimension id.
165    * @return Returns 1, rule for ultimate border or 0, rule for any border if given universe exists, otherwise -1.
166    */
167    FUNCTION get_ultimate_border(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
168  	 RETURN usim_multiverse.usim_ultimate_border%TYPE
169    ;
170  
171    /**
172    * Gets the relation id for a universe and dimension id.
173    * @param p_usim_id_mlv The universe id of the relation.
174    * @param p_usim_id_dim The dimension id of the relation.
175    * @param p_usim_sign The sign of the dimension axis.
176    * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
177    * @return Returns usim_id_rmd for given parameters or NULL if relation does not exists.
178    */
179    FUNCTION get_id_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
180  			  , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
181  			  , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE	DEFAULT 1
182  			  , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
183  			  )
184  	 RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
185    ;
186  
187    /**
188    * Gets the relation id for a universe id and a dimension.
189    * @param p_usim_id_mlv The universe id of the relation.
190    * @param p_usim_n_dimension The dimension of the relation.
191    * @param p_usim_sign The sign of the dimension axis.
192    * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
193    * @return Returns usim_id_rmd for given parameters or NULL if relation does not exists.
194    */
195    FUNCTION get_id_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
196  			  , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
197  			  , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE      DEFAULT 1
198  			  , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
199  			  )
200  	 RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
201    ;
202  
203    /**
204    * Inserts a new relation for a universe and dimension id describing one side of the dimension axis if n > 0.
205    * @param p_usim_id_mlv The universe id of the relation.
206    * @param p_usim_id_dim The dimension id of the relation.
207    * @param p_usim_sign The sign of the dimension axis.
208    * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
209    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
210    * @return Returns the new/existing usim_id_rmd or NULL if universe/dimension does not exists / overflow reached.
211    */
212    FUNCTION insert_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
213  			  , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
214  			  , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
215  			  , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
216  			  , p_do_commit    IN BOOLEAN				DEFAULT TRUE
217  			  )
218  	 RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
219    ;
220  
221    /**
222    * Inserts a new relation for a universe id and a dimension describing one side of the dimension axis if n > 0.
223    * @param p_usim_id_mlv The universe id of the relation.
224    * @param p_usim_n_dimension The dimension of the relation.
225    * @param p_usim_sign The sign of the dimension axis.
226    * @param p_usim_n1_sign The sign (1, -1) of the ancestor dimension axis at n = 1, if n > 0 otherwise NULL.
227    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
228    * @return Returns the new/existing usim_id_rmd or NULL if universe/dimension does not exists / overflow reached.
229    */
230    FUNCTION insert_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
231  			  , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
232  			  , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
233  			  , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
234  			  , p_do_commit        IN BOOLEAN			       DEFAULT TRUE
235  			  )
236  	 RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
237    ;
238  
239  END usim_rmd;
240  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_rmd
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_rmd

Package created.

SQL> @@../PACKAGES/USIM_RMD.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_rmd
  2  IS
  3    -- see header for documentation
  4  
  5    FUNCTION has_data
  6  	 RETURN NUMBER
  7    IS
  8  	 l_result NUMBER;
  9    BEGIN
 10  	 SELECT COUNT(*) INTO l_result FROM usim_rel_mlv_dim;
 11  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 12    END has_data
 13    ;
 14  
 15    FUNCTION has_data(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 16  	 RETURN NUMBER
 17    IS
 18  	 l_result NUMBER;
 19    BEGIN
 20  	 -- we expect one axis or nothing
 21  	 SELECT COUNT(*) INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
 22  	 RETURN l_result;
 23    END has_data
 24    ;
 25  
 26    FUNCTION has_data( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
 27  			, p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
 28  			, p_usim_sign	 IN usim_rel_mlv_dim.usim_sign%TYPE
 29  			, p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
 30  			)
 31  	 RETURN NUMBER
 32    IS
 33  	 l_result NUMBER;
 34    BEGIN
 35  	 -- we expect one axis or nothing
 36  	 SELECT COUNT(*)
 37  	   INTO l_result
 38  	   FROM usim_rel_mlv_dim
 39  	  WHERE usim_id_mlv	     = p_usim_id_mlv
 40  	    AND usim_id_dim	     = p_usim_id_dim
 41  	    AND usim_sign	     = p_usim_sign
 42  		-- deal with 0 dimension
 43  	    AND NVL(usim_n1_sign, 0) = NVL(p_usim_n1_sign, 0)
 44  	 ;
 45  	 RETURN l_result;
 46    END has_data
 47    ;
 48  
 49    FUNCTION has_data( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
 50  			, p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 51  			, p_usim_sign	     IN usim_rel_mlv_dim.usim_sign%TYPE
 52  			, p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
 53  			)
 54  	 RETURN NUMBER
 55    IS
 56  	 l_result NUMBER;
 57    BEGIN
 58  	 -- we expect one axis or nothing
 59  	 SELECT COUNT(*)
 60  	   INTO l_result
 61  	   FROM usim_rmd_v
 62  	  WHERE usim_id_mlv	     = p_usim_id_mlv
 63  	    AND usim_n_dimension     = p_usim_n_dimension
 64  	    AND usim_sign	     = p_usim_sign
 65  		-- deal with 0 dimension
 66  	    AND NVL(usim_n1_sign, 0) = NVL(p_usim_n1_sign, 0)
 67  	 ;
 68  	 RETURN l_result;
 69    END has_data
 70    ;
 71  
 72    FUNCTION get_max_dimension(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
 73  	 RETURN usim_dimension.usim_n_dimension%TYPE
 74    IS
 75  	 l_result usim_dimension.usim_n_dimension%TYPE;
 76    BEGIN
 77  	   SELECT MAX(usim_n_dimension) INTO l_result FROM usim_rmd_v WHERE usim_id_mlv = p_usim_id_mlv;
 78  	   RETURN NVL(l_result, -1);
 79    END get_max_dimension
 80    ;
 81  
 82    FUNCTION get_dimension(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 83  	 RETURN usim_dimension.usim_n_dimension%TYPE
 84    IS
 85  	 l_result usim_dimension.usim_n_dimension%TYPE;
 86    BEGIN
 87  	 IF usim_rmd.has_data(p_usim_id_rmd) = 1
 88  	 THEN
 89  	   SELECT usim_n_dimension INTO l_result FROM usim_rmd_v WHERE usim_id_rmd = p_usim_id_rmd;
 90  	   RETURN l_result;
 91  	 ELSE
 92  	   usim_erl.log_error('usim_rmd.get_dimension', 'Used with not existing id [' || p_usim_id_rmd || '].');
 93  	   RETURN NULL;
 94  	 END IF;
 95    END get_dimension
 96    ;
 97  
 98    FUNCTION get_dim_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
 99  	 RETURN usim_rel_mlv_dim.usim_sign%TYPE
100    IS
101  	 l_result usim_rel_mlv_dim.usim_sign%TYPE;
102    BEGIN
103  	 IF usim_rmd.has_data(p_usim_id_rmd) = 1
104  	 THEN
105  	   SELECT usim_sign INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
106  	   RETURN l_result;
107  	 ELSE
108  	   usim_erl.log_error('usim_rmd.get_dim_sign', 'Used with not existing id [' || p_usim_id_rmd || '].');
109  	   RETURN NULL;
110  	 END IF;
111    END get_dim_sign
112    ;
113  
114    FUNCTION get_dim_n1_sign(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
115  	 RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
116    IS
117  	 l_result usim_rel_mlv_dim.usim_n1_sign%TYPE;
118    BEGIN
119  	 IF usim_rmd.has_data(p_usim_id_rmd) = 1
120  	 THEN
121  	   SELECT usim_n1_sign INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
122  	   RETURN l_result;
123  	 ELSE
124  	   usim_erl.log_error('usim_rmd.get_dim_n1_sign', 'Used with not existing id [' || p_usim_id_rmd || '].');
125  	   RETURN NULL;
126  	 END IF;
127    END get_dim_n1_sign
128    ;
129  
130    FUNCTION get_id_mlv(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
131  	 RETURN usim_multiverse.usim_id_mlv%TYPE
132    IS
133  	 l_result usim_multiverse.usim_id_mlv%TYPE;
134    BEGIN
135  	 IF usim_rmd.has_data(p_usim_id_rmd) = 1
136  	 THEN
137  	   SELECT usim_id_mlv INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
138  	   RETURN l_result;
139  	 ELSE
140  	   usim_erl.log_error('usim_rmd.get_id_mlv', 'Used with not existing id [' || p_usim_id_rmd || '].');
141  	   RETURN NULL;
142  	 END IF;
143    END get_id_mlv
144    ;
145  
146    FUNCTION get_id_dim(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
147  	 RETURN usim_dimension.usim_id_dim%TYPE
148    IS
149  	 l_result usim_dimension.usim_id_dim%TYPE;
150    BEGIN
151  	 IF usim_rmd.has_data(p_usim_id_rmd) = 1
152  	 THEN
153  	   SELECT usim_id_dim INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
154  	   RETURN l_result;
155  	 ELSE
156  	   usim_erl.log_error('usim_rmd.get_id_dim', 'Used with not existing id [' || p_usim_id_rmd || '].');
157  	   RETURN NULL;
158  	 END IF;
159    END get_id_dim
160    ;
161  
162    FUNCTION get_rmd_details( p_usim_id_rmd	IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
163  			       , p_usim_id_dim	OUT usim_dimension.usim_id_dim%TYPE
164  			       , p_usim_sign	OUT usim_rel_mlv_dim.usim_sign%TYPE
165  			       , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
166  			       )
167  	 RETURN NUMBER
168    IS
169    BEGIN
170  	 IF usim_rmd.has_data(p_usim_id_rmd) = 1
171  	 THEN
172  	   SELECT usim_id_dim
173  		, usim_sign
174  		, usim_n1_sign
175  	     INTO p_usim_id_dim
176  		, p_usim_sign
177  		, p_usim_n1_sign
178  	     FROM usim_rel_mlv_dim
179  	    WHERE usim_id_rmd = p_usim_id_rmd
180  	   ;
181  	   RETURN 1;
182  	 ELSE
183  	   usim_erl.log_error('usim_rmd.get_rmd_details', 'Used with not existing id [' || p_usim_id_rmd || '].');
184  	   RETURN 0;
185  	 END IF;
186    END get_rmd_details
187    ;
188  
189    FUNCTION get_rmd_details( p_usim_id_rmd	     IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
190  			       , p_usim_n_dimension  OUT usim_dimension.usim_n_dimension%TYPE
191  			       , p_usim_sign	     OUT usim_rel_mlv_dim.usim_sign%TYPE
192  			       , p_usim_n1_sign      OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
193  			       )
194  	 RETURN NUMBER
195    IS
196    BEGIN
197  	 IF usim_rmd.has_data(p_usim_id_rmd) = 1
198  	 THEN
199  	   SELECT usim_n_dimension
200  		, usim_sign
201  		, usim_n1_sign
202  	     INTO p_usim_n_dimension
203  		, p_usim_sign
204  		, p_usim_n1_sign
205  	     FROM usim_rmd_v
206  	    WHERE usim_id_rmd = p_usim_id_rmd
207  	   ;
208  	   RETURN 1;
209  	 ELSE
210  	   usim_erl.log_error('usim_rmd.get_rmd_details', 'Used with not existing id [' || p_usim_id_rmd || '].');
211  	   RETURN 0;
212  	 END IF;
213    END get_rmd_details
214    ;
215  
216    FUNCTION get_rmd_details( p_usim_id_rmd	IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
217  			       , p_usim_id_mlv	OUT usim_multiverse.usim_id_mlv%TYPE
218  			       , p_usim_id_dim	OUT usim_dimension.usim_id_dim%TYPE
219  			       , p_usim_sign	OUT usim_rel_mlv_dim.usim_sign%TYPE
220  			       , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
221  			       )
222  	 RETURN NUMBER
223    IS
224    BEGIN
225  	 IF usim_rmd.has_data(p_usim_id_rmd) = 1
226  	 THEN
227  	   SELECT usim_id_mlv
228  		, usim_id_dim
229  		, usim_sign
230  		, usim_n1_sign
231  	     INTO p_usim_id_mlv
232  		, p_usim_id_dim
233  		, p_usim_sign
234  		, p_usim_n1_sign
235  	     FROM usim_rel_mlv_dim
236  	    WHERE usim_id_rmd = p_usim_id_rmd
237  	   ;
238  	   RETURN 1;
239  	 ELSE
240  	   usim_erl.log_error('usim_rmd.get_rmd_details', 'Used with not existing id [' || p_usim_id_rmd || '].');
241  	   RETURN 0;
242  	 END IF;
243    END get_rmd_details
244    ;
245  
246    FUNCTION get_ultimate_border(p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE)
247  	 RETURN usim_multiverse.usim_ultimate_border%TYPE
248    IS
249  	 l_result usim_multiverse.usim_id_mlv%TYPE;
250    BEGIN
251  	 IF usim_rmd.has_data(p_usim_id_rmd) = 1
252  	 THEN
253  	   SELECT usim_id_mlv INTO l_result FROM usim_rel_mlv_dim WHERE usim_id_rmd = p_usim_id_rmd;
254  	   RETURN usim_mlv.get_ultimate_border(l_result);
255  	 ELSE
256  	   usim_erl.log_error('usim_rmd.get_ultimate_border', 'Used with not existing id [' || p_usim_id_rmd || '].');
257  	   RETURN -1;
258  	 END IF;
259    END get_ultimate_border
260    ;
261  
262    FUNCTION get_id_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
263  			  , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
264  			  , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE	DEFAULT 1
265  			  , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
266  			  )
267  	 RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
268    IS
269  	 l_result usim_rel_mlv_dim.usim_id_rmd%TYPE;
270    BEGIN
271  	 IF usim_rmd.has_data(p_usim_id_mlv, p_usim_id_dim, p_usim_sign, p_usim_n1_sign) = 1
272  	 THEN
273  	   SELECT usim_id_rmd
274  	     INTO l_result
275  	     FROM usim_rel_mlv_dim
276  	    WHERE usim_id_mlv	       = p_usim_id_mlv
277  	      AND usim_id_dim	       = p_usim_id_dim
278  	      AND usim_sign	       = p_usim_sign
279  		  -- deal with 0 dimension
280  	      AND NVL(usim_n1_sign, 0) = NVL(p_usim_n1_sign, 0)
281  	   ;
282  	   RETURN l_result;
283  	 ELSE
284  	   usim_erl.log_error('usim_rmd.get_id_rmd', 'Used with not existing universe id [' || p_usim_id_mlv || '] and dimension id [' || p_usim_id_dim || '].');
285  	   RETURN NULL;
286  	 END IF;
287    END get_id_rmd
288    ;
289  
290    FUNCTION get_id_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
291  			  , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
292  			  , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE      DEFAULT 1
293  			  , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
294  			  )
295  	 RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
296    IS
297  	 l_result usim_rel_mlv_dim.usim_id_rmd%TYPE;
298  	 l_id_dim usim_dimension.usim_id_dim%TYPE;
299    BEGIN
300  	 IF usim_dim.has_data(p_usim_n_dimension) = 1
301  	 THEN
302  	   l_id_dim := usim_dim.get_id_dim(p_usim_n_dimension);
303  	   RETURN usim_rmd.get_id_rmd(p_usim_id_mlv, l_id_dim, p_usim_sign, p_usim_n1_sign);
304  	 ELSE
305  	   usim_erl.log_error('usim_rmd.get_id_rmd', 'Used with not existing dimension [' || p_usim_n_dimension || '].');
306  	   RETURN NULL;
307  	 END IF;
308    END get_id_rmd
309    ;
310  
311    FUNCTION insert_rmd( p_usim_id_mlv  IN usim_multiverse.usim_id_mlv%TYPE
312  			  , p_usim_id_dim  IN usim_dimension.usim_id_dim%TYPE
313  			  , p_usim_sign    IN usim_rel_mlv_dim.usim_sign%TYPE
314  			  , p_usim_n1_sign IN usim_rel_mlv_dim.usim_n1_sign%TYPE
315  			  , p_do_commit    IN BOOLEAN				DEFAULT TRUE
316  			  )
317  	 RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
318    IS
319  	 l_result  usim_rel_mlv_dim.usim_id_rmd%TYPE;
320  	 l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
321    BEGIN
322  	 IF	usim_dim.get_dimension(p_usim_id_dim) = 0
323  	    AND p_usim_sign			     != 0
324  	 THEN
325  	   usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension id [' || p_usim_id_dim || '] for sign [' || p_usim_sign || '].');
326  	   RETURN NULL;
327  	 END IF;
328  	 IF (	 usim_dim.get_dimension(p_usim_id_dim) > 0
329  	     AND p_usim_n1_sign 		  NOT IN (1, -1)
330  	    ) OR
331  	    (	 usim_dim.get_dimension(p_usim_id_dim) = 0
332  	     AND p_usim_n1_sign 		       IS NOT NULL
333  	    )
334  	 THEN
335  	   usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension id [' || p_usim_id_dim || '] for ancestor sign n = 1 [' || p_usim_n1_sign || '].');
336  	   RETURN NULL;
337  	 END IF;
338  	 IF usim_dim.get_dimension(p_usim_id_dim) = 1
339  	 THEN
340  	   l_n1_sign := p_usim_sign;
341  	 ELSE
342  	   l_n1_sign := p_usim_n1_sign;
343  	 END IF;
344  	 IF usim_rmd.has_data(p_usim_id_mlv, p_usim_id_dim, p_usim_sign, l_n1_sign) = 1
345  	 THEN
346  	   RETURN usim_rmd.get_id_rmd(p_usim_id_mlv, p_usim_id_dim, p_usim_sign, l_n1_sign);
347  	 ELSE
348  	   IF	  usim_mlv.has_data(p_usim_id_mlv)	   = 1
349  	      AND usim_dim.has_data(p_usim_id_dim)	   = 1
350  	      AND p_usim_sign				  IN (0, 1, -1)
351  	   THEN
352  	     INSERT INTO usim_rel_mlv_dim
353  	       ( usim_id_mlv
354  	       , usim_id_dim
355  	       , usim_sign
356  	       , usim_n1_sign
357  	       )
358  	       VALUES
359  	       ( p_usim_id_mlv
360  	       , p_usim_id_dim
361  	       , p_usim_sign
362  	       , l_n1_sign
363  	       )
364  	       RETURNING usim_id_rmd INTO l_result
365  	     ;
366  	     IF p_do_commit
367  	     THEN
368  	       COMMIT;
369  	     END IF;
370  	     RETURN l_result;
371  	   ELSE
372  	     usim_erl.log_error('usim_rmd.insert_rmd', 'Used with not existing universe id [' || p_usim_id_mlv || '],  dimension id [' || p_usim_id_dim || '] or sign [' || p_usim_sign || '].');
373  	     RETURN NULL;
374  	   END IF;
375  	 END IF;
376    END insert_rmd
377    ;
378  
379    FUNCTION insert_rmd( p_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
380  			  , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
381  			  , p_usim_sign        IN usim_rel_mlv_dim.usim_sign%TYPE
382  			  , p_usim_n1_sign     IN usim_rel_mlv_dim.usim_n1_sign%TYPE
383  			  , p_do_commit        IN BOOLEAN			       DEFAULT TRUE
384  			  )
385  	 RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
386    IS
387  	 l_result      usim_rel_mlv_dim.usim_id_rmd%TYPE;
388  	 l_usim_id_dim usim_dimension.usim_id_dim%TYPE;
389    BEGIN
390  	 IF	p_usim_n_dimension = 0
391  	    AND p_usim_sign	  != 0
392  	 THEN
393  	   usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension [' || p_usim_n_dimension || '] for sign [' || p_usim_sign || '].');
394  	   RETURN NULL;
395  	 END IF;
396  	 IF (	 p_usim_n_dimension > 0
397  	     AND p_usim_n1_sign NOT IN (1, -1)
398  	    ) OR
399  	    (	 p_usim_n_dimension = 0
400  	     AND p_usim_n1_sign IS NOT NULL
401  	    )
402  	 THEN
403  	   usim_erl.log_error('usim_rmd.insert_rmd', 'Used with wrong dimension [' || p_usim_n_dimension || '] for ancestor sign n = 1 [' || p_usim_n1_sign || '].');
404  	   RETURN NULL;
405  	 END IF;
406  	 IF usim_rmd.has_data(p_usim_id_mlv, p_usim_n_dimension, p_usim_sign, p_usim_n1_sign) = 1
407  	 THEN
408  	   RETURN usim_rmd.get_id_rmd(p_usim_id_mlv, p_usim_n_dimension, p_usim_sign, p_usim_n1_sign);
409  	 ELSE
410  	   IF	  usim_mlv.has_data(p_usim_id_mlv)		= 1
411  	      AND usim_dim.has_data(p_usim_n_dimension) 	= 1
412  	      AND p_usim_sign				       IN (0, 1, -1)
413  	   THEN
414  	     l_usim_id_dim := usim_dim.get_id_dim(p_usim_n_dimension);
415  	     RETURN usim_rmd.insert_rmd(p_usim_id_mlv, l_usim_id_dim, p_usim_sign, p_usim_n1_sign, p_do_commit);
416  	   ELSE
417  	     usim_erl.log_error('usim_rmd.insert_rmd', 'Used with not existing universe id [' || p_usim_id_mlv || '], dimension [' || p_usim_n_dimension || '] or sign [' || p_usim_sign || '].');
418  	     RETURN NULL;
419  	   END IF;
420  	 END IF;
421    END insert_rmd
422    ;
423  
424  END usim_rmd;
425  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_rmd
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_rmd

Package body created.

SQL> -- USIM_RMD_CHILD (rchi)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_RMD_CHILD_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_RMD_CHILD still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_RMD_CHILD'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../TABLES/USIM_RMD_CHILD_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_RMD_CHILD (rchi)
SQL> CREATE TABLE &USIM_SCHEMA..usim_rmd_child
  2    ( usim_id_rmd	    CHAR(55) NOT NULL ENABLE
  3    , usim_id_rmd_child  CHAR(55) NOT NULL ENABLE
  4    )
  5  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_rmd_child
new   1: CREATE TABLE USIM_TEST.usim_rmd_child

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_rmd_child IS 'Describes the parent-child relation between dimension axis. Will use the alias rchi.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_rmd_child IS 'Describes the parent-child relation between dimension axis. Will use the alias rchi.'
new   1: COMMENT ON TABLE USIM_TEST.usim_rmd_child IS 'Describes the parent-child relation between dimension axis. Will use the alias rchi.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rmd_child.usim_id_rmd IS 'The parent id from usim_rel_mlv_dim.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_rmd_child.usim_id_rmd IS 'The parent id from usim_rel_mlv_dim.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_rmd_child.usim_id_rmd IS 'The parent id from usim_rel_mlv_dim.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_rmd_child.usim_id_rmd_child IS 'The child id from usim_rel_mlv_dim. Only two childs possible';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_rmd_child.usim_id_rmd_child IS 'The child id from usim_rel_mlv_dim. Only two childs possible'
new   1: COMMENT ON COLUMN USIM_TEST.usim_rmd_child.usim_id_rmd_child IS 'The child id from usim_rel_mlv_dim. Only two childs possible'

Comment created.

SQL> 
SQL> -- uk
SQL> ALTER TABLE &USIM_SCHEMA..usim_rmd_child
  2    ADD CONSTRAINT usim_rchi_uk
  3    UNIQUE (usim_id_rmd, usim_id_rmd_child)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_rmd_child
new   1: ALTER TABLE USIM_TEST.usim_rmd_child

Table altered.

SQL> 
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rchi_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_rmd_child
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   IF :NEW.usim_id_rmd = :NEW.usim_id_rmd_child
  6  	   THEN
  7  	     RAISE_APPLICATION_ERROR( num => -20000
  8  				    , msg => 'Insert requirement not fulfilled. Parent and child cannot be equal.'
  9  				    )
 10  	     ;
 11  	   END IF;
 12  	 END;
 13  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rchi_ins_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_rchi_ins_trg
old   2:   BEFORE INSERT ON &USIM_SCHEMA..usim_rmd_child
new   2:   BEFORE INSERT ON USIM_TEST.usim_rmd_child

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_rchi_ins_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_rchi_ins_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_rchi_ins_trg ENABLE

Trigger altered.

SQL> 
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rchi_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_rmd_child
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   RAISE_APPLICATION_ERROR( num => -20001
  6  				  , msg => 'Update requirement not fulfilled. No update allowed.'
  7  				  )
  8  	   ;
  9  	 END;
 10  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_rchi_upd_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_rchi_upd_trg
old   2:   BEFORE UPDATE ON &USIM_SCHEMA..usim_rmd_child
new   2:   BEFORE UPDATE ON USIM_TEST.usim_rmd_child

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_rchi_upd_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_rchi_upd_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_rchi_upd_trg ENABLE

Trigger altered.

SQL> -- foreign keys
SQL> @@../FK/USIM_RCHI_PARENT_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk parent-child relation between dimension axis in usim_rel_mlv_dim (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_rmd_child
  2    ADD CONSTRAINT usim_rchi_parent_fk
  3    FOREIGN KEY (usim_id_rmd) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_rmd_child
new   1: ALTER TABLE USIM_TEST.usim_rmd_child

Table altered.

SQL> @@../FK/USIM_RCHI_CHILD_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk parent-child relation between dimensions in usim_rel_mlv_dim (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_rmd_child
  2    ADD CONSTRAINT usim_rchi_child_fk
  3    FOREIGN KEY (usim_id_rmd_child) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_rmd_child
new   1: ALTER TABLE USIM_TEST.usim_rmd_child

Table altered.

SQL> -- USIM_SPACE (spc)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_SPACE_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPACE still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPACE'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------
../TABLES/USIM_SPACE_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_SPACE (spc)
SQL> CREATE TABLE &USIM_SCHEMA..usim_space
  2    ( usim_id_spc	   CHAR(55)    NOT NULL ENABLE
  3    , usim_id_rmd	   CHAR(55)    NOT NULL ENABLE
  4    , usim_id_pos	   CHAR(55)    NOT NULL ENABLE
  5    , usim_id_nod	   CHAR(55)    NOT NULL ENABLE
  6    , usim_process_spin NUMBER(1,0) NOT NULL ENABLE
  7    )
  8  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_space
new   1: CREATE TABLE USIM_TEST.usim_space

Table created.

SQL> COMMENT ON TABLE usim_space IS 'A table describing the space of the universes by universe, dimension, position, node and volume. Will use the alias spc.';

Comment created.

SQL> COMMENT ON COLUMN usim_space.usim_id_spc IS 'The id for a node in space. Automatically set, update not allowed.';

Comment created.

SQL> COMMENT ON COLUMN usim_space.usim_id_rmd IS 'The id for the universe / dimension relation. Must exist and be set on insert, update not allowed.';

Comment created.

SQL> COMMENT ON COLUMN usim_space.usim_id_pos IS 'The id for the position relation. Must exist and be set on insert, update not allowed.';

Comment created.

SQL> COMMENT ON COLUMN usim_space.usim_id_nod IS 'The id for the node relation. Must exist and be set on insert, update not allowed.';

Comment created.

SQL> COMMENT ON COLUMN usim_space.usim_process_spin IS 'The direction to emit energy to. 1 is direction childs, -1 direction parents. Nodes in dimension 0 will always have direction childs.';

Comment created.

SQL> 
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_pk
  3    PRIMARY KEY (usim_id_spc)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_space
new   1: ALTER TABLE USIM_TEST.usim_space

Table altered.

SQL> 
SQL> -- uk universe/dim/position/node is unique
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_uk
  3    UNIQUE (usim_id_rmd, usim_id_pos, usim_id_nod)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_space
new   1: ALTER TABLE USIM_TEST.usim_space

Table altered.

SQL> 
SQL> -- uk node is unique
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_nod_uk
  3    UNIQUE (usim_id_nod)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_space
new   1: ALTER TABLE USIM_TEST.usim_space

Table altered.

SQL> 
SQL> -- check usim_process_spin
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_spin_chk
  3    CHECK (usim_process_spin IN (-1, 1))
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_space
new   1: ALTER TABLE USIM_TEST.usim_space

Table altered.

SQL> 
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spc_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_space
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   -- ignore input on pk
  6  	   :NEW.usim_id_spc := usim_static.get_big_pk(usim_spc_id_seq.NEXTVAL);
  7  	 END;
  8  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spc_ins_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_spc_ins_trg
old   2:   BEFORE INSERT ON &USIM_SCHEMA..usim_space
new   2:   BEFORE INSERT ON USIM_TEST.usim_space

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_spc_ins_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_spc_ins_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_spc_ins_trg ENABLE

Trigger altered.

SQL> 
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spc_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_space
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   IF :NEW.usim_process_spin = :OLD.usim_process_spin
  6  	   THEN
  7  	     RAISE_APPLICATION_ERROR( num => -20001
  8  				    , msg => 'Update requirement not fulfilled. Only changing update of usim_process_spin allowed.'
  9  				    )
 10  	     ;
 11  	   END IF;
 12  	 END;
 13  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spc_upd_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_spc_upd_trg
old   2:   BEFORE UPDATE ON &USIM_SCHEMA..usim_space
new   2:   BEFORE UPDATE ON USIM_TEST.usim_space

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_spc_upd_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_spc_upd_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_spc_upd_trg ENABLE

Trigger altered.

SQL> -- foreign keys
SQL> @@../FK/USIM_SPC_RMD_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk relation space for relation universe/dimension (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_rmd_fk
  3    FOREIGN KEY (usim_id_rmd) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_space
new   1: ALTER TABLE USIM_TEST.usim_space

Table altered.

SQL> @@../FK/USIM_SPC_POS_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk relation space for position (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_pos_fk
  3    FOREIGN KEY (usim_id_pos) REFERENCES usim_position (usim_id_pos) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_space
new   1: ALTER TABLE USIM_TEST.usim_space

Table altered.

SQL> @@../FK/USIM_SPC_NOD_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk relation space for node (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_space
  2    ADD CONSTRAINT usim_spc_nod_fk
  3    FOREIGN KEY (usim_id_nod) REFERENCES usim_node (usim_id_nod) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_space
new   1: ALTER TABLE USIM_TEST.usim_space

Table altered.

SQL> --@@../FK/USIM_SPC_VOL_FK.sql
SQL> -- views
SQL> @@../VIEW/USIM_SPC_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_SPC_V (spcv)
SQL> -- minimal joining
SQL> CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_spc_v AS
  2    SELECT rmd.usim_id_mlv
  3  	    , spc.usim_id_spc
  4  	    , spc.usim_id_rmd
  5  	    , spc.usim_id_pos
  6  	    , spc.usim_id_nod
  7  	    , spc.usim_process_spin
  8  	    , dim.usim_id_dim
  9  	    , dim.usim_n_dimension
 10  	    , rmd.usim_sign AS dim_sign
 11  	    , rmd.usim_n1_sign AS dim_n1_sign
 12  	    , pos.usim_coordinate
 13  	    , nod.usim_energy
 14  	    , mlv.usim_universe_status
 15  	    , mlv.usim_is_base_universe
 16  	    , CASE
 17  		WHEN usim_spc.is_universe_base(spc.usim_id_spc) = 1
 18  		THEN mlv.usim_energy_start_value
 19  		ELSE NULL
 20  	      END				       AS usim_energy_start_value
 21  	    , mlv.usim_ultimate_border
 22  	    , mlv.usim_planck_stable
 23  	    , mlv.usim_planck_length_unit
 24  	 FROM usim_space spc
 25  	INNER JOIN usim_rel_mlv_dim rmd
 26  	   ON spc.usim_id_rmd = rmd.usim_id_rmd
 27  	INNER JOIN usim_dimension dim
 28  	   ON rmd.usim_id_dim = dim.usim_id_dim
 29  	INNER JOIN usim_multiverse mlv
 30  	   ON rmd.usim_id_mlv = mlv.usim_id_mlv
 31  	INNER JOIN usim_position pos
 32  	   ON spc.usim_id_pos = pos.usim_id_pos
 33  	INNER JOIN usim_node nod
 34  	   ON spc.usim_id_nod = nod.usim_id_nod
 35  ;
old   1: CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_spc_v AS
new   1: CREATE OR REPLACE FORCE VIEW USIM_TEST.usim_spc_v AS

Warning: View created with compilation errors.

SQL> -- usim_space package
SQL> @@../PACKAGES/USIM_SPC.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_spc
  2  IS
  3    /**A low level package for actions on table usim_space and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9  
 10    /**
 11    * Checks if usim_space has already data.
 12    * @return Returns 1 if data are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15  	 RETURN NUMBER
 16    ;
 17  
 18    /**
 19    * Checks if usim_space has already data for a given space id.
 20    * @param p_usim_id_spc The relation id of universe/dimension/position/node.
 21    * @return Returns 1 if data are available, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 24  	 RETURN NUMBER
 25    ;
 26  
 27    /**
 28    * Checks if usim_space has already data for given relation ids.
 29    * @param p_usim_id_rmd The relation id of universe/dimension.
 30    * @param p_usim_id_pos The id of the position.
 31    * @return Returns 1 if data are available, otherwise 0.
 32    */
 33    FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
 34  			, p_usim_id_pos IN usim_position.usim_id_pos%TYPE
 35  			)
 36  	 RETURN NUMBER
 37    ;
 38  
 39    /**
 40    * Checks if usim_space has already data for given relation ids.
 41    * @param p_usim_id_rmd The relation id of universe/dimension.
 42    * @param p_usim_id_pos The id of the position.
 43    * @param p_usim_id_nod The id of the node.
 44    * @return Returns 1 if data are available, otherwise 0.
 45    */
 46    FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
 47  			, p_usim_id_pos IN usim_position.usim_id_pos%TYPE
 48  			, p_usim_id_nod IN usim_node.usim_id_nod%TYPE
 49  			)
 50  	 RETURN NUMBER
 51    ;
 52  
 53    /**
 54    * Checks if usim_space has a entry for the base universe with dimension 0, position 0 and sign 0.
 55    * @return Returns 1 if base universe exists, otherwise 0.
 56    */
 57    FUNCTION has_base_universe
 58  	 RETURN NUMBER
 59    ;
 60  
 61    /**
 62    * Checks if the space id is a universe base entry with dimension 0, position 0 and sign 0. Not necessarily the base universe.
 63    * @param p_usim_id_spc The space id.
 64    * @return Returns 1 if universe base entry exists, otherwise 0.
 65    */
 66    FUNCTION is_universe_base(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 67  	 RETURN NUMBER
 68    ;
 69  
 70    /**
 71    * Returns the maximum available dimensions for a space id and the related universe in usim_space. Considers
 72    * all dimensions, not caring about the n1 sign.
 73    * @param p_usim_id_spc The space id.
 74    * @return Returns the maximum available dimensions for the related universe or -1 if no dimension available.
 75    */
 76    FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 77  	 RETURN usim_dimension.usim_n_dimension%TYPE
 78    ;
 79  
 80    /**
 81    * Returns the current maximum available dimensions for a space id and the related universe in usim_space. Considers
 82    * only n1 dimension of the given id.
 83    * @param p_usim_id_spc The space id.
 84    * @return Returns the maximum available n=1 related dimensions for the related universe or NULL on errors.
 85    */
 86    FUNCTION get_cur_max_dim_n1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 87  	 RETURN usim_dimension.usim_n_dimension%TYPE
 88    ;
 89  
 90    /**
 91    * Returns the current maximum absolute position coordinate for a space id and the related universe in usim_space. Considers
 92    * only the dimension axis of the given id.
 93    * @param p_usim_id_spc The space id.
 94    * @return Returns the maximum available absolute position coordinate (always positive) or NULL on errors.
 95    */
 96    FUNCTION get_cur_max_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 97  	 RETURN usim_position.usim_coordinate%TYPE
 98    ;
 99  
100    /**
101    * Retrieves the universe/dimension id for a given space id if it exists in usim_space.
102    * @param p_usim_id_spc The space id.
103    * @return Returns usim_id_rmd if space id exists, otherwise NULL.
104    */
105    FUNCTION get_id_rmd(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
106  	 RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
107    ;
108  
109    /**
110    * Retrieves the universe/dimension id for a given space id if it exists in usim_space.
111    * @param p_usim_id_spc The space id.
112    * @return Returns usim_id_rmd if space id exists, otherwise NULL.
113    */
114    FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
115  	 RETURN usim_position.usim_id_pos%TYPE
116    ;
117  
118    /**
119    * Retrieves the universe id for a given space id if it exists in usim_space.
120    * @param p_usim_id_spc The space id.
121    * @return Returns usim_id_mlv if space id exists, otherwise NULL.
122    */
123    FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
124  	 RETURN usim_multiverse.usim_id_mlv%TYPE
125    ;
126  
127    /**
128    * Retrieves the node id for a given space id if it exists in usim_space.
129    * @param p_usim_id_spc The space id.
130    * @return Returns usim_id_nod if space id exists, otherwise NULL.
131    */
132    FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
133  	 RETURN usim_node.usim_id_nod%TYPE
134    ;
135  
136    /**
137    * Retrieves a space id for a given ids if it exists in usim_space.
138    * @param p_usim_id_rmd The universe/dimension relation id.
139    * @param p_usim_id_pos The position id.
140    * @return Returns usim_id_spc if it exists, otherwise NULL.
141    */
142    FUNCTION get_id_spc( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
143  			  , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
144  			  )
145  	 RETURN usim_space.usim_id_spc%TYPE
146    ;
147  
148    /**
149    * Retrieves the space id for the base universe if it exists in usim_space.
150    * @return Returns usim_id_spc if base universe exists, otherwise NULL.
151    */
152    FUNCTION get_id_spc_base_universe
153  	 RETURN usim_space.usim_id_spc%TYPE
154    ;
155  
156    /**
157    * Retrieves the dimension sign of a given space node.
158    * @param p_usim_id_spc The space id.
159    * @return The dimension sign of the space id or NULL, if space id does not exist.
160    */
161    FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
162  	 RETURN usim_rel_mlv_dim.usim_sign%TYPE
163    ;
164  
165    /**
166    * Retrieves the dimension n=1 sign of a given space node.
167    * @param p_usim_id_spc The space id.
168    * @return The dimension n=1 sign of the space id, base universe nodes will return 0. NULL, if space id does not exist.
169    */
170    FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
171  	 RETURN usim_rel_mlv_dim.usim_sign%TYPE
172    ;
173  
174    /**
175    * Retrieves the dimension for a given node.
176    * @param p_usim_id_spc The space id to get the dimension.
177    * @return Returns the dimension or -1 if node does not exist.
178    */
179    FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
180  	 RETURN usim_dimension.usim_n_dimension%TYPE
181    ;
182  
183    /**
184    * Retrieves the coordinate for a given node.
185    * @param p_usim_id_spc The space id to get the dimension.
186    * @return Returns the coordinate or NULL if node does not exist.
187    */
188    FUNCTION get_coordinate(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
189  	 RETURN usim_position.usim_coordinate%TYPE
190    ;
191  
192    /**
193    * Retrieves the process direction of a given space node.
194    * @param p_usim_id_spc The space id to get the process direction.
195    * @return Returns the process directions or NULL if space node does not exist.
196    */
197    FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
198  	 RETURN usim_space.usim_process_spin%TYPE
199    ;
200  
201    /**
202    * Get basic details about a given space node.
203    * @param p_usim_id_spc The space id to get the details for.
204    * @param p_usim_id_rmd The associated dimension axis id.
205    * @param p_usim_id_pos The associated position id.
206    * @param p_usim_id_nod The associated node id.
207    * @param p_process_spin The current process spin of the space node.
208    * @return Returns 1 if data could be fetched or 0 on errors.
209    */
210    FUNCTION get_spc_details( p_usim_id_spc	IN  usim_space.usim_id_spc%TYPE
211  			       , p_usim_id_rmd	OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
212  			       , p_usim_id_pos	OUT usim_position.usim_id_pos%TYPE
213  			       , p_usim_id_nod	OUT usim_node.usim_id_nod%TYPE
214  			       , p_process_spin OUT usim_space.usim_process_spin%TYPE
215  			       )
216  	 RETURN NUMBER
217    ;
218  
219    /**
220    * Get all details about a given space node.
221    * @param p_usim_id_spc The space id to get the details for.
222    * @param p_usim_id_rmd The associated dimension axis id.
223    * @param p_usim_id_pos The associated position id.
224    * @param p_usim_id_nod The associated node id.
225    * @param p_process_spin The current process spin of the space node.
226    * @param p_usim_id_mlv The associated universe id.
227    * @param p_n_dimension The associated dimension n.
228    * @param p_dim_sign The associated sign of the dimension axis.
229    * @param p_dim_n1_sign The associated n1 sign of the dimension axis.
230    * @param p_coordinate The associated coordinate.
231    * @param p_is_base The associated universe type.
232    * @param p_energy The associated node energy.
233    * @return Returns 1 if data could be fetched or 0 on errors.
234    */
235    FUNCTION get_spc_details( p_usim_id_spc	IN  usim_space.usim_id_spc%TYPE
236  			       , p_usim_id_rmd	OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
237  			       , p_usim_id_pos	OUT usim_position.usim_id_pos%TYPE
238  			       , p_usim_id_nod	OUT usim_node.usim_id_nod%TYPE
239  			       , p_process_spin OUT usim_space.usim_process_spin%TYPE
240  			       , p_usim_id_mlv	OUT usim_multiverse.usim_id_mlv%TYPE
241  			       , p_n_dimension	OUT usim_dimension.usim_n_dimension%TYPE
242  			       , p_dim_sign	OUT usim_rel_mlv_dim.usim_sign%TYPE
243  			       , p_dim_n1_sign	OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
244  			       , p_coordinate	OUT usim_position.usim_coordinate%TYPE
245  			       , p_is_base	OUT usim_multiverse.usim_is_base_universe%TYPE
246  			       , p_energy	OUT usim_node.usim_energy%TYPE
247  			       )
248  	 RETURN NUMBER
249    ;
250  
251    /**
252    * Inserts a new space node for the given ids in usim_space if it does not exist yet.
253    * @param p_usim_id_rmd The universe/dimension relation id.
254    * @param p_usim_id_pos The position id.
255    * @param p_usim_id_nod The node id.
256    * @param p_usim_process_spin The process spin (1, -1).
257    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
258    * @return Returns the new usim_id_spc id or NULL on errors.
259    */
260    FUNCTION insert_spc( p_usim_id_rmd	IN usim_rel_mlv_dim.usim_id_rmd%TYPE
261  			  , p_usim_id_pos	IN usim_position.usim_id_pos%TYPE
262  			  , p_usim_id_nod	IN usim_node.usim_id_nod%TYPE
263  			  , p_usim_process_spin IN usim_space.usim_process_spin%TYPE
264  			  , p_do_commit 	IN BOOLEAN			     DEFAULT TRUE
265  			  )
266  	 RETURN usim_space.usim_id_spc%TYPE
267    ;
268  
269    /**
270    * Updates usim_process_spin by flipping the existing value (1 to -1 and vice versa)
271    * if the given space node is not in dimension 0 with position 0. Otherwise does nothing.
272    * @param p_usim_id_spc The space id to get the max dimension.
273    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
274    * @return Returns 1 if no errors or 0 if space id does not exist.
275    */
276    FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
277  				 , p_do_commit	 IN BOOLEAN			DEFAULT TRUE
278  				 )
279  	 RETURN NUMBER
280    ;
281  
282  END usim_spc;
283  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_spc
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_spc

Package created.

SQL> @@../PACKAGES/USIM_SPC.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_spc
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_data
  5  	 RETURN NUMBER
  6    IS
  7  	 l_result NUMBER;
  8    BEGIN
  9  	 SELECT COUNT(*) INTO l_result FROM usim_space;
 10  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 11    END has_data
 12    ;
 13  
 14    FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 15  	 RETURN NUMBER
 16    IS
 17  	 l_result NUMBER;
 18    BEGIN
 19  	 SELECT COUNT(*) INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
 20  	 RETURN l_result;
 21    END has_data
 22    ;
 23  
 24    FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
 25  			, p_usim_id_pos IN usim_position.usim_id_pos%TYPE
 26  			)
 27  	 RETURN NUMBER
 28    IS
 29  	 l_result NUMBER;
 30    BEGIN
 31  	 SELECT COUNT(*) INTO l_result FROM usim_spc_v WHERE usim_id_rmd = p_usim_id_rmd AND usim_id_pos = p_usim_id_pos;
 32  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 33    END has_data
 34    ;
 35  
 36    FUNCTION has_data( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
 37  			, p_usim_id_pos IN usim_position.usim_id_pos%TYPE
 38  			, p_usim_id_nod IN usim_node.usim_id_nod%TYPE
 39  			)
 40  	 RETURN NUMBER
 41    IS
 42  	 l_result NUMBER;
 43    BEGIN
 44  	 SELECT COUNT(*) INTO l_result FROM usim_space WHERE usim_id_rmd = p_usim_id_rmd AND usim_id_pos = p_usim_id_pos AND usim_id_nod = p_usim_id_nod;
 45  	 RETURN l_result;
 46    END has_data
 47    ;
 48  
 49    FUNCTION has_base_universe
 50  	 RETURN NUMBER
 51    IS
 52  	 l_result NUMBER;
 53    BEGIN
 54  	 SELECT COUNT(*) INTO l_result FROM usim_spc_v WHERE usim_is_base_universe = 1 AND usim_n_dimension = 0 AND usim_coordinate = 0;
 55  	 RETURN l_result;
 56    END has_base_universe
 57    ;
 58  
 59    FUNCTION is_universe_base(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 60  	 RETURN NUMBER
 61    IS
 62  	 l_result NUMBER;
 63    BEGIN
 64  	 SELECT COUNT(*) INTO l_result FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc AND usim_n_dimension = 0 AND usim_coordinate = 0;
 65  	 RETURN l_result;
 66    END is_universe_base
 67    ;
 68  
 69    FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 70  	 RETURN usim_dimension.usim_n_dimension%TYPE
 71    IS
 72  	 l_result      usim_dimension.usim_n_dimension%TYPE;
 73  	 l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
 74    BEGIN
 75  	 IF usim_spc.has_data(p_usim_id_spc) = 1
 76  	 THEN
 77  	   l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
 78  	   SELECT NVL(MAX(usim_n_dimension), -1)
 79  	     INTO l_result
 80  	     FROM usim_spc_v
 81  	    WHERE usim_id_mlv = l_usim_id_mlv
 82  	   ;
 83  	   RETURN l_result;
 84  	 ELSE
 85  	   usim_erl.log_error('usim_spc.get_cur_max_dimension', 'Used not existing id [' || p_usim_id_spc || '].');
 86  	   RETURN NULL;
 87  	 END IF;
 88    END get_cur_max_dimension
 89    ;
 90  
 91    FUNCTION get_cur_max_dim_n1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 92  	 RETURN usim_dimension.usim_n_dimension%TYPE
 93    IS
 94  	 l_result      usim_dimension.usim_n_dimension%TYPE;
 95  	 l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
 96  	 l_n1_sign     usim_rel_mlv_dim.usim_n1_sign%TYPE;
 97    BEGIN
 98  	 IF usim_spc.has_data(p_usim_id_spc) = 1
 99  	 THEN
100  	   l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
101  	   l_n1_sign	 := usim_spc.get_dim_n1_sign(p_usim_id_spc);
102  	   SELECT MAX(usim_n_dimension)
103  	     INTO l_result
104  	     FROM usim_spc_v
105  	    WHERE usim_id_mlv = l_usim_id_mlv
106  	      AND dim_n1_sign = l_n1_sign
107  	   ;
108  	   RETURN l_result;
109  	 ELSE
110  	   usim_erl.log_error('usim_spc.get_cur_max_dim_n1', 'Used not existing id [' || p_usim_id_spc || '].');
111  	   RETURN NULL;
112  	 END IF;
113    END get_cur_max_dim_n1
114    ;
115  
116    FUNCTION get_cur_max_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
117  	 RETURN usim_position.usim_coordinate%TYPE
118    IS
119  	 l_usim_id_rmd usim_rel_mlv_dim.usim_id_rmd%TYPE;
120  	 l_max_pos     usim_position.usim_coordinate%TYPE;
121    BEGIN
122  	 IF usim_spc.has_data(p_usim_id_spc) = 1
123  	 THEN
124  	   l_usim_id_rmd := usim_spc.get_id_rmd(p_usim_id_spc);
125  	   SELECT MAX(ABS(usim_coordinate))
126  	     INTO l_max_pos
127  	     FROM usim_spc_v
128  	    WHERE usim_id_rmd = l_usim_id_rmd
129  	   ;
130  	   RETURN l_max_pos;
131  	 ELSE
132  	   usim_erl.log_error('usim_spc.get_cur_max_pos', 'Used not existing id [' || p_usim_id_spc || '].');
133  	   RETURN NULL;
134  	 END IF;
135    END get_cur_max_pos
136    ;
137  
138    FUNCTION get_id_rmd(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
139  	 RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
140    IS
141  	 l_result usim_rel_mlv_dim.usim_id_rmd%TYPE;
142    BEGIN
143  	 IF usim_spc.has_data(p_usim_id_spc) = 1
144  	 THEN
145  	   SELECT usim_id_rmd INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
146  	   RETURN l_result;
147  	 ELSE
148  	   usim_erl.log_error('usim_spc.get_id_rmd', 'Used with not existing space id [' || p_usim_id_spc || '].');
149  	   RETURN NULL;
150  	 END IF;
151    END get_id_rmd
152    ;
153  
154    FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
155  	 RETURN usim_position.usim_id_pos%TYPE
156    IS
157  	 l_result usim_position.usim_id_pos%TYPE;
158    BEGIN
159  	 IF usim_spc.has_data(p_usim_id_spc) = 1
160  	 THEN
161  	   SELECT usim_id_pos INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
162  	   RETURN l_result;
163  	 ELSE
164  	   usim_erl.log_error('usim_spc.get_id_pos', 'Used with not existing space id [' || p_usim_id_spc || '].');
165  	   RETURN NULL;
166  	 END IF;
167    END get_id_pos
168    ;
169  
170    FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
171  	 RETURN usim_multiverse.usim_id_mlv%TYPE
172    IS
173  	 l_result usim_multiverse.usim_id_mlv%TYPE;
174    BEGIN
175  	 IF usim_spc.has_data(p_usim_id_spc) = 1
176  	 THEN
177  	   SELECT usim_id_mlv INTO l_result FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc;
178  	   RETURN l_result;
179  	 ELSE
180  	   usim_erl.log_error('usim_spc.get_id_mlv', 'Used with not existing space id [' || p_usim_id_spc || '].');
181  	   RETURN NULL;
182  	 END IF;
183    END get_id_mlv
184    ;
185  
186    FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
187  	 RETURN usim_node.usim_id_nod%TYPE
188    IS
189  	 l_result usim_node.usim_id_nod%TYPE;
190    BEGIN
191  	 IF usim_spc.has_data(p_usim_id_spc) = 1
192  	 THEN
193  	   SELECT usim_id_nod INTO l_result FROM usim_space WHERE usim_id_spc = p_usim_id_spc;
194  	   RETURN l_result;
195  	 ELSE
196  	   usim_erl.log_error('usim_spc.get_id_nod', 'Used with not existing space id [' || p_usim_id_spc || '].');
197  	   RETURN NULL;
198  	 END IF;
199    END get_id_nod
200    ;
201  
202    FUNCTION get_id_spc( p_usim_id_rmd IN usim_rel_mlv_dim.usim_id_rmd%TYPE
203  			  , p_usim_id_pos IN usim_position.usim_id_pos%TYPE
204  			  )
205  	 RETURN usim_space.usim_id_spc%TYPE
206    IS
207  	 l_result usim_space.usim_id_spc%TYPE;
208    BEGIN
209  	 IF usim_spc.has_data(p_usim_id_rmd, p_usim_id_pos) = 1
210  	 THEN
211  	   SELECT usim_id_spc INTO l_result FROM usim_space WHERE usim_id_rmd = p_usim_id_rmd AND usim_id_pos = p_usim_id_pos;
212  	   RETURN l_result;
213  	 ELSE
214  	   usim_erl.log_error('usim_spc.get_id_spc', 'Used with not existing rmd id [' || p_usim_id_rmd || '] or pos id [' || p_usim_id_pos || '].');
215  	   RETURN NULL;
216  	 END IF;
217    END get_id_spc
218    ;
219  
220    FUNCTION get_id_spc_base_universe
221  	 RETURN usim_space.usim_id_spc%TYPE
222    IS
223  	 l_result usim_space.usim_id_spc%TYPE;
224    BEGIN
225  	 IF usim_spc.has_base_universe = 1
226  	 THEN
227  	   SELECT usim_id_spc INTO l_result FROM usim_spc_v WHERE usim_is_base_universe = 1 AND usim_n_dimension = 0 AND usim_coordinate = 0;
228  	   RETURN l_result;
229  	 ELSE
230  	   usim_erl.log_error('usim_spc.get_id_spc_base_universe', 'Used with not existing base universe.');
231  	   RETURN NULL;
232  	 END IF;
233    END get_id_spc_base_universe
234    ;
235  
236    FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
237  	 RETURN usim_rel_mlv_dim.usim_sign%TYPE
238    IS
239  	 l_result usim_rel_mlv_dim.usim_sign%TYPE;
240    BEGIN
241  	 IF usim_spc.has_data(p_usim_id_spc) = 1
242  	 THEN
243  	   SELECT dim_sign
244  	     INTO l_result
245  	     FROM usim_spc_v
246  	    WHERE usim_id_spc = p_usim_id_spc
247  	   ;
248  	   RETURN l_result;
249  	 ELSE
250  	   -- no space node available
251  	   usim_erl.log_error('usim_spc.get_dim_sign', 'Not existing space id [' || p_usim_id_spc || '].');
252  	   RETURN NULL;
253  	 END IF;
254    END get_dim_sign
255    ;
256  
257    FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
258  	 RETURN usim_rel_mlv_dim.usim_sign%TYPE
259    IS
260  	 l_result usim_rel_mlv_dim.usim_sign%TYPE;
261    BEGIN
262  	 IF usim_spc.has_data(p_usim_id_spc) = 1
263  	 THEN
264  	   SELECT NVL(dim_n1_sign, 0)
265  	     INTO l_result
266  	     FROM usim_spc_v
267  	    WHERE usim_id_spc = p_usim_id_spc
268  	   ;
269  	   RETURN l_result;
270  	 ELSE
271  	   -- no space node available
272  	   usim_erl.log_error('usim_spc.get_dim_n1_sign', 'Not existing space id [' || p_usim_id_spc || '].');
273  	   RETURN NULL;
274  	 END IF;
275    END get_dim_n1_sign
276    ;
277  
278    FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
279  	 RETURN usim_dimension.usim_n_dimension%TYPE
280    IS
281  	 l_result usim_dimension.usim_n_dimension%TYPE;
282    BEGIN
283  	 IF usim_spc.has_data(p_usim_id_spc) = 1
284  	 THEN
285  	   SELECT usim_n_dimension
286  	     INTO l_result
287  	     FROM usim_spc_v
288  	    WHERE usim_id_spc = p_usim_id_spc
289  	   ;
290  	   RETURN l_result;
291  	 ELSE
292  	   -- no space node available
293  	   usim_erl.log_error('usim_spc.get_dimension', 'Not existing space id [' || p_usim_id_spc || '].');
294  	   RETURN -1;
295  	 END IF;
296    END get_dimension
297    ;
298  
299    FUNCTION get_coordinate(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
300  	 RETURN usim_position.usim_coordinate%TYPE
301    IS
302  	 l_result usim_position.usim_coordinate%TYPE;
303    BEGIN
304  	 IF usim_spc.has_data(p_usim_id_spc) = 1
305  	 THEN
306  	   SELECT usim_coordinate
307  	     INTO l_result
308  	     FROM usim_spc_v
309  	    WHERE usim_id_spc = p_usim_id_spc
310  	   ;
311  	   RETURN l_result;
312  	 ELSE
313  	   -- no space node available
314  	   usim_erl.log_error('usim_spc.get_coordinate', 'Not existing space id [' || p_usim_id_spc || '].');
315  	   RETURN NULL;
316  	 END IF;
317    END get_coordinate
318    ;
319  
320    FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
321  	 RETURN usim_space.usim_process_spin%TYPE
322    IS
323  	 l_result usim_space.usim_process_spin%TYPE;
324    BEGIN
325  	 IF usim_spc.has_data(p_usim_id_spc) = 1
326  	 THEN
327  	   SELECT usim_process_spin
328  	     INTO l_result
329  	     FROM usim_space
330  	    WHERE usim_id_spc = p_usim_id_spc
331  	   ;
332  	   RETURN l_result;
333  	 ELSE
334  	   -- no space node available
335  	   usim_erl.log_error('usim_spc.get_process_spin', 'Not existing space id [' || p_usim_id_spc || '].');
336  	   RETURN NULL;
337  	 END IF;
338    END get_process_spin
339    ;
340  
341    FUNCTION get_spc_details( p_usim_id_spc	IN  usim_space.usim_id_spc%TYPE
342  			       , p_usim_id_rmd	OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
343  			       , p_usim_id_pos	OUT usim_position.usim_id_pos%TYPE
344  			       , p_usim_id_nod	OUT usim_node.usim_id_nod%TYPE
345  			       , p_process_spin OUT usim_space.usim_process_spin%TYPE
346  			       )
347  	 RETURN NUMBER
348    IS
349    BEGIN
350  	 IF usim_spc.has_data(p_usim_id_spc) = 1
351  	 THEN
352  	   SELECT usim_id_rmd
353  		, usim_id_pos
354  		, usim_id_nod
355  		, usim_process_spin
356  	     INTO p_usim_id_rmd
357  		, p_usim_id_pos
358  		, p_usim_id_nod
359  		, p_process_spin
360  	     FROM usim_space
361  	    WHERE usim_id_spc = p_usim_id_spc
362  	   ;
363  	   RETURN 1;
364  	 ELSE
365  	   -- no space node available
366  	   usim_erl.log_error('usim_spc.get_spc_details', 'Not existing space id [' || p_usim_id_spc || '].');
367  	   RETURN 0;
368  	 END IF;
369    END get_spc_details
370    ;
371  
372    FUNCTION get_spc_details( p_usim_id_spc	IN  usim_space.usim_id_spc%TYPE
373  			       , p_usim_id_rmd	OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
374  			       , p_usim_id_pos	OUT usim_position.usim_id_pos%TYPE
375  			       , p_usim_id_nod	OUT usim_node.usim_id_nod%TYPE
376  			       , p_process_spin OUT usim_space.usim_process_spin%TYPE
377  			       , p_usim_id_mlv	OUT usim_multiverse.usim_id_mlv%TYPE
378  			       , p_n_dimension	OUT usim_dimension.usim_n_dimension%TYPE
379  			       , p_dim_sign	OUT usim_rel_mlv_dim.usim_sign%TYPE
380  			       , p_dim_n1_sign	OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
381  			       , p_coordinate	OUT usim_position.usim_coordinate%TYPE
382  			       , p_is_base	OUT usim_multiverse.usim_is_base_universe%TYPE
383  			       , p_energy	OUT usim_node.usim_energy%TYPE
384  			       )
385  	 RETURN NUMBER
386    IS
387    BEGIN
388  	 IF usim_spc.has_data(p_usim_id_spc) = 1
389  	 THEN
390  	   SELECT usim_id_rmd
391  		, usim_id_pos
392  		, usim_id_nod
393  		, usim_process_spin
394  		, usim_id_mlv
395  		, usim_n_dimension
396  		, dim_sign
397  		, dim_n1_sign
398  		, usim_coordinate
399  		, usim_is_base_universe
400  		, usim_energy
401  	     INTO p_usim_id_rmd
402  		, p_usim_id_pos
403  		, p_usim_id_nod
404  		, p_process_spin
405  		, p_usim_id_mlv
406  		, p_n_dimension
407  		, p_dim_sign
408  		, p_dim_n1_sign
409  		, p_coordinate
410  		, p_is_base
411  		, p_energy
412  	     FROM usim_spc_v
413  	    WHERE usim_id_spc = p_usim_id_spc
414  	   ;
415  	   RETURN 1;
416  	 ELSE
417  	   -- no space node available
418  	   usim_erl.log_error('usim_spc.get_spc_details', 'Not existing space id [' || p_usim_id_spc || '].');
419  	   RETURN 0;
420  	 END IF;
421    END get_spc_details
422    ;
423  
424    FUNCTION insert_spc( p_usim_id_rmd	IN usim_rel_mlv_dim.usim_id_rmd%TYPE
425  			  , p_usim_id_pos	IN usim_position.usim_id_pos%TYPE
426  			  , p_usim_id_nod	IN usim_node.usim_id_nod%TYPE
427  			  , p_usim_process_spin IN usim_space.usim_process_spin%TYPE
428  			  , p_do_commit 	IN BOOLEAN			     DEFAULT TRUE
429  			  )
430  	 RETURN usim_space.usim_id_spc%TYPE
431    IS
432  	 l_result usim_space.usim_id_spc%TYPE;
433    BEGIN
434  	 IF	p_usim_id_rmd	    IS NOT NULL
435  	    AND p_usim_id_pos	    IS NOT NULL
436  	    AND p_usim_id_nod	    IS NOT NULL
437  	    AND p_usim_process_spin IN (1, -1)
438  	 THEN
439  	   INSERT INTO usim_space
440  	     ( usim_id_rmd
441  	     , usim_id_pos
442  	     , usim_id_nod
443  	     , usim_process_spin
444  	     )
445  	     VALUES
446  	     ( p_usim_id_rmd
447  	     , p_usim_id_pos
448  	     , p_usim_id_nod
449  	     , p_usim_process_spin
450  	     )
451  	     RETURNING usim_id_spc INTO l_result
452  	   ;
453  	   IF p_do_commit
454  	   THEN
455  	     COMMIT;
456  	   END IF;
457  	   RETURN l_result;
458  	 ELSE
459  	   usim_erl.log_error('usim_spc.insert_spc', 'Used with invalid rmd id [' || p_usim_id_rmd || '], pos id [' || p_usim_id_pos || '], node id [' || p_usim_id_nod || '] or process spin [' || p_usim_process_spin || '].');
460  	   RETURN NULL;
461  	 END IF;
462    END insert_spc
463    ;
464  
465    FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
466  				 , p_do_commit	 IN BOOLEAN			DEFAULT TRUE
467  				 )
468  	 RETURN NUMBER
469    IS
470  	 l_spin usim_space.usim_process_spin%TYPE;
471    BEGIN
472  	 IF usim_spc.has_data(p_usim_id_spc) = 1
473  	 THEN
474  	   IF usim_spc.is_universe_base(p_usim_id_spc) = 0
475  	   THEN
476  	     l_spin := usim_spc.get_process_spin(p_usim_id_spc) * -1;
477  	     UPDATE usim_space
478  		SET usim_process_spin = l_spin
479  	      WHERE usim_id_spc = p_usim_id_spc
480  	     ;
481  	     IF p_do_commit
482  	     THEN
483  	       COMMIT;
484  	     END IF;
485  	   END IF;
486  	   RETURN 1;
487  	 ELSE
488  	   -- no space node available
489  	   usim_erl.log_error('usim_spc.flip_process_spin', 'Not existing space id [' || p_usim_id_spc || '].');
490  	   RETURN 0;
491  	 END IF;
492  
493    END flip_process_spin
494    ;
495  
496  END usim_spc;
497  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_spc
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_spc

Package body created.

SQL> -- USIM_SPC_CHILD (chi)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_SPC_CHILD_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPC_CHILD still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_CHILD'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-----------------------------------------------------------------------
../TABLES/USIM_SPC_CHILD_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_SPC_CHILD (chi)
SQL> CREATE TABLE &USIM_SCHEMA..usim_spc_child
  2    ( usim_id_spc	    CHAR(55) NOT NULL ENABLE
  3    , usim_id_spc_child  CHAR(55) NOT NULL ENABLE
  4    )
  5  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_spc_child
new   1: CREATE TABLE USIM_TEST.usim_spc_child

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_spc_child IS 'Describes the parent-child relation between active nodes. Will use the alias chi.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_spc_child IS 'Describes the parent-child relation between active nodes. Will use the alias chi.'
new   1: COMMENT ON TABLE USIM_TEST.usim_spc_child IS 'Describes the parent-child relation between active nodes. Will use the alias chi.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_child.usim_id_spc IS 'The parent id from usim_space.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_child.usim_id_spc IS 'The parent id from usim_space.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_child.usim_id_spc IS 'The parent id from usim_space.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_child.usim_id_spc_child IS 'The child id from usim_space.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_child.usim_id_spc_child IS 'The child id from usim_space.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_child.usim_id_spc_child IS 'The child id from usim_space.'

Comment created.

SQL> 
SQL> -- uk
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_child
  2    ADD CONSTRAINT usim_chi_uk
  3    UNIQUE (usim_id_spc, usim_id_spc_child)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_spc_child
new   1: ALTER TABLE USIM_TEST.usim_spc_child

Table altered.

SQL> 
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_chi_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_spc_child
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   IF :NEW.usim_id_spc = :NEW.usim_id_spc_child
  6  	   THEN
  7  	     RAISE_APPLICATION_ERROR( num => -20000
  8  				    , msg => 'Insert requirement not fulfilled. Parent and child cannot be equal.'
  9  				    )
 10  	     ;
 11  	   END IF;
 12  	 END;
 13  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_chi_ins_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_chi_ins_trg
old   2:   BEFORE INSERT ON &USIM_SCHEMA..usim_spc_child
new   2:   BEFORE INSERT ON USIM_TEST.usim_spc_child

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_chi_ins_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_chi_ins_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_chi_ins_trg ENABLE

Trigger altered.

SQL> 
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_chi_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_spc_child
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   RAISE_APPLICATION_ERROR( num => -20001
  6  				  , msg => 'Update requirement not fulfilled. No update allowed.'
  7  				  )
  8  	   ;
  9  	 END;
 10  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_chi_upd_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_chi_upd_trg
old   2:   BEFORE UPDATE ON &USIM_SCHEMA..usim_spc_child
new   2:   BEFORE UPDATE ON USIM_TEST.usim_spc_child

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_chi_upd_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_chi_upd_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_chi_upd_trg ENABLE

Trigger altered.

SQL> -- foreign keys
SQL> @@../FK/USIM_CHI_PARENT_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk parent-child relation between nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_child
  2    ADD CONSTRAINT usim_chi_parent_fk
  3    FOREIGN KEY (usim_id_spc) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_spc_child
new   1: ALTER TABLE USIM_TEST.usim_spc_child

Table altered.

SQL> @@../FK/USIM_CHI_CHILD_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk parent-child relation between nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_child
  2    ADD CONSTRAINT usim_chi_child_fk
  3    FOREIGN KEY (usim_id_spc_child) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_spc_child
new   1: ALTER TABLE USIM_TEST.usim_spc_child

Table altered.

SQL> -- views
SQL> @@../VIEW/USIM_CHI_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_CHI_V (chiv)
SQL> CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_chi_v AS
  2    SELECT r_parent.usim_n_dimension AS parent_dimension
  3  	    , r_parent.dim_sign AS parent_dim_sign
  4  	    , r_parent.dim_n1_sign AS parent_dim_n1_sign
  5  	    , r_child.usim_n_dimension AS child_dimension
  6  	    , r_child.dim_sign AS child_dim_sign
  7  	    , r_child.dim_n1_sign AS child_dim_n1_sign
  8  	    , r_parent.usim_coordinate AS parent_coordinate
  9  	    , r_child.usim_coordinate AS child_coordinate
 10  	    , chi.usim_id_spc
 11  	    , chi.usim_id_spc_child
 12  	    , r_parent.usim_id_rmd AS parent_id_rmd
 13  	    , r_child.usim_id_rmd AS child_id_rmd
 14  	    , r_parent.usim_id_mlv AS parent_id_mlv
 15  	    , r_child.usim_id_mlv AS child_id_mlv
 16  	 FROM usim_spc_child chi
 17  	 LEFT OUTER JOIN usim_spc_v r_parent
 18  	   ON chi.usim_id_spc = r_parent.usim_id_spc
 19  	 LEFT OUTER JOIN usim_spc_v r_child
 20  	   ON chi.usim_id_spc_child = r_child.usim_id_spc
 21  ;
old   1: CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_chi_v AS
new   1: CREATE OR REPLACE FORCE VIEW USIM_TEST.usim_chi_v AS

View created.

SQL> @@../VIEW/USIM_SPC_CHI_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_SPC_CHI_V (scv)
SQL> -- guarantees all space id in view with or without childs
SQL> CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spc_chi_v AS
  2    SELECT spcv.usim_n_dimension AS parent_dimension
  3  	    , spcv.dim_sign	    AS parent_dim_sign
  4  	    , chiv.child_dimension
  5  	    , chiv.child_dim_sign
  6  	    , spcv.usim_coordinate  AS parent_coordinate
  7  	    , chiv.child_coordinate
  8  	    , spcv.usim_id_spc
  9  	    , chiv.usim_id_spc_child
 10  	    , spcv.usim_id_rmd
 11  	    , spcv.usim_id_pos
 12  	    , spcv.usim_id_mlv
 13  	    , spcv.usim_id_nod
 14  	    , spcv.usim_id_dim
 15  	    , chiv.child_id_rmd
 16  	 FROM usim_spc_v spcv
 17  	 LEFT OUTER JOIN usim_chi_v chiv
 18  	   ON spcv.usim_id_spc = chiv.usim_id_spc
 19  ;
old   1: CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spc_chi_v AS
new   1: CREATE OR REPLACE VIEW USIM_TEST.usim_spc_chi_v AS

View created.

SQL> -- usim_spc_child package
SQL> @@../PACKAGES/USIM_CHI.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_chi
  2  IS
  3    /**A package for actions on table usim_spc_child.*/
  4    /**A low level package for actions on table usim_spc_child and its associated
  5    * views. Views can be seen as interfaces and dependency. No other package dependencies
  6    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  7    * from constraints, triggers and foreign keys. Caller is responsible to handle
  8    * possible exceptions.
  9    */
 10  
 11    /**
 12    * Checks if usim_spc_child has already data.
 13    * @return Returns 1 if data are available, otherwise 0.
 14    */
 15    FUNCTION has_data
 16  	 RETURN NUMBER
 17    ;
 18  
 19    /**
 20    * Checks if usim_spc_child has data for parent or child.
 21    * @param p_usim_id_spc The parent id to check data for.
 22    * @return Returns 1 if data are available, otherwise 0.
 23    */
 24    FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 25  	 RETURN NUMBER
 26    ;
 27  
 28    /**
 29    * Checks if usim_spc_child has data for given parent and child.
 30    * @param p_usim_id_spc The parent id to check data for.
 31    * @param p_usim_id_spc_child The child id to check data for.
 32    * @return Returns 1 if data are available, otherwise 0.
 33    */
 34    FUNCTION has_data( p_usim_id_spc       IN usim_space.usim_id_spc%TYPE
 35  			, p_usim_id_spc_child IN usim_space.usim_id_spc%TYPE
 36  			)
 37  	 RETURN NUMBER
 38    ;
 39  
 40    /**
 41    * Checks if usim_spc_child has data for the given parent id.
 42    * @param p_usim_id_spc The parent id to check data for.
 43    * @return Returns 1 if data are available, otherwise 0.
 44    */
 45    FUNCTION has_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 46  	 RETURN NUMBER
 47    ;
 48  
 49    /**
 50    * Checks if usim_spc_child has data for the given child id.
 51    * @param p_usim_id_spc The child id to check data for.
 52    * @return Returns 1 if data are available, otherwise 0.
 53    */
 54    FUNCTION has_child(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 55  	 RETURN NUMBER
 56    ;
 57  
 58    /**
 59    * Checks if a given parent has the same universe as the child.
 60    * @param p_usim_id_spc The parent id to check data for.
 61    * @return Returns 1 if universe is equal for child and parent, otherwise 0.
 62    */
 63    FUNCTION has_child_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 64  	 RETURN NUMBER
 65    ;
 66  
 67    /**
 68    * Checks if a given child has the same universe as the parent.
 69    * @param p_usim_id_spc The child id to check data for.
 70    * @return Returns 1 if universe is equal for child and parent, otherwise 0.
 71    */
 72    FUNCTION has_parent_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 73  	 RETURN NUMBER
 74    ;
 75  
 76    /**
 77    * Checks if a given space node has a child in the next dimension.
 78    * @param p_usim_id_spc The space id to check data for.
 79    * @return Returns 1 if the node has at least one child in the next dimension, otherwise 0.
 80    */
 81    FUNCTION has_child_next_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 82  	 RETURN NUMBER
 83    ;
 84  
 85    /**
 86    * Checks if a given space node has a child in the given dimension.
 87    * @param p_usim_id_spc The space id to check data for.
 88    * @param p_usim_n_dimension The dimension to check childs for.
 89    * @return Returns 1 if the node has at least one child in the given dimension, otherwise 0.
 90    */
 91    FUNCTION has_child_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
 92  				, p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 93  				)
 94  	 RETURN NUMBER
 95    ;
 96  
 97    /**
 98    * Checks if a given space node has a parent in the given dimension.
 99    * @param p_usim_id_spc The space id to check data for.
100    * @param p_usim_n_dimension The dimension to check parents for.
101    * @return Returns 1 if the node has at least one parent in the given dimension, otherwise 0.
102    */
103    FUNCTION has_parent_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
104  				 , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
105  				 )
106  	 RETURN NUMBER
107    ;
108  
109    /**
110    * Checks if a given space node has a child in the current dimension.
111    * @param p_usim_id_spc The space id to check data for.
112    * @return Returns 1 if the node has a child in the current dimension, otherwise 0.
113    */
114    FUNCTION has_child_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
115  	 RETURN NUMBER
116    ;
117  
118    /**
119    * Checks if a given space node has a parent in the current dimension.
120    * @param p_usim_id_spc The space id to check data for.
121    * @return Returns 1 if the node has a parent in the current dimension, otherwise 0.
122    */
123    FUNCTION has_parent_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
124  	 RETURN NUMBER
125    ;
126  
127    /**
128    * Checks if a given space nodes have a relation. Type of relation is not considered, means not caring about
129    * whether one is child or parent.
130    * @param p_usim_id_spc The first space id to check data for.
131    * @param p_usim_id_spc_rel The second space id to check data for.
132    * @return Returns 1 if the nodes are related, otherwise 0.
133    */
134    FUNCTION has_relation( p_usim_id_spc	 IN usim_space.usim_id_spc%TYPE
135  			    , p_usim_id_spc_rel  IN usim_space.usim_id_spc%TYPE
136  			    )
137  	 RETURN NUMBER
138    ;
139  
140    /**
141    * Retrieves the amount of childs a given space id has in the universe the parent is in.
142    * @param p_usim_id_spc The space id to get the amount of childs.
143    * @return Returns the amount of childs found for the given space id in the related universe.
144    */
145    FUNCTION child_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
146  	 RETURN NUMBER
147    ;
148  
149    /**
150    * Retrieves the amount of childs a given space id has in the universe the parent is in.
151    * @param p_usim_id_spc The space id to get the amount of childs.
152    * @return Returns the amount of childs found for the given space id regardless of related universe.
153    */
154    FUNCTION child_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
155  	 RETURN NUMBER
156    ;
157  
158    /**
159    * Retrieves the amount of parents a given space id has in the universe the child is in.
160    * @param p_usim_id_spc The space id to get the amount of parents.
161    * @return Returns the amount of childs found for the given space id.
162    */
163    FUNCTION parent_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
164  	 RETURN NUMBER
165    ;
166  
167    /**
168    * Retrieves the amount of parents a given space id has in the universe the child is in.
169    * @param p_usim_id_spc The space id to get the amount of parents.
170    * @return Returns the amount of childs found for the given space id.
171    */
172    FUNCTION parent_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
173  	 RETURN NUMBER
174    ;
175  
176    /***
177    * Retrieve the child in the same dimension. Expected a from space node, which should always
178    * have only one child in the same dimension with the same sign.
179    * @param p_usim_id_spc The space id to get the child for.
180    * @return Returns the child space id or NULL if wrong space node used.
181    */
182    FUNCTION get_child_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
183  	 RETURN usim_space.usim_id_spc%TYPE
184    ;
185  
186    /***
187    * Retrieve the child in the next dimension. Expects a space node, which should always
188    * have only one from child in the next dimension with given sign.
189    * @param p_usim_id_spc The space id to get the child for.
190    * @return Returns the child space id or NULL if wrong space node used.
191    */
192    FUNCTION get_child_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
193  	 RETURN usim_space.usim_id_spc%TYPE
194    ;
195  
196    /***
197    * Retrieve the parent in the same dimension. Expected a to space node, which should always
198    * have only one parent in the same dimension with the same sign.
199    * @param p_usim_id_spc The space id to get the parent for.
200    * @return Returns the parent space id or NULL if wrong space node used.
201    */
202    FUNCTION get_parent_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
203  	 RETURN usim_space.usim_id_spc%TYPE
204    ;
205  
206    /***
207    * Retrieve the maximum available dimension by childs and parents.
208    * @param p_usim_id_spc The space id to get the max child/parent dimensions for.
209    * @return Returns the highest dimension of childs/parents for the node.
210    */
211    FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
212  	 RETURN usim_dimension.usim_n_dimension%TYPE
213    ;
214  
215    /**
216    * Get child and parent details for a given space node id.
217    * @param p_usim_id_spc The space id to get the details for.
218    * @return Returns 1 if data could be fetched or 0 on errors.
219    */
220    FUNCTION get_chi_details( p_usim_id_spc	IN  usim_space.usim_id_spc%TYPE
221  			       , p_parent_count OUT NUMBER
222  			       , p_child_count	OUT NUMBER
223  			       )
224  	 RETURN NUMBER
225    ;
226  
227    /**
228    * Inserts a parent-child relation between nodes, if active nodes exist and are not equal. If relation
229    * exists, 1 is returned.
230    * @param p_usim_id_spc The parent id to insert.
231    * @param p_usim_id_spc_child The child id to insert.
232    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
233    * @return Returns 1 if insert was successful or 0 if constraints are not fulfilled.
234    */
235    FUNCTION insert_chi( p_usim_id_spc	 IN usim_space.usim_id_spc%TYPE
236  			  , p_usim_id_spc_child  IN usim_space.usim_id_spc%TYPE
237  			  , p_do_commit 	 IN BOOLEAN			DEFAULT TRUE
238  			  )
239  	 RETURN NUMBER
240    ;
241  
242  END usim_chi;
243  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_chi
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_chi

Package created.

SQL> @@../PACKAGES/USIM_CHI.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_chi
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_data
  5  	 RETURN NUMBER
  6    IS
  7  	 l_result NUMBER;
  8    BEGIN
  9  	 SELECT COUNT(*) INTO l_result FROM usim_spc_child;
 10  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 11    END has_data
 12    ;
 13  
 14    FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 15  	 RETURN NUMBER
 16    IS
 17  	 l_result NUMBER;
 18    BEGIN
 19  	 SELECT COUNT(*)
 20  	   INTO l_result
 21  	   FROM usim_spc_child
 22  	  WHERE usim_id_spc	  = p_usim_id_spc
 23  	     OR usim_id_spc_child = p_usim_id_spc
 24  	 ;
 25  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 26    END has_data
 27    ;
 28  
 29    FUNCTION has_data( p_usim_id_spc       IN usim_space.usim_id_spc%TYPE
 30  			, p_usim_id_spc_child IN usim_space.usim_id_spc%TYPE
 31  			)
 32  	 RETURN NUMBER
 33    IS
 34  	 l_result NUMBER;
 35    BEGIN
 36  	 SELECT COUNT(*)
 37  	   INTO l_result
 38  	   FROM usim_spc_child
 39  	  WHERE usim_id_spc	  = p_usim_id_spc
 40  	    AND usim_id_spc_child = p_usim_id_spc_child
 41  	 ;
 42  	 RETURN l_result;
 43    END has_data
 44    ;
 45  
 46    FUNCTION has_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 47  	 RETURN NUMBER
 48    IS
 49  	 l_result NUMBER;
 50    BEGIN
 51  	 SELECT COUNT(*) INTO l_result FROM usim_spc_child WHERE usim_id_spc_child = p_usim_id_spc;
 52  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 53    END has_parent
 54    ;
 55  
 56    FUNCTION has_child(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 57  	 RETURN NUMBER
 58    IS
 59  	 l_result NUMBER;
 60    BEGIN
 61  	 SELECT COUNT(*) INTO l_result FROM usim_spc_child WHERE usim_id_spc = p_usim_id_spc;
 62  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 63    END has_child
 64    ;
 65  
 66    FUNCTION has_child_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 67  	 RETURN NUMBER
 68    IS
 69  	 l_result NUMBER;
 70    BEGIN
 71  	 SELECT COUNT(*) INTO l_result
 72  	   FROM usim_spc_child chi
 73  	   LEFT OUTER JOIN usim_spc_v spc_parent
 74  	     ON chi.usim_id_spc = spc_parent.usim_id_spc
 75  	   LEFT OUTER JOIN usim_spc_v spc_child
 76  	     ON chi.usim_id_spc_child = spc_child.usim_id_spc
 77  	  WHERE chi.usim_id_spc        = p_usim_id_spc
 78  	    AND spc_parent.usim_id_mlv = spc_child.usim_id_mlv
 79  	 ;
 80  	 RETURN l_result;
 81    END has_child_same_universe
 82    ;
 83  
 84    FUNCTION has_parent_same_universe(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 85  	 RETURN NUMBER
 86    IS
 87  	 l_result NUMBER;
 88    BEGIN
 89  	 SELECT COUNT(*) INTO l_result
 90  	   FROM usim_spc_child chi
 91  	   LEFT OUTER JOIN usim_spc_v spc_parent
 92  	     ON chi.usim_id_spc = spc_parent.usim_id_spc
 93  	   LEFT OUTER JOIN usim_spc_v spc_child
 94  	     ON chi.usim_id_spc_child = spc_child.usim_id_spc
 95  	  WHERE chi.usim_id_spc_child  = p_usim_id_spc
 96  	    AND spc_parent.usim_id_mlv = spc_child.usim_id_mlv
 97  	 ;
 98  	 RETURN l_result;
 99    END has_parent_same_universe
100    ;
101  
102    FUNCTION has_child_next_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
103  	 RETURN NUMBER
104    IS
105  	 l_result    NUMBER;
106    BEGIN
107  	 IF usim_chi.has_child(p_usim_id_spc) = 1
108  	 THEN
109  	   SELECT COUNT(*)
110  	     INTO l_result
111  	     FROM usim_chi_v
112  	    WHERE usim_id_spc		 = p_usim_id_spc
113  	      AND (parent_dimension + 1) = child_dimension
114  	   ;
115  	   RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
116  	 ELSE
117  	   RETURN 0;
118  	 END IF;
119    END has_child_next_dim
120    ;
121  
122    FUNCTION has_child_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
123  				, p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
124  				)
125  	 RETURN NUMBER
126    IS
127  	 l_result NUMBER;
128    BEGIN
129  	 IF usim_chi.has_child(p_usim_id_spc) = 1
130  	 THEN
131  	   SELECT COUNT(*)
132  	     INTO l_result
133  	     FROM usim_chi_v
134  	    WHERE usim_id_spc	  = p_usim_id_spc
135  	      AND child_dimension = p_usim_n_dimension
136  	   ;
137  	   RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
138  	 ELSE
139  	   RETURN 0;
140  	 END IF;
141    END has_child_at_dim
142    ;
143  
144    FUNCTION has_parent_at_dim( p_usim_id_spc      IN usim_space.usim_id_spc%TYPE
145  				 , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
146  				 )
147  	 RETURN NUMBER
148    IS
149  	 l_result NUMBER;
150    BEGIN
151  	 IF usim_chi.has_child(p_usim_id_spc) = 1
152  	 THEN
153  	   SELECT COUNT(*)
154  	     INTO l_result
155  	     FROM usim_chi_v
156  	    WHERE usim_id_spc_child = p_usim_id_spc
157  	      AND parent_dimension  = p_usim_n_dimension
158  	   ;
159  	   RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
160  	 ELSE
161  	   RETURN 0;
162  	 END IF;
163    END has_parent_at_dim
164    ;
165  
166    FUNCTION has_child_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
167  	 RETURN NUMBER
168    IS
169  	 l_result    NUMBER;
170    BEGIN
171  	 IF usim_chi.has_child(p_usim_id_spc) = 1
172  	 THEN
173  	   SELECT COUNT(*)
174  	     INTO l_result
175  	     FROM usim_chi_v
176  	    WHERE usim_id_spc	   = p_usim_id_spc
177  	      AND parent_id_rmd    = child_id_rmd
178  	   ;
179  	   RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
180  	 ELSE
181  	   RETURN 0;
182  	 END IF;
183    END has_child_same_dim
184    ;
185  
186    FUNCTION has_parent_same_dim(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
187  	 RETURN NUMBER
188    IS
189  	 l_result NUMBER;
190  	 l_id_rmd usim_rel_mlv_dim.usim_id_rmd%TYPE;
191    BEGIN
192  	 IF usim_chi.has_parent(p_usim_id_spc) = 1
193  	 THEN
194  	   SELECT COUNT(*)
195  	     INTO l_result
196  	     FROM usim_chi_v
197  	    WHERE usim_id_spc_child = p_usim_id_spc
198  	      AND parent_id_rmd     = child_id_rmd
199  	   ;
200  	   RETURN l_result;
201  	 ELSE
202  	   RETURN 0;
203  	 END IF;
204    END has_parent_same_dim
205    ;
206  
207    FUNCTION has_relation( p_usim_id_spc	 IN usim_space.usim_id_spc%TYPE
208  			    , p_usim_id_spc_rel  IN usim_space.usim_id_spc%TYPE
209  			    )
210  	 RETURN NUMBER
211    IS
212  	 l_result NUMBER;
213    BEGIN
214  	 SELECT COUNT(*)
215  	   INTO l_result
216  	   FROM usim_spc_child
217  	  WHERE (    usim_id_spc       = p_usim_id_spc
218  		 AND usim_id_spc_child = p_usim_id_spc_rel
219  		)
220  	     OR (    usim_id_spc       = p_usim_id_spc_rel
221  		 AND usim_id_spc_child = p_usim_id_spc
222  		)
223  	 ;
224  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
225    END has_relation
226    ;
227  
228    FUNCTION child_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
229  	 RETURN NUMBER
230    IS
231  	 l_result NUMBER;
232    BEGIN
233  	   WITH src AS
234  		(SELECT spc.usim_id_spc
235  		      , rmd.usim_id_mlv
236  		   FROM usim_space spc
237  		  INNER JOIN usim_rel_mlv_dim rmd
238  		     ON spc.usim_id_rmd = rmd.usim_id_rmd
239  		  WHERE spc.usim_id_spc = p_usim_id_spc
240  		)
241  	      , childs AS
242  		(SELECT chi.usim_id_spc
243  		      , chi.usim_id_spc_child
244  		      , rmd.usim_id_mlv AS usim_id_mlv_child
245  		   FROM usim_spc_child chi
246  		  INNER JOIN usim_space spc
247  		     ON chi.usim_id_spc_child = spc.usim_id_spc
248  		  INNER JOIN usim_rel_mlv_dim rmd
249  		     ON spc.usim_id_rmd = rmd.usim_id_rmd
250  		)
251  	 SELECT COUNT(*)
252  	   INTO l_result
253  	   FROM childs
254  	  INNER JOIN src
255  	     ON childs.usim_id_spc	 = src.usim_id_spc
256  	    AND childs.usim_id_mlv_child = src.usim_id_mlv
257  	 ;
258  	 RETURN l_result;
259    END child_count
260    ;
261  
262    FUNCTION child_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
263  	 RETURN NUMBER
264    IS
265  	 l_result NUMBER;
266    BEGIN
267  	 SELECT COUNT(*)
268  	   INTO l_result
269  	   FROM usim_spc_child
270  	  WHERE usim_id_spc   = p_usim_id_spc
271  	 ;
272  	 RETURN l_result;
273    END child_count_all
274    ;
275  
276    FUNCTION parent_count(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
277  	 RETURN NUMBER
278    IS
279  	 l_result NUMBER;
280    BEGIN
281  	   WITH src AS
282  		(SELECT spc.usim_id_spc
283  		      , rmd.usim_id_mlv
284  		   FROM usim_space spc
285  		  INNER JOIN usim_rel_mlv_dim rmd
286  		     ON spc.usim_id_rmd = rmd.usim_id_rmd
287  		  WHERE spc.usim_id_spc = p_usim_id_spc
288  		)
289  	      , parents AS
290  		(SELECT chi.usim_id_spc
291  		      , chi.usim_id_spc_child
292  		      , rmd.usim_id_mlv AS usim_id_mlv_parent
293  		   FROM usim_spc_child chi
294  		  INNER JOIN usim_space spc
295  		     ON chi.usim_id_spc = spc.usim_id_spc
296  		  INNER JOIN usim_rel_mlv_dim rmd
297  		     ON spc.usim_id_rmd = rmd.usim_id_rmd
298  		)
299  	 SELECT COUNT(*)
300  	   INTO l_result
301  	   FROM parents
302  	  INNER JOIN src
303  	     ON parents.usim_id_spc_child  = src.usim_id_spc
304  	    AND parents.usim_id_mlv_parent = src.usim_id_mlv
305  	 ;
306  	 RETURN l_result;
307    END parent_count
308    ;
309  
310    FUNCTION parent_count_all(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
311  	 RETURN NUMBER
312    IS
313  	 l_result NUMBER;
314    BEGIN
315  	 SELECT COUNT(*)
316  	   INTO l_result
317  	   FROM usim_spc_child
318  	  WHERE usim_id_spc_child = p_usim_id_spc
319  	 ;
320  	 RETURN l_result;
321    END parent_count_all
322    ;
323  
324    FUNCTION get_child_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
325  	 RETURN usim_space.usim_id_spc%TYPE
326    IS
327  	 l_result usim_space.usim_id_spc%TYPE;
328    BEGIN
329  	 IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
330  	 THEN
331  	   SELECT usim_id_spc_child
332  	     INTO l_result
333  	     FROM usim_chi_v
334  	    WHERE usim_id_spc	   = p_usim_id_spc
335  	      AND parent_id_rmd    = child_id_rmd
336  	   ;
337  	   RETURN l_result;
338  	 ELSE
339  	   usim_erl.log_error('usim_chi.get_child_same_dimension', 'Used with space id [' || p_usim_id_spc || '] that has no child in the same dimension.');
340  	   RETURN NULL;
341  	 END IF;
342    END get_child_same_dimension
343    ;
344  
345    FUNCTION get_child_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
346  	 RETURN usim_space.usim_id_spc%TYPE
347    IS
348  	 l_result usim_space.usim_id_spc%TYPE;
349    BEGIN
350  	 IF usim_chi.has_child_next_dim(p_usim_id_spc) = 1
351  	 THEN
352  	   SELECT usim_id_spc_child
353  	     INTO l_result
354  	     FROM usim_chi_v
355  	    WHERE usim_id_spc		 = p_usim_id_spc
356  	      AND (parent_dimension + 1) = child_dimension
357  	   ;
358  	   RETURN l_result;
359  	 ELSE
360  	   usim_erl.log_error('usim_chi.get_child_same_dimension', 'Used with space id [' || p_usim_id_spc || '] that has no child in the next dimension.');
361  	   RETURN NULL;
362  	 END IF;
363    END get_child_next_dimension
364    ;
365  
366    FUNCTION get_parent_same_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
367  	 RETURN usim_space.usim_id_spc%TYPE
368    IS
369  	 l_return usim_space.usim_id_spc%TYPE;
370    BEGIN
371  	 IF usim_chi.has_parent_same_dim(p_usim_id_spc) = 1
372  	 THEN
373  	   SELECT usim_id_spc
374  	     INTO l_return
375  	     FROM usim_chi_v
376  	    WHERE usim_id_spc_child = p_usim_id_spc
377  	      AND parent_id_rmd     = child_id_rmd
378  	   ;
379  	   RETURN l_return;
380  	 ELSE
381  	   usim_erl.log_error('usim_chi.get_parent_same_dimension', 'Used with space id [' || p_usim_id_spc || '] that has no parent in the same dimension.');
382  	   RETURN NULL;
383  	 END IF;
384    END get_parent_same_dimension
385    ;
386  
387    FUNCTION get_cur_max_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
388  	 RETURN usim_dimension.usim_n_dimension%TYPE
389    IS
390  	 l_max_dim usim_dimension.usim_n_dimension%TYPE;
391  	 l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
392    BEGIN
393  	   SELECT dim_n1_sign INTO l_n1_sign FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc;
394  	   WITH maxdim AS
395  		(SELECT MAX(child_dimension) AS max_dim
396  		   FROM usim_chi_v
397  		  WHERE usim_id_spc	  = p_usim_id_spc
398  		    AND child_dim_n1_sign = l_n1_sign
399  		  UNION ALL
400  			-- consider also possible parenting from higher dimensions
401  		 SELECT MAX(parent_dimension) AS max_dim
402  		   FROM usim_chi_v chip
403  		  WHERE usim_id_spc_child  = p_usim_id_spc
404  		    AND parent_dim_n1_sign = l_n1_sign
405  		)
406  	 SELECT NVL(MAX(max_dim), 0)
407  	   INTO l_max_dim
408  	   FROM maxdim
409  	 ;
410  	 RETURN l_max_dim;
411    END get_cur_max_dimension
412    ;
413  
414    FUNCTION get_chi_details( p_usim_id_spc	IN  usim_space.usim_id_spc%TYPE
415  			       , p_parent_count OUT NUMBER
416  			       , p_child_count	OUT NUMBER
417  			       )
418  	 RETURN NUMBER
419    IS
420    BEGIN
421  	 IF usim_chi.has_data(p_usim_id_spc) = 1
422  	 THEN
423  	   SELECT COUNT(*) INTO p_parent_count FROM usim_spc_child WHERE usim_id_spc_child = p_usim_id_spc;
424  	   SELECT COUNT(*) INTO p_child_count FROM usim_spc_child WHERE usim_id_spc = p_usim_id_spc;
425  	   RETURN 1;
426  	 ELSE
427  	   p_parent_count := 0;
428  	   p_child_count  := 0;
429  	   RETURN 0;
430  	 END IF;
431    END get_chi_details
432    ;
433  
434    FUNCTION insert_chi( p_usim_id_spc	 IN usim_space.usim_id_spc%TYPE
435  			  , p_usim_id_spc_child  IN usim_space.usim_id_spc%TYPE
436  			  , p_do_commit 	 IN BOOLEAN			DEFAULT TRUE
437  			  )
438  	 RETURN NUMBER
439    IS
440    BEGIN
441  	 IF usim_chi.has_data(p_usim_id_spc, p_usim_id_spc_child) = 1
442  	 THEN
443  	   RETURN 1;
444  	 ELSIF p_usim_id_spc != p_usim_id_spc_child
445  	 THEN
446  	   INSERT INTO usim_spc_child (usim_id_spc, usim_id_spc_child) VALUES (p_usim_id_spc, p_usim_id_spc_child);
447  	     IF p_do_commit
448  	     THEN
449  	       COMMIT;
450  	     END IF;
451  	     RETURN 1;
452  	 ELSE
453  	   usim_erl.log_error('usim_chi.insert_chi', 'Used with equal ids parent [' || p_usim_id_spc || '] child [' || p_usim_id_spc_child || '].');
454  	   RETURN 0;
455  	 END IF;
456    END insert_chi
457    ;
458  
459  END usim_chi;
460  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_chi
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_chi

Package body created.

SQL> -- USIM_SPC_POS (spo)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_SPC_POS_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPC_POS still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_POS'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------
../TABLES/USIM_SPC_POS_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_SPC_POS (spo)
SQL> CREATE TABLE &USIM_SCHEMA..usim_spc_pos
  2    ( usim_id_spc  CHAR(55) NOT NULL ENABLE
  3    , usim_id_rmd  CHAR(55) NOT NULL ENABLE
  4    , usim_id_pos  CHAR(55) NOT NULL ENABLE
  5    )
  6  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_spc_pos
new   1: CREATE TABLE USIM_TEST.usim_spc_pos

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_spc_pos IS 'Describes the axis coordinate index for a given space node over all dimensions. Will use the alias spo.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_spc_pos IS 'Describes the axis coordinate index for a given space node over all dimensions. Will use the alias spo.'
new   1: COMMENT ON TABLE USIM_TEST.usim_spc_pos IS 'Describes the axis coordinate index for a given space node over all dimensions. Will use the alias spo.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_pos.usim_id_spc IS 'The space node id from usim_space.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_pos.usim_id_spc IS 'The space node id from usim_space.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_pos.usim_id_spc IS 'The space node id from usim_space.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_pos.usim_id_rmd IS 'The dimension axis id relative to the universe defining the source position on this axis.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_pos.usim_id_rmd IS 'The dimension axis id relative to the universe defining the source position on this axis.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_pos.usim_id_rmd IS 'The dimension axis id relative to the universe defining the source position on this axis.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_pos.usim_id_pos IS 'The source position on the related dimension axis.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_pos.usim_id_pos IS 'The source position on the related dimension axis.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_pos.usim_id_pos IS 'The source position on the related dimension axis.'

Comment created.

SQL> 
SQL> -- uk
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_pos
  2    ADD CONSTRAINT usim_spo_uk
  3    UNIQUE (usim_id_spc, usim_id_rmd, usim_id_pos)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_spc_pos
new   1: ALTER TABLE USIM_TEST.usim_spc_pos

Table altered.

SQL> 
SQL> -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spo_upd_trg
  2    BEFORE UPDATE ON &USIM_SCHEMA..usim_spc_pos
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   RAISE_APPLICATION_ERROR( num => -20001
  6  				  , msg => 'Update requirement not fulfilled. No update allowed.'
  7  				  )
  8  	   ;
  9  	 END;
 10  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spo_upd_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_spo_upd_trg
old   2:   BEFORE UPDATE ON &USIM_SCHEMA..usim_spc_pos
new   2:   BEFORE UPDATE ON USIM_TEST.usim_spc_pos

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_spo_upd_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_spo_upd_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_spo_upd_trg ENABLE

Trigger altered.

SQL> -- foreign keys
SQL> @@../FK/USIM_SPO_SPC_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk relation to nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_pos
  2    ADD CONSTRAINT usim_spo_spc_fk
  3    FOREIGN KEY (usim_id_spc) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_spc_pos
new   1: ALTER TABLE USIM_TEST.usim_spc_pos

Table altered.

SQL> @@../FK/USIM_SPO_RMD_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk base-mirror relation between nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_pos
  2    ADD CONSTRAINT usim_spo_rmd_fk
  3    FOREIGN KEY (usim_id_rmd) REFERENCES usim_rel_mlv_dim (usim_id_rmd) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_spc_pos
new   1: ALTER TABLE USIM_TEST.usim_spc_pos

Table altered.

SQL> @@../FK/USIM_SPO_POS_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk base-mirror relation between nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_pos
  2    ADD CONSTRAINT usim_spo_pos_fk
  3    FOREIGN KEY (usim_id_pos) REFERENCES usim_position (usim_id_pos) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_spc_pos
new   1: ALTER TABLE USIM_TEST.usim_spc_pos

Table altered.

SQL> -- views
SQL> @@../VIEW/USIM_SPO_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_SPO_V (spov)
SQL> CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_spo_v AS
  2    SELECT spo.usim_id_spc
  3  	    , spo.usim_id_rmd
  4  	    , spo.usim_id_pos
  5  	    , rmdv.usim_sign AS dim_sign
  6  	    , rmdv.usim_n1_sign AS dim_n1_sign
  7  	    , rmdv.usim_n_dimension
  8  	    , pos.usim_coordinate
  9  	    , rmdv.usim_id_mlv
 10  	 FROM usim_spc_pos spo
 11  	INNER JOIN usim_rmd_v rmdv
 12  	   ON spo.usim_id_rmd = rmdv.usim_id_rmd
 13  	INNER JOIN usim_position pos
 14  	   ON spo.usim_id_pos = pos.usim_id_pos
 15  ;
old   1: CREATE OR REPLACE FORCE VIEW &USIM_SCHEMA..usim_spo_v AS
new   1: CREATE OR REPLACE FORCE VIEW USIM_TEST.usim_spo_v AS

View created.

SQL> -- usim_spc_pos package
SQL> @@../PACKAGES/USIM_SPO.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_spo
  2  IS
  3    /**A low level package for actions on table usim_spc_pos and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_STATIC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9  
 10    /**
 11    * Checks if usim_spc_pos has already data.
 12    * @return Returns 1 if data are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15  	 RETURN NUMBER
 16    ;
 17  
 18    /**
 19    * Checks if usim_spc_pos has already data for a given space node.
 20    * @param p_usim_id_spc The space id to check for data.
 21    * @return Returns 1 if data are available, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 24  	 RETURN NUMBER
 25    ;
 26  
 27    /**
 28    * Checks if usim_spc_pos has a given dimension for the given space node.
 29    * @param p_usim_id_spc The space id to check for data.
 30    * @param p_usim_n_dimension The dimension of the space node to check for data.
 31    * @return Returns 1 if space node has given dimension, otherwise 0.
 32    */
 33    FUNCTION has_data( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
 34  			, p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 35  			)
 36  	 RETURN NUMBER
 37    ;
 38  
 39    /**
 40    * Checks if for the given space id a maximum position on the dimension axis of the space
 41    * node exists, that may or may not be different to the given space id. Handles escape situation 4 where
 42    * dimension axis zero nodes can trigger new positions on their dimension axis.
 43    * @param p_usim_id_spc The space id to check for max position on its dimension axis.
 44    * @return Returns the count of maximum positions on the given dimension axis, any value not in 0,1 indicates an error in dimension symmetry.
 45    */
 46    FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 47  	 RETURN NUMBER
 48    ;
 49  
 50    /**
 51    * Retrieves the x,y,z coordinates of a given space node, if it exists in USIM_SPC_POS.
 52    * @param p_usim_id_spc The space id to get the coordinates for.
 53    * @return Returns on success a comma separated string, format x,y,z, otherwise NULL.
 54    */
 55    FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 56  	 RETURN VARCHAR2
 57    ;
 58  
 59    /**
 60    * Retrieves the coordinate of a given dimension and space node, if it exists in USIM_SPC_POS. The given dimension
 61    * may not be initialized yet and defaults to 0 if not available.
 62    * Relies on the fact, that table holds one position for one dimension, whatever axis the dimension has.
 63    * @param p_usim_id_spc The space id to get the coordinate for.
 64    * @param p_usim_n_dimension The dimension to get the coordinate for.
 65    * @return Returns on success the coordinate of the given dimension, otherwise NULL.
 66    */
 67    FUNCTION get_dim_coord( p_usim_id_spc	  IN usim_space.usim_id_spc%TYPE
 68  			     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 69  			     )
 70  	 RETURN usim_position.usim_coordinate%TYPE
 71    ;
 72  
 73    /**
 74    * Retrieves the magnitude of a vector for the given dimension.
 75    * @param p_usim_id_spc The space id to get the magnitude for.
 76    * @param p_usim_n_dimension The dimension for the magnitude calculation.
 77    * @return Returns the magnitude of the vector associated to the given space id or NULL on errors.
 78    */
 79    FUNCTION get_magnitude( p_usim_id_spc	  IN usim_space.usim_id_spc%TYPE
 80  			     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 81  			     )
 82  	 RETURN NUMBER
 83    ;
 84  
 85    /**
 86    * Builds a dimension coordinate index for a given space id, if the
 87    * index fits within VARCHAR2. Builds coordinate index like x,y,z but using
 88    * all supported dimension. Includes coordinate for dimension 0.
 89    * @param p_usim_id_spc The space id to build a dimension coordinate index.
 90    * @return Returns a coordinate string in the form of x,y,z with all dimensions, otherwise NULL.
 91    */
 92    FUNCTION get_coord_id(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 93  	 RETURN VARCHAR2
 94    ;
 95  
 96    /**
 97    * Checks if the given node is a 0 coordinate on all dimension axis.
 98    * @param p_usim_id_spc The space id to check.
 99    * @return Returns 1 if is a zero position node, otherwise 0.
100    */
101    FUNCTION is_axis_zero_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
102  	 RETURN NUMBER
103    ;
104  
105    /**
106    * Checks if the given node is a coordinate on a dimension axis, e.g. 1,0,0, 0,2,0.
107    * @param p_usim_id_spc The space id to check.
108    * @return Returns 1 if is an axis position node, otherwise 0.
109    */
110    FUNCTION is_axis_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
111  	 RETURN NUMBER
112    ;
113  
114    /**
115    * Gets the space node with the maximum position on the given dimension axis. The dimension sign is
116    * used to identify the expected coordinate sign, the dimension n1 sign is used to limit the space
117    * which is divided into two subspaces by dimension 1. The dimension itself is used to identify the
118    * dimension axis, we want to get a new parent node from to extend the dimension and universe.
119    * Used with escape situation 4 where dimension axis zero nodes can trigger new positions on their dimension axis.
120    * @param p_usim_id_spc The space id ancestor node which may be itself the parent node or a 0 node on a dimension axis that can trigger new coordinates.
121    * @return The space node with the highest position on a dimension axis, sign and n1 sign of the given ancestor node, otherwise NULL on errors. Use has_axis_max_pos_parent to check before call.
122    */
123    FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
124  	 RETURN usim_space.usim_id_spc%TYPE
125    ;
126  
127    /**
128    * Gets the space node with the position 0 on the given dimension axis.
129    * @param p_usim_id_spc The space id ancestor node which may be itself the parent node.
130    * @return The space node with the position 0 on a dimension axis, otherwise NULL on errors. Every dimension axis should have a zero entry.
131    */
132    FUNCTION get_axis_zero_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
133  	 RETURN usim_space.usim_id_spc%TYPE
134    ;
135  
136    /**
137    * Inserts a coordinate and its dimension position and extends dimension position by
138    * parent, if no dimension entry exists yet. Does nothing if all dimension positions exist
139    * already. Dimensions with position 0 are ignored if not in dimension 0 which is the root of all.
140    * @param p_usim_id_spc The space id to insert a coordinate.
141    * @param p_usim_id_spc_parent The parent space id to check or extend coordinate.
142    * @return Returns 1 on success, otherwise 0 (also on exception which is logged).
143    */
144    FUNCTION insert_spc_pos( p_usim_id_spc	     IN usim_space.usim_id_spc%TYPE
145  			      , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
146  			      , p_do_commit	     IN BOOLEAN 		    DEFAULT TRUE
147  			      )
148  	 RETURN NUMBER
149    ;
150  
151  END usim_spo;
152  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_spo
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_spo

Package created.

SQL> @@../PACKAGES/USIM_SPO.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_spo
  2  IS
  3    -- see header for documentation
  4    FUNCTION has_data
  5  	 RETURN NUMBER
  6    IS
  7  	 l_result NUMBER;
  8    BEGIN
  9  	 SELECT COUNT(*) INTO l_result FROM usim_spc_pos;
 10  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 11    END has_data
 12    ;
 13  
 14    FUNCTION has_data(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 15  	 RETURN NUMBER
 16    IS
 17  	 l_result NUMBER;
 18    BEGIN
 19  	 SELECT COUNT(*) INTO l_result FROM usim_spc_pos WHERE usim_id_spc = p_usim_id_spc;
 20  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 21    END has_data
 22    ;
 23  
 24    FUNCTION has_data( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
 25  			, p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 26  			)
 27  	 RETURN NUMBER
 28    IS
 29  	 l_result NUMBER;
 30    BEGIN
 31  	 SELECT COUNT(*) INTO l_result FROM usim_spo_v WHERE usim_id_spc = p_usim_id_spc and usim_n_dimension = p_usim_n_dimension;
 32  	 RETURN l_result;
 33    END has_data
 34    ;
 35  
 36    FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 37  	 RETURN NUMBER
 38    IS
 39  	 l_result	     NUMBER;
 40    BEGIN
 41  	 -- fetch count
 42  	   WITH known AS
 43  		(SELECT usim_id_spc
 44  		      , usim_spo.is_axis_pos(usim_id_spc) AS is_axis
 45  		      , usim_coordinate
 46  		      , usim_id_rmd
 47  		      , dim_sign
 48  		   FROM usim_spc_v
 49  		  WHERE usim_id_rmd = (SELECT usim_id_rmd FROM usim_space WHERE usim_id_spc = p_usim_id_spc)
 50  		)
 51  	      , maxpos AS
 52  		(SELECT CASE
 53  			  WHEN dim_sign >= 0
 54  			  THEN MAX(usim_coordinate)
 55  			  ELSE MIN(usim_coordinate)
 56  			END			    AS parent_pos
 57  		      , usim_id_rmd
 58  		      , dim_sign
 59  		   FROM known
 60  		  WHERE is_axis = 1
 61  		  GROUP BY usim_id_rmd
 62  			 , dim_sign
 63  		)
 64  	 SELECT COUNT(*)
 65  	   INTO l_result
 66  	   FROM known
 67  	  INNER JOIN maxpos
 68  	     ON known.usim_coordinate  = maxpos.parent_pos
 69  	    AND known.usim_id_rmd      = maxpos.usim_id_rmd
 70  	    AND known.dim_sign	       = maxpos.dim_sign
 71  	  WHERE known.is_axis = 1
 72  	 ;
 73  	 -- do not mimic count to 0 and 1 as any value > 1 is a dimension symmetry error
 74  	 RETURN l_result;
 75    END has_axis_max_pos_parent
 76    ;
 77  
 78  
 79    FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 80  	 RETURN VARCHAR2
 81    IS
 82  	 l_result VARCHAR2(32000);
 83    BEGIN
 84  	 IF usim_spo.has_data(p_usim_id_spc) = 1
 85  	 THEN
 86  	   l_result := '' || usim_spo.get_dim_coord(p_usim_id_spc, 1) || ',' || usim_spo.get_dim_coord(p_usim_id_spc, 2) || ',' || usim_spo.get_dim_coord(p_usim_id_spc, 3);
 87  	   RETURN TRIM(l_result);
 88  	 ELSE
 89  	   usim_erl.log_error('usim_spo.get_xyz', 'Used with space id [' || p_usim_id_spc || '] not in USIM_SPC_POS.');
 90  	   RETURN NULL;
 91  	 END IF;
 92    END get_xyz
 93    ;
 94  
 95    FUNCTION get_dim_coord( p_usim_id_spc	  IN usim_space.usim_id_spc%TYPE
 96  			     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
 97  			     )
 98  	 RETURN usim_position.usim_coordinate%TYPE
 99    IS
100  	 l_result usim_position.usim_coordinate%TYPE;
101    BEGIN
102  	 IF usim_spo.has_data(p_usim_id_spc) = 1
103  	 THEN
104  	     WITH dim AS
105  		  (SELECT p_usim_n_dimension AS usim_n_dimension FROM dual)
106  		, coords AS
107  		  (SELECT usim_n_dimension
108  			, usim_coordinate
109  		     FROM usim_spo_v
110  		    WHERE usim_id_spc = p_usim_id_spc
111  		  )
112  	   SELECT NVL(usim_coordinate, 0)
113  	     INTO l_result
114  	     FROM dim
115  	     LEFT OUTER JOIN coords
116  	       ON dim.usim_n_dimension = coords.usim_n_dimension
117  	   ;
118  	   RETURN l_result;
119  	 ELSE
120  	   usim_erl.log_error('usim_spo.get_dim_coord', 'Used with space id [' || p_usim_id_spc || '] not in USIM_SPC_POS or not available dimension [' || p_usim_n_dimension || '].');
121  	   RETURN NULL;
122  	 END IF;
123    END get_dim_coord
124    ;
125  
126    FUNCTION get_magnitude( p_usim_id_spc	  IN usim_space.usim_id_spc%TYPE
127  			     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
128  			     )
129  	 RETURN NUMBER
130    IS
131  	 l_sum	  NUMBER;
132  	 l_result NUMBER;
133    BEGIN
134  	 IF usim_spc.has_data(p_usim_id_spc) = 0
135  	 THEN
136  	   usim_erl.log_error('usim_spo.get_magnitude', 'Used with not existing space id [' || p_usim_id_spc || ']');
137  	 END IF;
138  	 l_result := 0;
139  	 l_sum	  := 0;
140  	 FOR l_idx IN 1..p_usim_n_dimension
141  	 LOOP
142  	   l_sum := l_sum + POWER(usim_spo.get_dim_coord(p_usim_id_spc, l_idx), 2);
143  	 END LOOP;
144  	 l_result := SQRT(l_sum);
145  	 RETURN l_result;
146    END get_magnitude
147    ;
148  
149    FUNCTION get_coord_id(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
150  	 RETURN VARCHAR2
151    IS
152  	 l_coord_id VARCHAR2(32767);
153  	 l_max_dim  NUMBER;
154    BEGIN
155  	 IF usim_spo.has_data(p_usim_id_spc) = 1
156  	 THEN
157  	   l_max_dim  := usim_base.get_max_dimension;
158  	   l_coord_id := '';
159  	   FOR l_dim IN 0..l_max_dim
160  	   LOOP
161  	     -- check size before
162  	     IF LENGTH(l_coord_id) + LENGTH(',' || usim_spo.get_dim_coord(p_usim_id_spc, l_dim)) > 32767
163  	     THEN
164  	       usim_erl.log_error('usim_spo.get_coord_id', 'Too much dimensions to build coordinate id within system limits for space id [' || p_usim_id_spc || '].');
165  	       RETURN NULL;
166  	     END IF;
167  	     IF l_dim = 0
168  	     THEN
169  	       l_coord_id := l_coord_id || usim_spo.get_dim_coord(p_usim_id_spc, l_dim);
170  	     ELSE
171  	       l_coord_id := l_coord_id || ',' || usim_spo.get_dim_coord(p_usim_id_spc, l_dim);
172  	     END IF;
173  	   END LOOP;
174  	   RETURN l_coord_id;
175  	 ELSE
176  	   usim_erl.log_error('usim_spo.get_coord_id', 'Used with invalid space id [' || p_usim_id_spc || '].');
177  	   RETURN NULL;
178  	 END IF;
179    END get_coord_id
180    ;
181  
182    FUNCTION is_axis_zero_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
183  	 RETURN NUMBER
184    IS
185  	 l_result NUMBER;
186    BEGIN
187  	 SELECT COUNT(*)
188  	   INTO l_result
189  	   FROM usim_spo_v
190  	  WHERE usim_id_spc	 = p_usim_id_spc
191  	    AND usim_coordinate != 0
192  	 ;
193  
194  	 RETURN (CASE WHEN l_result > 0 THEN 0 ELSE 1 END);
195    END is_axis_zero_pos
196    ;
197  
198    FUNCTION is_axis_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
199  	 RETURN NUMBER
200    IS
201  	 l_result NUMBER;
202    BEGIN
203  	 -- zero axis is axis
204  	 IF usim_spo.is_axis_zero_pos(p_usim_id_spc) = 1
205  	 THEN
206  	   RETURN 1;
207  	 END IF;
208  	 -- get axis if not zero axis
209  	 SELECT COUNT(*)
210  	   INTO l_result
211  	   FROM usim_spo_v
212  	  WHERE usim_coordinate != 0
213  	    AND usim_id_spc	 = p_usim_id_spc
214  	  GROUP BY usim_id_spc
215  	 ;
216  	 IF l_result = 1
217  	 THEN
218  	   RETURN 1;
219  	 ELSE
220  	   RETURN 0;
221  	 END IF;
222    END is_axis_pos
223    ;
224  
225    FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
226  	 RETURN usim_space.usim_id_spc%TYPE
227    IS
228  	 l_result	     usim_space.usim_id_spc%TYPE;
229    BEGIN
230  	 IF usim_spo.has_axis_max_pos_parent(p_usim_id_spc) = 1
231  	 THEN
232  	   -- fetch data
233  	     WITH known AS
234  		  (SELECT usim_id_spc
235  			, usim_spo.is_axis_pos(usim_id_spc) AS is_axis
236  			, usim_coordinate
237  			, usim_id_rmd
238  			, dim_sign
239  		     FROM usim_spc_v
240  		    WHERE usim_id_rmd = (SELECT usim_id_rmd FROM usim_space WHERE usim_id_spc = p_usim_id_spc)
241  		  )
242  		, maxpos AS
243  		  (SELECT CASE
244  			    WHEN dim_sign >= 0
245  			    THEN MAX(usim_coordinate)
246  			    ELSE MIN(usim_coordinate)
247  			  END			      AS parent_pos
248  			, usim_id_rmd
249  			, dim_sign
250  		     FROM known
251  		    WHERE is_axis = 1
252  		    GROUP BY usim_id_rmd
253  			   , dim_sign
254  		  )
255  	   SELECT known.usim_id_spc
256  	     INTO l_result
257  	     FROM known
258  	    INNER JOIN maxpos
259  	       ON known.usim_coordinate  = maxpos.parent_pos
260  	      AND known.usim_id_rmd	 = maxpos.usim_id_rmd
261  	      AND known.dim_sign	 = maxpos.dim_sign
262  	    WHERE known.is_axis = 1
263  	   ;
264  	   RETURN l_result;
265  	 ELSE
266  	   RETURN NULL;
267  	 END IF;
268    END get_axis_max_pos_parent
269    ;
270  
271    FUNCTION get_axis_zero_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
272  	 RETURN usim_space.usim_id_spc%TYPE
273    IS
274  	 l_result	     usim_space.usim_id_spc%TYPE;
275    BEGIN
276  	 -- fetch data
277  	   WITH known AS
278  		(SELECT usim_id_spc
279  		      , usim_spo.is_axis_pos(usim_id_spc) AS is_axis
280  		      , usim_coordinate
281  		      , usim_id_rmd
282  		      , dim_sign
283  		   FROM usim_spc_v
284  		  WHERE usim_id_rmd	= (SELECT usim_id_rmd FROM usim_space WHERE usim_id_spc = p_usim_id_spc)
285  		    AND usim_coordinate = 0
286  		)
287  	 SELECT known.usim_id_spc
288  	   INTO l_result
289  	   FROM known
290  	  WHERE known.is_axis = 1
291  	 ;
292  	 RETURN l_result;
293    END get_axis_zero_pos_parent
294    ;
295  
296    FUNCTION insert_spc_pos( p_usim_id_spc	     IN usim_space.usim_id_spc%TYPE
297  			      , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
298  			      , p_do_commit	     IN BOOLEAN 		    DEFAULT TRUE
299  			      )
300  	 RETURN NUMBER
301    IS
302  	 l_dim	   usim_dimension.usim_n_dimension%TYPE;
303  	 l_id_mlv  usim_multiverse.usim_id_mlv%TYPE;
304  
305  	 CURSOR cur_dims( cp_usim_id_spc	IN usim_space.usim_id_spc%TYPE
306  			, cp_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
307  			, cp_usim_id_mlv	IN usim_multiverse.usim_id_mlv%TYPE
308  			)
309  	 IS
310  	     WITH org_dim AS
311  		  (SELECT /*+MATERIALIZE */
312  			  usim_n_dimension
313  		     FROM usim_spo_v
314  		    WHERE usim_id_spc = cp_usim_id_spc
315  			  -- consider only the universe of the given new space id
316  		      AND usim_id_mlv = cp_usim_id_mlv
317  		  )
318  	   SELECT usim_id_rmd
319  		, usim_id_pos
320  	     FROM usim_spo_v
321  		  -- parent might be in a different universe, so no positions are added from other universes
322  	    WHERE usim_id_spc		= cp_usim_id_spc_parent
323  	      AND usim_id_mlv		= cp_usim_id_mlv
324  	      AND usim_n_dimension NOT IN (SELECT usim_n_dimension FROM org_dim)
325  -- not sure if to exclude 0 coordinates and dimensions
326  -- 	AND (	usim_coordinate  != 0
327  -- 	     OR usim_n_dimension  = 0
328  -- 	    )
329  	 ;
330    BEGIN
331  	 IF usim_spo.has_data(p_usim_id_spc) = 0
332  	 THEN
333  	   -- insert the new space id
334  	   INSERT INTO usim_spc_pos
335  	     ( usim_id_spc
336  	     , usim_id_rmd
337  	     , usim_id_pos
338  	     )
339  	     SELECT usim_id_spc
340  		  , usim_id_rmd
341  		  , usim_id_pos
342  	       FROM usim_space
343  	      WHERE usim_id_spc = p_usim_id_spc
344  	   ;
345  	 END IF;
346  	 -- check parent
347  	 IF usim_spo.has_data(p_usim_id_spc_parent) = 1
348  	 THEN
349  	   l_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
350  	   -- only lower dimension not present and position > 0, missing dimensions means 0 position in this dimension
351  	   FOR rec IN cur_dims(p_usim_id_spc, p_usim_id_spc_parent, l_id_mlv)
352  	   LOOP
353  	     INSERT INTO usim_spc_pos
354  	       ( usim_id_spc
355  	       , usim_id_rmd
356  	       , usim_id_pos
357  	       )
358  	       VALUES
359  	       ( p_usim_id_spc
360  	       , rec.usim_id_rmd
361  	       , rec.usim_id_pos
362  	       )
363  	     ;
364  	   END LOOP;
365  	 ELSE
366  	   -- if parent is NULL and dimension is 0, everything okay, only one entry otherwise error
367  	   IF p_usim_id_spc_parent IS NOT NULL
368  	   THEN
369  	     SELECT usim_n_dimension INTO l_dim FROM usim_spc_v WHERE usim_id_spc = p_usim_id_spc;
370  	     IF l_dim != 0
371  	     THEN
372  	       ROLLBACK;
373  	       usim_erl.log_error('usim_spo.insert_spc_pos', 'Used with invalid parent space id [' || p_usim_id_spc_parent || '] or wrong dimension > 0.');
374  	       RETURN 0;
375  	     END IF;
376  	   END IF;
377  	 END IF;
378  	 -- everything done, do commit if needed
379  	 IF p_do_commit
380  	 THEN
381  	   COMMIT;
382  	 END IF;
383  	 RETURN 1;
384    END insert_spc_pos
385    ;
386  
387  END usim_spo;
388  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_spo
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_spo

Package body created.

SQL> -- package depend view
SQL> @@../VIEW/USIM_SPO_XYZ_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_SPO_XYZ_V (xyzv)
SQL> CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spo_xyz_v AS
  2    SELECT usim_id_spc
  3  	    , usim_process_spin
  4  	    , usim_spo.get_dim_coord(usim_id_spc, 1) AS x_coord
  5  	    , usim_spo.get_dim_coord(usim_id_spc, 2) AS y_coord
  6  	    , usim_spo.get_dim_coord(usim_id_spc, 3) AS z_coord
  7  	    , usim_spo.get_xyz(usim_id_spc) AS xyz_coord
  8  	    , usim_n_dimension
  9  	    , dim_sign
 10  	    , dim_n1_sign
 11  	    , usim_id_mlv
 12  	    , usim_energy
 13  	 FROM usim_spc_v
 14  ;
old   1: CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spo_xyz_v AS
new   1: CREATE OR REPLACE VIEW USIM_TEST.usim_spo_xyz_v AS

View created.

SQL> @@../VIEW/USIM_SPO_BASE3D_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_SPO_BASE3D_V (spb3d)
SQL> CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spo_base3d_v AS
  2  	 WITH base AS
  3  	      (SELECT /*+ MATERIALIZE */
  4  		      usim_spo.get_xyz(chi.usim_id_spc) 	 AS src_xyz
  5  		    , usim_spo.get_xyz(chi.usim_id_spc_child)	 AS tgt_xyz
  6  		    , usim_spo.get_magnitude(chi.usim_id_spc, 3) AS src_mag
  7  		    , src.usim_n_dimension			 AS src_dim
  8  		    , tgt.usim_n_dimension			 AS tgt_dim
  9  		    , src.dim_sign				 AS src_dim_sign
 10  		    , tgt.dim_sign				 AS tgt_dim_sign
 11  		    , src.usim_id_mlv				 AS src_id_mlv
 12  		 FROM usim_spc_child chi
 13  		 LEFT OUTER JOIN usim_spc_v src
 14  		   ON chi.usim_id_spc = src.usim_id_spc
 15  		 LEFT OUTER JOIN usim_spc_v tgt
 16  		   ON chi.usim_id_spc_child = tgt.usim_id_spc
 17  		WHERE src.usim_n_dimension <= 3
 18  		  AND tgt.usim_n_dimension <= 3
 19  		  AND src.usim_id_mlv	    = tgt.usim_id_mlv -- no inter universe connects
 20  	      )
 21  	    , grp_prep AS
 22  	      (SELECT src_xyz
 23  		    , tgt_xyz
 24  		    , src_mag
 25  		    , CASE
 26  			WHEN src_xyz = '0,0,0'
 27  			 AND src_xyz = tgt_xyz
 28  			THEN 0
 29  			ELSE src_dim
 30  		      END			 AS src_dim
 31  		    , CASE
 32  			WHEN src_xyz = '0,0,0'
 33  			 AND src_xyz = tgt_xyz
 34  			THEN 1
 35  			ELSE tgt_dim
 36  		      END			 AS tgt_dim
 37  		    , CASE
 38  			WHEN src_xyz = '0,0,0'
 39  			 AND src_xyz = tgt_xyz
 40  			THEN 0
 41  			ELSE src_dim_sign
 42  		      END			 AS src_dim_sign
 43  		    , CASE
 44  			WHEN src_xyz = '0,0,0'
 45  			 AND src_xyz = tgt_xyz
 46  			THEN 0
 47  			ELSE tgt_dim_sign
 48  		      END			 AS tgt_dim_sign
 49  		    , src_id_mlv
 50  		 FROM base
 51  	      )
 52    SELECT src_xyz
 53  	    , tgt_xyz
 54  	    , src_mag
 55  	    , src_dim
 56  	    , tgt_dim
 57  	    , src_dim_sign
 58  	    , tgt_dim_sign
 59  	    , src_id_mlv     AS usim_id_mlv
 60  	 FROM grp_prep
 61  	GROUP BY src_id_mlv
 62  	       , src_xyz
 63  	       , tgt_xyz
 64  	       , src_mag
 65  	       , src_dim
 66  	       , tgt_dim
 67  	       , src_dim_sign
 68  	       , tgt_dim_sign
 69  	ORDER BY src_id_mlv
 70  	       , src_mag
 71  	       , src_dim
 72  	       , tgt_dim
 73  	       , src_dim_sign DESC
 74  	       , tgt_dim_sign DESC
 75  	       , src_xyz
 76  	       , tgt_xyz
 77  ;
old   1: CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spo_base3d_v AS
new   1: CREATE OR REPLACE VIEW USIM_TEST.usim_spo_base3d_v AS

View created.

SQL> @@../VIEW/USIM_SPO_ZERO3D_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_SPO_ZERO3D_V (spz3d)
SQL> CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spo_zero3d_v AS
  2  	 WITH base AS
  3  	      (SELECT /*+ MATERIALIZE */
  4  		      usim_spo.get_xyz(chi.usim_id_spc) 	 AS src_xyz
  5  		    , usim_spo.get_xyz(chi.usim_id_spc_child)	 AS tgt_xyz
  6  		    , usim_spo.get_magnitude(chi.usim_id_spc, 3) AS src_mag
  7  		    , src.usim_n_dimension			 AS src_dim
  8  		    , tgt.usim_n_dimension			 AS tgt_dim
  9  		    , src.dim_sign				 AS src_dim_sign
 10  		    , tgt.dim_sign				 AS tgt_dim_sign
 11  		    , src.dim_n1_sign				 AS src_n1_sign
 12  		    , tgt.dim_n1_sign				 AS tgt_n1_sign
 13  		    , src.usim_id_mlv				 AS src_id_mlv
 14  		 FROM usim_spc_child chi
 15  		 LEFT OUTER JOIN usim_spc_v src
 16  		   ON chi.usim_id_spc = src.usim_id_spc
 17  		 LEFT OUTER JOIN usim_spc_v tgt
 18  		   ON chi.usim_id_spc_child = tgt.usim_id_spc
 19  		WHERE src.usim_n_dimension <= 3
 20  		  AND tgt.usim_n_dimension <= 3
 21  		  AND src.usim_id_mlv	    = tgt.usim_id_mlv -- no inter universe connects
 22  	      )
 23    SELECT src_xyz
 24  	    , tgt_xyz
 25  	    , src_mag
 26  	    , src_dim
 27  	    , tgt_dim
 28  	    , src_dim_sign
 29  	    , tgt_dim_sign
 30  	    , src_n1_sign
 31  	    , tgt_n1_sign
 32  	    , src_id_mlv     AS usim_id_mlv
 33  	 FROM base
 34  	GROUP BY src_id_mlv
 35  	       , src_xyz
 36  	       , tgt_xyz
 37  	       , src_mag
 38  	       , src_dim
 39  	       , tgt_dim
 40  	       , src_dim_sign
 41  	       , tgt_dim_sign
 42  	       , src_n1_sign
 43  	       , tgt_n1_sign
 44  	ORDER BY src_id_mlv
 45  	       , src_mag
 46  	       , src_dim
 47  	       , tgt_dim
 48  	       , src_dim_sign DESC
 49  	       , tgt_dim_sign DESC
 50  	       , src_n1_sign DESC
 51  	       , tgt_n1_sign DESC
 52  	       , src_xyz
 53  	       , tgt_xyz
 54  ;
old   1: CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spo_zero3d_v AS
new   1: CREATE OR REPLACE VIEW USIM_TEST.usim_spo_zero3d_v AS

View created.

SQL> -- USIM_SPC_PROCESS (SPR)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_SPC_PROCESS_TBL.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_SPC_PROCESS still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_SPC_PROCESS'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
-------------------------------------------------------------------------
../TABLES/USIM_SPC_PROCESS_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_SPC_PROCESS (SPR)
SQL> CREATE TABLE &USIM_SCHEMA..usim_spc_process
  2    ( usim_id_spr	    CHAR(55)			 NOT NULL ENABLE
  3    , usim_planck_aeon   CHAR(55)			 NOT NULL ENABLE
  4    , usim_planck_time   NUMBER			 NOT NULL ENABLE
  5    , usim_id_spc_source CHAR(55)			 NOT NULL ENABLE
  6    , usim_id_spc_target CHAR(55)			 NOT NULL ENABLE
  7    , usim_real_time     DATE	 DEFAULT SYSDATE NOT NULL ENABLE
  8    , is_processed	    NUMBER(1, 0) DEFAULT 0	 NOT NULL ENABLE
  9    , usim_energy_source NUMBER
 10    , usim_energy_target NUMBER
 11    , usim_energy_output NUMBER
 12    )
 13    PARTITION BY RANGE (usim_real_time)
 14  	 INTERVAL (NUMTODSINTERVAL(1, 'DAY'))
 15  	 (PARTITION p_first VALUES LESS THAN (TO_DATE('01.01.2023', 'DD.MM.YYYY')))
 16  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_spc_process
new   1: CREATE TABLE USIM_TEST.usim_spc_process

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_spc_process IS 'Holds the log of all space activity. Will use the alias spr.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_spc_process IS 'Holds the log of all space activity. Will use the alias spr.'
new   1: COMMENT ON TABLE USIM_TEST.usim_spc_process IS 'Holds the log of all space activity. Will use the alias spr.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_id_spr IS 'The unique id of a process step. Will be set on insert.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_id_spr IS 'The unique id of a process step. Will be set on insert.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_id_spr IS 'The unique id of a process step. Will be set on insert.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_planck_aeon IS 'The current planck aeon of the energy output. Only insert allowed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_planck_aeon IS 'The current planck aeon of the energy output. Only insert allowed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_planck_aeon IS 'The current planck aeon of the energy output. Only insert allowed.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_planck_time IS 'The current planck time relative to the planck aeon of the energy output. Only insert allowed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_planck_time IS 'The current planck time relative to the planck aeon of the energy output. Only insert allowed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_planck_time IS 'The current planck time relative to the planck aeon of the energy output. Only insert allowed.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_id_spc_source IS 'The space node id of the energy source, which will output energy to the target. Only insert allowed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_id_spc_source IS 'The space node id of the energy source, which will output energy to the target. Only insert allowed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_id_spc_source IS 'The space node id of the energy source, which will output energy to the target. Only insert allowed.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_id_spc_target IS 'The space node id of the target, which will receive the energy output from the source. Only insert allowed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_id_spc_target IS 'The space node id of the target, which will receive the energy output from the source. Only insert allowed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_id_spc_target IS 'The space node id of the target, which will receive the energy output from the source. Only insert allowed.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_real_time IS 'The real date time of the simulation. Automatically set.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_real_time IS 'The real date time of the simulation. Automatically set.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_real_time IS 'The real date time of the simulation. Automatically set.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.is_processed IS 'The indicator for processed outputs. On creation 0, after output applied 1, if universe of target not valid 2. Only updates allowed. Any update sets this to 1 (processed).';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.is_processed IS 'The indicator for processed outputs. On creation 0, after output applied 1, if universe of target not valid 2. Only updates allowed. Any update sets this to 1 (processed).'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_process.is_processed IS 'The indicator for processed outputs. On creation 0, after output applied 1, if universe of target not valid 2. Only updates allowed. Any update sets this to 1 (processed).'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_energy_source IS 'The energy of the source, which was the base of the calculated output before processing. Only insert allowed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_energy_source IS 'The energy of the source, which was the base of the calculated output before processing. Only insert allowed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_energy_source IS 'The energy of the source, which was the base of the calculated output before processing. Only insert allowed.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_energy_target IS 'The energy of the target before processing. Only insert allowed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_energy_target IS 'The energy of the target before processing. Only insert allowed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_energy_target IS 'The energy of the target before processing. Only insert allowed.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_energy_output IS 'The output energy of the source that has to be applied to the target. Only insert allowed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_spc_process.usim_energy_output IS 'The output energy of the source that has to be applied to the target. Only insert allowed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_spc_process.usim_energy_output IS 'The output energy of the source that has to be applied to the target. Only insert allowed.'

Comment created.

SQL> 
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_process
  2    ADD CONSTRAINT usim_spr_pk
  3    PRIMARY KEY (usim_id_spr)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_spc_process
new   1: ALTER TABLE USIM_TEST.usim_spc_process

Table altered.

SQL> -- indexes
SQL> CREATE INDEX &USIM_SCHEMA..usim_spr_src_idx
  2  	 ON &USIM_SCHEMA..usim_spc_process
  3  	    ( usim_planck_aeon
  4  	    , usim_planck_time
  5  	    , usim_id_spc_source
  6  	    )
  7  ;
old   1: CREATE INDEX &USIM_SCHEMA..usim_spr_src_idx
new   1: CREATE INDEX USIM_TEST.usim_spr_src_idx
old   2:     ON &USIM_SCHEMA..usim_spc_process
new   2:     ON USIM_TEST.usim_spc_process

Index created.

SQL> 
SQL> CREATE INDEX &USIM_SCHEMA..usim_spr_tgt_idx
  2  	 ON &USIM_SCHEMA..usim_spc_process
  3  	    ( usim_planck_aeon
  4  	    , usim_planck_time
  5  	    , usim_id_spc_target
  6  	    )
  7  ;
old   1: CREATE INDEX &USIM_SCHEMA..usim_spr_tgt_idx
new   1: CREATE INDEX USIM_TEST.usim_spr_tgt_idx
old   2:     ON &USIM_SCHEMA..usim_spc_process
new   2:     ON USIM_TEST.usim_spc_process

Index created.

SQL> -- constraints
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_process
  2    ADD CONSTRAINT usim_processed_chk
  3    CHECK (is_processed IN (0, 1, 2))
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_spc_process
new   1: ALTER TABLE USIM_TEST.usim_spc_process

Table altered.

SQL> 
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spr_ins_trg
  2    -- set insert values that can not be changed on insert
  3    BEFORE INSERT ON &USIM_SCHEMA..usim_spc_process
  4  	 FOR EACH ROW
  5  	 BEGIN
  6  	   -- ignore input on pk, is_processed and real time
  7  	   :NEW.usim_id_spr := usim_static.get_big_pk(usim_spr_id_seq.NEXTVAL);
  8  	   :NEW.is_processed   := 0;
  9  	   :NEW.usim_real_time := SYSDATE;
 10  	 END;
 11   /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spr_ins_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_spr_ins_trg
old   3:   BEFORE INSERT ON &USIM_SCHEMA..usim_spc_process
new   3:   BEFORE INSERT ON USIM_TEST.usim_spc_process

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_spr_ins_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_spr_ins_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_spr_ins_trg ENABLE

Trigger altered.

SQL>  -- update trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spr_upd_trg
  2    -- set insert values that can not be changed on insert
  3    BEFORE UPDATE ON &USIM_SCHEMA..usim_spc_process
  4  	 FOR EACH ROW
  5  	 BEGIN
  6  	   IF :NEW.usim_id_spr != :OLD.usim_id_spr
  7  	   THEN
  8  	     :NEW.usim_id_spr := :OLD.usim_id_spr;
  9  	   END IF;
 10  	   IF :NEW.usim_planck_aeon != :OLD.usim_planck_aeon
 11  	   THEN
 12  	     :NEW.usim_planck_aeon := :OLD.usim_planck_aeon;
 13  	   END IF;
 14  	   IF :NEW.usim_planck_time != :OLD.usim_planck_time
 15  	   THEN
 16  	     :NEW.usim_planck_time := :OLD.usim_planck_time;
 17  	   END IF;
 18  	   IF :NEW.usim_id_spc_source != :OLD.usim_id_spc_source
 19  	   THEN
 20  	     :NEW.usim_id_spc_source := :OLD.usim_id_spc_source;
 21  	   END IF;
 22  	   IF :NEW.usim_id_spc_target != :OLD.usim_id_spc_target
 23  	   THEN
 24  	     :NEW.usim_id_spc_target := :OLD.usim_id_spc_target;
 25  	   END IF;
 26  	   IF :NEW.usim_real_time != :OLD.usim_real_time
 27  	   THEN
 28  	     :NEW.usim_real_time := :OLD.usim_real_time;
 29  	   END IF;
 30  	   IF :NEW.usim_energy_source != :OLD.usim_energy_source
 31  	   THEN
 32  	     :NEW.usim_energy_source := :OLD.usim_energy_source;
 33  	   END IF;
 34  	   IF :NEW.usim_energy_target != :OLD.usim_energy_target
 35  	   THEN
 36  	     :NEW.usim_energy_target := :OLD.usim_energy_target;
 37  	   END IF;
 38  	   IF :NEW.usim_energy_output != :OLD.usim_energy_output
 39  	   THEN
 40  	     :NEW.usim_energy_output := :OLD.usim_energy_output;
 41  	   END IF;
 42  	 END;
 43   /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_spr_upd_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_spr_upd_trg
old   3:   BEFORE UPDATE ON &USIM_SCHEMA..usim_spc_process
new   3:   BEFORE UPDATE ON USIM_TEST.usim_spc_process

Trigger created.

SQL>  ALTER TRIGGER &USIM_SCHEMA..usim_spr_upd_trg ENABLE;
old   1:  ALTER TRIGGER &USIM_SCHEMA..usim_spr_upd_trg ENABLE
new   1:  ALTER TRIGGER USIM_TEST.usim_spr_upd_trg ENABLE

Trigger altered.

SQL> -- foreign keys
SQL> @@../FK/USIM_SPR_SRC_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk relation to nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_process
  2    ADD CONSTRAINT usim_spr_src_fk
  3    FOREIGN KEY (usim_id_spc_source) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_spc_process
new   1: ALTER TABLE USIM_TEST.usim_spc_process

Table altered.

SQL> @@../FK/USIM_SPR_TGT_FK.sql
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- fk relation to nodes in usim_space (for documentation, if disabled)
SQL> ALTER TABLE &USIM_SCHEMA..usim_spc_process
  2    ADD CONSTRAINT usim_spr_tgt_fk
  3    FOREIGN KEY (usim_id_spc_target) REFERENCES usim_space (usim_id_spc) ON DELETE CASCADE
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_spc_process
new   1: ALTER TABLE USIM_TEST.usim_spc_process

Table altered.

SQL> -- views
SQL> @@../VIEW/USIM_SPR_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spr_v AS
  2    SELECT spr.is_processed
  3  	    , xyzv_src.xyz_coord	 AS src_xyz -- temporary, must have all dimensions
  4  	    , xyzv_src.usim_process_spin AS src_spin
  5  	    , xyzv_src.usim_n_dimension  AS src_dim
  6  	    , xyzv_src.dim_sign 	 AS src_dim_sign
  7  	    , xyzv_src.dim_n1_sign	 AS src_dim_n1_sign
  8  	    , xyzv_tgt.xyz_coord	 AS tgt_xyz
  9  	    , xyzv_tgt.usim_process_spin AS tgt_spin
 10  	    , xyzv_tgt.usim_n_dimension  AS tgt_dim
 11  	    , xyzv_tgt.dim_sign 	 AS tgt_dim_sign
 12  	    , xyzv_tgt.dim_n1_sign	 AS tgt_dim_n1_sign
 13  	    , spr.usim_energy_source
 14  	    , spr.usim_energy_output
 15  	    , spr.usim_energy_target
 16  	    , spr.usim_id_spc_source
 17  	    , spr.usim_id_spc_target
 18  	    , xyzv_src.usim_id_mlv	 AS src_id_mlv
 19  	    , xyzv_tgt.usim_id_mlv	 AS tgt_id_mlv
 20  	    , spr.usim_planck_aeon
 21  	    , spr.usim_planck_time
 22  	    , spr.usim_real_time
 23  	 FROM usim_spc_process spr
 24  	 LEFT OUTER JOIN usim_spo_xyz_v xyzv_src
 25  	   ON spr.usim_id_spc_source = xyzv_src.usim_id_spc
 26  	 LEFT OUTER JOIN usim_spo_xyz_v xyzv_tgt
 27  	   ON spr.usim_id_spc_target = xyzv_tgt.usim_id_spc
 28  	      -- provide basic process order as ROWID can only be accessed from here
 29  	ORDER BY spr.usim_planck_aeon
 30  	       , spr.usim_planck_time
 31  	       , spr.usim_real_time
 32  		 -- use ROWID order for processes to fast for real time and planck time
 33  	       , spr.ROWID ASC
 34  ;
old   1: CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_spr_v AS
new   1: CREATE OR REPLACE VIEW USIM_TEST.usim_spr_v AS

View created.

SQL> -- usim_spc_process package
SQL> @@../PACKAGES/USIM_SPR.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_spr
  2  IS
  3    /**A low level package for actions on table usim_spc_process and its associated
  4    * views. Views can be seen as interfaces and dependency. No other package dependencies
  5    * apart from USIM_BASE and USIM_SPC. ATTENTION Package may throw exceptions
  6    * from constraints, triggers and foreign keys. Caller is responsible to handle
  7    * possible exceptions.
  8    */
  9  
 10    /**
 11    * Checks if usim_spc_process has already data.
 12    * @return Returns 1 if data are available, otherwise 0.
 13    */
 14    FUNCTION has_data
 15  	 RETURN NUMBER
 16    ;
 17  
 18    /**
 19    * Checks if usim_spc_process has already data for a given process id.
 20    * @param p_usim_id_spr The process id to check.
 21    * @return Returns 1 if data are available for this id, otherwise 0.
 22    */
 23    FUNCTION has_data(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
 24  	 RETURN NUMBER
 25    ;
 26  
 27    /**
 28    * Checks if usim_spc_process has unprocessed data.
 29    * @return Returns 1 if unprocessed data are available, otherwise 0.
 30    */
 31    FUNCTION has_unprocessed
 32  	 RETURN NUMBER
 33    ;
 34  
 35    /**
 36    * Checks if the current unprocessed queue is valid. All unprocessed records must have the current
 37    * planck aeon and time and if the table is not empty, there must be at least 2 process records.
 38    * Count of process records must be a multitude of 2. An empty table will also return 1.
 39    * @return Returns 1 if queue is ready to be processed, otherwise error code: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
 40    */
 41    FUNCTION is_queue_valid
 42  	 RETURN NUMBER
 43    ;
 44  
 45    /**
 46    * Fetches the current planck aeon and time if the queue is valid. Will not operate on empty tables.
 47    * @param p_usim_planck_aeon The planck aeon for the current unprocessed records.
 48    * @param p_usim_planck_time The planck time for the current unprocessed records.
 49    * @return Returns 1 if planck data could be fetched, otherwise error code from USIM_SPR.IS_QUEUE_VALID: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
 50    */
 51    FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
 52  				      , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
 53  				      )
 54  	 RETURN NUMBER
 55    ;
 56  
 57    /**
 58    * Inserts a new process record with status IS_PROCESSED = 0 and current real time, planck aeon
 59    * and planck tick.
 60    * @param p_usim_id_spc_source The space id of the process that emits energy. Must exist.
 61    * @param p_usim_id_spc_target The space id of the process that receives energy. Must exist.
 62    * @param p_usim_energy_source The energy of the source before processing. NULL not allowed.
 63    * @param p_usim_energy_target The energy of the target before processing.
 64    * @param p_usim_energy_output The energy output of the source before processing. NULL not allowed.
 65    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 66    * @return Returns the new unique process id or NULL on errors. May throw exceptions on number inserts causing overflows.
 67    */
 68    FUNCTION insert_spr( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
 69  			  , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
 70  			  , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
 71  			  , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
 72  			  , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
 73  			  , p_do_commit 	 IN BOOLEAN				     DEFAULT TRUE
 74  			  )
 75  	 RETURN usim_spc_process.usim_id_spr%TYPE
 76    ;
 77  
 78    /**
 79    * Sets the given process step to processed.
 80    * @param p_usim_id_spr The process id of the process that should be set to processed. Must exist.
 81    * @param p_process_state The process state to set. 1=processed, 2=universe not active, not processed. Default is 1.
 82    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 83    * @return Returns 1 if processed state could be set otherwise 0.
 84    */
 85    FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
 86  			     , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
 87  			     , p_do_commit     IN BOOLEAN			     DEFAULT TRUE
 88  			     )
 89  	 RETURN NUMBER
 90    ;
 91  
 92  END usim_spr;
 93  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_spr
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_spr

Package created.

SQL> @@../PACKAGES/USIM_SPR.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_spr
  2  IS
  3    -- see header for documentation
  4  
  5    FUNCTION has_data
  6  	 RETURN NUMBER
  7    IS
  8  	 l_result NUMBER;
  9    BEGIN
 10  	 SELECT COUNT(*) INTO l_result FROM usim_spc_process;
 11  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 12    END has_data
 13    ;
 14  
 15    FUNCTION has_data(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
 16  	 RETURN NUMBER
 17    IS
 18  	 l_result NUMBER;
 19    BEGIN
 20  	 SELECT COUNT(*) INTO l_result FROM usim_spc_process WHERE usim_id_spr = p_usim_id_spr;
 21  	 RETURN l_result;
 22    END has_data
 23    ;
 24  
 25    FUNCTION has_unprocessed
 26  	 RETURN NUMBER
 27    IS
 28  	 l_result NUMBER;
 29    BEGIN
 30  	 SELECT COUNT(*) INTO l_result FROM usim_spc_process WHERE is_processed = 0;
 31  	 RETURN (CASE WHEN l_result = 0 THEN l_result ELSE 1 END);
 32    END has_unprocessed
 33    ;
 34  
 35    FUNCTION is_queue_valid
 36  	 RETURN NUMBER
 37    IS
 38  	 l_count       NUMBER;
 39  	 l_planck_aeon usim_spc_process.usim_planck_aeon%TYPE;
 40  	 l_planck_time usim_spc_process.usim_planck_time%TYPE;
 41    BEGIN
 42  	 IF usim_spr.has_data = 0
 43  	 THEN
 44  	   RETURN 1;
 45  	 ELSE
 46  	   IF usim_spr.has_unprocessed = 0
 47  	   THEN
 48  	     RETURN 0;
 49  	   END IF;
 50  	   SELECT COUNT(*) INTO l_count FROM (SELECT usim_planck_aeon, usim_planck_time FROM usim_spc_process WHERE is_processed = 0 GROUP BY usim_planck_aeon, usim_planck_time);
 51  	   IF l_count != 1
 52  	   THEN
 53  	     RETURN -1;
 54  	   END IF;
 55  	   SELECT COUNT(*) INTO l_count FROM usim_spc_process WHERE is_processed = 0;
 56  	   IF MOD(l_count, 2) != 0
 57  	   THEN
 58  	     RETURN -2;
 59  	   END IF;
 60  	   SELECT usim_planck_aeon, usim_planck_time INTO l_planck_aeon, l_planck_time FROM usim_spc_process WHERE is_processed = 0 GROUP BY usim_planck_aeon, usim_planck_time;
 61  	   IF	 usim_base.get_planck_aeon_seq_current != l_planck_aeon
 62  	      OR usim_base.get_planck_time_current     != l_planck_time
 63  	   THEN
 64  	     RETURN -1;
 65  	   END IF;
 66  	   -- all checks passed
 67  	   RETURN 1;
 68  	 END IF;
 69    END is_queue_valid
 70    ;
 71  
 72    FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
 73  				      , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
 74  				      )
 75  	 RETURN NUMBER
 76    IS
 77  	 l_return NUMBER;
 78    BEGIN
 79  	 -- can't process not existing data
 80  	 IF usim_spr.has_data = 0
 81  	 THEN
 82  	   RETURN 0;
 83  	 END IF;
 84  	 l_return := usim_spr.is_queue_valid;
 85  	 IF l_return = 1
 86  	 THEN
 87  	   SELECT usim_planck_aeon, usim_planck_time INTO p_usim_planck_aeon, p_usim_planck_time FROM usim_spc_process WHERE is_processed = 0 GROUP BY usim_planck_aeon, usim_planck_time;
 88  	 END IF;
 89  	 RETURN l_return;
 90    END get_unprocessed_planck
 91    ;
 92  
 93    FUNCTION insert_spr( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
 94  			  , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
 95  			  , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
 96  			  , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
 97  			  , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
 98  			  , p_do_commit 	 IN BOOLEAN				     DEFAULT TRUE
 99  			  )
100  	 RETURN usim_spc_process.usim_id_spr%TYPE
101    IS
102  	 l_result usim_spc_process.usim_id_spr%TYPE;
103    BEGIN
104  	 -- check parameters
105  	 IF	usim_spc.has_data(p_usim_id_spc_source) = 1
106  	    AND usim_spc.has_data(p_usim_id_spc_target) = 1
107  	    AND p_usim_energy_source		       IS NOT NULL
108  	    AND p_usim_energy_output		       IS NOT NULL
109  	 THEN
110  	   INSERT INTO usim_spc_process
111  	     ( usim_planck_aeon
112  	     , usim_planck_time
113  	     , usim_id_spc_source
114  	     , usim_id_spc_target
115  	     , usim_energy_source
116  	     , usim_energy_target
117  	     , usim_energy_output
118  	     )
119  	     VALUES
120  	     ( usim_base.get_planck_aeon_seq_current
121  	     , usim_base.get_planck_time_current
122  	     , p_usim_id_spc_source
123  	     , p_usim_id_spc_target
124  	     , p_usim_energy_source
125  	     , p_usim_energy_target
126  	     , p_usim_energy_output
127  	     )
128  	     RETURNING usim_id_spr INTO l_result
129  	   ;
130  	   IF p_do_commit
131  	   THEN
132  	     COMMIT;
133  	   END IF;
134  	   RETURN l_result;
135  	 ELSE
136  	   -- constraints not fulfilled
137  	   usim_erl.log_error('usim_spr.insert_spr', 'Constraints not fulfilled for process insert of source id [' || p_usim_id_spc_source || '], target id [' || p_usim_id_spc_target || '], source energy [' || p_usim_energy_source || '] and output energy [' || p_usim_energy_output || '].');
138  	   RETURN NULL;
139  	 END IF;
140    END insert_spr
141    ;
142  
143    FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
144  			     , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
145  			     , p_do_commit     IN BOOLEAN			     DEFAULT TRUE
146  			     )
147  	 RETURN NUMBER
148    IS
149  	 l_target_id usim_space.usim_id_spc%TYPE;
150    BEGIN
151  	 IF	usim_spr.has_data(p_usim_id_spr) = 1
152  	    AND p_process_state 		IN (1, 2)
153  	 THEN
154  	   UPDATE usim_spc_process
155  	      SET is_processed = p_process_state
156  	    WHERE usim_id_spr = p_usim_id_spr
157  	   ;
158  	   IF p_do_commit
159  	   THEN
160  	     COMMIT;
161  	   END IF;
162  	   RETURN 1;
163  	 ELSE
164  	   usim_erl.log_error('usim_spr.set_processed', 'Used with invalid process id [' || p_usim_id_spr || '] or process state [' || p_process_state || '].');
165  	   RETURN 0;
166  	 END IF;
167    END set_processed
168    ;
169  
170  END usim_spr;
171  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_spr
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_spr

Package body created.

SQL> --== relation tables end ==--
SQL> --== other views start ==--
SQL> @@../VIEW/USIM_MLV_STATE_V.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_MLV_STATE_V (mlsv)
SQL> CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_mlv_state_v AS
  2  	 WITH det AS
  3  	      (SELECT usim_id_mlv
  4  		    , dim_n1_sign
  5  		    , SUM(NVL(usim_energy, 0)) AS energy
  6  		 FROM usim_spc_v
  7  		GROUP BY usim_id_mlv
  8  		       , dim_n1_sign
  9  	      )
 10  	    , tot AS
 11  	      (SELECT usim_id_mlv
 12  		    , SUM(NVL(usim_energy, 0)) AS energy
 13  		 FROM usim_spc_v
 14  		GROUP BY usim_id_mlv
 15  	      )
 16  	    , ovr AS
 17  	      (SELECT mlv.usim_id_mlv
 18  		    , usim_static.get_multiverse_status(mlv.usim_universe_status) AS current_status
 19  		    , mlv.usim_is_base_universe
 20  		    , tot.energy AS energy_total
 21  		    , det_base.energy AS energy_base
 22  		    , det_pos.energy AS energy_positive
 23  		    , det_neg.energy AS energy_negative
 24  		    , mlv.usim_universe_status
 25  		    , usim_spr.has_data AS has_process_data
 26  		    , usim_spr.has_unprocessed AS has_unprocessed
 27  		 FROM usim_multiverse mlv
 28  		 LEFT OUTER JOIN det det_neg
 29  		   ON mlv.usim_id_mlv = det_neg.usim_id_mlv
 30  		  AND det_neg.dim_n1_sign = -1
 31  		 LEFT OUTER JOIN det det_pos
 32  		   ON mlv.usim_id_mlv = det_pos.usim_id_mlv
 33  		  AND det_pos.dim_n1_sign = 1
 34  		 LEFT OUTER JOIN det det_base
 35  		   ON mlv.usim_id_mlv = det_base.usim_id_mlv
 36  		  AND det_base.dim_n1_sign IS NULL
 37  		 LEFT OUTER JOIN tot
 38  		   ON mlv.usim_id_mlv = tot.usim_id_mlv
 39  	      )
 40    SELECT usim_id_mlv
 41  	    , usim_base.get_planck_aeon_seq_current  AS planck_aeon
 42  	    , usim_base.get_planck_time_current      AS planck_time
 43  	    , current_status			     AS status_txt
 44  	    , CASE usim_universe_status
 45  		WHEN usim_static.get_multiverse_active
 46  		THEN CASE
 47  		       WHEN has_process_data = 1
 48  			AND energy_base      = 0
 49  		       THEN 1
 50  		       ELSE 0
 51  		     END
 52  		WHEN usim_static.get_multiverse_crashed
 53  		THEN CASE
 54  		       WHEN has_process_data = 1
 55  			AND has_unprocessed  = 0
 56  		       THEN 1
 57  		       WHEN has_process_data  = 1
 58  			AND has_unprocessed   = 1
 59  			AND energy_base      != 0
 60  		       THEN 1
 61  		       ELSE 0
 62  		     END
 63  		WHEN usim_static.get_multiverse_dead
 64  		THEN CASE
 65  		       WHEN has_process_data = 1
 66  			AND energy_base      = 0
 67  			AND energy_total     = 0
 68  			AND energy_positive  = 0
 69  			AND energy_negative  = 0
 70  		       THEN 1
 71  		       ELSE 0
 72  		     END
 73  		WHEN usim_static.get_multiverse_inactive
 74  		THEN CASE
 75  		       WHEN has_process_data = 0
 76  		       THEN 1
 77  		       ELSE 0
 78  		     END
 79  		ELSE -1
 80  	      END				     AS status_valid
 81  	    , CASE
 82  		WHEN has_process_data	 = 1
 83  		 AND NVL(energy_base, 0) = 0
 84  		THEN usim_static.get_multiverse_active
 85  		WHEN has_process_data = 1
 86  		 AND has_unprocessed  = 0
 87  		THEN usim_static.get_multiverse_crashed
 88  		WHEN has_process_data = 1
 89  		 AND has_unprocessed  = 1
 90  		 AND energy_base     != 0
 91  		THEN usim_static.get_multiverse_crashed
 92  		WHEN energy_base      = 0
 93  		 AND energy_total     = 0
 94  		 AND energy_positive  = 0
 95  		 AND energy_negative  = 0
 96  		THEN usim_static.get_multiverse_dead
 97  		WHEN has_process_data = 0
 98  		THEN usim_static.get_multiverse_inactive
 99  		ELSE NULL
100  	      END				     AS status_calculated
101  	    , usim_universe_status		     AS status_current
102  	    , usim_is_base_universe
103  	    , energy_base
104  	    , energy_total AS energy_total_calc
105  	    , energy_positive
106  	    , energy_negative
107  	    , has_process_data
108  	    , has_unprocessed
109  	 FROM ovr
110  ;
old   1: CREATE OR REPLACE VIEW &USIM_SCHEMA..usim_mlv_state_v AS
new   1: CREATE OR REPLACE VIEW USIM_TEST.usim_mlv_state_v AS

View created.

SQL> 
SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.status_valid IS 'Determines if the current database status is valid. 1 = valid 0 = invalid, -1 = no valid calculation rule found for a related universe';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.status_valid IS 'Determines if the current database status is valid. 1 = valid 0 = invalid, -1 = no valid calculation rule found for a related universe'
new   1: COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.status_valid IS 'Determines if the current database status is valid. 1 = valid 0 = invalid, -1 = no valid calculation rule found for a related universe'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.status_calculated IS 'Calculates the database status by current energy and process data for a related universe, NULL means invalid no rules found to determine state';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.status_calculated IS 'Calculates the database status by current energy and process data for a related universe, NULL means invalid no rules found to determine state'
new   1: COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.status_calculated IS 'Calculates the database status by current energy and process data for a related universe, NULL means invalid no rules found to determine state'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_total_calc IS 'The total summed up energy of the related universe, may differ slightly from 0 for missing SUM exactness on high decimals';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_total_calc IS 'The total summed up energy of the related universe, may differ slightly from 0 for missing SUM exactness on high decimals'
new   1: COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.energy_total_calc IS 'The total summed up energy of the related universe, may differ slightly from 0 for missing SUM exactness on high decimals'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_positive IS 'The energy sum for all dimension axis with n1 sign = +1';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_positive IS 'The energy sum for all dimension axis with n1 sign = +1'
new   1: COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.energy_positive IS 'The energy sum for all dimension axis with n1 sign = +1'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_negative IS 'The energy sum for all dimension axis with n1 sign = -1';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_negative IS 'The energy sum for all dimension axis with n1 sign = -1'
new   1: COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.energy_negative IS 'The energy sum for all dimension axis with n1 sign = -1'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_base IS 'The energy sum for the base universe node with n1 sign = NULL';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.energy_base IS 'The energy sum for the base universe node with n1 sign = NULL'
new   1: COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.energy_base IS 'The energy sum for the base universe node with n1 sign = NULL'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.has_process_data IS 'Determines if process data are available. Without process data or no unprocessed data, the universe is inactive';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.has_process_data IS 'Determines if process data are available. Without process data or no unprocessed data, the universe is inactive'
new   1: COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.has_process_data IS 'Determines if process data are available. Without process data or no unprocessed data, the universe is inactive'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.has_unprocessed IS 'Determines if there are unprocessed data. An active universe should always have some unprocessed data';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_mlv_state_v.has_unprocessed IS 'Determines if there are unprocessed data. An active universe should always have some unprocessed data'
new   1: COMMENT ON COLUMN USIM_TEST.usim_mlv_state_v.has_unprocessed IS 'Determines if there are unprocessed data. An active universe should always have some unprocessed data'

Comment created.

SQL> --== other views end ==--
SQL> --== interface package start ==--
SQL> @@../PACKAGES/USIM_DBIF.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_dbif
  2  IS
  3    /**This package is used as an database interface package, handling
  4    * exceptions from low level packages for the existing tables and
  5    * applying universe rules on package usage. It has dependencies to
  6    * all low level packages. Packages on a higher level should only
  7    * use usim_dbif for accessing objects.</br>
  8    * Will try to handle exceptions if possible. Severe application or
  9    * database errors will set all universes to crashed and raise the
 10    * exception found. All errors get logged as far as the database basically
 11    * still works.
 12    */
 13  
 14    /**
 15    * Sets all multiverses to crashed. This is for application errors like
 16    * exceptions that invalidate the whole model.
 17    * Uses an anonymous transaction to be able to write in any case.
 18    */
 19    PROCEDURE set_crashed;
 20  
 21    /**
 22    * Wrapper for usim_mlv.update_state. Updates state by USIM_MLV_STATE_V valid and calculated state.
 23    * If state does not match (STATUS_VALID = 0) the calculated state is set. If state is valid, do nothing.
 24    * @param p_usim_id_mlv The id of the universe, that should update its state.
 25    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 26    * @return Returns the updated state or NULL on errors.
 27    */
 28    FUNCTION set_universe_state( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
 29  				  , p_do_commit   IN BOOLEAN			      DEFAULT TRUE
 30  				  )
 31  	 RETURN usim_multiverse.usim_universe_status%TYPE
 32    ;
 33  
 34    /**
 35    * Determines the state of the universe, the given space node is in and updates the state to the calculated state
 36    * of USIM_MLV_STATE_V if current state is not valid.
 37    * @param p_usim_id_spc The space id of a node in a universe that should update its state.
 38    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 39    * @return Returns the current state of the universe or NULL on errors.
 40    */
 41    FUNCTION set_universe_state_spc( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
 42  				      , p_do_commit   IN BOOLEAN		     DEFAULT TRUE
 43  				      )
 44  	 RETURN usim_multiverse.usim_universe_status%TYPE
 45    ;
 46  
 47    /**
 48    * Sets the seed universe active ignoring any current state. Used for placing start node and activate the seed universe for the
 49    * first run. Afterwards the universe state should be determined after running a process queue.
 50    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 51    * @return Returns the activated state of the universe or NULL on errors.
 52    */
 53    FUNCTION set_seed_active(p_do_commit IN BOOLEAN DEFAULT TRUE)
 54  	 RETURN usim_multiverse.usim_universe_status%TYPE
 55    ;
 56  
 57    /**
 58    * Wrapper for usim_base.init_basedata.
 59    * Initializes the base data with the attributes that have to be set on insert if no base data
 60    * exist, otherwise do nothing. As this procedure mimics the constraints, adjusting the constraints needs package adjustment.
 61    * @param p_max_dimension The maximum dimensions possible for this multiverse.
 62    * @param p_usim_abs_max_number The absolute maximum number available for this multiverse.
 63    * @param p_usim_overflow_node_seed Defines the overflow behaviour, default 0 means standard overflow behaviour. If set to 1, all new nodes are created with the universe seed at coordinate 0 as the parent.
 64    * @return Returns 1 if base data init was successful, 0 on errors.
 65    */
 66    FUNCTION init_basedata( p_max_dimension		  IN NUMBER DEFAULT 42
 67  			     , p_usim_abs_max_number	  IN NUMBER DEFAULT 99999999999999999999999999999999999999
 68  			     , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
 69  			     )
 70  	 RETURN NUMBER
 71    ;
 72  
 73    /**
 74    * Initialize the dimensions supported by the multiverse defined by usim_max_dimension in base_data.
 75    * Does nothing if base data do not exist. Wrapper for usim_dim.init_dimensions.
 76    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 77    * @return Returns 1 if base data exist and init was successful, 0 if base data do not exist and -1 on errors.
 78    */
 79    FUNCTION init_dimensions(p_do_commit IN BOOLEAN DEFAULT TRUE)
 80  	 RETURN NUMBER
 81    ;
 82  
 83    /**
 84    * Initialize the positions supported by the multiverse defined by usim_abs_max_number in base_data.
 85    * Does nothing if base data do not exist. Wrapper for usim_pos.init_positions.
 86    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 87    * @return Returns 1 if base data exist and init was successful, 0 if base data do not exist and -1 on errors.
 88    */
 89    FUNCTION init_positions(p_do_commit IN BOOLEAN DEFAULT TRUE)
 90  	 RETURN NUMBER
 91    ;
 92  
 93    /**
 94    * Checks if base data have been initialized.
 95    * @return Returns 1 if base data are available, otherwise 0.
 96    */
 97    FUNCTION has_basedata
 98  	 RETURN NUMBER
 99    ;
100  
101    /**
102    * Checks if usim_space has already data.
103    * @return Returns 1 if data are available, otherwise 0.
104    */
105    FUNCTION has_data_spc
106  	 RETURN NUMBER
107    ;
108  
109    /**
110    * Checks if usim_space has already data for a given space id.
111    * @param p_usim_id_spc The relation id of universe/dimension/position/node.
112    * @return Returns 1 if data are available, otherwise 0.
113    */
114    FUNCTION has_data_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
115  	 RETURN NUMBER
116    ;
117  
118    /**
119    * Checks if usim_spc_process has already data.
120    * @return Returns 1 if data are available, otherwise 0.
121    */
122    FUNCTION has_data_spr
123  	 RETURN NUMBER
124    ;
125  
126    /**
127    * Checks if usim_spc_process has already data for a given process id.
128    * @param p_usim_id_spr The process id to check.
129    * @return Returns 1 if data are available for this id, otherwise 0.
130    */
131    FUNCTION has_data_spr(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
132  	 RETURN NUMBER
133    ;
134  
135    /**
136    * Wrapper for usim_spr.has_unprocessed.
137    * Checks if usim_spc_process has unprocessed data.
138    * @return Returns 1 if unprocessed data are available, otherwise 0.
139    */
140    FUNCTION has_unprocessed
141  	 RETURN NUMBER
142    ;
143  
144    /**
145    * Checks if usim_multiverse has data.
146    * @return Returns 1 if data exists, otherwise 0.
147    */
148    FUNCTION has_data_mlv
149  	 RETURN NUMBER
150    ;
151  
152    /**
153    * Checks if a given usim_multiverse id exists.
154    * @param p_usim_id_mlv The id of the universe to check.
155    * @return Returns 1 if universe exists, otherwise 0.
156    */
157    FUNCTION has_data_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
158  	 RETURN NUMBER
159    ;
160  
161    /**
162    * Wrapper for usim_spo.has_axis_max_pos_parent.
163    * Checks if for the given space id a maximum position on the dimension axis of the space
164    * node exists, that may or may not be different to the given space id. Handles escape situation 4 where
165    * dimension axis zero nodes can trigger new positions on their dimension axis.
166    * @param p_usim_id_spc The space id to check for max position on its dimension axis.
167    * @return Returns 1 for maximum dimension position found, 0 for not found and -1 for errors in dimension symmetry.
168    */
169    FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
170  	 RETURN NUMBER
171    ;
172  
173    /**
174    * Checks if a given space node has free between axis positions, if node has not reached max childs possible.
175    * @param p_usim_id_spc The space id to check for free between position on available dimension axis.
176    * @return Returns 1 if between positions are available or 0 for no between positions available.
177    */
178    FUNCTION has_free_between(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
179  	 RETURN NUMBER
180    ;
181  
182    /**
183    * Checks if the universe seed is active.
184    * @return Returns 1 if universe seed is active, otherwise 0.
185    */
186    FUNCTION is_seed_active
187  	 RETURN NUMBER
188    ;
189  
190    /**
191    * Checks if the universe is active the given space node is in.
192    * @param p_usim_id_spc The id of the space node to check universe state.
193    * @return Returns 1 if universe is active, otherwise 0 for dead, crashed or inactive.
194    */
195    FUNCTION is_universe_active(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
196  	 RETURN NUMBER
197    ;
198  
199    /**
200    * Checks if the given space node is a base universe, not necessarily the base universe seed. Must have position 0
201    * at dimension 0. Parents are not considered.
202    * @param p_usim_id_spc The id of the space node to check universe base state.
203    * @return Returns 1 if universe is a base type universe otherwise 0.
204    */
205    FUNCTION is_universe_base_type(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
206  	 RETURN NUMBER
207    ;
208  
209    /**
210    * Checks if a given position is in overflow. Depends on init_positions. Overflow is simply detected
211    * by a position that does not exist.
212    * @param p_usim_coordinate The coordinate to check against overflow.
213    * @return Returns 1 if given position coordinate is counted as overflow otherwise 0.
214    */
215    FUNCTION is_overflow_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
216  	 RETURN NUMBER
217    ;
218  
219    /**
220    * Checks if a given universe is in position overflow. Depends on base data. Overflow is detected by highest
221    * available space coordinates for every sign and compared against the maximum possible number.
222    * @param p_usim_id_mlv The universe id to check against position overflow.
223    * @return Returns 1 if given universe is counted as position overflow otherwise 0.
224    */
225    FUNCTION is_overflow_pos_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
226  	 RETURN NUMBER
227    ;
228  
229    /**
230    * Checks if a given universe is in dimension overflow. Depends on base data. Overflow is detected by highest
231    * available rmd dimension for every n1 sign and compared against the maximum possible dimensions. It will check
232    * only dimension overflow on axis level, not considering nodes inbetween connected to other dimensions.
233    * @param p_usim_id_mlv The universe id to check against dimension overflow.
234    * @return Returns TRUE if given universe is counted as dimension overflow otherwise FALSE.
235    */
236    FUNCTION is_overflow_dim_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
237  	 RETURN NUMBER
238    ;
239  
240    /**
241    * Checks if the universe for a given space id is in dimension overflow. Depends on base data. Overflow is detected by highest
242    * available space dimension for every n1 sign and compared against the maximum possible dimension.It will check
243    * only dimension overflow on axis level, not considering nodes inbetween connected to other dimensions.
244    * @param p_usim_id_spc The space id to check the universe it belongs against dimension overflow.
245    * @return Returns 1 if the universe for the given space id is counted as dimension overflow otherwise 0.
246    */
247    FUNCTION is_overflow_dim_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
248  	 RETURN NUMBER
249    ;
250  
251    /**
252    * Checks if the universe for a given space id is in position overflow. Means that for this specific space
253    * id no position is free. Positions itself may not be in overflow. It will check only position overflow
254    * on axis level, not considering nodes inbetween connected to other dimensions.
255    * @param p_usim_id_spc The space id to check the universe it belongs against position overflow.
256    * @return Returns 1 if the universe for the given space id is counted as position overflow otherwise 0.
257    */
258    FUNCTION is_overflow_pos_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
259  	 RETURN NUMBER
260    ;
261  
262    /**
263    * Checks if a given energy is in overflow. Depends on base data. Overflow is detected
264    * by checking the given value against the maximum number supported.
265    * @param p_energy The energy value to check against overflow.
266    * @return Returns 1 if energy is counted as overflow otherwise 0 (also if no base data exist).
267    */
268    FUNCTION is_overflow_energy(p_energy IN NUMBER)
269  	 RETURN NUMBER
270    ;
271  
272    /**
273    * Checks if an addition of  given energies would produce an overflow. Depends on base data. Overflow is detected
274    * by checking the given value against the maximum number supported.
275    * @param p_energy The energy value to check against overflow.
276    * @return Returns 1 if energy is counted as overflow otherwise 0.
277    */
278    FUNCTION is_overflow_energy_add( p_energy IN NUMBER
279  				      , p_add	 IN NUMBER
280  				      )
281  	 RETURN NUMBER
282    ;
283  
284    /**
285    * Wrapper for usim_spc.get_id_spc_base_universe.
286    * Checks if a given space node id is the base universe seed at dimension 0 and position 0.
287    * @param p_usim_id_spc The space node id to check.
288    * @return Returns 1 space node is base universe seed otherwise 0.
289    */
290    FUNCTION is_base_universe_seed(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
291  	 RETURN NUMBER
292    ;
293  
294    /**
295    * Wrapper for usim_spr.is_queue_valid.
296    * Checks if the current unprocessed queue is valid. All unprocessed records must have the current
297    * planck aeon and time and if the table is not empty, there must be at least 2 process records.
298    * Count of process records must be a multitude of 2. An empty table will also return 1.
299    * @return Returns 1 if queue is ready to be processed, otherwise error code: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
300    */
301    FUNCTION is_queue_valid
302  	 RETURN NUMBER
303    ;
304  
305    /**
306    * Checks if a given space id is extendable with a new position. Space node must either be a zero position axis node or
307    * a node that has no child it its dimension to match.
308    * @param p_usim_id_spc The space node id to check.
309    * @return Returns 1 if node has no child in its dimension, 2 if node is a zero position axis node else 0.
310    */
311    FUNCTION is_pos_extendable(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
312  	 RETURN NUMBER
313    ;
314  
315    /**
316    * Checks if a given space id is extendable with a new dimension.
317    * @param p_usim_id_spc The space node id to check.
318    * @param p_use_parent The parent space node id to use for dimension extend. NULL on return 0.
319    * @param p_next_dim The next available dimension to create. NULL on return 0.
320    * @return Returns 1 if node has no child in free dimension, 2 if new dimension on zero axis should be build else error 0.
321    */
322    FUNCTION is_dim_extendable( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
323  				 , p_use_parent  OUT usim_space.usim_id_spc%TYPE
324  				 , p_next_dim	 OUT usim_dimension.usim_n_dimension%TYPE
325  				 )
326  	 RETURN NUMBER
327    ;
328  
329    /**
330    * Get the child count of a given space node either in related universe or in all
331    * universes.
332    * @param p_usim_id_spc The space node id to check.
333    * @param p_ignore_mlv Defines if childs are only counted within universe of the space node (0) or childs are counted regardless of the universe they are in.
334    * @return Returns amount of childs for the given space node and universe mode or NULL on errors.
335    */
336    FUNCTION child_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
337  			   , p_ignore_mlv  IN NUMBER			  DEFAULT 0
338  			   )
339  	 RETURN NUMBER
340    ;
341  
342    /**
343    * Get the parent count of a given space node either in related universe or in all
344    * universes.
345    * @param p_usim_id_spc The space node id to check.
346    * @param p_ignore_mlv Defines if parents are only counted within universe of the space node (0) or parents are counted regardless of the universe they are in.
347    * @return Returns amount of parents for the given space node and universe mode or NULL on errors.
348    */
349    FUNCTION parent_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
350  			    , p_ignore_mlv  IN NUMBER			   DEFAULT 0
351  			    )
352  	 RETURN NUMBER
353    ;
354  
355    /**
356    * Wrapper for usim_mlv.insert_universe.
357    * Inserts a new universe with the given values. Does check if a base universe already exists. USIM_UNIVERSE_STATUS is automatically set
358    * to inactive on insert. USIM_IS_BASE_UNIVERSE is determined by existance of data. If no base universe exist, the universe gets the base universe, otherwise
359    * the universe will be a sub-universe of the existing base universe.
360    * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used or default if NULL or 0.
361    * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value or default if NULL or 0.
362    * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value or default if NULL or 0.
363    * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value or default if NULL or 0.
364    * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct.
365    * @param p_usim_ultimate_border The ultimate border rule for this universe. 1 is ultimate border reached, no childs left, 0 is any border at dimensions axis even with childs left.
366    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
367    * @return The new universe big id or NULL if insert failed.
368    */
369    FUNCTION create_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
370  			       , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
371  			       , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
372  			       , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
373  			       , p_usim_planck_stable	   IN usim_multiverse.usim_planck_stable%TYPE	   DEFAULT 1
374  			       , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
375  			       , p_do_commit		   IN BOOLEAN					   DEFAULT TRUE
376  			       )
377  	 RETURN usim_multiverse.usim_id_mlv%TYPE
378    ;
379  
380    /**
381    * Creates a negative and a positive dim axis in usim_rel_mlv_dim if dimension > 0. Dimension 0 has only one
382    * axis, in this case positive and negative dimension axis are equal. Wrapper for usim_rmd.insert_rmd.
383    * @param p_usim_id_mlv The id of the universe, to add a dimension axis. The universe must exist.
384    * @param p_usim_n_dimension The dimension n to create an dimension axis with signs for. Must be >= 0, integer and must exist.
385    * @param p_usim_id_rmd_parent The rmd id of the parent axis at n = 1 if dimension > 1 otherwise NULL.
386    * @param p_usim_id_rmd_pos The dimension axis for the given dimension with sign 1 if dimension > 0. Otherwise equal to p_usim_id_rmd_neg.
387    * @param p_usim_id_rmd_neg The dimension axis for the given dimension with sign -1 if dimension > 0. Otherwise equal to p_usim_id_rmd_pos.
388    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
389    * @return Returns 1 if dimension axis could be created or retrieved, 0 on errors.
390    */
391    FUNCTION create_dim_axis( p_usim_id_mlv	      IN  usim_multiverse.usim_id_mlv%TYPE
392  			       , p_usim_n_dimension   IN  usim_dimension.usim_n_dimension%TYPE
393  			       , p_usim_id_rmd_parent IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
394  			       , p_usim_id_rmd_pos    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
395  			       , p_usim_id_rmd_neg    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
396  			       , p_do_commit	      IN  BOOLEAN			       DEFAULT TRUE
397  			       )
398  	 RETURN NUMBER
399    ;
400  
401    /**
402    * Wrapper for usim_spc.insert_spc.
403    * Inserts a new space node for the given ids in usim_space. Updates childs
404    * and space position. Node is created for the space node.
405    * @param p_usim_id_rmd The universe/dimension relation id.
406    * @param p_usim_id_pos The position id.
407    * @param p_usim_parents An array of position parent ids for this space node. EMPTY only allowed if universe of rmd is base universe and no entry at dimension 0, position 0, sign 0, n1 sign NULL does not exist.
408    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
409    * @return Returns the new usim_id_spc id or NULL on errors.
410    */
411    FUNCTION create_space_node( p_usim_id_rmd  IN usim_rel_mlv_dim.usim_id_rmd%TYPE
412  				 , p_usim_id_pos  IN usim_position.usim_id_pos%TYPE
413  				 , p_usim_parents IN usim_static.usim_ids_type
414  				 , p_do_commit	  IN BOOLEAN			       DEFAULT TRUE
415  				 )
416  	 RETURN usim_space.usim_id_spc%TYPE
417    ;
418  
419    /**
420    * Wrapper for usim_spr.insert_spr.
421    * Inserts a new process record with status IS_PROCESSED = 0 and current real time, planck aeon
422    * and planck tick.
423    * @param p_usim_id_spc_source The space id of the process that emits energy. Must exist.
424    * @param p_usim_id_spc_target The space id of the process that receives energy. Must exist.
425    * @param p_usim_energy_source The energy of the source before processing. NULL not allowed.
426    * @param p_usim_energy_target The energy of the target before processing.
427    * @param p_usim_energy_output The energy output of the source before processing. NULL not allowed.
428    * @return Returns the process id, otherwise NULL if constraints are not fulfilled.
429    */
430    FUNCTION create_process( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
431  			      , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
432  			      , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
433  			      , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
434  			      , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
435  			      , p_do_commit	     IN BOOLEAN 				 DEFAULT TRUE
436  			      )
437  	 RETURN usim_spc_process.usim_id_spr%TYPE
438    ;
439  
440    /**
441    * Checks border situation for a given space node and flips, depending on the border rule,
442    * the process spin to the correct direction.
443    * @param p_usim_id_spc The space node to check. Mandatory.
444    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
445    * @return Return 1 if all was successfully processed otherwise 0.
446    */
447    FUNCTION check_border( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
448  			    , p_do_commit   IN BOOLEAN			   DEFAULT TRUE
449  			    )
450  	 RETURN NUMBER
451    ;
452  
453    /**
454    * Wrapper for usim_spc.flip_process_spin.
455    * Updates usim_process_spin by flipping the existing value (1 to -1 and vice versa)
456    * if the given space node is not in dimension 0 with position 0. Otherwise does nothing.
457    * @param p_usim_id_spc The space id to flip process spin.
458    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
459    * @return Returns 1 if no errors or 0 if space id does not exist.
460    */
461    FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
462  				 , p_do_commit	 IN BOOLEAN			DEFAULT TRUE
463  				 )
464  	 RETURN NUMBER
465    ;
466  
467    /**
468    * Wrapper for usim_spr.set_processed.
469    * Sets the given process step to processed.
470    * @param p_usim_id_spr The process id of the process that should be set to processed. Must exist.
471    * @param p_process_state The process state to set. 1=processed, 2=universe not active, not processed. Default is 1.
472    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
473    * @return Returns 1 if processed state could be set otherwise 0.
474    */
475    FUNCTION set_processed( p_usim_id_spr   IN usim_spc_process.usim_id_spr%TYPE
476  			     , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
477  			     , p_do_commit     IN BOOLEAN			     DEFAULT TRUE
478  			     )
479  	 RETURN NUMBER
480    ;
481  
482    /**
483    * Wrapper for usim_pos.get_id_pos.
484    * Retrieve the position id for a given coordinate.
485    * @param p_usim_coordinate The coordinate to get the position id for.
486    * @return Returns the usim_id_pos for the given coordinate or NULL on errors.
487    */
488    FUNCTION get_id_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
489  	 RETURN usim_position.usim_id_pos%TYPE
490    ;
491  
492    /**
493    * Wrapper for usim_spc.get_id_pos.
494    * Retrieve the position id for a given coordinate.
495    * @param p_usim_id_spc The space id to get the position id for.
496    * @return Returns the usim_id_pos for the given coordinate or NULL on errors.
497    */
498    FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
499  	 RETURN usim_position.usim_id_pos%TYPE
500    ;
501  
502    /**
503    * Wrapper for usim_spc.get_id_nod.
504    * Retrieves the node id for a given space id if it exists in usim_space.
505    * @param p_usim_id_spc The space id.
506    * @return Returns usim_id_nod if space id exists, otherwise NULL.
507    */
508    FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
509  	 RETURN usim_node.usim_id_nod%TYPE
510    ;
511  
512    /**
513    * Wrapper for usim_spc.get_id_mlv.
514    * Retrieves the universe id for a given space id if it exists in usim_space.
515    * @param p_usim_id_spc The space id.
516    * @return Returns usim_id_mlv if space id exists, otherwise NULL.
517    */
518    FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
519  	 RETURN usim_multiverse.usim_id_mlv%TYPE
520    ;
521  
522    /**
523    * Wrapper for usim_spc.get_id_spc_base_universe.
524    * Retrieve the space id of the universe base seed at position 0 and dimension 0 without any parents.
525    * @return Returns the usim_id_spc if a base universe seed exists or NULL.
526    */
527    FUNCTION get_id_spc_base_universe
528  	 RETURN usim_space.usim_id_spc%TYPE
529    ;
530  
531    /**
532    * Retrieve details about the space id for creation new dimensions.
533    * @param p_usim_id_spc The space id to get data for.
534    * @param p_usim_id_mlv The universe id of the space node.
535    * @param p_usim_id_rmd The dimension axis id of the space node.
536    * @param p_usim_sign The dimension sign of the space node.
537    * @param p_usim_n1_sign The dimension n1 sign of the space node.
538    * @return Returns 1 if data exist for space id or 0 if space id does not exist.
539    */
540    FUNCTION get_spc_dim_details( p_usim_id_spc  IN	usim_space.usim_id_spc%TYPE
541  				   , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
542  				   , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
543  				   , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
544  				   , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
545  				   )
546  	 RETURN NUMBER
547    ;
548  
549    /**
550    * Retrieves the current absolute maximum number allowed.
551    * @return The current value from column usim_abs_max_number or NULL if base data are not initialized.
552    */
553    FUNCTION get_abs_max_number
554  	 RETURN NUMBER
555    ;
556  
557    /**
558    * Retrieves the coordinate of a given dimension and space node, if it exists in USIM_SPC_POS. The given dimension
559    * may not be initialized yet and defaults to 0 if not available.
560    * Relies on the fact, that table holds one position for one dimension, whatever axis the dimension has.
561    * @param p_usim_id_spc The space id to get the coordinate for.
562    * @param p_usim_n_dimension The dimension to get the coordinate for.
563    * @return Returns on success the coordinate of the given dimension, otherwise NULL.
564    */
565    FUNCTION get_dim_coord( p_usim_id_spc	  IN usim_space.usim_id_spc%TYPE
566  			     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
567  			     )
568  	 RETURN usim_position.usim_coordinate%TYPE
569    ;
570  
571    /**
572    * Retrieves the dimension for a given node.
573    * @param p_usim_id_spc The space id to get the dimension.
574    * @return Returns the dimension or -1 if node does not exist.
575    */
576    FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
577  	 RETURN usim_dimension.usim_n_dimension%TYPE
578    ;
579  
580    /**
581    * Retrieves the dimension sign of a given space node.
582    * @param p_usim_id_spc The space id.
583    * @return The dimension sign of the space id or NULL, if space id does not exist.
584    */
585    FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
586  	 RETURN usim_rel_mlv_dim.usim_sign%TYPE
587    ;
588  
589    /**
590    * Retrieves the dimension n=1 sign of a given space node.
591    * @param p_usim_id_spc The space id.
592    * @return The dimension n1 sign of the space id, 0 for base universe nodes or NULL, if space id does not exist.
593    */
594    FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
595  	 RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
596    ;
597  
598    /**
599    * Wrapper for usim_spo.get_xyz.
600    * Retrieves the x,y,z coordinates of a given space node, if it exists in USIM_SPC_POS.
601    * @param p_usim_id_spc The space id to get the coordinates for.
602    * @return Returns on success a comma separated string, format x,y,z, otherwise NULL.
603    */
604    FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
605  	 RETURN VARCHAR2
606    ;
607  
608    /**
609    * Wrapper for usim_spo.get_magnitude.
610    * Retrieves the magnitude of a vector for the given dimension.
611    * @param p_usim_id_spc The space id to get the magnitude for.
612    * @param p_usim_n_dimension The dimension for the magnitude calculation.
613    * @return Returns the magnitude of the vector associated to the given space id or NULL on errors.
614    */
615    FUNCTION get_magnitude( p_usim_id_spc	  IN usim_space.usim_id_spc%TYPE
616  			     , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
617  			     )
618  	 RETURN NUMBER
619    ;
620  
621    /**
622    * Wrapper for usim_spc.get_process_spin.
623    * Retrieves the process direction of a given space node.
624    * @param p_usim_id_spc The space id to get the process direction.
625    * @return Returns the process directions or NULL if space node does not exist.
626    */
627    FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
628  	 RETURN usim_space.usim_process_spin%TYPE
629    ;
630  
631    /**
632    * Retrieves the text expression of the universe state of the given space node.
633    * @param p_usim_id_spc The space id to get the universe state description for.
634    * @return Returns ACTIVE, INACTIVE, CRASHED, DEAD or UNKNOWN if universe does not exist.
635    */
636    FUNCTION get_universe_state_desc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
637  	 RETURN VARCHAR2
638    ;
639  
640    /**
641    * Wrapper for usim_base.get_planck_time_current
642    * Retrieves the current planck time tick.
643    * @return The current value from column usim_planck_time_seq_curr or NULL if not initialized.
644    */
645    FUNCTION get_planck_time_current
646  	 RETURN NUMBER
647    ;
648  
649    /**
650    * Wrapper for usim_base.get_planck_aeon_seq_current.
651    * Retrieves the current planck aeon sequence big id.
652    * @return The current value from column usim_planck_aeon_seq_curr or usim_static.usim_not_available if not initialized.
653    */
654    FUNCTION get_planck_aeon_seq_current
655  	 RETURN VARCHAR2
656    ;
657  
658    /**
659    * Wrapper for usim_base.get_planck_time_next.
660    * Retrieves the next planck time tick. Will update current and last planck time as well as planck
661    * aeon if planck time sequence will cycle. If planck aeon is not set, it will be initialized.
662    * @return The next planck time tick number or NULL if not initialized/sequence does not exist.
663    */
664    FUNCTION get_planck_time_next
665  	 RETURN NUMBER
666    ;
667  
668    /**
669    * Wrapper for usim_spr.get_unprocessed_planck.
670    * Fetches the current planck aeon and time if the queue is valid. Will not operate on empty tables.
671    * @param p_usim_planck_aeon The planck aeon for the current unprocessed records.
672    * @param p_usim_planck_time The planck time for the current unprocessed records.
673    * @return Returns 1 if planck data could be fetched, otherwise error code from USIM_SPR.IS_QUEUE_VALID: 0 no unprocessed records, -1 planck aeon/time error, -2 record count wrong.
674    */
675    FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
676  				      , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
677  				      )
678  	 RETURN NUMBER
679    ;
680  
681    /**
682    * Wrapper for usim_spo.get_axis_max_pos_parent.
683    * Gets the space node with the maximum position on the given dimension axis. The dimension sign is
684    * used to identify the expected coordinate sign, the dimension n1 sign is used to limit the space
685    * which is divided into two subspaces by dimension 1. The dimension itself is used to identify the
686    * dimension axis, we want to get a new parent node from to extend the dimension and universe.
687    * Used with escape situation 4 where dimension axis zero nodes can trigger new positions on their dimension axis.
688    * @param p_usim_id_spc The space id ancestor node which may be itself the parent node or a 0 node on a dimension axis that can trigger new coordinates.
689    * @return The space node with the highest position on a dimension axis, sign and n1 sign of the given ancestor node, otherwise NULL on errors. Use has_axis_max_pos_parent to check before call.
690    */
691    FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
692  	 RETURN usim_space.usim_id_spc%TYPE
693    ;
694  
695    /**
696    * Gets the current maximum position on the related dimension 1 axis for a given space node.
697    * @param p_usim_id_spc The space id node to get the max dimension 1 position.
698    * @return The maximum coordinate on dimension axis 1 or NULL on errors.
699    */
700    FUNCTION get_axis_max_pos_dim1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
701  	 RETURN usim_position.usim_coordinate%TYPE
702    ;
703  
704    /**
705    * Retrieve the the next position and axis for a given space id.
706    * @param p_usim_id_spc The space id ancestor node which may be itself the parent node or a 0 node on a dimension axis that can trigger new coordinates.
707    * @return Return 1 if the operation was successful otherwise 0.
708    */
709    FUNCTION get_next_pos_on_axis( p_usim_id_spc IN	usim_space.usim_id_spc%TYPE
710  				    , p_usim_id_pos OUT usim_position.usim_id_pos%TYPE
711  				    , p_usim_id_rmd OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
712  				    )
713  	 RETURN NUMBER
714    ;
715  
716    /**
717    * Gets the overflow rating for a given space id. Overflow rating:</br>
718    * 0 if universe has overflow in position and dimension.</br>
719    * 1 if no overflow at all.</br>
720    * 2 if overflow in position.</br>
721    * 3 if overflow in dimension.</br>
722    * @param p_usim_id_spc The child id to check data for.
723    * @return Returns overflow rating as defined.
724    */
725    FUNCTION overflow_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
726  	 RETURN NUMBER
727    ;
728  
729    /**
730    * Gets the dimension axis rating for a given space id and the possible maximum number of childs. Maximum childs are calculated for the next
731    * possible dimension, if dimension is not already maximum to enable extension. Max n is n+1 where n+1 < max n else maximum possible dimensions. Dimension rating:</br>
732    * -1 error retrieving axis rating.</br>
733    * 0 center axis at dimension n = 0, with position 0 in dimension 0. 2 special childs possible with opposite output energy sign.</br>
734    * 1 center axis at dimension n = 1, with position 0 in dimension n and sign (-/+1). (max n - n) x 2 + 1 childs possible</br>
735    * 2 center axis at dimension n > 1, with position 0 in dimension n and sign (-/+1). 2 childs possible</br>
736    * 3 node is pure dimension axis coordinate, all other dimension coordinates are 0 apart from current dimension. (max n - n) + 1 possible childs</br>
737    * 4 node is in the middle of somewhere. max n possible childs</br>
738    * @param p_usim_id_spc The child id to check data for.
739    * @param p_max_childs The maximum childs possible as calculated for dimension axis type.
740    * @return Returns dimension rating as defined.
741    */
742    FUNCTION dimension_rating( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
743  				, p_max_childs	OUT NUMBER
744  				)
745  	 RETURN NUMBER
746    ;
747  
748    /**
749    * Gets the dimension axis rating for a given space id. Dimension rating:</br>
750    * -1 error retrieving axis rating.</br>
751    * 0 center axis at dimension n = 0, with position 0 in dimension 0. 2 special childs possible with opposite output energy sign.</br>
752    * 1 center axis at dimension n = 1, with position 0 in dimension n and sign (-/+1). (max n - n) x 2 + 1 childs possible</br>
753    * 2 center axis at dimension n > 1, with position 0 in dimension n and sign (-/+1). 2 childs possible</br>
754    * 3 node is pure dimension axis coordinate, all other dimension coordinates are 0 apart from current dimension. (max n - n) + 1 possible childs</br>
755    * 4 node is in the middle of somewhere. max n possible childs</br>
756    * @param p_usim_id_spc The child id to check data for.
757    * @return Returns dimension rating as defined.
758    */
759    FUNCTION dimension_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
760  	 RETURN NUMBER
761    ;
762  
763    /***
764    * Returns the maximum possible childs a given space node can have calculated by the identified dimension axis type.
765    * Just a wrapper for dimension_rating.
766    * @param p_usim_id_spc The child id to check data for.
767    * @return Returns the maximum possible childs for the given space node or < 0 on errors.
768    */
769    FUNCTION max_childs(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
770  	 RETURN NUMBER
771    ;
772  
773    /**
774    * Classifies a space parent node in means of options for connects to new space nodes. Considers only existing dimensions
775    * and position. Does not consider situations of escape and extend. Will set universe to crashed on severe errors.</br>
776    * Classifications:</br>
777    * -2 node not allowed, e.g. from type parent with ancestor in dimension 1 and position != 0.</br>
778    * -1 node data model corrupt, e.g. id is NULL or amount of childs not in sync with model.</br>
779    * 0 node is fully connected, no further childs or connects are possible.</br>
780    * 1 node is ready to get connected, further childs or connects are possible to dimensions and positions.</br>
781    * 2 node is ready to get connected, further childs or connects are possible only to dimensions.</br>
782    * 3 node is ready to get connected, further childs or connects are possible only to positions.</br>
783    * 4 node is ready to get connected, only new positions on dimension axis possible.</br>
784    * @param p_usim_id_spc The parent space id to classify.
785    * @return Returns the classification of the parent space node.
786    */
787    FUNCTION classify_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
788  	 RETURN NUMBER
789    ;
790  
791    /**
792    * Classifies a space node in means of options to escape the universe or extend the existing universe dimensions and
793    * positions within the limits, so new connections are possible.</br>
794    * Classifications:</br>
795    * -1 error.</br>
796    * 0 node can only escape to another universe.</br>
797    * 1 node can extend dimensions and positions to escape.</br>
798    * 2 node can only extend dimensions to escape. Includes between positions to higher dimensions.</br>
799    * 3 node can only extend positions to escape.</br>
800    * 4 node can only delegate new dim axis to axis zero position on dimension 1.</br>
801    * 5 node can only delegate new position on axis to axis zero position on current dimension.</br>
802    * 6 node can only delegate new position on dimension axis 1 related to the space node.</br>
803    * 7 node can only delegate new between position on current and next free higher dimension to axis zero position on current dimension.</br>
804    * @param p_usim_id_spc The space id to classify.
805    * @return Returns the classification of the space node for escapes.
806    */
807    FUNCTION classify_escape(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
808  	 RETURN NUMBER
809    ;
810  
811    /**
812    * Retrieves the dimensional gravitational constant for a given space node and its dimension.
813    * A wrapper for usim_maths.calc_dim_G.
814    * @param p_usim_id_spc The space node to get G for. Mandatory.
815    * @param p_node_G The dimensional gravitational constant for the space node as OUT parameter.
816    * @return Returns 1 if G could be calculated, 0 if an overflow happened or -1 on not supported errors or missing space id.
817    */
818    FUNCTION get_dim_G( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
819  			 , p_node_G	 OUT NUMBER
820  			 )
821  	 RETURN NUMBER
822    ;
823  
824    /**
825    * Retrieves the outer radius for a given space node. Radius r is the distance from one node to another node.
826    * @param p_usim_id_spc The space node to get G for. Mandatory.
827    * @param p_outer_planck_r The outer planck radius, the distance between space nodes, as OUT parameter.
828    * @return Returns 1 if radius could be calculated, 0 if an overflow happened or -1 on not supported errors or missing space id.
829    */
830    FUNCTION get_outer_planck_r( p_usim_id_spc    IN  usim_space.usim_id_spc%TYPE
831  				  , p_outer_planck_r OUT NUMBER
832  				  )
833  	 RETURN NUMBER
834    ;
835  
836    /**
837    * Retrieves the energy as acceleration to add to the target node.
838    * A wrapper for usim_maths.calc_planck_a2.
839    * @param p_energy The energy of the source space node that accelerates its energy to the position of the target space node.
840    * @param p_radius The outer distance between neighbor space nodes.
841    * @param p_G The dimensional gravitational constant G for the source space node and its dimension.
842    * @param p_target_energy The energy to add to the target energy as OUT parameter.
843    * @return Returns 1 if target energy could be calculated, 0 on overflow or -1 on not supported errors or missing space id.
844    */
845    FUNCTION get_acceleration( p_energy	   IN  NUMBER
846  				, p_radius	   IN  NUMBER
847  				, p_G		   IN  NUMBER
848  				, p_target_energy  OUT NUMBER
849  				)
850  	 RETURN NUMBER
851    ;
852  
853  END usim_dbif;
854  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_dbif
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_dbif

Package created.

SQL> @@../PACKAGES/USIM_DBIF.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_dbif
  2  IS
  3    -- see header for documentation
  4  
  5    PROCEDURE set_crashed
  6    IS
  7  	 PRAGMA AUTONOMOUS_TRANSACTION;
  8    BEGIN
  9  	 UPDATE usim_multiverse
 10  	    SET usim_universe_status = usim_static.usim_multiverse_status_crashed
 11  	 ;
 12  	 COMMIT;
 13    EXCEPTION
 14  	 WHEN OTHERS THEN
 15  	   ROLLBACK;
 16  	   -- write error might still work
 17  	   usim_erl.log_error('usim_dbif.set_crashed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
 18  	   -- try to set all to crashed
 19  	   usim_dbif.set_crashed;
 20  	   -- raise in any case
 21  	   RAISE;
 22    END set_crashed
 23    ;
 24  
 25    FUNCTION set_universe_state( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
 26  				  , p_do_commit   IN BOOLEAN			      DEFAULT TRUE
 27  				  )
 28  	 RETURN usim_multiverse.usim_universe_status%TYPE
 29    IS
 30  	 l_return	     NUMBER;
 31  	 l_status_valid      NUMBER;
 32  	 l_status_calculated usim_multiverse.usim_universe_status%TYPE;
 33    BEGIN
 34  	 -- check parameter
 35  	 IF usim_mlv.has_data(p_usim_id_mlv) = 1
 36  	 THEN
 37  	   -- check state and correct it if mismatch
 38  	   SELECT status_valid, status_calculated INTO l_status_valid, l_status_calculated FROM usim_mlv_state_v WHERE usim_id_mlv = p_usim_id_mlv;
 39  	   IF l_status_calculated != usim_static.usim_multiverse_status_active
 40  	   THEN
 41  	     -- we have an error in the universe
 42  	     usim_erl.log_error('usim_dbif.set_universe_state', 'Current invalid status not running for mlv id [' || p_usim_id_mlv || '] is [' || l_status_valid || '] calculated [' || l_status_calculated || '].');
 43  	     IF l_status_valid != 1
 44  	     THEN
 45  	       l_return := usim_mlv.update_state(p_usim_id_mlv, l_status_calculated, FALSE);
 46  	       IF l_return IS NULL
 47  	       THEN
 48  		 ROLLBACK;
 49  		 usim_erl.log_error('usim_dbif.set_universe_state', 'Could not update state for mlv id [' || p_usim_id_mlv || '].');
 50  	       END IF;
 51  	       RETURN l_return;
 52  	     ELSE
 53  	       RETURN l_status_calculated;
 54  	     END IF;
 55  	   ELSE
 56  	     -- update state, if current state not valid
 57  	     IF l_status_valid != 1
 58  	     THEN
 59  	       l_return := usim_mlv.update_state(p_usim_id_mlv, l_status_calculated, FALSE);
 60  	       IF l_return IS NULL
 61  	       THEN
 62  		 ROLLBACK;
 63  		 usim_erl.log_error('usim_dbif.set_universe_state', 'Could not update state for mlv id [' || p_usim_id_mlv || '].');
 64  	       END IF;
 65  	       RETURN l_return;
 66  	     ELSE
 67  	       RETURN l_status_calculated;
 68  	     END IF;
 69  	   END IF;
 70  	 ELSE
 71  	   usim_erl.log_error('usim_dbif.set_universe_state', 'Invalid parameter mlv id [' || p_usim_id_mlv || '].');
 72  	   RETURN NULL;
 73  	 END IF;
 74    EXCEPTION
 75  	 WHEN OTHERS THEN
 76  	   -- write error might still work
 77  	   usim_erl.log_error('usim_dbif.set_universe_state', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
 78  	   -- try to set all to crashed
 79  	   usim_dbif.set_crashed;
 80  	   -- raise in any case
 81  	   RAISE;
 82    END set_universe_state
 83    ;
 84  
 85    FUNCTION set_universe_state_spc( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
 86  				      , p_do_commit   IN BOOLEAN		     DEFAULT TRUE
 87  				      )
 88  	 RETURN usim_multiverse.usim_universe_status%TYPE
 89    IS
 90  	 l_usim_id_mlv	     usim_multiverse.usim_id_mlv%TYPE;
 91  	 l_status_calculated usim_multiverse.usim_universe_status%TYPE;
 92  	 l_return	     NUMBER;
 93  	 l_status_valid      NUMBER;
 94    BEGIN
 95  	 IF usim_spc.has_data(p_usim_id_spc) = 1
 96  	 THEN
 97  	   l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
 98  	   IF l_usim_id_mlv IS NULL
 99  	   THEN
100  	     usim_erl.log_error('usim_dbif.set_universe_state_spc', 'No valid universe found for space id [' || p_usim_id_spc || '].');
101  	     RETURN NULL;
102  	   END IF;
103  	   -- check state and correct it if mismatch
104  	   SELECT status_valid, status_calculated INTO l_status_valid, l_status_calculated FROM usim_mlv_state_v WHERE usim_id_mlv = l_usim_id_mlv;
105  	   -- do only something, is status is not valid
106  	   IF l_status_valid = 0
107  	   THEN
108  	     l_return := usim_mlv.update_state(l_usim_id_mlv, l_status_calculated, FALSE);
109  	     IF l_return IS NULL
110  	     THEN
111  	       ROLLBACK;
112  	       usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Could not update state for mlv id [' || l_usim_id_mlv || '].');
113  	     ELSE
114  	       IF p_do_commit
115  	       THEN
116  		 COMMIT;
117  	       END IF;
118  	     END IF;
119  	     RETURN l_return;
120  	   ELSIF l_status_valid = -1
121  	   THEN
122  	     usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Invalid calculation state for mlv id [' || l_usim_id_mlv || '].');
123  	     RETURN NULL;
124  	   ELSE
125  	     RETURN l_status_calculated;
126  	   END IF;
127  	 ELSE
128  	   usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Invalid parameter space id [' || p_usim_id_spc || '].');
129  	   RETURN NULL;
130  	 END IF;
131    EXCEPTION
132  	 WHEN OTHERS THEN
133  	   -- write error might still work
134  	   usim_erl.log_error('usim_dbif.set_universe_state_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
135  	   -- try to set all to crashed
136  	   usim_dbif.set_crashed;
137  	   -- raise in any case
138  	   RAISE;
139    END set_universe_state_spc
140    ;
141  
142    FUNCTION set_seed_active(p_do_commit IN BOOLEAN DEFAULT TRUE)
143  	 RETURN usim_multiverse.usim_universe_status%TYPE
144    IS
145  	 l_return      usim_multiverse.usim_universe_status%TYPE;
146  	 l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
147    BEGIN
148  	 IF usim_mlv.has_base = 1
149  	 THEN
150  	   SELECT usim_id_mlv INTO l_usim_id_mlv FROM usim_multiverse WHERE usim_is_base_universe = 1;
151  	   l_return := usim_mlv.update_state(l_usim_id_mlv, usim_static.usim_multiverse_status_active, FALSE);
152  	   IF l_return != usim_static.usim_multiverse_status_active
153  	   THEN
154  	     ROLLBACK;
155  	     usim_erl.log_error('usim_dbif.set_seed_active', 'Could not update state to active on universe seed id [' || l_usim_id_mlv || '] getting status [' || l_return || '].');
156  	     RETURN NULL;
157  	   ELSE
158  	     IF p_do_commit
159  	     THEN
160  	       COMMIT;
161  	     END IF;
162  	     RETURN l_return;
163  	   END IF;
164  	 ELSE
165  	   usim_erl.log_error('usim_dbif.set_seed_active', 'No base universe found.');
166  	   RETURN NULL;
167  	 END IF;
168    EXCEPTION
169  	 WHEN OTHERS THEN
170  	   ROLLBACK;
171  	   -- write error might still work
172  	   usim_erl.log_error('usim_dbif.set_seed_active', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
173  	   -- try to set all to crashed
174  	   usim_dbif.set_crashed;
175  	   -- raise in any case
176  	   RAISE;
177    END set_seed_active
178    ;
179  
180    FUNCTION init_basedata( p_max_dimension		  IN NUMBER DEFAULT 42
181  			     , p_usim_abs_max_number	  IN NUMBER DEFAULT 99999999999999999999999999999999999999
182  			     , p_usim_overflow_node_seed  IN NUMBER DEFAULT 0
183  			     )
184  	 RETURN NUMBER
185    IS
186  	 l_result NUMBER;
187    BEGIN
188  	 IF usim_base.has_basedata = 0
189  	 THEN
190  	   usim_base.init_basedata(p_max_dimension, p_usim_abs_max_number, p_usim_overflow_node_seed);
191  	 END IF;
192  	 IF usim_base.has_basedata = 0
193  	 THEN
194  	   usim_erl.log_error('usim_dbif.init_basedata', 'Could not initialize base data for max dim [' || p_max_dimension || '] max num [' || p_usim_abs_max_number || '] and overflow seed [' || p_usim_overflow_node_seed || '].');
195  	 END IF;
196  	 l_result := usim_base.has_basedata;
197  	 RETURN l_result;
198    EXCEPTION
199  	 WHEN OTHERS THEN
200  	   -- write error might still work
201  	   usim_erl.log_error('usim_dbif.init_basedata', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
202  	   -- try to set all to crashed
203  	   usim_dbif.set_crashed;
204  	   -- raise in any case
205  	   RAISE;
206    END init_basedata
207    ;
208  
209    FUNCTION init_dimensions(p_do_commit IN BOOLEAN DEFAULT TRUE)
210  	 RETURN NUMBER
211    IS
212  	 l_max_dim usim_dimension.usim_n_dimension%TYPE;
213  	 l_return  NUMBER;
214    BEGIN
215  	 IF usim_base.has_basedata = 1
216  	 THEN
217  	   l_max_dim := usim_base.get_max_dimension;
218  	   l_return  := usim_dim.init_dimensions(l_max_dim, FALSE);
219  	   IF l_return != 1
220  	   THEN
221  	     ROLLBACK;
222  	     usim_erl.log_error('usim_dbif.init_dimensions', 'Could not init dimensions up to max [' || l_max_dim || '].');
223  	     RETURN -1;
224  	   ELSE
225  	     IF p_do_commit
226  	     THEN
227  	       COMMIT;
228  	      END IF;
229  	   END IF;
230  	   RETURN l_return;
231  	 ELSE
232  	   RETURN 0;
233  	 END IF;
234    EXCEPTION
235  	 WHEN OTHERS THEN
236  	   -- write error might still work
237  	   usim_erl.log_error('usim_dbif.init_dimensions', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
238  	   -- try to set all to crashed
239  	   usim_dbif.set_crashed;
240  	   -- raise in any case
241  	   RAISE;
242    END init_dimensions
243    ;
244  
245    FUNCTION has_basedata
246  	 RETURN NUMBER
247    IS
248  	 l_result NUMBER;
249    BEGIN
250  	 l_result := usim_base.has_basedata;
251  	 RETURN l_result;
252    EXCEPTION
253  	 WHEN OTHERS THEN
254  	   ROLLBACK;
255  	   -- write error might still work
256  	   usim_erl.log_error('usim_dbif.has_basedata', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
257  	   -- try to set all to crashed
258  	   usim_dbif.set_crashed;
259  	   -- raise in any case
260  	   RAISE;
261    END has_basedata
262    ;
263  
264    FUNCTION has_data_spc
265  	 RETURN NUMBER
266    IS
267  	 l_result NUMBER;
268    BEGIN
269  	 l_result := usim_spc.has_data;
270  	 RETURN l_result;
271    EXCEPTION
272  	 WHEN OTHERS THEN
273  	   ROLLBACK;
274  	   -- write error might still work
275  	   usim_erl.log_error('usim_dbif.has_data_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
276  	   -- try to set all to crashed
277  	   usim_dbif.set_crashed;
278  	   -- raise in any case
279  	   RAISE;
280    END has_data_spc
281    ;
282  
283    FUNCTION has_data_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
284  	 RETURN NUMBER
285    IS
286  	 l_result NUMBER;
287    BEGIN
288  	 l_result := usim_spc.has_data(p_usim_id_spc);
289  	 RETURN l_result;
290    EXCEPTION
291  	 WHEN OTHERS THEN
292  	   ROLLBACK;
293  	   -- write error might still work
294  	   usim_erl.log_error('usim_dbif.has_data_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
295  	   -- try to set all to crashed
296  	   usim_dbif.set_crashed;
297  	   -- raise in any case
298  	   RAISE;
299    END has_data_spc
300    ;
301  
302    FUNCTION has_data_spr
303  	 RETURN NUMBER
304    IS
305  	 l_result NUMBER;
306    BEGIN
307  	 l_result := usim_spr.has_data;
308  	 RETURN l_result;
309    EXCEPTION
310  	 WHEN OTHERS THEN
311  	   -- write error might still work
312  	   usim_erl.log_error('usim_dbif.has_data_spr', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
313  	   -- try to set all to crashed
314  	   usim_dbif.set_crashed;
315  	   -- raise in any case
316  	   RAISE;
317    END has_data_spr
318    ;
319  
320    FUNCTION has_data_spr(p_usim_id_spr IN usim_spc_process.usim_id_spr%TYPE)
321  	 RETURN NUMBER
322    IS
323  	 l_result NUMBER;
324    BEGIN
325  	 l_result := usim_spr.has_data(p_usim_id_spr);
326  	 RETURN l_result;
327    EXCEPTION
328  	 WHEN OTHERS THEN
329  	   -- write error might still work
330  	   usim_erl.log_error('usim_dbif.has_data_spr', 'Unexpected error for id [' || p_usim_id_spr || '], SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
331  	   -- try to set all to crashed
332  	   usim_dbif.set_crashed;
333  	   -- raise in any case
334  	   RAISE;
335    END has_data_spr
336    ;
337  
338    FUNCTION has_unprocessed
339  	 RETURN NUMBER
340    IS
341  	 l_result NUMBER;
342    BEGIN
343  	 l_result := usim_spr.has_unprocessed;
344  	 RETURN l_result;
345    EXCEPTION
346  	 WHEN OTHERS THEN
347  	   -- write error might still work
348  	   usim_erl.log_error('usim_dbif.has_unprocessed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
349  	   -- try to set all to crashed
350  	   usim_dbif.set_crashed;
351  	   -- raise in any case
352  	   RAISE;
353    END has_unprocessed
354    ;
355  
356    FUNCTION has_data_mlv
357  	 RETURN NUMBER
358    IS
359  	 l_result NUMBER;
360    BEGIN
361  	 l_result := usim_mlv.has_data;
362  	 RETURN l_result;
363    EXCEPTION
364  	 WHEN OTHERS THEN
365  	   -- write error might still work
366  	   usim_erl.log_error('usim_dbif.has_data_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
367  	   -- try to set all to crashed
368  	   usim_dbif.set_crashed;
369  	   -- raise in any case
370  	   RAISE;
371    END has_data_mlv
372    ;
373  
374    FUNCTION has_data_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
375  	 RETURN NUMBER
376    IS
377  	 l_result NUMBER;
378    BEGIN
379  	 l_result := usim_mlv.has_data(p_usim_id_mlv);
380  	 RETURN l_result;
381    EXCEPTION
382  	 WHEN OTHERS THEN
383  	   -- write error might still work
384  	   usim_erl.log_error('usim_dbif.has_data_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
385  	   -- try to set all to crashed
386  	   usim_dbif.set_crashed;
387  	   -- raise in any case
388  	   RAISE;
389    END has_data_mlv
390    ;
391  
392    FUNCTION has_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
393  	 RETURN NUMBER
394    IS
395  	 l_result NUMBER;
396    BEGIN
397  	 l_result := usim_spo.has_axis_max_pos_parent(p_usim_id_spc);
398  	 IF l_result > 1
399  	 THEN
400  	   usim_erl.log_error('usim_dbif.has_axis_max_pos_parent', 'Error dimension symmetry, more than one maximum position on dimension axis found for space node [' || p_usim_id_spc || '].');
401  	   usim_dbif.set_crashed;
402  	   RETURN -1;
403  	 ELSE
404  	   RETURN l_result;
405  	 END IF;
406    EXCEPTION
407  	 WHEN OTHERS THEN
408  	   -- write error might still work
409  	   usim_erl.log_error('usim_dbif.has_axis_max_pos_parent', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
410  	   -- try to set all to crashed
411  	   usim_dbif.set_crashed;
412  	   -- raise in any case
413  	   RAISE;
414    END has_axis_max_pos_parent
415    ;
416  
417    FUNCTION has_free_between(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
418  	 RETURN NUMBER
419    IS
420    BEGIN
421  	 -- if not related to all dimensions, relying on dimensions are built and assigned in order
422  	 IF usim_chi.get_cur_max_dimension(p_usim_id_spc) < usim_spc.get_cur_max_dim_n1(p_usim_id_spc)
423  	 THEN
424  	   RETURN 1;
425  	 ELSE
426  	   RETURN 0;
427  	 END IF;
428    EXCEPTION
429  	 WHEN OTHERS THEN
430  	   -- write error might still work
431  	   usim_erl.log_error('usim_dbif.has_free_between', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
432  	   -- try to set all to crashed
433  	   usim_dbif.set_crashed;
434  	   -- raise in any case
435  	   RAISE;
436    END has_free_between
437    ;
438  
439    FUNCTION is_seed_active
440  	 RETURN NUMBER
441    IS
442  	 l_status_calculated NUMBER;
443  	 l_planck_aeon	     usim_static.usim_id;
444  	 l_planck_time	     NUMBER;
445  	 l_energy_total      NUMBER;
446  	 l_energy_positive   NUMBER;
447  	 l_energy_negative   NUMBER;
448  	 l_has_process_data  NUMBER;
449  	 l_has_unprocessed   NUMBER;
450    BEGIN
451  	 IF usim_mlv.has_base = 1
452  	 THEN
453  	   SELECT status_calculated INTO l_status_calculated FROM usim_mlv_state_v WHERE usim_is_base_universe = 1;
454  	   IF l_status_calculated = usim_static.usim_multiverse_status_active
455  	   THEN
456  	     RETURN 1;
457  	   ELSE
458  	     SELECT planck_aeon
459  		  , planck_time
460  		  , energy_base
461  		  , energy_positive
462  		  , energy_negative
463  		  , has_process_data
464  		  , has_unprocessed
465  	       INTO l_planck_aeon
466  		  , l_planck_time
467  		  , l_energy_total
468  		  , l_energy_positive
469  		  , l_energy_negative
470  		  , l_has_process_data
471  		  , l_has_unprocessed
472  	       FROM usim_mlv_state_v
473  	      WHERE usim_is_base_universe = 1
474  	     ;
475  	     usim_erl.log_error('usim_dbif.is_seed_active', 'Seed not active at planck aeon [' || l_planck_aeon || '], time [' || l_planck_time || '], total e [' || l_energy_total || '], e+ [' || l_energy_positive || '], e- [' || l_energy_negative || '], process data [' || l_has_process_data || '], unprocessed [' || l_has_unprocessed || '].');
476  	     RETURN 0;
477  	   END IF;
478  	 ELSE
479  	   usim_erl.log_error('usim_dbif.is_seed_active', 'No base universe found.');
480  	   RETURN 0;
481  	 END IF;
482    EXCEPTION
483  	 WHEN OTHERS THEN
484  	   -- write error might still work
485  	   usim_erl.log_error('usim_dbif.is_seed_active', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
486  	   -- try to set all to crashed
487  	   usim_dbif.set_crashed;
488  	   -- raise in any case
489  	   RAISE;
490    END is_seed_active
491    ;
492  
493    FUNCTION is_universe_active(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
494  	 RETURN NUMBER
495    IS
496  	 l_mlv_id    usim_multiverse.usim_id_mlv%TYPE;
497  	 l_state     usim_multiverse.usim_universe_status%TYPE;
498    BEGIN
499  	 -- get universe
500  	 l_mlv_id := usim_spc.get_id_mlv(p_usim_id_spc);
501  	 IF l_mlv_id IS NULL
502  	 THEN
503  	   RETURN 0;
504  	 END IF;
505  	 l_state  := usim_mlv.get_state(l_mlv_id);
506  	 IF l_state = usim_static.usim_multiverse_status_active
507  	 THEN
508  	   RETURN 1;
509  	 ELSE
510  	   RETURN 0;
511  	 END IF;
512    EXCEPTION
513  	 WHEN OTHERS THEN
514  	   -- write error might still work
515  	   usim_erl.log_error('usim_dbif.is_universe_active', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
516  	   -- try to set all to crashed
517  	   usim_dbif.set_crashed;
518  	   -- raise in any case
519  	   RAISE;
520    END is_universe_active
521    ;
522  
523    FUNCTION is_universe_base_type(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
524  	 RETURN NUMBER
525    IS
526  	 l_return NUMBER;
527    BEGIN
528  	 l_return := usim_spc.is_universe_base(p_usim_id_spc);
529  	 RETURN l_return;
530    EXCEPTION
531  	 WHEN OTHERS THEN
532  	   -- write error might still work
533  	   usim_erl.log_error('usim_dbif.is_universe_base', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
534  	   -- try to set all to crashed
535  	   usim_dbif.set_crashed;
536  	   -- raise in any case
537  	   RAISE;
538    END is_universe_base_type
539    ;
540  
541    FUNCTION init_positions(p_do_commit IN BOOLEAN DEFAULT TRUE)
542  	 RETURN NUMBER
543    IS
544  	 l_max_pos usim_position.usim_coordinate%TYPE;
545  	 l_return  NUMBER;
546    BEGIN
547  	 IF usim_base.has_basedata = 1
548  	 THEN
549  	   l_max_pos := usim_base.get_abs_max_number;
550  	   l_return  := usim_pos.init_positions(l_max_pos, FALSE);
551  	   IF l_return != 1
552  	   THEN
553  	     ROLLBACK;
554  	     usim_erl.log_error('usim_dbif.init_positions', 'Could not init positions up to max [' || l_max_pos || '].');
555  	     RETURN -1;
556  	   ELSE
557  	     IF p_do_commit
558  	     THEN
559  	       COMMIT;
560  	     END IF;
561  	   END IF;
562  	   RETURN l_return;
563  	 ELSE
564  	   RETURN 0;
565  	 END IF;
566    EXCEPTION
567  	 WHEN OTHERS THEN
568  	   ROLLBACK;
569  	   -- write error might still work
570  	   usim_erl.log_error('usim_dbif.init_positions', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
571  	   -- try to set all to crashed
572  	   usim_dbif.set_crashed;
573  	   -- raise in any case
574  	   RAISE;
575    END init_positions
576    ;
577  
578    FUNCTION is_overflow_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
579  	 RETURN NUMBER
580    IS
581    BEGIN
582  	 IF usim_pos.has_data = 0
583  	 THEN
584  	   -- no data
585  	   RETURN 0;
586  	 END IF;
587  	 IF usim_pos.has_data(p_usim_coordinate) = 1
588  	 THEN
589  	   RETURN 0;
590  	 ELSE
591  	   RETURN 1;
592  	 END IF;
593    EXCEPTION
594  	 WHEN OTHERS THEN
595  	   -- write error might still work
596  	   usim_erl.log_error('usim_dbif.is_overflow_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
597  	   -- try to set all to crashed
598  	   usim_dbif.set_crashed;
599  	   -- raise in any case
600  	   RAISE;
601    END is_overflow_pos
602    ;
603  
604    FUNCTION is_overflow_pos_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
605  	 RETURN NUMBER
606    IS
607  	 l_max_pos1 usim_position.usim_coordinate%TYPE;
608  	 l_max_neg1 usim_position.usim_coordinate%TYPE;
609  	 l_max_pos2 usim_position.usim_coordinate%TYPE;
610  	 l_max_neg2 usim_position.usim_coordinate%TYPE;
611  	 l_max	    NUMBER;
612    BEGIN
613  	 IF usim_mlv.has_data(p_usim_id_mlv) = 1
614  	 THEN
615  	   -- universe does not exist
616  	   RETURN 0;
617  	 END IF;
618  	 IF usim_base.has_basedata = 1
619  	 THEN
620  	   SELECT MAX(usim_n_dimension) INTO l_max_pos1 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = 1 AND usim_coordinate >= 0;
621  	   SELECT MIN(usim_n_dimension) INTO l_max_neg1 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = 1 AND usim_coordinate <= 0;
622  	   SELECT MAX(usim_n_dimension) INTO l_max_pos2 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = -1 AND usim_coordinate >= 0;
623  	   SELECT MIN(usim_n_dimension) INTO l_max_neg2 FROM usim_spc_v WHERE usim_id_mlv = p_usim_id_mlv AND dim_n1_sign = -1 AND usim_coordinate <= 0;
624  	   l_max := usim_base.get_abs_max_number;
625  	   IF	  l_max_pos1	  >= l_max
626  	      AND ABS(l_max_neg1) >= l_max
627  	      AND l_max_pos2	  >= l_max
628  	      AND ABS(l_max_neg2) >= l_max
629  	   THEN
630  	     RETURN 1;
631  	   ELSE
632  	     RETURN 0;
633  	   END IF;
634  	 ELSE
635  	   -- can't check
636  	   RETURN 0;
637  	 END IF;
638    EXCEPTION
639  	 WHEN OTHERS THEN
640  	   -- write error might still work
641  	   usim_erl.log_error('usim_dbif.is_overflow_pos_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
642  	   -- try to set all to crashed
643  	   usim_dbif.set_crashed;
644  	   -- raise in any case
645  	   RAISE;
646    END is_overflow_pos_mlv
647    ;
648  
649    FUNCTION is_overflow_dim_mlv(p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
650  	 RETURN NUMBER
651    IS
652  	 l_max_dim_pos usim_dimension.usim_n_dimension%TYPE;
653  	 l_max_dim_neg usim_dimension.usim_n_dimension%TYPE;
654  	 l_max	       NUMBER;
655    BEGIN
656  	 IF usim_mlv.has_data(p_usim_id_mlv) = 1
657  	 THEN
658  	   -- universe does not exist
659  	   RETURN 0;
660  	 END IF;
661  	 IF usim_base.has_basedata = 1
662  	 THEN
663  	   SELECT MAX(usim_n_dimension) INTO l_max_dim_pos FROM usim_rmd_v WHERE usim_id_mlv = p_usim_id_mlv AND usim_n1_sign = 1;
664  	   SELECT MAX(usim_n_dimension) INTO l_max_dim_neg FROM usim_rmd_v WHERE usim_id_mlv = p_usim_id_mlv AND usim_n1_sign = -1;
665  	   l_max := usim_base.get_max_dimension;
666  	   IF	  l_max_dim_neg >= l_max
667  	      AND l_max_dim_pos >= l_max
668  	   THEN
669  	     RETURN 1;
670  	   ELSE
671  	     RETURN 0;
672  	   END IF;
673  	 ELSE
674  	   -- can't check
675  	   RETURN 0;
676  	 END IF;
677    EXCEPTION
678  	 WHEN OTHERS THEN
679  	   -- write error might still work
680  	   usim_erl.log_error('usim_dbif.is_overflow_dim_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
681  	   -- try to set all to crashed
682  	   usim_dbif.set_crashed;
683  	   -- raise in any case
684  	   RAISE;
685    END is_overflow_dim_mlv
686    ;
687  
688    FUNCTION is_overflow_dim_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
689  	 RETURN NUMBER
690    IS
691  	 l_usim_id_mlv usim_multiverse.usim_id_mlv%TYPE;
692  	 l_max_dim     NUMBER;
693    BEGIN
694  	 IF usim_spc.has_data(p_usim_id_spc) = 1
695  	 THEN
696  	   l_usim_id_mlv := usim_spc.get_id_mlv(p_usim_id_spc);
697  	   IF l_usim_id_mlv IS NULL
698  	   THEN
699  	     -- no overflow for not existing mlv
700  	     RETURN 0;
701  	   END IF;
702  	   -- check if is base at dimension 0 and has two childs = overflow
703  	   IF	  usim_spc.is_universe_base(p_usim_id_spc) = 1
704  	      AND usim_chi.child_count(p_usim_id_spc)	   = 2
705  	   THEN
706  	     RETURN 1;
707  	   ELSIF usim_spc.is_universe_base(p_usim_id_spc) = 1
708  	   THEN
709  	     RETURN 0;
710  	   ELSE
711  	     -- check if is not base and childs have all dimensions = overflow
712  	     SELECT MAX(usim_n_dimension)
713  	       INTO l_max_dim
714  	       FROM usim_spo_v
715  	      WHERE usim_id_spc = p_usim_id_spc
716  		AND usim_id_mlv = l_usim_id_mlv
717  	     ;
718  	     IF l_max_dim >= usim_base.get_max_dimension
719  	     THEN
720  	       RETURN 1;
721  	     ELSE
722  	       RETURN 0;
723  	     END IF;
724  	   END IF;
725  	 ELSE
726  	   -- no overflow for not existing space id
727  	   RETURN 0;
728  	 END IF;
729    EXCEPTION
730  	 WHEN OTHERS THEN
731  	   -- write error might still work
732  	   usim_erl.log_error('usim_dbif.is_overflow_dim_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
733  	   -- try to set all to crashed
734  	   usim_dbif.set_crashed;
735  	   -- raise in any case
736  	   RAISE;
737    END is_overflow_dim_spc
738    ;
739  
740    FUNCTION is_overflow_pos_spc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
741  	 RETURN NUMBER
742    IS
743    BEGIN
744  	 IF usim_spc.has_data(p_usim_id_spc) = 1
745  	 THEN
746  	   -- no position free on base
747  	   IF usim_spc.is_universe_base(p_usim_id_spc) = 1
748  	   THEN
749  	     -- base node has no position free
750  	     RETURN 1;
751  	   END IF;
752  	   -- if child in same dimension we are in overflow
753  	   IF	  usim_chi.has_child_same_dim(p_usim_id_spc) = 1
754  		  -- if node is on position 0 on all axis, the node can trigger position extension, so it should not be a zero axis position
755  	      AND usim_spo.is_axis_zero_pos(p_usim_id_spc)   = 0
756  	   THEN
757  	     RETURN 1;
758  	   ELSE
759  	     RETURN 0;
760  	   END IF;
761  	 ELSE
762  	   -- no overflow if space id does not exist
763  	   RETURN 0;
764  	 END IF;
765    EXCEPTION
766  	 WHEN OTHERS THEN
767  	   -- write error might still work
768  	   usim_erl.log_error('usim_dbif.is_overflow_dim_spc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
769  	   -- try to set all to crashed
770  	   usim_dbif.set_crashed;
771  	   -- raise in any case
772  	   RAISE;
773    END is_overflow_pos_spc
774    ;
775  
776    FUNCTION is_overflow_energy(p_energy IN NUMBER)
777  	 RETURN NUMBER
778    IS
779  	 l_result NUMBER;
780    BEGIN
781  	 IF usim_base.has_basedata = 1
782  	 THEN
783  	   l_result := usim_base.num_has_overflow(p_energy);
784  	   IF l_result = 1
785  	   THEN
786  	     RETURN 1;
787  	   ELSE
788  	     RETURN 0;
789  	   END IF;
790  	 ELSE
791  	   -- we can't check
792  	   RETURN 0;
793  	 END IF;
794    EXCEPTION
795  	 WHEN OTHERS THEN
796  	   IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
797  	   THEN
798  	     -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
799  	     -- -1487: packed decimal number too large
800  	     usim_erl.log_error('usim_dbif.is_overflow_energy', 'Numerical error on energy overflow check for [' || SQLCODE || '] error message: ' || SQLERRM);
801  	     RETURN 1;
802  	   ELSE
803  	     -- write error might still work
804  	     usim_erl.log_error('usim_dbif.is_overflow_energy', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
805  	     -- try to set all to crashed
806  	     usim_dbif.set_crashed;
807  	     -- raise in any case
808  	     RAISE;
809  	   END IF;
810    END is_overflow_energy
811    ;
812  
813    FUNCTION is_overflow_energy_add( p_energy IN NUMBER
814  				      , p_add	 IN NUMBER
815  				      )
816  	 RETURN NUMBER
817    IS
818  	 l_result NUMBER;
819    BEGIN
820  	 IF usim_base.has_basedata = 1
821  	 THEN
822  	   -- check against base
823  	   l_result := usim_base.num_add_has_overflow(p_energy, p_add);
824  	   RETURN l_result;
825  	 ELSE
826  	   -- check against system, if fails with numerical exception we have overflow state
827  	   l_result := p_energy + p_add;
828  	   RETURN 0;
829  	 END IF;
830    EXCEPTION
831  	 WHEN OTHERS THEN
832  	   IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
833  	   THEN
834  	     -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
835  	     -- -1487: packed decimal number too large
836  	     usim_erl.log_error('usim_dbif.is_overflow_energy_add', 'Numerical error on add energy overflow check [' || SQLCODE || '] error message: ' || SQLERRM);
837  	     RETURN 1;
838  	   ELSE
839  	     -- write error might still work
840  	     usim_erl.log_error('usim_dbif.is_overflow_energy_add', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
841  	     -- try to set all to crashed
842  	     usim_dbif.set_crashed;
843  	     -- raise in any case
844  	     RAISE;
845  	   END IF;
846    END is_overflow_energy_add
847    ;
848  
849    FUNCTION is_base_universe_seed(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
850  	 RETURN NUMBER
851    IS
852    BEGIN
853  	 IF usim_spc.get_id_spc_base_universe = p_usim_id_spc
854  	 THEN
855  	   RETURN 1;
856  	 ELSE
857  	   IF usim_spc.has_base_universe = 0
858  	   THEN
859  	     usim_erl.log_error('usim_dbif.is_base_universe_seed', 'Used function without a base universe seed currently available.');
860  	   END IF;
861  	   RETURN 0;
862  	 END IF;
863    EXCEPTION
864  	 WHEN OTHERS THEN
865  	   -- write error might still work
866  	   usim_erl.log_error('usim_dbif.is_base_universe_seed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
867  	   -- try to set all to crashed
868  	   usim_dbif.set_crashed;
869  	   -- raise in any case
870  	   RAISE;
871    END is_base_universe_seed
872    ;
873  
874    FUNCTION is_queue_valid
875  	 RETURN NUMBER
876    IS
877  	 l_return NUMBER;
878    BEGIN
879  	 l_return := usim_spr.is_queue_valid;
880  	 RETURN l_return;
881    EXCEPTION
882  	 WHEN OTHERS THEN
883  	   -- write error might still work
884  	   usim_erl.log_error('usim_dbif.is_queue_valid', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
885  	   -- try to set all to crashed
886  	   usim_dbif.set_crashed;
887  	   -- raise in any case
888  	   RAISE;
889    END is_queue_valid
890    ;
891  
892    FUNCTION is_pos_extendable(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
893  	 RETURN NUMBER
894    IS
895    BEGIN
896  	 IF usim_chi.has_child_same_dim(p_usim_id_spc) = 0
897  	 THEN
898  	   RETURN 1;
899  	 END IF;
900  	 IF usim_spo.is_axis_zero_pos(p_usim_id_spc) = 1
901  	 THEN
902  	   RETURN 2;
903  	 END IF;
904  	 -- no check passed
905  	 usim_erl.log_error('usim_dbif.is_pos_extendable', 'Given space node id [' || p_usim_id_spc || '] is not extendable on position.');
906  	 RETURN 0;
907    EXCEPTION
908  	 WHEN OTHERS THEN
909  	   -- write error might still work
910  	   usim_erl.log_error('usim_dbif.is_pos_extendable', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
911  	   -- try to set all to crashed
912  	   usim_dbif.set_crashed;
913  	   -- raise in any case
914  	   RAISE;
915    END is_pos_extendable
916    ;
917  
918    FUNCTION is_dim_extendable( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
919  				 , p_use_parent  OUT usim_space.usim_id_spc%TYPE
920  				 , p_next_dim	 OUT usim_dimension.usim_n_dimension%TYPE
921  				 )
922  	 RETURN NUMBER
923    IS
924  	 l_max_cur_dim NUMBER;
925  	 l_max_chi_dim NUMBER;
926  	 l_max_dim     NUMBER;
927    BEGIN
928  	 l_max_cur_dim := usim_spc.get_cur_max_dim_n1(p_usim_id_spc);
929  	 l_max_chi_dim := usim_chi.get_cur_max_dimension(p_usim_id_spc);
930  	 l_max_dim     := usim_base.get_max_dimension;
931  	 IF usim_spo.is_axis_zero_pos(p_usim_id_spc) = 1
932  	 THEN
933  	   IF l_max_chi_dim < l_max_dim
934  	   THEN
935  	     p_use_parent := p_usim_id_spc;
936  	     p_next_dim   := l_max_chi_dim + 1;
937  	     RETURN 2;
938  	   ELSE
939  	     -- no dimension left
940  	     p_use_parent := NULL;
941  	     p_next_dim   := NULL;
942  	     RETURN 0;
943  	   END IF;
944  	 END IF;
945  	 IF l_max_chi_dim < l_max_cur_dim
946  	 THEN
947  	   -- free available dimensions
948  	   p_use_parent := p_usim_id_spc;
949  	   p_next_dim	:= l_max_chi_dim + 1;
950  	   RETURN 1;
951  	 ELSIF l_max_chi_dim < l_max_dim
952  	 THEN
953  	   -- free dimension, but dimension has to be build
954  	   p_use_parent := usim_spo.get_axis_zero_pos_parent(p_usim_id_spc);
955  	   p_next_dim	:= l_max_chi_dim + 1;
956  	   RETURN 2;
957  	 ELSE
958  	   p_use_parent := NULL;
959  	   p_next_dim	:= NULL;
960  	   RETURN 0;
961  	 END IF;
962    EXCEPTION
963  	 WHEN OTHERS THEN
964  	   -- write error might still work
965  	   usim_erl.log_error('usim_dbif.is_dim_extendable', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
966  	   -- try to set all to crashed
967  	   usim_dbif.set_crashed;
968  	   -- raise in any case
969  	   RAISE;
970    END is_dim_extendable
971    ;
972  
973    FUNCTION child_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
974  			   , p_ignore_mlv  IN NUMBER			  DEFAULT 0
975  			   )
976  	 RETURN NUMBER
977    IS
978  	 l_result NUMBER;
979    BEGIN
980  	 IF p_ignore_mlv = 0
981  	 THEN
982  	   l_result := usim_chi.child_count(p_usim_id_spc);
983  	 ELSE
984  	   l_result := usim_chi.child_count_all(p_usim_id_spc);
985  	 END IF;
986  	 RETURN l_result;
987    EXCEPTION
988  	 WHEN OTHERS THEN
989  	   -- write error might still work
990  	   usim_erl.log_error('usim_dbif.child_count', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
991  	   -- try to set all to crashed
992  	   usim_dbif.set_crashed;
993  	   -- raise in any case
994  	   RAISE;
995    END child_count
996    ;
997  
998    FUNCTION parent_count( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
999  			    , p_ignore_mlv  IN NUMBER			   DEFAULT 0
1000  			     )
1001  	  RETURN NUMBER
1002  	IS
1003  	  l_result NUMBER;
1004  	BEGIN
1005  	  IF p_ignore_mlv = 0
1006  	  THEN
1007  	    l_result := usim_chi.parent_count(p_usim_id_spc);
1008  	  ELSE
1009  	    l_result := usim_chi.parent_count_all(p_usim_id_spc);
1010  	  END IF;
1011  	  RETURN l_result;
1012  	EXCEPTION
1013  	  WHEN OTHERS THEN
1014  	    -- write error might still work
1015  	    usim_erl.log_error('usim_dbif.parent_count', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1016  	    -- try to set all to crashed
1017  	    usim_dbif.set_crashed;
1018  	    -- raise in any case
1019  	    RAISE;
1020  	END parent_count
1021  	;
1022  
1023  	FUNCTION create_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
1024  				, p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
1025  				, p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
1026  				, p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
1027  				, p_usim_planck_stable	    IN usim_multiverse.usim_planck_stable%TYPE	    DEFAULT 1
1028  				, p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
1029  				, p_do_commit		    IN BOOLEAN					    DEFAULT TRUE
1030  				)
1031  	  RETURN usim_multiverse.usim_id_mlv%TYPE
1032  	IS
1033  	  l_result usim_multiverse.usim_id_mlv%TYPE;
1034  	BEGIN
1035  	  IF usim_mlv.has_data	   = 1
1036  	     AND usim_mlv.has_base = 0
1037  	  THEN
1038  	    -- wrong state
1039  	    usim_erl.log_error('usim_dbif.create_universe', 'Unexpected multiverse state no base universe but universes exist.');
1040  	    usim_dbif.set_crashed;
1041  	    RETURN NULL;
1042  	  END IF;
1043  	  l_result := usim_mlv.insert_universe( p_usim_energy_start_value
1044  					      , p_usim_planck_time_unit
1045  					      , p_usim_planck_length_unit
1046  					      , p_usim_planck_speed_unit
1047  					      , p_usim_planck_stable
1048  					      , p_usim_ultimate_border
1049  					      , FALSE
1050  					      )
1051  	  ;
1052  	  IF l_result IS NULL
1053  	  THEN
1054  	    ROLLBACK;
1055  	    usim_erl.log_error('usim_dbif.create_universe', 'Could not insert new universe.');
1056  	  ELSE
1057  	    IF p_do_commit
1058  	    THEN
1059  	      COMMIT;
1060  	    END IF;
1061  	  END IF;
1062  	  RETURN l_result;
1063  	EXCEPTION
1064  	  WHEN OTHERS THEN
1065  	    ROLLBACK;
1066  	    -- write error might still work
1067  	    usim_erl.log_error('usim_dbif.create_universe', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1068  	    -- try to set all to crashed
1069  	    usim_dbif.set_crashed;
1070  	    -- raise in any case
1071  	    RAISE;
1072  	END create_universe
1073  	;
1074  
1075  	FUNCTION create_dim_axis( p_usim_id_mlv        IN  usim_multiverse.usim_id_mlv%TYPE
1076  				, p_usim_n_dimension   IN  usim_dimension.usim_n_dimension%TYPE
1077  				, p_usim_id_rmd_parent IN  usim_rel_mlv_dim.usim_id_rmd%TYPE
1078  				, p_usim_id_rmd_pos    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
1079  				, p_usim_id_rmd_neg    OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
1080  				, p_do_commit	       IN  BOOLEAN				DEFAULT TRUE
1081  				)
1082  	  RETURN NUMBER
1083  	IS
1084  	  l_sign    usim_rel_mlv_dim.usim_sign%TYPE;
1085  	  l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
1086  	BEGIN
1087  	  IF	 usim_dim.has_data(p_usim_n_dimension) = 1
1088  	     AND usim_mlv.has_data(p_usim_id_mlv)      = 1
1089  	  THEN
1090  	    -- do not commit until everything is processed
1091  	    IF p_usim_n_dimension = 0
1092  	    THEN
1093  	      p_usim_id_rmd_pos := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, 0, NULL, FALSE);
1094  	      p_usim_id_rmd_neg := usim_rmd.get_id_rmd(p_usim_id_mlv, p_usim_n_dimension, 0, NULL);
1095  	    ELSE
1096  	      IF p_usim_n_dimension > 1
1097  	      THEN
1098  		IF p_usim_id_rmd_parent IS NOT NULL
1099  		THEN
1100  		  l_sign := usim_rmd.get_dim_n1_sign(p_usim_id_rmd_parent);
1101  		  IF l_sign != 0
1102  		  THEN
1103  		    p_usim_id_rmd_pos := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, 1, l_sign, FALSE);
1104  		    p_usim_id_rmd_neg := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, -1, l_sign, FALSE);
1105  		  ELSE
1106  		    usim_erl.log_error('usim_dbif.create_dim_axis', 'Pparent rmd id returns invalid n1 sign 0.');
1107  		    RETURN 0;
1108  		  END IF;
1109  		ELSE
1110  		  usim_erl.log_error('usim_dbif.create_dim_axis', 'Dimension > 1 but NULL parent rmd id given.');
1111  		  RETURN 0;
1112  		END IF;
1113  	      ELSIF p_usim_n_dimension = 1
1114  	      THEN
1115  		p_usim_id_rmd_pos := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, 1, 1, FALSE);
1116  		p_usim_id_rmd_neg := usim_rmd.insert_rmd(p_usim_id_mlv, p_usim_n_dimension, -1, -1, FALSE);
1117  	      ELSE
1118  		usim_erl.log_error('usim_dbif.create_dim_axis', 'Invalid dimension [' || p_usim_n_dimension || '].');
1119  		RETURN 0;
1120  	      END IF;
1121  	    END IF;
1122  	    -- now check out values if we arrive here
1123  	    IF	    p_usim_id_rmd_pos IS NOT NULL
1124  		AND p_usim_id_rmd_neg IS NOT NULL
1125  	    THEN
1126  	      -- commit everything
1127  	      IF p_do_commit
1128  	      THEN
1129  		COMMIT;
1130  	      END IF;
1131  	      RETURN 1;
1132  	    ELSE
1133  	      ROLLBACK;
1134  	      usim_erl.log_error('usim_dbif.create_dim_axis', 'Error creating dimension axis for [' || p_usim_n_dimension || '].');
1135  	      RETURN 0;
1136  	    END IF;
1137  	  ELSE
1138  	    usim_erl.log_error('usim_dbif.create_dim_axis', 'Invalid mlv [' || p_usim_id_mlv || '] or dimension [' || p_usim_n_dimension || '].');
1139  	    RETURN 0;
1140  	  END IF;
1141  	EXCEPTION
1142  	  WHEN OTHERS THEN
1143  	    ROLLBACK;
1144  	    -- write error might still work
1145  	    usim_erl.log_error('usim_dbif.create_dim_axis', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1146  	    -- try to set all to crashed
1147  	    usim_dbif.set_crashed;
1148  	    -- raise in any case
1149  	    RAISE;
1150  	END create_dim_axis
1151  	;
1152  
1153  	FUNCTION create_space_node( p_usim_id_rmd  IN usim_rel_mlv_dim.usim_id_rmd%TYPE
1154  				  , p_usim_id_pos  IN usim_position.usim_id_pos%TYPE
1155  				  , p_usim_parents IN usim_static.usim_ids_type
1156  				  , p_do_commit    IN BOOLEAN				DEFAULT TRUE
1157  				  )
1158  	  RETURN usim_space.usim_id_spc%TYPE
1159  	IS
1160  	  l_usim_id_mlv     usim_multiverse.usim_id_mlv%TYPE;
1161  	  l_usim_id_nod     usim_node.usim_id_nod%TYPE;
1162  	  l_usim_id_spc     usim_space.usim_id_spc%TYPE;
1163  	  l_usim_coordinate usim_position.usim_coordinate%TYPE;
1164  	  l_count	    NUMBER;
1165  	  l_spin	    NUMBER;
1166  	  l_return	    NUMBER;
1167  	BEGIN
1168  	  IF	 usim_rmd.has_data(p_usim_id_rmd) = 1
1169  	     AND usim_pos.has_data(p_usim_id_pos) = 1
1170  	  THEN
1171  	    -- pos and rmd not unique, inbetween nodes
1172  	    -- check situation
1173  	    l_usim_id_mlv     := usim_rmd.get_id_mlv(p_usim_id_rmd);
1174  	    IF l_usim_id_mlv IS NULL
1175  	    THEN
1176  	      usim_erl.log_error('usim_dbif.create_space_node', 'Could not get universe for rmd [' || p_usim_id_rmd || '].');
1177  	      usim_dbif.set_crashed;
1178  	      RETURN NULL;
1179  	    END IF;
1180  	    l_usim_coordinate := usim_pos.get_coordinate(p_usim_id_pos);
1181  	    IF l_usim_coordinate IS NULL
1182  	    THEN
1183  	      usim_erl.log_error('usim_dbif.create_space_node', 'Could not get coordinate for pos [' || p_usim_id_pos || '].');
1184  	      usim_dbif.set_crashed;
1185  	      RETURN NULL;
1186  	    END IF;
1187  	    IF	   usim_mlv.is_base(l_usim_id_mlv) = 0
1188  	       AND l_usim_coordinate		  != 0
1189  	       AND p_usim_parents.COUNT 	   = 0
1190  	    THEN
1191  	      usim_erl.log_error('usim_dbif.create_space_node', 'Missing parent for not base universe and position not 0.');
1192  	      RETURN NULL;
1193  	    END IF;
1194  	    IF p_usim_parents.COUNT = 0
1195  	    THEN
1196  	      -- check if not already set
1197  	      SELECT COUNT(*)
1198  		INTO l_count
1199  		FROM usim_spc_v
1200  	       WHERE usim_id_mlv	   = l_usim_id_mlv
1201  		 AND usim_is_base_universe = 1
1202  		 AND dim_sign		   = 0
1203  		 AND dim_n1_sign	  IS NULL
1204  		 AND usim_coordinate	   = 0
1205  	      ;
1206  	      IF l_count != 0
1207  	      THEN
1208  		usim_erl.log_error('usim_dbif.create_space_node', 'Base universe node at position 0, dimension 0 already exists.');
1209  		RETURN NULL;
1210  	      END IF;
1211  	    END IF;
1212  	    -- define process spin, new childs normally are at the end of the row, so direction would be -1 (parent)
1213  	    -- whereas a node without parent is always in direction 1 (childs). The sign is initially direction child. As soon as
1214  	    -- processing begins, it will be flipped by processing to the correct direction, whenever the process encounters
1215  	    -- a border space node as defined by border rule.
1216  	    l_spin := 1;
1217  	    -- all checks passed, create node, do not commit until all is done
1218  	    l_usim_id_nod := usim_nod.insert_node(FALSE);
1219  	    l_usim_id_spc := usim_spc.insert_spc(p_usim_id_rmd, p_usim_id_pos, l_usim_id_nod, l_spin, FALSE);
1220  	    IF l_usim_id_spc IS NULL
1221  	    THEN
1222  	      ROLLBACK;
1223  	      usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node for rmd [' || p_usim_id_rmd || '] and position [' || p_usim_id_pos || '] .');
1224  	      usim_dbif.set_crashed;
1225  	      RETURN NULL;
1226  	    END IF;
1227  	    -- update position for parents
1228  	    IF p_usim_parents.COUNT > 0
1229  	    THEN
1230  	      FOR i IN p_usim_parents.FIRST..p_usim_parents.LAST
1231  	      LOOP
1232  		l_return := usim_spo.insert_spc_pos(l_usim_id_spc, p_usim_parents(i), FALSE);
1233  		IF l_return = 0
1234  		THEN
1235  		  ROLLBACK;
1236  		  usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node position for spc [' || l_usim_id_spc || '] and parent [' || p_usim_parents(i) || '] .');
1237  		  usim_dbif.set_crashed;
1238  		  RETURN NULL;
1239  		END IF;
1240  		-- check parent child relation only same n1 sign apart from base universe nodes
1241  		IF    usim_spc.get_dim_n1_sign(p_usim_parents(i))  = usim_spc.get_dim_n1_sign(l_usim_id_spc)
1242  		   OR usim_spc.is_universe_base(p_usim_parents(i)) = 1
1243  		   OR usim_spc.is_universe_base(l_usim_id_spc)	   = 1
1244  		THEN
1245  		  -- define relationship if parent is set
1246  		  l_return := usim_chi.insert_chi(p_usim_parents(i), l_usim_id_spc, FALSE);
1247  		  IF l_return = 0
1248  		  THEN
1249  		    ROLLBACK;
1250  		    usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node relation for spc [' || l_usim_id_spc || '] and parent [' || p_usim_parents(i) || '] .');
1251  		    usim_dbif.set_crashed;
1252  		    RETURN NULL;
1253  		  END IF;
1254  		ELSE
1255  		  ROLLBACK;
1256  		  usim_erl.log_error('usim_dbif.create_space_node', 'Space node relation not allowed due to different n1 sign for spc [' || l_usim_id_spc || '] and parent [' || p_usim_parents(i) || '] not base node.');
1257  		  usim_dbif.set_crashed;
1258  		  RETURN NULL;
1259  		END IF;
1260  	      END LOOP;
1261  	    ELSE
1262  	      l_return := usim_spo.insert_spc_pos(l_usim_id_spc, NULL, FALSE);
1263  	      IF l_return = 0
1264  	      THEN
1265  		ROLLBACK;
1266  		usim_erl.log_error('usim_dbif.create_space_node', 'Could not create space node position for spc [' || l_usim_id_spc || '] and parent NULL.');
1267  		usim_dbif.set_crashed;
1268  		RETURN NULL;
1269  	      END IF;
1270  	    END IF;
1271  	    -- creation done, commit if given
1272  	    IF p_do_commit
1273  	    THEN
1274  	      COMMIT;
1275  	    END IF;
1276  	    RETURN l_usim_id_spc;
1277  	  ELSE
1278  	    usim_erl.log_error('usim_dbif.create_space_node', 'Invalid rmd [' || p_usim_id_rmd || '] or position [' || p_usim_id_pos || '].');
1279  	    RETURN NULL;
1280  	  END IF;
1281  	EXCEPTION
1282  	  WHEN OTHERS THEN
1283  	    ROLLBACK;
1284  	    -- write error might still work
1285  	    usim_erl.log_error('usim_dbif.create_space_node', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1286  	    -- try to set all to crashed
1287  	    usim_dbif.set_crashed;
1288  	    -- raise in any case
1289  	    RAISE;
1290  	END create_space_node
1291  	;
1292  
1293  	FUNCTION create_process( p_usim_id_spc_source IN usim_space.usim_id_spc%TYPE
1294  			       , p_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
1295  			       , p_usim_energy_source IN usim_spc_process.usim_energy_source%TYPE
1296  			       , p_usim_energy_target IN usim_spc_process.usim_energy_target%TYPE
1297  			       , p_usim_energy_output IN usim_spc_process.usim_energy_output%TYPE
1298  			       , p_do_commit	      IN BOOLEAN				  DEFAULT TRUE
1299  			       )
1300  	  RETURN usim_spc_process.usim_id_spr%TYPE
1301  	IS
1302  	  l_result usim_spc_process.usim_id_spr%TYPE;
1303  	BEGIN
1304  	  l_result := usim_spr.insert_spr(p_usim_id_spc_source, p_usim_id_spc_target, p_usim_energy_source, p_usim_energy_target, p_usim_energy_output, FALSE);
1305  	  IF l_result IS NOT NULL
1306  	  THEN
1307  	    IF p_do_commit
1308  	    THEN
1309  	      COMMIT;
1310  	    END IF;
1311  	  ELSE
1312  	    usim_erl.log_error('usim_dbif.create_process', 'Failed to insert process record.');
1313  	    ROLLBACK;
1314  	  END IF;
1315  	  RETURN l_result;
1316  	EXCEPTION
1317  	  WHEN OTHERS THEN
1318  	    ROLLBACK;
1319  	    -- write error might still work
1320  	    usim_erl.log_error('usim_dbif.create_process', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1321  	    -- try to set all to crashed
1322  	    usim_dbif.set_crashed;
1323  	    -- raise in any case
1324  	    RAISE;
1325  	END create_process
1326  	;
1327  
1328  	FUNCTION flip_process_spin( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
1329  				  , p_do_commit   IN BOOLEAN			 DEFAULT TRUE
1330  				  )
1331  	  RETURN NUMBER
1332  	IS
1333  	  l_result NUMBER;
1334  	BEGIN
1335  	  l_result := usim_spc.flip_process_spin(p_usim_id_spc, FALSE);
1336  	  IF l_result = 0
1337  	  THEN
1338  	    ROLLBACK;
1339  	    usim_erl.log_error('usim_dbif.flip_process_spin', 'Failed to flip process spin for space id [' || p_usim_id_spc || '].');
1340  	  ELSE
1341  	    IF p_do_commit
1342  	    THEN
1343  	      COMMIT;
1344  	    END IF;
1345  	  END IF;
1346  	  RETURN l_result;
1347  	EXCEPTION
1348  	  WHEN OTHERS THEN
1349  	    ROLLBACK;
1350  	    -- write error might still work
1351  	    usim_erl.log_error('usim_dbif.flip_process_spin', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1352  	    -- try to set all to crashed
1353  	    usim_dbif.set_crashed;
1354  	    -- raise in any case
1355  	    RAISE;
1356  	END flip_process_spin
1357  	;
1358  
1359  	FUNCTION set_processed( p_usim_id_spr	IN usim_spc_process.usim_id_spr%TYPE
1360  			      , p_process_state IN usim_spc_process.is_processed%TYPE DEFAULT 1
1361  			      , p_do_commit	IN BOOLEAN			      DEFAULT TRUE
1362  			      )
1363  	  RETURN NUMBER
1364  	IS
1365  	  l_result NUMBER;
1366  	BEGIN
1367  	  l_result := usim_spr.set_processed(p_usim_id_spr, p_process_state, FALSE);
1368  	  IF l_result = 0
1369  	  THEN
1370  	    ROLLBACK;
1371  	    usim_erl.log_error('usim_dbif.set_processed', 'Failed to set processed state for id [' || p_usim_id_spr || '] and state [' || p_process_state || '].');
1372  	  ELSE
1373  	    IF p_do_commit
1374  	    THEN
1375  	      COMMIT;
1376  	    END IF;
1377  	  END IF;
1378  	  RETURN l_result;
1379  	EXCEPTION
1380  	  WHEN OTHERS THEN
1381  	    ROLLBACK;
1382  	    -- write error might still work
1383  	    usim_erl.log_error('usim_dbif.set_processed', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1384  	    -- try to set all to crashed
1385  	    usim_dbif.set_crashed;
1386  	    -- raise in any case
1387  	    RAISE;
1388  	END set_processed
1389  	;
1390  
1391  	FUNCTION check_border( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
1392  			     , p_do_commit   IN BOOLEAN 		    DEFAULT TRUE
1393  			     )
1394  	  RETURN NUMBER
1395  	IS
1396  	  l_usim_id_mlv   usim_multiverse.usim_id_mlv%TYPE;
1397  	  l_border_rule   usim_multiverse.usim_ultimate_border%TYPE;
1398  	  l_process_spin  usim_space.usim_process_spin%TYPE;
1399  	  l_result	  INTEGER;
1400  	BEGIN
1401  	  l_usim_id_mlv  := usim_spc.get_id_mlv(p_usim_id_spc);
1402  	  l_border_rule  := usim_mlv.get_ultimate_border(l_usim_id_mlv);
1403  	  l_process_spin := usim_spc.get_process_spin(p_usim_id_spc);
1404  	  IF l_border_rule = 1
1405  	  THEN
1406  	    -- if no child and direction is child flip to parent
1407  	    IF	   usim_chi.child_count(p_usim_id_spc) = 0
1408  	       AND l_process_spin		       = 1
1409  	    THEN
1410  	      l_result := usim_spc.flip_process_spin(p_usim_id_spc, FALSE);
1411  	      -- check fail
1412  	      IF l_result = 1
1413  	      THEN
1414  		IF p_do_commit
1415  		THEN
1416  		  COMMIT;
1417  		END IF;
1418  		RETURN 1;
1419  	      ELSE
1420  		usim_erl.log_error('usim_dbif.check_border', 'Could not flip process spin on space id [' || p_usim_id_spc || '].');
1421  		-- set all to crashed
1422  		usim_dbif.set_crashed;
1423  		ROLLBACK;
1424  		RETURN 0;
1425  	      END IF;
1426  	    ELSE
1427  	      RETURN 1;
1428  	    END IF;
1429  	  ELSE
1430  	    -- if no child in dimension and direction is child flip to parent
1431  	    IF	   usim_chi.has_child_same_dim(p_usim_id_spc) = 0
1432  	       AND l_process_spin			      = 1
1433  	    THEN
1434  	      l_result := usim_spc.flip_process_spin(p_usim_id_spc, FALSE);
1435  	      -- check fail
1436  	      IF l_result = 1
1437  	      THEN
1438  		IF p_do_commit
1439  		THEN
1440  		  COMMIT;
1441  		END IF;
1442  		RETURN 1;
1443  	      ELSE
1444  		usim_erl.log_error('usim_dbif.check_border', 'Could not flip process spin on space id [' || p_usim_id_spc || '].');
1445  		-- set all to crashed
1446  		usim_dbif.set_crashed;
1447  		ROLLBACK;
1448  		RETURN 0;
1449  	      END IF;
1450  	    END IF;
1451  	  END IF;
1452  	  RETURN 1;
1453  	EXCEPTION
1454  	  WHEN OTHERS THEN
1455  	    ROLLBACK;
1456  	    -- write error might still work
1457  	    usim_erl.log_error('usim_dbif.check_border', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1458  	    -- try to set all to crashed
1459  	    usim_dbif.set_crashed;
1460  	    -- raise in any case
1461  	    RAISE;
1462  	END check_border
1463  	;
1464  
1465  	FUNCTION get_id_pos(p_usim_coordinate IN usim_position.usim_coordinate%TYPE)
1466  	  RETURN usim_position.usim_id_pos%TYPE
1467  	IS
1468  	  l_usim_id_pos usim_position.usim_id_pos%TYPE;
1469  	BEGIN
1470  	  IF usim_pos.has_data(p_usim_coordinate) = 1
1471  	  THEN
1472  	    l_usim_id_pos := usim_pos.get_id_pos(p_usim_coordinate);
1473  	    IF l_usim_id_pos IS NULL
1474  	    THEN
1475  	      usim_erl.log_error('usim_dbif.get_id_pos', 'Could not get position id for coordinate [' || p_usim_coordinate || '].');
1476  	    END IF;
1477  	    RETURN l_usim_id_pos;
1478  	  ELSE
1479  	    usim_erl.log_error('usim_dbif.get_id_pos', 'Invalid coordinate [' || p_usim_coordinate || '], maybe overflow.');
1480  	    RETURN NULL;
1481  	  END IF;
1482  	EXCEPTION
1483  	  WHEN OTHERS THEN
1484  	    -- write error might still work
1485  	    usim_erl.log_error('usim_dbif.get_id_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1486  	    -- try to set all to crashed
1487  	    usim_dbif.set_crashed;
1488  	    -- raise in any case
1489  	    RAISE;
1490  	END get_id_pos
1491  	;
1492  
1493  	FUNCTION get_id_pos(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1494  	  RETURN usim_position.usim_id_pos%TYPE
1495  	IS
1496  	  l_usim_id_pos usim_position.usim_id_pos%TYPE;
1497  	BEGIN
1498  	  IF usim_spc.has_data(p_usim_id_spc) = 1
1499  	  THEN
1500  	    l_usim_id_pos := usim_spc.get_id_pos(p_usim_id_spc);
1501  	    IF l_usim_id_pos IS NULL
1502  	    THEN
1503  	      usim_erl.log_error('usim_dbif.get_id_pos', 'Could not get position id for space node [' || p_usim_id_spc || '].');
1504  	    END IF;
1505  	    RETURN l_usim_id_pos;
1506  	  ELSE
1507  	    usim_erl.log_error('usim_dbif.get_id_pos', 'Invalid space id [' || p_usim_id_spc || '].');
1508  	    RETURN NULL;
1509  	  END IF;
1510  	EXCEPTION
1511  	  WHEN OTHERS THEN
1512  	    -- write error might still work
1513  	    usim_erl.log_error('usim_dbif.get_id_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1514  	    -- try to set all to crashed
1515  	    usim_dbif.set_crashed;
1516  	    -- raise in any case
1517  	    RAISE;
1518  	END get_id_pos
1519  	;
1520  
1521  	FUNCTION get_id_nod(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1522  	  RETURN usim_node.usim_id_nod%TYPE
1523  	IS
1524  	  l_result usim_node.usim_id_nod%TYPE;
1525  	BEGIN
1526  	  l_result := usim_spc.get_id_nod(p_usim_id_spc);
1527  	  IF l_result IS NULL
1528  	  THEN
1529  	    usim_erl.log_error('usim_dbif.get_id_nod', 'Invalid space id [' || p_usim_id_spc || '] or no node found.');
1530  	    usim_dbif.set_crashed;
1531  	  END IF;
1532  	  RETURN l_result;
1533  	EXCEPTION
1534  	  WHEN OTHERS THEN
1535  	    -- write error might still work
1536  	    usim_erl.log_error('usim_dbif.get_id_nod', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1537  	    -- try to set all to crashed
1538  	    usim_dbif.set_crashed;
1539  	    -- raise in any case
1540  	    RAISE;
1541  	END get_id_nod
1542  	;
1543  
1544  	FUNCTION get_id_mlv(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1545  	  RETURN usim_multiverse.usim_id_mlv%TYPE
1546  	IS
1547  	  l_result usim_multiverse.usim_id_mlv%TYPE;
1548  	BEGIN
1549  	  l_result := usim_spc.get_id_mlv(p_usim_id_spc);
1550  	  IF l_result IS NULL
1551  	  THEN
1552  	    usim_erl.log_error('usim_dbif.get_id_mlv', 'Invalid space id [' || p_usim_id_spc || '] or no node found.');
1553  	    usim_dbif.set_crashed;
1554  	  END IF;
1555  	  RETURN l_result;
1556  	EXCEPTION
1557  	  WHEN OTHERS THEN
1558  	    -- write error might still work
1559  	    usim_erl.log_error('usim_dbif.get_id_mlv', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1560  	    -- try to set all to crashed
1561  	    usim_dbif.set_crashed;
1562  	    -- raise in any case
1563  	    RAISE;
1564  	END get_id_mlv
1565  	;
1566  
1567  	FUNCTION get_id_spc_base_universe
1568  	  RETURN usim_space.usim_id_spc%TYPE
1569  	IS
1570  	  l_result usim_space.usim_id_spc%TYPE;
1571  	BEGIN
1572  	  l_result := usim_spc.get_id_spc_base_universe;
1573  	  RETURN l_result;
1574  	EXCEPTION
1575  	  WHEN OTHERS THEN
1576  	    -- write error might still work
1577  	    usim_erl.log_error('usim_dbif.get_id_spc_base_universe', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1578  	    -- try to set all to crashed
1579  	    usim_dbif.set_crashed;
1580  	    -- raise in any case
1581  	    RAISE;
1582  	END get_id_spc_base_universe
1583  	;
1584  
1585  	FUNCTION get_spc_dim_details( p_usim_id_spc  IN  usim_space.usim_id_spc%TYPE
1586  				    , p_usim_id_mlv  OUT usim_multiverse.usim_id_mlv%TYPE
1587  				    , p_usim_id_rmd  OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
1588  				    , p_usim_sign    OUT usim_rel_mlv_dim.usim_sign%TYPE
1589  				    , p_usim_n1_sign OUT usim_rel_mlv_dim.usim_n1_sign%TYPE
1590  				    )
1591  	  RETURN NUMBER
1592  	IS
1593  	BEGIN
1594  	  IF usim_spc.has_data(p_usim_id_spc) = 1
1595  	  THEN
1596  	    p_usim_id_mlv   := usim_spc.get_id_mlv(p_usim_id_spc);
1597  	    p_usim_id_rmd   := usim_spc.get_id_rmd(p_usim_id_spc);
1598  	    p_usim_sign     := usim_spc.get_dim_sign(p_usim_id_spc);
1599  	    p_usim_n1_sign  := usim_spc.get_dim_n1_sign(p_usim_id_spc);
1600  	    RETURN 1;
1601  	  ELSE
1602  	    usim_erl.log_error('usim_dbif.get_spc_dim_details', 'Not existing space id [' || p_usim_id_spc || '].');
1603  	    usim_dbif.set_crashed;
1604  	    RETURN 0;
1605  	  END IF;
1606  	EXCEPTION
1607  	  WHEN OTHERS THEN
1608  	    -- write error might still work
1609  	    usim_erl.log_error('usim_dbif.get_spc_dim_details', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1610  	    -- try to set all to crashed
1611  	    usim_dbif.set_crashed;
1612  	    -- raise in any case
1613  	    RAISE;
1614  	END get_spc_dim_details
1615  	;
1616  
1617  	FUNCTION get_abs_max_number
1618  	  RETURN NUMBER
1619  	IS
1620  	  l_result NUMBER;
1621  	BEGIN
1622  	  l_result := usim_base.get_abs_max_number;
1623  	  IF l_result IS NULL
1624  	  THEN
1625  	    usim_erl.log_error('usim_dbif.get_abs_max_number', 'Base data not initialized.');
1626  	  END IF;
1627  	  RETURN l_result;
1628  	EXCEPTION
1629  	  WHEN OTHERS THEN
1630  	    -- write error might still work
1631  	    usim_erl.log_error('usim_dbif.get_abs_max_number', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1632  	    -- try to set all to crashed
1633  	    usim_dbif.set_crashed;
1634  	    -- raise in any case
1635  	    RAISE;
1636  	END get_abs_max_number
1637  	;
1638  
1639  	FUNCTION get_dim_coord( p_usim_id_spc	   IN usim_space.usim_id_spc%TYPE
1640  			      , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
1641  			      )
1642  	  RETURN usim_position.usim_coordinate%TYPE
1643  	IS
1644  	  l_result usim_position.usim_coordinate%TYPE;
1645  	BEGIN
1646  	  l_result := usim_spo.get_dim_coord(p_usim_id_spc, p_usim_n_dimension);
1647  	  IF l_result IS NULL
1648  	  THEN
1649  	    usim_erl.log_error('usim_dbif.get_dim_coord', 'Invalid space id [' || p_usim_id_spc || '] or dimension [' || p_usim_n_dimension || '].');
1650  	  END IF;
1651  	  RETURN l_result;
1652  	EXCEPTION
1653  	  WHEN OTHERS THEN
1654  	    -- write error might still work
1655  	    usim_erl.log_error('usim_dbif.get_dim_coord', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1656  	    -- try to set all to crashed
1657  	    usim_dbif.set_crashed;
1658  	    -- raise in any case
1659  	    RAISE;
1660  	END get_dim_coord
1661  	;
1662  
1663  	FUNCTION get_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1664  	  RETURN usim_dimension.usim_n_dimension%TYPE
1665  	IS
1666  	  l_result usim_dimension.usim_n_dimension%TYPE;
1667  	BEGIN
1668  	  l_result := usim_spc.get_dimension(p_usim_id_spc);
1669  	  IF l_result = -1
1670  	  THEN
1671  	    usim_erl.log_error('usim_dbif.get_dimension', 'Invalid space id [' || p_usim_id_spc || '].');
1672  	  END IF;
1673  	  RETURN l_result;
1674  	EXCEPTION
1675  	  WHEN OTHERS THEN
1676  	    -- write error might still work
1677  	    usim_erl.log_error('usim_dbif.get_dimension', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1678  	    -- try to set all to crashed
1679  	    usim_dbif.set_crashed;
1680  	    -- raise in any case
1681  	    RAISE;
1682  	END get_dimension
1683  	;
1684  
1685  	FUNCTION get_dim_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1686  	  RETURN usim_rel_mlv_dim.usim_sign%TYPE
1687  	IS
1688  	  l_result usim_rel_mlv_dim.usim_sign%TYPE;
1689  	BEGIN
1690  	  l_result := usim_spc.get_dim_sign(p_usim_id_spc);
1691  	  IF l_result IS NULL
1692  	  THEN
1693  	    usim_erl.log_error('usim_dbif.get_dim_sign', 'Invalid space id [' || p_usim_id_spc || '].');
1694  	  END IF;
1695  	  RETURN l_result;
1696  	EXCEPTION
1697  	  WHEN OTHERS THEN
1698  	    -- write error might still work
1699  	    usim_erl.log_error('usim_dbif.get_dim_sign', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1700  	    -- try to set all to crashed
1701  	    usim_dbif.set_crashed;
1702  	    -- raise in any case
1703  	    RAISE;
1704  	END get_dim_sign
1705  	;
1706  
1707  	FUNCTION get_dim_n1_sign(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1708  	  RETURN usim_rel_mlv_dim.usim_n1_sign%TYPE
1709  	IS
1710  	  l_result usim_rel_mlv_dim.usim_n1_sign%TYPE;
1711  	BEGIN
1712  	  l_result := usim_spc.get_dim_n1_sign(p_usim_id_spc);
1713  	  IF l_result IS NULL
1714  	  THEN
1715  	    usim_erl.log_error('usim_dbif.get_dim_n1_sign', 'Invalid space id [' || p_usim_id_spc || '].');
1716  	  END IF;
1717  	  RETURN l_result;
1718  	EXCEPTION
1719  	  WHEN OTHERS THEN
1720  	    -- write error might still work
1721  	    usim_erl.log_error('usim_dbif.get_dim_n1_sign', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1722  	    -- try to set all to crashed
1723  	    usim_dbif.set_crashed;
1724  	    -- raise in any case
1725  	    RAISE;
1726  	END get_dim_n1_sign
1727  	;
1728  
1729  	FUNCTION get_xyz(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1730  	  RETURN VARCHAR2
1731  	IS
1732  	  l_result VARCHAR2(32000);
1733  	BEGIN
1734  	  l_result := usim_spo.get_xyz(p_usim_id_spc);
1735  	  IF l_result IS NULL
1736  	  THEN
1737  	    usim_erl.log_error('usim_dbif.get_xyz', 'Invalid space id [' || p_usim_id_spc || '].');
1738  	  END IF;
1739  	  RETURN l_result;
1740  	EXCEPTION
1741  	  WHEN OTHERS THEN
1742  	    -- write error might still work
1743  	    usim_erl.log_error('usim_dbif.get_xyz', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1744  	    -- try to set all to crashed
1745  	    usim_dbif.set_crashed;
1746  	    -- raise in any case
1747  	    RAISE;
1748  	END get_xyz
1749  	;
1750  
1751  	FUNCTION get_magnitude( p_usim_id_spc	   IN usim_space.usim_id_spc%TYPE
1752  			      , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
1753  			      )
1754  	  RETURN NUMBER
1755  	IS
1756  	  l_result  NUMBER;
1757  	BEGIN
1758  	  l_result := usim_spo.get_magnitude(p_usim_id_spc, p_usim_n_dimension);
1759  	  RETURN l_result;
1760  	EXCEPTION
1761  	  WHEN OTHERS THEN
1762  	    -- write error might still work
1763  	    usim_erl.log_error('usim_dbif.get_magnitude', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1764  	    -- try to set all to crashed
1765  	    usim_dbif.set_crashed;
1766  	    -- raise in any case
1767  	    RAISE;
1768  	END get_magnitude
1769  	;
1770  
1771  	FUNCTION get_process_spin(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1772  	  RETURN usim_space.usim_process_spin%TYPE
1773  	IS
1774  	  l_result usim_space.usim_process_spin%TYPE;
1775  	BEGIN
1776  	  l_result := usim_spc.get_process_spin(p_usim_id_spc);
1777  	  IF l_result IS NULL
1778  	  THEN
1779  	    usim_erl.log_error('usim_dbif.get_process_spin', 'Used with invalid space id [' || p_usim_id_spc || '].');
1780  	  END IF;
1781  	  RETURN l_result;
1782  	EXCEPTION
1783  	  WHEN OTHERS THEN
1784  	    -- write error might still work
1785  	    usim_erl.log_error('usim_dbif.get_process_spin', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1786  	    -- try to set all to crashed
1787  	    usim_dbif.set_crashed;
1788  	    -- raise in any case
1789  	    RAISE;
1790  	END get_process_spin
1791  	;
1792  
1793  	FUNCTION get_universe_state_desc(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1794  	  RETURN VARCHAR2
1795  	IS
1796  	  l_mlv_id    usim_multiverse.usim_id_mlv%TYPE;
1797  	  l_state     usim_multiverse.usim_universe_status%TYPE;
1798  	  l_result    VARCHAR2(8);
1799  	BEGIN
1800  	  -- get universe
1801  	  l_mlv_id := usim_spc.get_id_mlv(p_usim_id_spc);
1802  	  IF l_mlv_id IS NULL
1803  	  THEN
1804  	    RETURN 'UNKNOWN';
1805  	  END IF;
1806  	  l_state  := usim_mlv.get_state(l_mlv_id);
1807  	  l_result := usim_static.get_multiverse_status(l_state);
1808  	  RETURN l_result;
1809  	EXCEPTION
1810  	  WHEN OTHERS THEN
1811  	    -- write error might still work
1812  	    usim_erl.log_error('usim_dbif.get_universe_state_desc', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1813  	    -- try to set all to crashed
1814  	    usim_dbif.set_crashed;
1815  	    -- raise in any case
1816  	    RAISE;
1817  	END get_universe_state_desc
1818  	;
1819  
1820  	FUNCTION get_planck_time_current
1821  	  RETURN NUMBER
1822  	IS
1823  	  l_result NUMBER;
1824  	BEGIN
1825  	  l_result := usim_base.get_planck_time_current;
1826  	  IF l_result IS NULL
1827  	  THEN
1828  	    usim_erl.log_error('usim_dbif.get_planck_time_current', 'Planck time not initialized.');
1829  	    usim_dbif.set_crashed;
1830  	  END IF;
1831  	  RETURN l_result;
1832  	EXCEPTION
1833  	  WHEN OTHERS THEN
1834  	    -- write error might still work
1835  	    usim_erl.log_error('usim_dbif.get_planck_time_current', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1836  	    -- try to set all to crashed
1837  	    usim_dbif.set_crashed;
1838  	    -- raise in any case
1839  	    RAISE;
1840  	END get_planck_time_current
1841  	;
1842  
1843  	FUNCTION get_planck_aeon_seq_current
1844  	  RETURN VARCHAR2
1845  	IS
1846  	  l_result CHAR(55);
1847  	BEGIN
1848  	  l_result := usim_base.get_planck_aeon_seq_current;
1849  	  IF l_result IS NULL
1850  	  THEN
1851  	    usim_erl.log_error('usim_dbif.get_planck_aeon_seq_current', 'Planck aeon not initialized.');
1852  	    usim_dbif.set_crashed;
1853  	  END IF;
1854  	  RETURN l_result;
1855  	EXCEPTION
1856  	  WHEN OTHERS THEN
1857  	    -- write error might still work
1858  	    usim_erl.log_error('usim_dbif.get_planck_aeon_seq_current', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1859  	    -- try to set all to crashed
1860  	    usim_dbif.set_crashed;
1861  	    -- raise in any case
1862  	    RAISE;
1863  	END get_planck_aeon_seq_current
1864  	;
1865  
1866  	FUNCTION get_planck_time_next
1867  	  RETURN NUMBER
1868  	IS
1869  	  l_result NUMBER;
1870  	BEGIN
1871  	  l_result := usim_base.get_planck_time_next;
1872  	  IF l_result IS NULL
1873  	  THEN
1874  	    usim_erl.log_error('usim_dbif.get_planck_time_next', 'Planck time initialization error.');
1875  	    usim_dbif.set_crashed;
1876  	  END IF;
1877  	  RETURN l_result;
1878  	EXCEPTION
1879  	  WHEN OTHERS THEN
1880  	    -- write error might still work
1881  	    usim_erl.log_error('usim_dbif.get_planck_time_next', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1882  	    -- try to set all to crashed
1883  	    usim_dbif.set_crashed;
1884  	    -- raise in any case
1885  	    RAISE;
1886  	END get_planck_time_next
1887  	;
1888  
1889  	FUNCTION get_unprocessed_planck( p_usim_planck_aeon OUT usim_spc_process.usim_planck_aeon%TYPE
1890  				       , p_usim_planck_time OUT usim_spc_process.usim_planck_time%TYPE
1891  				       )
1892  	  RETURN NUMBER
1893  	IS
1894  	  l_return NUMBER;
1895  	BEGIN
1896  	  l_return := usim_spr.get_unprocessed_planck(p_usim_planck_aeon, p_usim_planck_time);
1897  	  RETURN l_return;
1898  	EXCEPTION
1899  	  WHEN OTHERS THEN
1900  	    -- write error might still work
1901  	    usim_erl.log_error('usim_dbif.get_unprocessed_planck', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1902  	    -- try to set all to crashed
1903  	    usim_dbif.set_crashed;
1904  	    -- raise in any case
1905  	    RAISE;
1906  	END get_unprocessed_planck
1907  	;
1908  
1909  	FUNCTION get_axis_max_pos_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1910  	  RETURN usim_space.usim_id_spc%TYPE
1911  	IS
1912  	  l_result usim_space.usim_id_spc%TYPE;
1913  	BEGIN
1914  	  l_result := usim_spo.get_axis_max_pos_parent(p_usim_id_spc);
1915  	  RETURN l_result;
1916  	EXCEPTION
1917  	  WHEN OTHERS THEN
1918  	    -- write error might still work
1919  	    usim_erl.log_error('usim_dbif.get_axis_max_pos_parent', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1920  	    -- try to set all to crashed
1921  	    usim_dbif.set_crashed;
1922  	    -- raise in any case
1923  	    RAISE;
1924  	END get_axis_max_pos_parent
1925  	;
1926  
1927  	FUNCTION get_axis_max_pos_dim1(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
1928  	  RETURN usim_position.usim_coordinate%TYPE
1929  	IS
1930  	  l_id_mlv  usim_multiverse.usim_id_mlv%TYPE;
1931  	  l_n1_sign usim_rel_mlv_dim.usim_n1_sign%TYPE;
1932  	  l_id_spc  usim_space.usim_id_spc%TYPE;
1933  	  l_parent  usim_space.usim_id_spc%TYPE;
1934  	  l_max_pos usim_position.usim_coordinate%TYPE;
1935  	BEGIN
1936  	  l_id_mlv  := usim_spc.get_id_mlv(p_usim_id_spc);
1937  	  l_n1_sign := usim_spc.get_dim_n1_sign(p_usim_id_spc);
1938  	  IF usim_spc.get_cur_max_dim_n1(p_usim_id_spc) > 0
1939  	  THEN
1940  	    -- get dimension 1 by universe parent
1941  	    WITH rmd AS
1942  		 (SELECT usim_id_rmd
1943  		    FROM usim_rmd_v
1944  		   WHERE usim_id_mlv = l_id_mlv
1945  		     AND usim_n_dimension = 0
1946  		 )
1947  	       , spc AS
1948  		 (SELECT spcv.usim_id_spc
1949  		    FROM usim_spc_v spcv
1950  		   INNER JOIN rmd
1951  		      ON spcv.usim_id_rmd = rmd.usim_id_rmd
1952  		 )
1953  	    SELECT chiv.usim_id_spc_child
1954  	      INTO l_id_spc
1955  	      FROM usim_chi_v chiv
1956  	     INNER JOIN spc
1957  		ON chiv.usim_id_spc = spc.usim_id_spc
1958  	     WHERE child_dim_n1_sign = l_n1_sign
1959  	    ;
1960  	    l_parent  := usim_spo.get_axis_max_pos_parent(l_id_spc);
1961  	    IF l_parent IS NULL
1962  	    THEN
1963  	      usim_erl.log_error('usim_dbif.get_axis_max_pos_dim1', 'Could not get max axis dimension 1 coordinate for [' || p_usim_id_spc || '] axis 1 pos 0 id [' || l_id_spc || '].');
1964  	      usim_dbif.set_crashed;
1965  	    END IF;
1966  	    l_max_pos := usim_spc.get_coordinate(l_parent);
1967  	    IF l_max_pos IS NULL
1968  	    THEN
1969  	      usim_erl.log_error('usim_dbif.get_axis_max_pos_dim1', 'Could not get max coordinate for [' || p_usim_id_spc || '] max pos space id [' || l_parent || '].');
1970  	      usim_dbif.set_crashed;
1971  	    END IF;
1972  	    RETURN l_max_pos;
1973  	  ELSE
1974  	    RETURN 0;
1975  	  END IF;
1976  	EXCEPTION
1977  	  WHEN OTHERS THEN
1978  	    -- write error might still work
1979  	    usim_erl.log_error('usim_dbif.get_axis_max_pos_dim1', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
1980  	    -- try to set all to crashed
1981  	    usim_dbif.set_crashed;
1982  	    -- raise in any case
1983  	    RAISE;
1984  	END get_axis_max_pos_dim1
1985  	;
1986  
1987  	FUNCTION get_next_pos_on_axis( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
1988  				     , p_usim_id_pos OUT usim_position.usim_id_pos%TYPE
1989  				     , p_usim_id_rmd OUT usim_rel_mlv_dim.usim_id_rmd%TYPE
1990  				     )
1991  	  RETURN NUMBER
1992  	IS
1993  	  l_new_pos NUMBER;
1994  	BEGIN
1995  	  IF usim_spc.has_data(p_usim_id_spc) = 1
1996  	  THEN
1997  	    -- determine the sign of the coordinate by dim sign
1998  	    IF usim_spc.get_dim_sign(p_usim_id_spc) = 1
1999  	    THEN
2000  	      l_new_pos := usim_spc.get_coordinate(p_usim_id_spc) + 1;
2001  	    ELSE
2002  	      l_new_pos := usim_spc.get_coordinate(p_usim_id_spc) - 1;
2003  	    END IF;
2004  	    p_usim_id_pos := usim_pos.get_id_pos(l_new_pos);
2005  	    p_usim_id_rmd := usim_spc.get_id_rmd(p_usim_id_spc);
2006  	    RETURN 1;
2007  	  ELSE
2008  	    usim_erl.log_error('usim_dbif.get_next_pos_on_axis', 'Invalid space id [' || p_usim_id_spc || '].');
2009  	    RETURN 0;
2010  	  END IF;
2011  	EXCEPTION
2012  	  WHEN OTHERS THEN
2013  	    -- write error might still work
2014  	    usim_erl.log_error('usim_dbif.get_next_pos_on_axis', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2015  	    -- try to set all to crashed
2016  	    usim_dbif.set_crashed;
2017  	    -- raise in any case
2018  	    RAISE;
2019  	END get_next_pos_on_axis
2020  	;
2021  
2022  	FUNCTION overflow_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
2023  	  RETURN NUMBER
2024  	IS
2025  	BEGIN
2026  	  -- do we have overflow on dimensions and positions
2027  	  IF	  usim_dbif.is_overflow_dim_spc(p_usim_id_spc) = 1
2028  	     AND  usim_dbif.is_overflow_pos_spc(p_usim_id_spc) = 1
2029  	  THEN
2030  	    -- total overflow, no possible dimension or position open
2031  	    RETURN 0;
2032  	  ELSIF usim_dbif.max_childs(p_usim_id_spc) = usim_dbif.child_count(p_usim_id_spc)
2033  	  THEN
2034  	    -- total overflow, all possible childs connected
2035  	    RETURN 0;
2036  	  ELSIF usim_dbif.is_overflow_pos_spc(p_usim_id_spc) = 1
2037  	  THEN
2038  	    -- position overflow
2039  	    RETURN 2;
2040  	  ELSIF usim_dbif.is_overflow_dim_spc(p_usim_id_spc) = 1
2041  	  THEN
2042  	    -- dimension overflow
2043  	    RETURN 3;
2044  	  ELSE
2045  	    -- no overflow
2046  	    RETURN 1;
2047  	  END IF;
2048  	EXCEPTION
2049  	  WHEN OTHERS THEN
2050  	    -- write error might still work
2051  	    usim_erl.log_error('usim_dbif.overflow_rating', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2052  	    -- try to set all to crashed
2053  	    usim_dbif.set_crashed;
2054  	    -- raise in any case
2055  	    RAISE;
2056  	END overflow_rating
2057  	;
2058  
2059  	FUNCTION dimension_rating( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
2060  				 , p_max_childs  OUT NUMBER
2061  				 )
2062  	  RETURN NUMBER
2063  	IS
2064  	  l_return	 NUMBER;
2065  	  l_count	 NUMBER;
2066  	  l_max_dim	 NUMBER;
2067  	  l_usim_id_rmd  usim_rel_mlv_dim.usim_id_rmd%TYPE;
2068  	  l_usim_id_pos  usim_position.usim_id_pos%TYPE;
2069  	  l_usim_id_nod  usim_node.usim_id_nod%TYPE;
2070  	  l_process_spin usim_space.usim_process_spin%TYPE;
2071  	  l_usim_id_mlv  usim_multiverse.usim_id_mlv%TYPE;
2072  	  l_n_dimension  usim_dimension.usim_n_dimension%TYPE;
2073  	  l_dim_sign	 usim_rel_mlv_dim.usim_sign%TYPE;
2074  	  l_dim_n1_sign  usim_rel_mlv_dim.usim_n1_sign%TYPE;
2075  	  l_coordinate	 usim_position.usim_coordinate%TYPE;
2076  	  l_is_base	 usim_multiverse.usim_is_base_universe%TYPE;
2077  	  l_energy	 usim_node.usim_energy%TYPE;
2078  	 BEGIN
2079  	  IF usim_spc.has_data(p_usim_id_spc) = 1
2080  	  THEN
2081  	    -- get details
2082  	    l_return := usim_spc.get_spc_details( p_usim_id_spc
2083  						, l_usim_id_rmd
2084  						, l_usim_id_pos
2085  						, l_usim_id_nod
2086  						, l_process_spin
2087  						, l_usim_id_mlv
2088  						, l_n_dimension
2089  						, l_dim_sign
2090  						, l_dim_n1_sign
2091  						, l_coordinate
2092  						, l_is_base
2093  						, l_energy
2094  						)
2095  	    ;
2096  	    IF l_return = 0
2097  	    THEN
2098  	      usim_erl.log_error('usim_dbif.dimension_rating', 'Failed to get details for space id [' || p_usim_id_spc || '].');
2099  	      RETURN -1;
2100  	    END IF;
2101  	    IF	   l_n_dimension = 0
2102  	       AND l_coordinate  = 0
2103  	    THEN
2104  	      -- only 2 special childs with opposite energy output sign possible
2105  	      p_max_childs := 2;
2106  	      RETURN 0;
2107  	    END IF;
2108  	    l_max_dim := NVL(usim_spc.get_cur_max_dim_n1(p_usim_id_spc), 0) + 1;
2109  	    IF usim_base.get_max_dimension < l_max_dim
2110  	    THEN
2111  	      l_max_dim := usim_base.get_max_dimension;
2112  	    END IF;
2113  	    IF	   l_n_dimension = 1
2114  	       AND l_coordinate  = 0
2115  	    THEN
2116  	      -- zero pos dimension axis at dimension 1
2117  	      -- all dimension axis and position on dimension axis: (max n - n) x 2 + 1 axis child
2118  	      p_max_childs := ((l_max_dim - l_n_dimension) * 2) + 1;
2119  	      RETURN 1;
2120  	    END IF;
2121  	    IF	   l_n_dimension > 1
2122  	       AND l_coordinate  = 0
2123  	    THEN
2124  	      -- zero pos dimension axis dimension > 1
2125  	      -- only position on dimension axis and 1 inbetween node: 2 childs
2126  	      p_max_childs := 2;
2127  	      RETURN 2;
2128  	    END IF;
2129  	    -- count coordinates not 0 for space id
2130  	    SELECT COUNT(*) INTO l_count FROM usim_spo_v WHERE usim_id_spc = p_usim_id_spc AND usim_coordinate != 0;
2131  	    IF	   l_count	 = 1
2132  	       AND l_coordinate != 0
2133  	    THEN
2134  	      -- pure dimension axis, possible childs: (max n - n) + 1 axis child
2135  	      p_max_childs := (l_max_dim  - l_n_dimension) + 1;
2136  	      RETURN 3;
2137  	    ELSE
2138  	      -- anywhere, possible childs: max n
2139  	      p_max_childs := l_max_dim;
2140  	      RETURN 4;
2141  	    END IF;
2142  	  ELSE
2143  	    usim_erl.log_error('usim_dbif.dimension_rating', 'Invalid space id [' || p_usim_id_spc || '].');
2144  	    RETURN -1;
2145  	  END IF;
2146  	EXCEPTION
2147  	  WHEN OTHERS THEN
2148  	    -- write error might still work
2149  	    usim_erl.log_error('usim_dbif.dimension_rating', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2150  	    -- try to set all to crashed
2151  	    usim_dbif.set_crashed;
2152  	    -- raise in any case
2153  	    RAISE;
2154  	END dimension_rating
2155  	;
2156  
2157  	FUNCTION dimension_rating(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
2158  	  RETURN NUMBER
2159  	IS
2160  	  l_max_childs NUMBER;
2161  	  l_rating     NUMBER;
2162  	BEGIN
2163  	  l_rating := usim_dbif.dimension_rating(p_usim_id_spc, l_max_childs);
2164  	  RETURN l_rating;
2165  	EXCEPTION
2166  	  WHEN OTHERS THEN
2167  	    -- write error might still work
2168  	    usim_erl.log_error('usim_dbif.dimension_rating', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2169  	    -- try to set all to crashed
2170  	    usim_dbif.set_crashed;
2171  	    -- raise in any case
2172  	    RAISE;
2173  	END dimension_rating
2174  	;
2175  
2176  	FUNCTION max_childs(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
2177  	  RETURN NUMBER
2178  	IS
2179  	  l_max_childs NUMBER;
2180  	  l_rating     NUMBER;
2181  	BEGIN
2182  	  l_rating := usim_dbif.dimension_rating(p_usim_id_spc, l_max_childs);
2183  	  RETURN l_max_childs;
2184  	EXCEPTION
2185  	  WHEN OTHERS THEN
2186  	    -- write error might still work
2187  	    usim_erl.log_error('usim_dbif.max_childs', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2188  	    -- try to set all to crashed
2189  	    usim_dbif.set_crashed;
2190  	    -- raise in any case
2191  	    RAISE;
2192  	END max_childs
2193  	;
2194  
2195  	FUNCTION classify_parent(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
2196  	  RETURN NUMBER
2197  	IS
2198  	  l_count	 NUMBER;
2199  	  l_return	 NUMBER;
2200  	  l_dim_rating	 NUMBER;
2201  	  l_parent_count NUMBER;
2202  	  l_child_count  NUMBER;
2203  	  l_connections  NUMBER;
2204  	  l_max_dim	 NUMBER;
2205  	  l_max_child	 NUMBER;
2206  	  l_dimension	 NUMBER;
2207  	  l_max_pos	 NUMBER;
2208  	  l_has_n1	 NUMBER;
2209  	BEGIN
2210  	  IF usim_spc.has_data(p_usim_id_spc) = 0
2211  	  THEN
2212  	    RETURN -1;
2213  	  END IF;
2214  	  -- get details
2215  	  l_dim_rating := usim_dbif.dimension_rating(p_usim_id_spc, l_max_child);
2216  	  IF l_dim_rating = -1
2217  	  THEN
2218  	    usim_erl.log_error('usim_dbif.classify_parent', 'Failed to get a dimension rating for space id [' || p_usim_id_spc || '].');
2219  	    RETURN -1;
2220  	  END IF;
2221  	  -- ignore errors like no child or parent, we get values anyway
2222  	  l_return	:= usim_chi.get_chi_details(p_usim_id_spc, l_parent_count, l_child_count);
2223  	  IF l_dim_rating = 0 -- center of a universe dimension
2224  	  THEN
2225  	    -- no more childs possible
2226  	    IF l_child_count = l_max_child
2227  	    THEN
2228  	      -- fully connected
2229  	      RETURN 0;
2230  	    ELSE
2231  	      -- only next dimension possible
2232  	      RETURN 2;
2233  	    END IF;
2234  	  ELSIF l_dim_rating = 1 -- center dimension axis with pos 0 dimension > 0
2235  	  THEN
2236  	    -- only 2 childs possible
2237  	    IF l_child_count = l_max_child
2238  	    THEN
2239  	      -- fully connected
2240  	      RETURN 0;
2241  	    ELSE
2242  	      IF l_child_count > 0
2243  	      THEN
2244  		-- find free node
2245  		IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
2246  		THEN
2247  		  -- if the position number on x axis that equals next dimension does not exist only position on X axis possible
2248  		  l_dimension := usim_spc.get_dimension(p_usim_id_spc) + 1;
2249  		  l_max_pos := ABS(NVL(usim_spc.get_coordinate(usim_spo.get_axis_max_pos_parent(p_usim_id_spc)), 1));
2250  		  IF l_max_pos >= l_dimension
2251  		  THEN
2252  		    -- only next dimension possible
2253  		    RETURN 2;
2254  		  ELSE
2255  		    -- first extend dimension axis
2256  		    RETURN 4;
2257  		  END IF;
2258  		ELSE
2259  		  -- position or dimension (not checking upper dimensions available)
2260  		  RETURN 1;
2261  		END IF;
2262  	      ELSE
2263  		-- no childs at all
2264  		-- position or dimension (not checking upper dimensions available)
2265  		RETURN 1;
2266  	      END IF;
2267  	    END IF;
2268  	  ELSIF l_dim_rating = 2 -- on dimension axis pos > 0
2269  	  THEN
2270  	    IF l_child_count = l_max_child
2271  	    THEN
2272  	      -- fully connected
2273  	      RETURN 0;
2274  	    ELSE
2275  	      -- find free node
2276  	      IF l_child_count > 0
2277  	      THEN
2278  		IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
2279  		THEN
2280  		  -- only next dimension possible
2281  		  RETURN 2;
2282  		ELSE
2283  		  -- position or dimension (not checking upper dimensions available)
2284  		  RETURN 1;
2285  		END IF;
2286  	      ELSE
2287  		-- position or dimension (not checking upper dimensions available)
2288  		RETURN 1;
2289  	      END IF;
2290  	    END IF;
2291  	  ELSE -- everywhere else
2292  	    IF l_child_count = l_max_child
2293  	    THEN
2294  	      -- fully connected
2295  	      RETURN 0;
2296  	    ELSE
2297  	      IF usim_chi.has_child_same_dim(p_usim_id_spc) = 1
2298  	      THEN
2299  		-- only next dimension possible
2300  		RETURN 2;
2301  	      ELSE
2302  		-- position or dimension (not checking upper dimensions available)
2303  		RETURN 1;
2304  	      END IF;
2305  	    END IF;
2306  	  END IF;
2307  	EXCEPTION
2308  	  WHEN OTHERS THEN
2309  	    -- write error might still work
2310  	    usim_erl.log_error('usim_dbif.classify_parent', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2311  	    -- try to set all to crashed
2312  	    usim_dbif.set_crashed;
2313  	    -- raise in any case
2314  	    RAISE;
2315  	END classify_parent
2316  	;
2317  
2318  	FUNCTION classify_escape(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
2319  	  RETURN NUMBER
2320  	IS
2321  	  l_parent_classification NUMBER;
2322  	  l_max_dim		  NUMBER;
2323  	  l_max_cur_dim 	  NUMBER;
2324  	  l_max_pos		  NUMBER;
2325  	  l_max_cur_pos 	  NUMBER;
2326  	  l_max_n1_pos		  NUMBER;
2327  	  l_max_childs		  NUMBER;
2328  	  l_childs		  NUMBER;
2329  	BEGIN
2330  	  IF usim_spc.has_data(p_usim_id_spc) = 1
2331  	  THEN
2332  	    l_max_dim		    := usim_base.get_max_dimension;
2333  	    l_max_pos		    := usim_base.get_abs_max_number;
2334  	    l_max_cur_dim	    := usim_spc.get_cur_max_dim_n1(p_usim_id_spc);
2335  	    l_max_cur_pos	    := usim_spc.get_cur_max_pos(p_usim_id_spc);
2336  	    l_max_childs	    := usim_dbif.max_childs(p_usim_id_spc);
2337  	    l_childs		    := usim_dbif.child_count(p_usim_id_spc);
2338  	    l_parent_classification := usim_dbif.classify_parent(p_usim_id_spc);
2339  	    l_max_n1_pos	    := ABS(usim_dbif.get_axis_max_pos_dim1(p_usim_id_spc));
2340  
2341  	    -- check all classifications against all kinds of overflow
2342  	    IF l_parent_classification < 0
2343  	    THEN
2344  	      -- classification error, we should stop here
2345  	      usim_erl.log_error('usim_dbif.classify_escape', 'Classification error parent on id [' || p_usim_id_spc || '].');
2346  	      usim_dbif.set_crashed;
2347  	      RETURN -1;
2348  	    ELSIF l_parent_classification = 0
2349  	    THEN
2350  	      RETURN l_parent_classification;
2351  	    ELSIF l_parent_classification = 1
2352  	    THEN
2353  	      -- check if dimension and positions are over the max for n1 side of space node
2354  	      IF     l_max_cur_dim  < l_max_dim
2355  		 AND l_max_cur_pos  < l_max_pos
2356  		 AND l_max_n1_pos  >= l_max_cur_dim
2357  	      THEN
2358  		-- everything available
2359  		RETURN l_parent_classification;
2360  	      ELSIF	l_max_cur_dim  < l_max_dim
2361  		    AND l_max_n1_pos  >= l_max_cur_dim
2362  	      THEN
2363  		-- only dimensions available
2364  		RETURN 2;
2365  	      ELSIF	l_max_cur_dim < l_max_dim
2366  		    AND l_max_n1_pos  < l_max_cur_dim
2367  	      THEN
2368  		IF usim_dbif.has_free_between(p_usim_id_spc) = 1
2369  		THEN
2370  		  -- prefer filling between nodes
2371  		  RETURN 7;
2372  		ELSE
2373  		  -- only position dim axis 1 delegate available
2374  		  RETURN 6;
2375  		END IF;
2376  	      ELSIF l_max_cur_pos < l_max_pos
2377  	      THEN
2378  		-- only positions available
2379  		RETURN 3;
2380  	      -- full only new universe or delegate between
2381  	      ELSIF usim_dbif.has_free_between(p_usim_id_spc) = 1
2382  	      THEN
2383  		  -- delegate between
2384  		  RETURN 7;
2385  	      ELSE
2386  		-- no delegate options
2387  		RETURN 0;
2388  	      END IF;
2389  	    ELSIF l_parent_classification = 2
2390  	    THEN
2391  	      -- check
2392  	      IF     l_max_cur_dim  < l_max_dim
2393  		 AND l_max_n1_pos  >= l_max_cur_dim
2394  	      THEN
2395  		-- everything available
2396  		RETURN l_parent_classification;
2397  	      ELSIF	l_max_cur_dim < l_max_dim
2398  		    AND l_max_n1_pos  < l_max_cur_dim
2399  	      THEN
2400  		IF usim_dbif.has_free_between(p_usim_id_spc) = 1
2401  		THEN
2402  		  -- prefer filling between nodes
2403  		  RETURN 7;
2404  		ELSE
2405  		  -- only position dim axis 1 delegate available
2406  		  RETURN 6;
2407  		END IF;
2408  	      -- full only new universe or delegate
2409  	      ELSIF	l_max_cur_pos				  < l_max_pos
2410  		    AND usim_dbif.has_free_between(p_usim_id_spc) = 0
2411  	      THEN
2412  		-- delegate position, if no between nodes are free
2413  		RETURN 5;
2414  	      ELSIF usim_dbif.has_free_between(p_usim_id_spc) = 1
2415  	      THEN
2416  		-- delegate between
2417  		RETURN 7;
2418  	      ELSE
2419  		-- no delegate options
2420  		RETURN 0;
2421  	      END IF;
2422  	    ELSIF l_parent_classification IN (3, 4)
2423  	    THEN
2424  	      -- check
2425  	      IF l_max_cur_pos < l_max_pos
2426  	      THEN
2427  		-- everything available
2428  		RETURN l_parent_classification;
2429  	      -- full only new universe or delegate
2430  	      ELSIF	l_parent_classification 		  = 4
2431  		    AND usim_dbif.has_free_between(p_usim_id_spc) = 0
2432  	      THEN
2433  		RETURN l_parent_classification;
2434  	      ELSIF	l_max_cur_dim				  < l_max_dim
2435  		    AND usim_dbif.has_free_between(p_usim_id_spc) = 0
2436  	      THEN
2437  		-- delegate new dimension, if no between nodes are free
2438  		RETURN 4;
2439  	      ELSIF usim_dbif.has_free_between(p_usim_id_spc) = 1
2440  	      THEN
2441  		-- delegate between
2442  		RETURN 7;
2443  	      ELSE
2444  		-- no delegate options
2445  		RETURN 0;
2446  	      END IF;
2447  	    ELSE
2448  	      -- classification unknown
2449  	      usim_erl.log_error('usim_dbif.classify_escape', 'Unknown parent classfication [' || l_parent_classification || '] for id [' || p_usim_id_spc || '].');
2450  	      usim_dbif.set_crashed;
2451  	      RETURN -1;
2452  	    END IF;
2453  	  ELSE
2454  	    RETURN -1;
2455  	  END IF;
2456  	EXCEPTION
2457  	  WHEN OTHERS THEN
2458  	    -- write error might still work
2459  	    usim_erl.log_error('usim_dbif.classify_escape', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
2460  	    -- try to set all to crashed
2461  	    usim_dbif.set_crashed;
2462  	    -- raise in any case
2463  	    RAISE;
2464  	END classify_escape
2465  	;
2466  
2467  	FUNCTION get_dim_G( p_usim_id_spc IN  usim_space.usim_id_spc%TYPE
2468  			  , p_node_G	  OUT NUMBER
2469  			  )
2470  	  RETURN NUMBER
2471  	IS
2472  	  l_dimension	usim_dimension.usim_n_dimension%TYPE;
2473  	  l_G		NUMBER;
2474  	BEGIN
2475  	  IF usim_spc.has_data(p_usim_id_spc) = 0
2476  	  THEN
2477  	    usim_erl.log_error('usim_process.get_dim_G', 'Used with invalid space id [' || p_usim_id_spc || '].');
2478  	    RETURN -1;
2479  	  END IF;
2480  	  l_dimension := usim_spc.get_dimension(p_usim_id_spc);
2481  	  IF l_dimension = -1
2482  	  THEN
2483  	    usim_erl.log_error('usim_process.get_dim_G', 'Failed to get_dimension for space id [' || p_usim_id_spc || '].');
2484  	    RETURN -1;
2485  	  END IF;
2486  	  l_G := usim_maths.calc_dim_G(l_dimension);
2487  	  IF usim_base.num_has_overflow(l_G) = 1
2488  	  THEN
2489  	    usim_erl.log_error('usim_dbif.get_dim_G', 'Numerical overflow for l_G[' || l_G || '] overflow [' || usim_base.get_abs_max_number || ',-' || usim_base.get_abs_max_number || '] underflow[' || usim_base.get_max_underflow || ',' || usim_base.get_min_underflow || '].');
2490  	    RETURN 0;
2491  	  ELSE
2492  	    -- only set out value if valid value
2493  	    p_node_G := l_G;
2494  	    RETURN 1;
2495  	  END IF;
2496  	EXCEPTION
2497  	  WHEN OTHERS THEN
2498  	    IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
2499  	    THEN
2500  	      -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
2501  	      -- -1487: packed decimal number too large
2502  	      usim_erl.log_error('usim_dbif.get_dim_G', 'Numerical error on G calculate [' || SQLCODE || '] error message: ' || SQLERRM);
2503  	      RETURN 0;
2504  	    ELSE
2505  	      usim_erl.log_error('usim_dbif.get_dim_G', 'Unknown error [' || SQLCODE || '] error message: ' || SQLERRM);
2506  	      -- try to set all to crashed
2507  	      usim_dbif.set_crashed;
2508  	      -- return -1 handling is up to caller
2509  	      RETURN -1;
2510  	    END IF;
2511  	END get_dim_G
2512  	;
2513  
2514  	FUNCTION get_outer_planck_r( p_usim_id_spc    IN  usim_space.usim_id_spc%TYPE
2515  				   , p_outer_planck_r OUT NUMBER
2516  				   )
2517  	  RETURN NUMBER
2518  	IS
2519  	  l_planck_length NUMBER;
2520  	  l_radius	  NUMBER;
2521  	BEGIN
2522  	  IF usim_spc.has_data(p_usim_id_spc) = 0
2523  	  THEN
2524  	    usim_erl.log_error('usim_process.get_dim_G', 'Used with invalid space id [' || p_usim_id_spc || '].');
2525  	    RETURN -1;
2526  	  END IF;
2527  	  SELECT usim_planck_length_unit
2528  	    INTO l_planck_length
2529  	    FROM usim_spc_v
2530  	   WHERE usim_id_spc = p_usim_id_spc
2531  	  ;
2532  	  l_radius := usim_maths.apply_planck(1, l_planck_length);
2533  	  IF usim_base.num_has_overflow(l_radius) = 1
2534  	  THEN
2535  	    usim_erl.log_error('usim_dbif.get_outer_planck_r', 'Numerical overflow for l_radius[' || l_radius || '] overflow [' || usim_base.get_abs_max_number || ',-' || usim_base.get_abs_max_number || '] underflow[' || usim_base.get_max_underflow || ',' || usim_base.get_min_underflow || '].');
2536  	    RETURN 0;
2537  	  ELSE
2538  	    -- only set out value if valid value
2539  	    p_outer_planck_r := l_radius;
2540  	    RETURN 1;
2541  	  END IF;
2542  	EXCEPTION
2543  	  WHEN OTHERS THEN
2544  	    IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
2545  	    THEN
2546  	      -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
2547  	      -- -1487: packed decimal number too large
2548  	      usim_erl.log_error('usim_dbif.get_outer_planck_r', 'Numerical error on outer planck r calculation [' || SQLCODE || '] error message: ' || SQLERRM);
2549  	      RETURN 0;
2550  	    ELSE
2551  	      usim_erl.log_error('usim_process.get_outer_planck_r', 'Unknown error [' || SQLCODE || '] error message: ' || SQLERRM);
2552  	      -- try to set all to crashed
2553  	      usim_dbif.set_crashed;
2554  	      -- return -1 handling is up to caller
2555  	      RETURN -1;
2556  	    END IF;
2557  	END get_outer_planck_r
2558  	;
2559  
2560  	FUNCTION get_acceleration( p_energy	    IN	NUMBER
2561  				 , p_radius	    IN	NUMBER
2562  				 , p_G		    IN	NUMBER
2563  				 , p_target_energy  OUT NUMBER
2564  				 )
2565  	  RETURN NUMBER
2566  	IS
2567  	  l_energy NUMBER;
2568  	BEGIN
2569  	  l_energy := usim_maths.calc_planck_a2(p_energy, p_radius, p_G);
2570  	  IF usim_base.num_has_overflow(l_energy) = 1
2571  	  THEN
2572  	    usim_debug.debug_log('usim_dbif.get_acceleration', 'Numerical overflow for l_energy[' || l_energy || '] overflow [' || usim_base.get_abs_max_number || ',-' || usim_base.get_abs_max_number || '] underflow[' || usim_base.get_max_underflow || ',' || usim_base.get_min_underflow || '].');
2573  	    RETURN 0;
2574  	  ELSE
2575  	    -- only set out value if valid value
2576  	    p_target_energy := l_energy;
2577  	    RETURN 1;
2578  	  END IF;
2579  	EXCEPTION
2580  	  WHEN OTHERS THEN
2581  	    IF SQLCODE IN (-6502, -1426, -1428, -1476, -1487)
2582  	    THEN
2583  	      -- -6502 numeric value error POWER etc. or -1426 overflow or -1428 value range, -1476 zero divide, -1401: inserted value too large for column
2584  	      -- -1487: packed decimal number too large
2585  	      usim_debug.debug_log('usim_dbif.get_acceleration', 'Numerical error on acceleration calculation [' || SQLCODE || '] error message: ' || SQLERRM);
2586  	      RETURN 0;
2587  	    ELSE
2588  	      usim_erl.log_error('usim_process.get_acceleration', 'Unknown error [' || SQLCODE || '] error message: ' || SQLERRM);
2589  	      -- try to set all to crashed
2590  	      usim_dbif.set_crashed;
2591  	      -- return -1 handling is up to caller
2592  	      RETURN -1;
2593  	    END IF;
2594  	END get_acceleration
2595  	;
2596  
2597  END usim_dbif;
2598  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_dbif
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_dbif

Package body created.

SQL> --== interface package end ==--
SQL> --== processing packages start ==--
SQL> @@../PACKAGES/USIM_CREATOR.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_creator
  2  IS
  3    /**A package providing creator function on objects needed */
  4  
  5    /**
  6    * Writes a given CLOB with JSON data to the given filename with extension .json in directory USIM_DIR. Copies existing files
  7    * to the directory USIM_HIST_DIR and renames them to [filename]_YYYYMMDDHH24MISS.json.
  8    * @param p_json_clob The JSON formatted CLOB to write to [p_filename].json.
  9    * @param p_filename The filename for the JSON file to write. Do not use special chars and spaces. Lenght limited to 100.
 10    * @return Return 1 if file was written, 0 on errors.
 11    */
 12    FUNCTION write_json_file( p_json_clob IN CLOB
 13  			       , p_filename  IN VARCHAR2 DEFAULT 'usim_space_log'
 14  			       )
 15  	 RETURN NUMBER
 16    ;
 17  
 18    /**
 19    * Builds a JSON representation of the USIM_SPC_PROCESS content for the given range. If size too long for JS P5 limit the size by choosen range.
 20    * Will also create an assoziated structure.
 21    * @param p_planck_aeon The valid planck time aeon for the log.
 22    * @param p_from_planck_time The valid planck time tick for start of log.
 23    * @param p_to_planck_time The valid planck time tick for end of log.
 24    * @param p_json_log The JSON formatted log chunk as CLOB.
 25    * @return Return 1 if log was completely delivered or -1 on errors.
 26    */
 27    FUNCTION get_json_log( p_planck_aeon	 IN	usim_spc_process.usim_planck_aeon%TYPE
 28  			    , p_from_planck_time IN	usim_spc_process.usim_planck_time%TYPE
 29  			    , p_to_planck_time	 IN	usim_spc_process.usim_planck_time%TYPE
 30  			    , p_json_log	    OUT CLOB
 31  			    )
 32  	 RETURN NUMBER
 33    ;
 34  
 35    /**
 36    * Builds a JSON representation of the USIM_SPACE content in means of coordinates and child relations for all
 37    * existing universes. No limitation in size. The given aeon and from to ticks will only mark current log content range
 38    * as active for display from the first tick they occured in the log. Structure will not know current energy of node.
 39    * @param p_planck_aeon The valid planck time aeon for the log to mark node as active.
 40    * @param p_from_planck_time The valid planck time tick for start of log to mark node as active.
 41    * @param p_to_planck_time The valid planck time tick for end of log to mark node as active.
 42    * @param p_json_struct The JSON formatted structure chunk as CLOB.
 43    * @return Return 1 if structure was completely delivered or -1 on errors.
 44    */
 45    FUNCTION get_json_struct( p_planck_aeon	    IN	   usim_spc_process.usim_planck_aeon%TYPE
 46  			       , p_from_planck_time IN	   usim_spc_process.usim_planck_time%TYPE
 47  			       , p_to_planck_time   IN	   usim_spc_process.usim_planck_time%TYPE
 48  			       , p_json_struct	       OUT CLOB
 49  			       )
 50  	 RETURN NUMBER
 51    ;
 52  
 53    /**
 54    * Writes a space structure file in JSON format. The name of the file is fixed to usim_space_struct.json.
 55    * The file is written to the directory USIM_DIR. If a file already exists, it is copied before to the directory
 56    * USIM_HIST_DIR and renamed to a unique file name by current date extension. The given aeon and from to ticks will only mark current log content range
 57    * as active for display from the first tick they occured in the log. Structure will not know current energy of node.
 58    * As the structure for all existing universes is build, the file may get too big for JS P5. Row Order:</br>
 59    * 0:from x, 1:from y, 2:from z, 3:from dimension, 4:from dim sign, 5:from n1 sign, 6:first from tick active, 7:to x, 8:to y, 9:to z, 10:to dimension, 11:to dim sign, 12:to n1 sign, 13:first to tick active</br>
 60    * @param p_planck_aeon The valid planck time aeon for the log to mark node as active or ignored.
 61    * @param p_from_planck_time The valid planck time tick for start of log to mark node as active or ignored.
 62    * @param p_to_planck_time The valid planck time tick for end of log to mark node as active or ignored.
 63    * @return Return 1 if operation was successful otherwise 0.
 64    */
 65    FUNCTION create_json_struct( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
 66  				  , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
 67  				  , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
 68  				  )
 69  	 RETURN NUMBER
 70    ;
 71  
 72    /**
 73    * Writes a space log file in JSON format. The name of the file is fixed to usim_space_log.json. The file is written to the directory USIM_DIR.
 74    * If a file already exists, it is copied before to the directory USIM_HIST_DIR and renamed to a unique file name by
 75    * current date extension. Only one planck aeon supported. Will create also an associated structure, where log content is marked as active in
 76    * the created structure. To keep space as low as possible an array structure is used per row. Order:</br>
 77    * 0:from x, 1:from y, 2:from z, 3:from dimension, 4:from dim sign, 5:from n1 sign, 6:from energy, 7:to x, 8:to y, 9:to z, 10:to dimension, 11:to dim sign, 12:to n1 sign, 13:to energy, 14:output energy</br>
 78    * @param p_planck_aeon The planck time aeon for of the log. If NULL, p_from_planck_time is ignored and log starts with current aeon.
 79    * @param p_from_planck_time The planck time tick for start of log. Ignored if p_from_planck_aeon is NULL using first planck time tick in aeon given or found.
 80    * @param p_to_planck_time The planck time tick for end of log. if NULL, log contains every record of USIM_SPC_PROCESS for aeon given or found.
 81    * @return Return 1 if operation was successful otherwise 0.
 82    */
 83    FUNCTION create_space_log( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
 84  				, p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
 85  				, p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
 86  				)
 87  	 RETURN NUMBER
 88    ;
 89  
 90    FUNCTION create_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 91  	 RETURN NUMBER
 92    ;
 93  
 94    /**
 95    * Retrieves the dimension id for a given dimension and creates necessary dimensions, if they
 96    * do not exist. Given dimension must be within the base data limits.
 97    * @param p_usim_n_dimension The dimension to verify.
 98    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 99    * @return The dimension id for given dimension or NULL if error or base data are not available.
100    */
101    FUNCTION init_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
102  			      , p_do_commit	   IN BOOLEAN				   DEFAULT TRUE
103  			      )
104  	 RETURN usim_dimension.usim_id_dim%TYPE
105    ;
106  
107    /**
108    * Retrieves the universe dimension axis id for a given universe and dimension id. Creates necessary dimension axis, if it
109    * does not exist.
110    * @param p_usim_id_mlv The universe id for the dimension axis.
111    * @param p_usim_id_dim The dimension id for the dimension axis.
112    * @param p_usim_sign The sign of the dimension axis.
113    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
114    * @return The rmd id of the dimension axis or NULL if error or base data are not available.
115    */
116    FUNCTION init_dim_axis( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
117  			     , p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE
118  			     , p_usim_sign   IN usim_rel_mlv_dim.usim_sign%TYPE
119  			     , p_do_commit   IN BOOLEAN 			 DEFAULT TRUE
120  			     )
121  	 RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
122    ;
123  
124    /**
125    * Verifies that dimension and dimension axis exist for the given universe. Creates all necessary objects.
126    * @param p_usim_id_mlv The universe id for the dimension.
127    * @param p_usim_n_dimension The dimension to verify.
128    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
129    * @return Return 1 if all was successfully verified or created otherwise 0.
130    */
131    FUNCTION init_dim_all( p_usim_id_mlv	 IN usim_multiverse.usim_id_mlv%TYPE
132  			    , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
133  			    , p_do_commit	 IN BOOLEAN				 DEFAULT TRUE
134  			    )
135  	 RETURN NUMBER
136    ;
137  
138    /**
139    * Verifies that a zero position has all connected space nodes. Creates all necessary objects.
140    * Positions are set (0, 1, -1) and connections are defined.
141    * @param p_usim_id_mlv The universe id for the space nodes. Mandatory.
142    * @param p_usim_id_spc_parent The parent space node with position 0 and dimension one lower than the given dimension. Mandatory.
143    * @param p_usim_n_dimension The dimension to use. Given dimension must be one greater than parent dimension. Mandatory.
144    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
145    * @return Return 1 if all was successfully verified or created otherwise 0.
146    */
147    FUNCTION init_zero_dim_nodes( p_usim_id_mlv	  IN usim_multiverse.usim_id_mlv%TYPE
148  				   , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
149  				   , p_usim_n_dimension   IN usim_dimension.usim_n_dimension%TYPE
150  				   , p_do_commit	  IN BOOLEAN				  DEFAULT TRUE
151  				   )
152  	 RETURN NUMBER
153    ;
154  
155    /**
156    * Creates a universe, with a basic position coordinate 0, dimension 0 and node for it. If first universe, it will be the base universe. Will
157    * create also the basic connections to dimension 1 with positions +0/-0 and +1/-1 for both dimension axis.
158    * Will only commit changes (if p_do_commit is TRUE) if all steps have been executed without errors. On errors always a rollback is executed.
159    * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used and default if NULL or 0.
160    * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value and default if NULL or 0.
161    * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value and default if NULL or 0.
162    * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value and default if NULL or 0.
163    * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct.
164    * @param p_usim_ultimate_border The energy flow rule for ultimate border (1) or any dimension border (0). NULL is interpreted as 1.
165    * @param p_usim_id_spc_parent The usim_space id of the node, that is the parent of this universe. Ignored, if universe is base universe. Mandatory for non-base universes.
166    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
167    * @return The new usim_space id for dimension 0 or NULL if error or base data / mandatory parent in populated universe are not available.
168    */
169    FUNCTION create_new_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
170  				   , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
171  				   , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
172  				   , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
173  				   , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
174  				   , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
175  				   , p_usim_id_spc_parent      IN usim_space.usim_id_spc%TYPE		       DEFAULT NULL
176  				   , p_do_commit	       IN BOOLEAN				       DEFAULT TRUE
177  				   )
178  	 RETURN usim_space.usim_id_spc%TYPE
179    ;
180  
181    /**
182    * In case of dimension overflow either a new node is created, if a higher free dimension is available
183    * or the creation of a new dimension with pos 0 and 1 is triggered.
184    * @param p_usim_id_spc The space node id causing the overflow.
185    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
186    * @return Returns 1 on success or 0 on errors.
187    */
188    FUNCTION handle_overflow_dim( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
189  				   , p_do_commit   IN BOOLEAN			  DEFAULT TRUE
190  				   )
191  	 RETURN NUMBER
192    ;
193  
194    /**
195    * Creates a new node in case of position overflow. Will add a new position on the axis the
196    * given node is. Depends on correct identified escape strategy (3, 4) which imply the creation
197    * of a new position. Will only accept nodes that are either 0 coordinate on the dimension axis or
198    * nodes that have no child in current dimension.
199    * @param p_usim_id_spc The space node id causing the overflow.
200    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
201    * @return Returns 1 on success or 0 on errors.
202    */
203    FUNCTION handle_overflow_pos( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
204  				   , p_do_commit   IN BOOLEAN			  DEFAULT TRUE
205  				   )
206  	 RETURN NUMBER
207    ;
208  
209    /**
210    * Creates a new node in case of between node is needed. Between nodes are filled from bottom up.
211    * @param p_usim_id_spc The space node id causing the overflow.
212    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
213    * @return Returns 1 on success or 0 on errors.
214    */
215    FUNCTION handle_overflow_between( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
216  				       , p_do_commit   IN BOOLEAN		      DEFAULT TRUE
217  				       )
218  	 RETURN NUMBER
219    ;
220  
221    /**
222    * Main hub to handle overflow situations. Depending on escape classify an appropriate
223    * action is executed. Will create necessary space nodes for positions, dimensions or universes.
224    * @param p_usim_id_spc The usim_space id causing the overflow.
225    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
226    * @return Returns 1 if overflow could be handled otherwise 0.
227    */
228    FUNCTION handle_overflow( p_usim_id_spc	 IN usim_space.usim_id_spc%TYPE
229  			       , p_do_commit	 IN BOOLEAN			DEFAULT TRUE
230  			       )
231  	 RETURN NUMBER
232    ;
233  
234  END usim_creator;
235  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_creator
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_creator

Package created.

SQL> @@../PACKAGES/USIM_CREATOR.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_creator
  2  IS
  3    -- see header for documentation
  4  
  5    FUNCTION write_json_file( p_json_clob IN CLOB
  6  			       , p_filename  IN VARCHAR2 DEFAULT 'usim_space_log'
  7  			       )
  8  	 RETURN NUMBER
  9    IS
 10  	 l_file        UTL_FILE.FILE_TYPE;
 11  	 l_filename    VARCHAR2(100);
 12  	 l_backup      VARCHAR2(100);
 13  	 l_buffer      VARCHAR2(8191);
 14  	 l_bufsize     CONSTANT BINARY_INTEGER := 8191;
 15  	 l_pos	       PLS_INTEGER;
 16  	 l_clob_len    PLS_INTEGER;
 17  	 l_clob        CLOB;
 18  	 l_file_exist  BOOLEAN;
 19  	 l_file_length NUMBER;
 20  	 l_block_size  BINARY_INTEGER;
 21    BEGIN
 22  	 IF LENGTH(p_filename) > 100
 23  	 THEN
 24  	   usim_erl.log_error('usim_creator.write_json_file', 'Filename [' || p_filename || '] too long.');
 25  	   RETURN 0;
 26  	 END IF;
 27  	 l_clob  := p_json_clob;
 28  	 l_filename := TRIM(p_filename) || '.json';
 29  	 UTL_FILE.FGETATTR('USIM_DIR', l_filename, l_file_exist, l_file_length, l_block_size);
 30  	 IF l_file_exist
 31  	 THEN
 32  	   l_backup := TRIM(p_filename) || '_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '.json';
 33  	   -- "copy" file first by rename, FCOPY requires reading content with required CR limiter before 32767 bytes
 34  	   -- furthermore with rename no FREMOVE is required
 35  	   UTL_FILE.FRENAME('USIM_DIR', l_filename, 'USIM_HIST_DIR', l_backup);
 36  	 END IF;
 37  	 -- now write new file
 38  	 -- prepare
 39  	 l_pos	    := 1;
 40  	 l_clob_len := DBMS_LOB.GETLENGTH(l_clob);
 41  	 l_file     := UTL_FILE.FOPEN('USIM_DIR', l_filename, 'WB', l_bufsize);
 42  	 -- get first buffer chunk
 43  	 l_buffer   := DBMS_LOB.SUBSTR(l_clob, l_bufsize, l_pos);
 44  	 -- loop until last chunk
 45  	 WHILE l_pos < l_clob_len
 46  	 LOOP
 47  	   EXIT WHEN l_buffer IS NULL;
 48  	   UTL_FILE.PUT_RAW(l_file, UTL_RAW.CAST_TO_RAW(l_buffer));
 49  	   l_pos := l_pos + LEAST(LENGTH(l_buffer) + 1, l_bufsize);
 50  	   UTL_FILE.FFLUSH(l_file);
 51  	   -- load next buffer chunk
 52  	   l_buffer := DBMS_LOB.SUBSTR(l_clob, l_bufsize, l_pos);
 53  	 END LOOP;
 54  	 -- close file
 55  	 UTL_FILE.FCLOSE(l_file);
 56  	 RETURN 1;
 57    EXCEPTION
 58  	 WHEN OTHERS THEN
 59  	   IF UTL_FILE.IS_OPEN(l_file)
 60  	   THEN
 61  	     UTL_FILE.FCLOSE(l_file);
 62  	   END IF;
 63  	   usim_erl.log_error('usim_creator.write_json_file', 'Unexpected exception writing JSON log SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
 64  	   RETURN 0;
 65    END write_json_file
 66    ;
 67  
 68    FUNCTION get_json_log( p_planck_aeon	 IN	usim_spc_process.usim_planck_aeon%TYPE
 69  			    , p_from_planck_time IN	usim_spc_process.usim_planck_time%TYPE
 70  			    , p_to_planck_time	 IN	usim_spc_process.usim_planck_time%TYPE
 71  			    , p_json_log	    OUT CLOB
 72  			    )
 73  	 RETURN NUMBER
 74    IS
 75  	 l_main_object	       JSON_OBJECT_T;
 76  	 l_universe_object     JSON_OBJECT_T;
 77  	 l_universe_array      JSON_ARRAY_T;
 78  	 l_universe_select     JSON_ARRAY_T;
 79  	 l_planck_times_array  JSON_ARRAY_T;
 80  	 l_planck_detail_array JSON_ARRAY_T;
 81  	 l_planck_time_details JSON_OBJECT_T;
 82  	 l_planck_time_main    JSON_OBJECT_T;
 83  	 l_fromto_array        VARCHAR2(32000);
 84  	 l_return	       NUMBER;
 85  
 86  	 -- get all known universes
 87  	 CURSOR cur_universes
 88  	 IS
 89  	   SELECT usim_id_mlv
 90  	     FROM usim_multiverse
 91  	    ORDER BY usim_is_base_universe DESC
 92  		, usim_id_mlv
 93  	 ;
 94  	 -- get needed planck pieces with associated universe
 95  	 CURSOR cur_planck_pieces( cp_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
 96  				 , cp_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
 97  				 , cp_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
 98  				 , cp_usim_id_mlv      IN usim_multiverse.usim_id_mlv%TYPE
 99  				 )
100  	 IS
101  	   SELECT usim_planck_aeon
102  		, usim_planck_time
103  		, src_id_mlv
104  	     FROM usim_spr_v
105  	    WHERE src_id_mlv		 = tgt_id_mlv
106  	      AND src_id_mlv		 = cp_usim_id_mlv
107  	      AND usim_planck_aeon	 = cp_planck_aeon
108  	      AND usim_planck_time BETWEEN cp_from_planck_time AND cp_to_planck_time
109  	    GROUP BY src_id_mlv
110  		   , usim_planck_aeon
111  		   , usim_planck_time
112  	    ORDER BY src_id_mlv
113  		   , usim_planck_aeon
114  		   , usim_planck_time
115  	 ;
116  	 -- get details on a specific planck aeon and time using ordered view
117  	 CURSOR cur_log_details( cp_planck_aeon IN usim_spc_process.usim_planck_aeon%TYPE
118  			       , cp_planck_time IN usim_spc_process.usim_planck_time%TYPE
119  			       , cp_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
120  			       )
121  	 IS
122  	   SELECT usim_planck_aeon
123  		, usim_planck_time
124  		, usim_id_spc_source
125  		, usim_id_spc_target
126  		, usim_real_time
127  		, is_processed
128  		, usim_energy_source
129  		, usim_energy_target
130  		, usim_energy_output
131  	     FROM usim_spr_v
132  	    WHERE src_id_mlv	   = tgt_id_mlv
133  	      AND src_id_mlv	   = cp_usim_id_mlv
134  	      AND usim_planck_aeon = cp_planck_aeon
135  	      AND usim_planck_time = cp_planck_time
136  	 ;
137    BEGIN
138  	 -- check the parameters for given range without universe specified
139  	 SELECT COUNT(*)
140  	   INTO l_return
141  	   FROM (SELECT usim_planck_time
142  		   FROM usim_spc_process
143  		  WHERE usim_planck_aeon = p_planck_aeon
144  		    AND usim_planck_time IN (p_from_planck_time, p_to_planck_time)
145  		  GROUP BY usim_planck_aeon
146  			 , usim_planck_time
147  		)
148  	 ;
149  	 IF l_return	     NOT IN (1, 2)
150  	    OR p_from_planck_time > p_to_planck_time
151  	 THEN
152  	   usim_erl.log_error('usim_creator.get_json_log', 'Invalid input parameter aeon [' || p_planck_aeon || '], from [' || p_from_planck_time || '] or to [' || p_to_planck_time || '].');
153  	   RETURN -1;
154  	 END IF;
155  	 -- start processing
156  	 l_main_object	       := new JSON_OBJECT_T;
157  	 l_planck_times_array  := new JSON_ARRAY_T;
158  	 l_universe_array      := new JSON_ARRAY_T;
159  	 l_universe_select     := new JSON_ARRAY_T;
160  	 l_main_object.put('aeon', p_planck_aeon);
161  	 l_main_object.put('max', usim_dbif.get_abs_max_number);
162  	 -- cycle through universes
163  	 FOR usim_rec IN cur_universes
164  	 LOOP
165  	   l_universe_object := new JSON_OBJECT_T;
166  	   l_universe_object.put('id', usim_rec.usim_id_mlv);
167  	   -- Collect all universes in a separate array for fast and easy JS selection and access
168  	   l_universe_select.append(usim_rec.usim_id_mlv);
169  	   FOR mainrec IN cur_planck_pieces(p_planck_aeon, p_from_planck_time, p_to_planck_time, usim_rec.usim_id_mlv)
170  	   LOOP
171  	     l_planck_detail_array := new JSON_ARRAY_T;
172  	     l_planck_time_main    := new JSON_OBJECT_T;
173  	     -- get details for time tick
174  	     FOR rec IN cur_log_details(mainrec.usim_planck_aeon, mainrec.usim_planck_time, usim_rec.usim_id_mlv)
175  	     LOOP
176  	       -- build JSON array like csv to save space
177  	       l_fromto_array :=  '[' || usim_dbif.get_xyz(rec.usim_id_spc_source) || ',' ||
178  					 usim_dbif.get_dimension(rec.usim_id_spc_source) || ',' ||
179  					 usim_dbif.get_dim_sign(rec.usim_id_spc_source) || ',' ||
180  					 usim_dbif.get_dim_n1_sign(rec.usim_id_spc_source) || ',' ||
181  					 NVL(rec.usim_energy_source, 0) || ',' ||
182  					 usim_dbif.get_xyz(rec.usim_id_spc_target) || ',' ||
183  					 usim_dbif.get_dimension(rec.usim_id_spc_target) || ',' ||
184  					 usim_dbif.get_dim_sign(rec.usim_id_spc_target) || ',' ||
185  					 usim_dbif.get_dim_n1_sign(rec.usim_id_spc_target) || ',' ||
186  					 NVL(rec.usim_energy_target,0) || ',' ||
187  					 rec.usim_energy_output || ']'
188  	       ;
189  	       l_planck_time_details := new JSON_OBJECT_T;
190  	       l_planck_time_details.put('row', JSON_ARRAY_T.parse(l_fromto_array));
191  	       -- put structure for this tick
192  	       l_planck_detail_array.append(l_planck_time_details);
193  	     END LOOP;
194  	     l_planck_time_main.put('tick', mainrec.usim_planck_time);
195  	     l_planck_time_main.put('data', l_planck_detail_array);
196  	     l_planck_times_array.append(l_planck_time_main);
197  	   END LOOP;
198  	   l_universe_object.put('ticks', l_planck_times_array);
199  	   l_universe_array.append(l_universe_object);
200  	 END LOOP;
201  	 l_main_object.put('select', l_universe_select);
202  	 l_main_object.put('usims', l_universe_array);
203  	 p_json_log := l_main_object.to_clob;
204  	 RETURN 1;
205    EXCEPTION
206  	 WHEN OTHERS THEN
207  	   usim_erl.log_error('usim_creator.get_json_log', 'Unexpected exception SQL code [' || SQLCODE || '] message [' || SQLERRM || '].');
208  	   RETURN -1;
209    END get_json_log
210    ;
211  
212    FUNCTION get_json_struct( p_planck_aeon	    IN	   usim_spc_process.usim_planck_aeon%TYPE
213  			       , p_from_planck_time IN	   usim_spc_process.usim_planck_time%TYPE
214  			       , p_to_planck_time   IN	   usim_spc_process.usim_planck_time%TYPE
215  			       , p_json_struct	       OUT CLOB
216  			       )
217  	 RETURN NUMBER
218    IS
219  	 l_has_data	    NUMBER;
220  	 l_main_object	    JSON_OBJECT_T;
221  	 l_universe_object  JSON_OBJECT_T;
222  	 l_universe_array   JSON_ARRAY_T;
223  	 l_zero_array	    JSON_ARRAY_T;
224  	 l_zero_node	    JSON_OBJECT_T;
225  	 l_node 	    JSON_OBJECT_T;
226  	 l_node_array	    JSON_ARRAY_T;
227  	 l_fromto_array     VARCHAR2(32000);
228  	 l_src_first_tick   INTEGER;
229  	 l_tgt_first_tick   INTEGER;
230  
231  	 -- get all known universes
232  	 CURSOR cur_universes
233  	 IS
234  	   SELECT usim_id_mlv
235  	     FROM usim_multiverse
236  	    ORDER BY usim_is_base_universe DESC
237  		, usim_id_mlv
238  	 ;
239  	 CURSOR cur_structure(cp_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
240  	 IS
241  	   SELECT src_xyz
242  		, tgt_xyz
243  		, src_mag
244  		, src_dim
245  		, tgt_dim
246  		, src_dim_sign
247  		, tgt_dim_sign
248  		, 0 AS src_n1_sign
249  		, 0 AS tgt_n1_sign
250  		, usim_id_mlv
251  	     FROM usim_spo_base3d_v
252  	    WHERE usim_id_mlv = cp_usim_id_mlv
253  	 ;
254  	 CURSOR cur_zero_structure(cp_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE)
255  	 IS
256  	   SELECT src_xyz
257  		, tgt_xyz
258  		, src_mag
259  		, src_dim
260  		, tgt_dim
261  		, src_dim_sign
262  		, tgt_dim_sign
263  		, NVL(src_n1_sign, 0) AS src_n1_sign
264  		, NVL(tgt_n1_sign, 0) AS tgt_n1_sign
265  		, usim_id_mlv
266  	     FROM usim_spo_zero3d_v
267  	    WHERE usim_id_mlv = cp_usim_id_mlv
268  	 ;
269  
270    BEGIN
271  	 l_main_object	   := new JSON_OBJECT_T;
272  	 l_node_array	   := new JSON_ARRAY_T;
273  	 l_zero_array	   := new JSON_ARRAY_T;
274  	 l_universe_array  := new JSON_ARRAY_T;
275  	 -- cycle through universes
276  	 FOR usim_rec IN cur_universes
277  	 LOOP
278  	   l_universe_object := new JSON_OBJECT_T;
279  	   l_universe_object.put('id', usim_rec.usim_id_mlv);
280  	   -- zero structure
281  	   FOR mainrec IN cur_zero_structure(usim_rec.usim_id_mlv)
282  	   LOOP
283  	     -- get min planck ticks for first active source and target
284  	     SELECT NVL(MIN(usim_planck_time), -1)
285  	       INTO l_src_first_tick
286  	       FROM usim_spr_v
287  	      WHERE src_id_mlv		   = usim_rec.usim_id_mlv
288  		AND usim_planck_aeon	   = p_planck_aeon
289  		AND usim_planck_time BETWEEN p_from_planck_time
290  					 AND p_to_planck_time
291  		AND src_xyz		   = mainrec.src_xyz
292  		AND src_dim		   = mainrec.src_dim
293  		AND src_dim_sign	   = mainrec.src_dim_sign
294  		AND src_dim_n1_sign	   = mainrec.src_n1_sign
295  	     ;
296  	     SELECT NVL(MIN(usim_planck_time), -1)
297  	       INTO l_tgt_first_tick
298  	       FROM usim_spr_v
299  	      WHERE src_id_mlv		   = usim_rec.usim_id_mlv
300  		AND usim_planck_aeon	   = p_planck_aeon
301  		AND usim_planck_time BETWEEN p_from_planck_time
302  					 AND p_to_planck_time
303  		AND tgt_xyz		   = mainrec.tgt_xyz
304  		AND tgt_dim		   = mainrec.tgt_dim
305  		AND tgt_dim_sign	   = mainrec.tgt_dim_sign
306  		AND tgt_dim_n1_sign	   = mainrec.tgt_n1_sign
307  	     ;
308  	     -- build JSON array like csv to save space
309  	     l_fromto_array :=	'[' || mainrec.src_xyz || ',' ||
310  				       mainrec.src_dim || ',' ||
311  				       mainrec.src_dim_sign || ',' ||
312  				       mainrec.src_n1_sign || ',' ||
313  				       l_src_first_tick || ',' ||
314  				       mainrec.tgt_xyz || ',' ||
315  				       mainrec.tgt_dim || ',' ||
316  				       mainrec.tgt_dim_sign || ',' ||
317  				       mainrec.tgt_n1_sign || ',' ||
318  				       l_tgt_first_tick || ']'
319  	     ;
320  	     l_zero_node := new JSON_OBJECT_T;
321  	     l_zero_node.put('row', JSON_ARRAY_T.parse(l_fromto_array));
322  	     l_zero_array.append(l_zero_node);
323  	   END LOOP;
324  	   l_universe_object.put('zero', l_zero_array);
325  	   -- xyz relations
326  	   FOR mainrec IN cur_structure(usim_rec.usim_id_mlv)
327  	   LOOP
328  	     -- get min planck ticks for first active source and target
329  	     SELECT NVL(MIN(usim_planck_time), -1)
330  	       INTO l_src_first_tick
331  	       FROM usim_spr_v
332  	      WHERE src_id_mlv		   = usim_rec.usim_id_mlv
333  		AND usim_planck_aeon	   = p_planck_aeon
334  		AND usim_planck_time BETWEEN p_from_planck_time
335  					 AND p_to_planck_time
336  		AND src_xyz		   = mainrec.src_xyz
337  	     ;
338  	     SELECT NVL(MIN(usim_planck_time), -1)
339  	       INTO l_tgt_first_tick
340  	       FROM usim_spr_v
341  	      WHERE src_id_mlv		   = usim_rec.usim_id_mlv
342  		AND usim_planck_aeon	   = p_planck_aeon
343  		AND usim_planck_time BETWEEN p_from_planck_time
344  					 AND p_to_planck_time
345  		AND tgt_xyz		   = mainrec.tgt_xyz
346  	     ;
347  	     -- build JSON array like csv to save space
348  	     l_fromto_array :=	'[' || mainrec.src_xyz || ',' ||
349  				       mainrec.src_dim || ',' ||
350  				       mainrec.src_dim_sign || ',' ||
351  				       '0,' ||
352  				       l_src_first_tick || ',' ||
353  				       mainrec.tgt_xyz || ',' ||
354  				       mainrec.tgt_dim || ',' ||
355  				       mainrec.tgt_dim_sign || ',' ||
356  				       '0,' ||
357  				       l_tgt_first_tick || ']'
358  	     ;
359  	     -- build main node
360  	     l_node	:= new JSON_OBJECT_T;
361  	     l_node.put('row', JSON_ARRAY_T.parse(l_fromto_array));
362  	     l_node_array.append(l_node);
363  	   END LOOP;
364  	   l_universe_object.put('data', l_node_array);
365  	   l_universe_array.append(l_universe_object);
366  	 END LOOP;
367  	 -- add to main object
368  	 l_main_object.put('usims', l_universe_array);
369  	 p_json_struct := l_main_object.to_clob;
370  	 RETURN 1;
371    EXCEPTION
372  	 WHEN OTHERS THEN
373  	   usim_erl.log_error('usim_creator.get_json_struct', 'Unexpected exception SQL code [' || SQLCODE || '] message [' || SQLERRM || '].');
374  	   RETURN NULL;
375    END get_json_struct
376    ;
377  
378    FUNCTION create_json_struct( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
379  				  , p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
380  				  , p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
381  				  )
382  	 RETURN NUMBER
383    IS
384  	 l_json_struct CLOB;
385  	 l_return      NUMBER;
386  	 l_file        NUMBER;
387    BEGIN
388  	 IF usim_dbif.has_data_spc = 0
389  	 THEN
390  	   usim_erl.log_error('usim_creator.create_json_struct', 'No data in USIM_SPACE for structure JSON.');
391  	   RETURN 0;
392  	 END IF;
393  	 l_return := usim_creator.get_json_struct(p_planck_aeon, p_from_planck_time, p_to_planck_time, l_json_struct);
394  	 IF l_return = 0
395  	 THEN
396  	   usim_erl.log_error('usim_creator.create_json_struct', 'ERROR getting json space structure.');
397  	   RETURN 0;
398  	 END IF;
399  	 -- write file
400  	 l_file := usim_creator.write_json_file(l_json_struct, 'usim_space_struct');
401  	 IF l_file = 0
402  	 THEN
403  	   usim_erl.log_error('usim_creator.create_json_struct', 'ERROR writing json space structure.');
404  	   RETURN 0;
405  	 END IF;
406  	 RETURN 1;
407    END create_json_struct
408    ;
409  
410    FUNCTION create_space_log( p_planck_aeon      IN usim_spc_process.usim_planck_aeon%TYPE
411  				, p_from_planck_time IN usim_spc_process.usim_planck_time%TYPE
412  				, p_to_planck_time   IN usim_spc_process.usim_planck_time%TYPE
413  				)
414  	 RETURN NUMBER
415    IS
416  	 l_has_data	     NUMBER;
417  	 l_result	     NUMBER;
418  	 l_file 	     NUMBER;
419  	 l_planck_aeon	     usim_spc_process.usim_planck_aeon%TYPE;
420  	 l_from_planck_time  usim_spc_process.usim_planck_time%TYPE;
421  	 l_to_planck_time    usim_spc_process.usim_planck_time%TYPE;
422  	 l_json_log	     CLOB;
423    BEGIN
424  	 SELECT COUNT(*) INTO l_has_data FROM usim_spc_process;
425  	 IF l_has_data = 0
426  	 THEN
427  	   usim_erl.log_error('usim_creator.create_space_log', 'Could not write log without logging data in USIM_SPC_PROCESS, table is empty.');
428  	   RETURN 0;
429  	 END IF;
430  	 -- get aeon to use if NULL
431  	 SELECT COUNT(*) INTO l_has_data FROM usim_spc_process WHERE usim_planck_aeon = NVL(p_planck_aeon, usim_dbif.get_planck_aeon_seq_current);
432  	 IF l_has_data = 0
433  	 THEN
434  	   -- get max aeon in process, maybe a switch has occured after last processing
435  	   SELECT MAX(usim_planck_aeon) INTO l_planck_aeon FROM usim_spc_process;
436  	 ELSE
437  	   l_planck_aeon := NVL(p_planck_aeon, usim_dbif.get_planck_aeon_seq_current);
438  	 END IF;
439  	 -- check from record
440  	 SELECT COUNT(*) INTO l_has_data FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon AND usim_planck_time = p_from_planck_time;
441  	 IF l_has_data = 0
442  	 THEN
443  	   SELECT MIN(usim_planck_time) INTO l_from_planck_time FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon;
444  	 ELSE
445  	   l_from_planck_time := p_from_planck_time;
446  	 END IF;
447  	 -- check to record
448  	 SELECT COUNT(*) INTO l_has_data FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon AND usim_planck_time = p_to_planck_time;
449  	 IF l_has_data = 0
450  	 THEN
451  	   SELECT MAX(usim_planck_time) INTO l_from_planck_time FROM usim_spc_process WHERE usim_planck_aeon = l_planck_aeon;
452  	 ELSE
453  	   l_to_planck_time := p_to_planck_time;
454  	 END IF;
455  	 -- write JSON log file
456  	 l_result := usim_creator.get_json_log(l_planck_aeon, l_from_planck_time, l_to_planck_time, l_json_log);
457  	 IF l_result = -1
458  	 THEN
459  	   usim_erl.log_error('usim_creator.create_space_log', 'Could not get json space log for from [' || l_planck_aeon || '], [' || l_from_planck_time || '] or to [' || l_to_planck_time || '].');
460  	   RETURN 0;
461  	 ELSE
462  	   l_file := usim_creator.write_json_file(l_json_log, 'usim_space_log');
463  	 END IF;
464  	 -- write associated JSON structure file
465  	 l_result := usim_creator.create_json_struct(l_planck_aeon, l_from_planck_time, l_to_planck_time);
466  	 IF l_result = 0
467  	 THEN
468  	   usim_erl.log_error('usim_creator.create_space_log', 'Could not create associated structure for from [' || l_planck_aeon || '], [' || l_from_planck_time || '] or to [' || l_to_planck_time || '].');
469  	   RETURN 0;
470  	 END IF;
471  	 RETURN 1;
472    END create_space_log
473    ;
474  
475    FUNCTION create_next_dimension(p_usim_id_spc IN usim_space.usim_id_spc%TYPE)
476  	 RETURN NUMBER
477    IS
478    BEGIN
479  	 usim_erl.log_error('usim_creator.create_next_dimension', 'NOT IMPLEMENTED.');
480  	 RETURN 1;
481    END create_next_dimension
482    ;
483  
484    FUNCTION init_dimension( p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
485  			      , p_do_commit	   IN BOOLEAN				   DEFAULT TRUE
486  			      )
487  	 RETURN usim_dimension.usim_id_dim%TYPE
488    IS
489    BEGIN
490  	 usim_erl.log_error('usim_creator.init_dimension', 'NOT IMPLEMENTED.');
491  	 RETURN NULL;
492    END init_dimension
493    ;
494  
495    FUNCTION init_dim_axis( p_usim_id_mlv IN usim_multiverse.usim_id_mlv%TYPE
496  			     , p_usim_id_dim IN usim_dimension.usim_id_dim%TYPE
497  			     , p_usim_sign   IN usim_rel_mlv_dim.usim_sign%TYPE
498  			     , p_do_commit   IN BOOLEAN 			 DEFAULT TRUE
499  			     )
500  	 RETURN usim_rel_mlv_dim.usim_id_rmd%TYPE
501    IS
502    BEGIN
503  	 usim_debug.debug_log('usim_creator.init_dim_axis', 'NOT IMPLEMENTED.');
504  	 RETURN NULL;
505    END init_dim_axis
506    ;
507  
508    FUNCTION init_dim_all( p_usim_id_mlv	 IN usim_multiverse.usim_id_mlv%TYPE
509  			    , p_usim_n_dimension IN usim_dimension.usim_n_dimension%TYPE
510  			    , p_do_commit	 IN BOOLEAN				 DEFAULT TRUE
511  			    )
512  	 RETURN NUMBER
513    IS
514    BEGIN
515  	 usim_debug.debug_log('usim_creator.init_dim_all', 'NOT IMPLEMENTED.');
516  	 RETURN 0;
517    END init_dim_all
518    ;
519  
520    FUNCTION init_zero_dim_nodes( p_usim_id_mlv	  IN usim_multiverse.usim_id_mlv%TYPE
521  				   , p_usim_id_spc_parent IN usim_space.usim_id_spc%TYPE
522  				   , p_usim_n_dimension   IN usim_dimension.usim_n_dimension%TYPE
523  				   , p_do_commit	  IN BOOLEAN				  DEFAULT TRUE
524  				   )
525  	 RETURN NUMBER
526    IS
527    BEGIN
528  	 usim_debug.debug_log('usim_creator.init_zero_dim_nodes', 'NOT IMPLEMENTED.');
529  	 RETURN 0;
530    END init_zero_dim_nodes
531    ;
532  
533    FUNCTION create_new_universe( p_usim_energy_start_value IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
534  				   , p_usim_planck_time_unit   IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
535  				   , p_usim_planck_length_unit IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
536  				   , p_usim_planck_speed_unit  IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
537  				   , p_usim_planck_stable      IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
538  				   , p_usim_ultimate_border    IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
539  				   , p_usim_id_spc_parent      IN usim_space.usim_id_spc%TYPE		       DEFAULT NULL
540  				   , p_do_commit	       IN BOOLEAN				       DEFAULT TRUE
541  				   )
542  	 RETURN usim_space.usim_id_spc%TYPE
543    IS
544  	 -- zero node dim 0 pos 0
545  	 l_usim_id_spc		 usim_space.usim_id_spc%TYPE;
546  	 -- used for parent check
547  	 l_usim_id_spc_parent	 usim_space.usim_id_spc%TYPE;
548  	 -- dim 1 n1+ pos +0
549  	 l_id_spc0_n1p_1p	 usim_space.usim_id_spc%TYPE;
550  	 -- dim 1 n1- pos -0
551  	 l_id_spc0_n1n_1n	 usim_space.usim_id_spc%TYPE;
552  	 -- dim 1 n1+ pos +1
553  	 l_id_spc1p_n1p_1p	 usim_space.usim_id_spc%TYPE;
554  	 -- dim 1 n1- pos -1
555  	 l_id_spc1n_n1n_1n	 usim_space.usim_id_spc%TYPE;
556  	 -- universe id
557  	 l_usim_id_mlv		 usim_multiverse.usim_id_mlv%TYPE;
558  	 -- dim axis 0
559  	 l_usim_id_rmd		 usim_rel_mlv_dim.usim_id_rmd%TYPE;
560  	 -- pos 0
561  	 l_usim_id_pos		 usim_position.usim_id_pos%TYPE;
562  	 -- pos +1
563  	 l_usim_id_pos_1p	 usim_position.usim_id_pos%TYPE;
564  	 -- pos -1
565  	 l_usim_id_pos_1n	 usim_position.usim_id_pos%TYPE;
566  	 -- dim axis 1+
567  	 l_id_rmd_n1p_1p	 usim_rel_mlv_dim.usim_id_rmd%TYPE;
568  	 -- dim axis 1-
569  	 l_id_rmd_n1n_1n	 usim_rel_mlv_dim.usim_id_rmd%TYPE;
570  	 -- dummy of dim axis 0 creation
571  	 l_rmd_dummy		 usim_rel_mlv_dim.usim_id_rmd%TYPE;
572  	 -- parents array
573  	 l_parents		 usim_static.usim_ids_type;
574  	 l_return		 NUMBER;
575    BEGIN
576  	 -- check base data, must exist
577  	 IF usim_dbif.has_basedata = 0
578  	 THEN
579  	   usim_erl.log_error('usim_creator.create_new_universe', 'Base data not initialized.');
580  	   RETURN NULL;
581  	 END IF;
582  	 -- a parent must be given, if usim_space has already data, assuming an existing base universe seed.
583  	 IF	usim_dbif.has_data_mlv = 1
584  	    AND p_usim_id_spc_parent  IS NULL
585  	 THEN
586  	   usim_erl.log_error('usim_creator.create_new_universe', 'Parent for new universe missing, as already data in usim_multiverse exist.');
587  	   RETURN NULL;
588  	 END IF;
589  	 -- ignore parent if usim_space is empty
590  	 IF	usim_dbif.has_data_mlv = 0
591  	    AND p_usim_id_spc_parent  IS NOT NULL
592  	 THEN
593  	   usim_erl.log_error('usim_creator.create_new_universe', 'Ignoring parent assignment [' || p_usim_id_spc_parent || '] on empty multiverse.');
594  	   l_usim_id_spc_parent := NULL;
595  	 ELSE
596  	   l_usim_id_spc_parent := p_usim_id_spc_parent;
597  	 END IF;
598  	 -- create universe
599  	 l_usim_id_mlv := usim_dbif.create_universe( p_usim_energy_start_value
600  						   , p_usim_planck_time_unit
601  						   , p_usim_planck_length_unit
602  						   , p_usim_planck_speed_unit
603  						   , p_usim_planck_stable
604  						   , p_usim_ultimate_border
605  						   , FALSE
606  						   )
607  	 ;
608  	 -- if universe creation failed rollback everything
609  	 IF l_usim_id_mlv IS NULL
610  	 THEN
611  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create new universe with data energy start [' || p_usim_energy_start_value || '], planck time [' || p_usim_planck_time_unit || '], planck length [' || p_usim_planck_length_unit || '], planck speed [' || p_usim_planck_speed_unit || '], planck stable [' || p_usim_planck_stable || '] and ultimate border rule [' || p_usim_ultimate_border || '].');
612  	   ROLLBACK;
613  	   RETURN NULL;
614  	 END IF;
615  	 -- check and create dimension, if necessary
616  	 l_return := usim_dbif.init_dimensions(FALSE);
617  	 IF l_return = 0
618  	 THEN
619  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to init dimensions.');
620  	   ROLLBACK;
621  	   RETURN NULL;
622  	 END IF;
623  	 -- check and create positions, if necessary
624  	 l_return := usim_dbif.init_positions(FALSE);
625  	 IF l_return = 0
626  	 THEN
627  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to init positions.');
628  	   ROLLBACK;
629  	   RETURN NULL;
630  	 END IF;
631  	 -- get position 0
632  	 l_usim_id_pos := usim_dbif.get_id_pos(0);
633  	 IF l_usim_id_pos IS NULL
634  	 THEN
635  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to get position 0.');
636  	   ROLLBACK;
637  	   RETURN NULL;
638  	 END IF;
639  	 -- create dim axis
640  	 l_return  := usim_dbif.create_dim_axis(l_usim_id_mlv, 0, NULL, l_usim_id_rmd, l_rmd_dummy, FALSE);
641  	 IF l_return = 0
642  	 THEN
643  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create dimension axis for dimension 0 universe id [' || l_usim_id_mlv || '].');
644  	   ROLLBACK;
645  	   RETURN NULL;
646  	 END IF;
647  	 -- set parent if available
648  	 IF l_usim_id_spc_parent IS NOT NULL
649  	 THEN
650  	   l_parents(1) := l_usim_id_spc_parent;
651  	 END IF;
652  	 -- create basic space node
653  	 l_usim_id_spc := usim_dbif.create_space_node(l_usim_id_rmd, l_usim_id_pos, l_parents, FALSE);
654  	 IF l_usim_id_spc IS NULL
655  	 THEN
656  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node for rmd id [' || l_usim_id_rmd || '], pos id [' || l_usim_id_pos || '] and parent [' || NVL(l_usim_id_spc_parent, 'NONE') || '].');
657  	   ROLLBACK;
658  	   RETURN NULL;
659  	 END IF;
660  	 -- create dim axis (+/-) for dimension 1
661  	 l_return := usim_dbif.create_dim_axis(l_usim_id_mlv, 1, l_usim_id_rmd, l_id_rmd_n1p_1p, l_id_rmd_n1n_1n, FALSE);
662  	 IF l_return = 0
663  	 THEN
664  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create dimension axis for dimension 1 universe id [' || l_usim_id_mlv || '] and rmd id [' || l_usim_id_rmd || '].');
665  	   ROLLBACK;
666  	   RETURN NULL;
667  	 END IF;
668  	 -- create space nodes on dimension 1
669  	 l_parents(1) := l_usim_id_spc;
670  	 -- +0,0,0
671  	 l_id_spc0_n1p_1p  := usim_dbif.create_space_node(l_id_rmd_n1p_1p, l_usim_id_pos, l_parents, FALSE);
672  	 IF l_id_spc0_n1p_1p IS NULL
673  	 THEN
674  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position +0 at dimension 1, n1+ for rmd id [' || l_id_rmd_n1p_1p || '], pos id [' || l_usim_id_pos || '] and parent [' || NVL(l_usim_id_spc_parent, 'NONE') || '].');
675  	   ROLLBACK;
676  	   RETURN NULL;
677  	 END IF;
678  	 -- -0,0,0
679  	 l_id_spc0_n1n_1n  := usim_dbif.create_space_node(l_id_rmd_n1n_1n, l_usim_id_pos, l_parents, FALSE);
680  	 IF l_id_spc0_n1p_1p IS NULL
681  	 THEN
682  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position -0 at dimension 1, n1- for rmd id [' || l_id_rmd_n1n_1n || '], pos id [' || l_usim_id_pos || '] and parent [' || NVL(l_usim_id_spc_parent, 'NONE') || '].');
683  	   ROLLBACK;
684  	   RETURN NULL;
685  	 END IF;
686  	 -- get positions 1 (+/-)
687  	 l_usim_id_pos_1p := usim_dbif.get_id_pos(1);
688  	 IF l_usim_id_pos_1p IS NULL
689  	 THEN
690  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to get position +1.');
691  	   ROLLBACK;
692  	   RETURN NULL;
693  	 END IF;
694  	 l_usim_id_pos_1n := usim_dbif.get_id_pos(-1);
695  	 IF l_usim_id_pos_1n IS NULL
696  	 THEN
697  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to get position -1.');
698  	   ROLLBACK;
699  	   RETURN NULL;
700  	 END IF;
701  	 -- from here on parents have to have the same dim n1 sign
702  	 -- +1,0,0
703  	 l_parents(1) := l_id_spc0_n1p_1p;
704  	 l_id_spc1p_n1p_1p := usim_dbif.create_space_node(l_id_rmd_n1p_1p, l_usim_id_pos_1p, l_parents, FALSE);
705  	 IF l_id_spc1p_n1p_1p IS NULL
706  	 THEN
707  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position +1 at dimension 1, n1+ for rmd id [' || l_id_rmd_n1p_1p || '], pos id [' || l_usim_id_pos_1p || '] and parent [' || NVL(l_parents(1), 'NONE') || '].');
708  	   ROLLBACK;
709  	   RETURN NULL;
710  	 END IF;
711  	 -- -1,0,0
712  	 l_parents(1) := l_id_spc0_n1n_1n;
713  	 l_id_spc1n_n1n_1n := usim_dbif.create_space_node(l_id_rmd_n1n_1n, l_usim_id_pos_1n, l_parents, FALSE);
714  	 IF l_id_spc1p_n1p_1p IS NULL
715  	 THEN
716  	   usim_erl.log_error('usim_creator.create_new_universe', 'Failed to create space node position -1 at dimension 1, n1- for rmd id [' || l_id_rmd_n1n_1n || '], pos id [' || l_usim_id_pos_1n || '] and parent [' || NVL(l_parents(1), 'NONE') || '].');
717  	   ROLLBACK;
718  	   RETURN NULL;
719  	 END IF;
720  	 -- now commit if coming so far and do commit is set
721  	 IF p_do_commit
722  	 THEN
723  	   COMMIT;
724  	 END IF;
725  	 RETURN l_usim_id_spc;
726    EXCEPTION
727  	 WHEN OTHERS THEN
728  	   -- write error might still work
729  	   usim_erl.log_error('usim_creator.create_new_universe', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
730  	   -- try to set all to crashed
731  	   usim_dbif.set_crashed;
732  	   -- raise in any case
733  	   RAISE;
734    END create_new_universe
735    ;
736  
737    FUNCTION handle_overflow_dim( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
738  				   , p_do_commit   IN BOOLEAN			  DEFAULT TRUE
739  				   )
740  	 RETURN NUMBER
741    IS
742  	 l_dim_parent	   usim_space.usim_id_spc%TYPE;
743  	 l_spc_id_pos0p    usim_space.usim_id_spc%TYPE;
744  	 l_spc_id_pos1p    usim_space.usim_id_spc%TYPE;
745  	 l_spc_id_pos0n    usim_space.usim_id_spc%TYPE;
746  	 l_spc_id_pos1n    usim_space.usim_id_spc%TYPE;
747  	 l_id_pos0	   usim_position.usim_id_pos%TYPE;
748  	 l_id_pos1p	   usim_position.usim_id_pos%TYPE;
749  	 l_id_pos1n	   usim_position.usim_id_pos%TYPE;
750  	 l_parents	   usim_static.usim_ids_type;
751  	 l_next_dim	   usim_dimension.usim_n_dimension%TYPE;
752  	 l_usim_id_mlv	   usim_multiverse.usim_id_mlv%TYPE;
753  	 l_usim_id_rmd	   usim_rel_mlv_dim.usim_id_rmd%TYPE;
754  	 l_usim_id_rmd_p   usim_rel_mlv_dim.usim_id_rmd%TYPE;
755  	 l_usim_id_rmd_n   usim_rel_mlv_dim.usim_id_rmd%TYPE;
756  	 l_dim_sign	   usim_rel_mlv_dim.usim_sign%TYPE;
757  	 l_dim_n1_sign	   usim_rel_mlv_dim.usim_n1_sign%TYPE;
758  	 l_result	   NUMBER;
759  	 l_classify	   NUMBER;
760    BEGIN
761  	 l_classify := usim_dbif.is_dim_extendable(p_usim_id_spc, l_dim_parent, l_next_dim);
762  	 IF l_classify = 2
763  	 THEN
764  	   -- get data for create dimension
765  	   l_result := usim_dbif.get_spc_dim_details(l_dim_parent, l_usim_id_mlv, l_usim_id_rmd, l_dim_sign, l_dim_n1_sign);
766  	   IF l_result = 0
767  	   THEN
768  	     usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not fetch data for space id [' || p_usim_id_spc || '].');
769  	     usim_dbif.set_crashed;
770  	     RETURN 0;
771  	   END IF;
772  	   -- create a new dimension on zero pos axis node
773  	   l_result := usim_dbif.create_dim_axis(l_usim_id_mlv, l_next_dim, l_usim_id_rmd, l_usim_id_rmd_p, l_usim_id_rmd_n);
774  	   -- create position 0 and 1 on new dimension
775  	   l_id_pos0	  := usim_dbif.get_id_pos(0);
776  	   l_id_pos1p	  := usim_dbif.get_id_pos(1);
777  	   l_id_pos1n	  := usim_dbif.get_id_pos(-1);
778  	   l_parents(1)   := l_dim_parent;
779  	   l_spc_id_pos0p := usim_dbif.create_space_node(l_usim_id_rmd_p, l_id_pos0, l_parents);
780  	   IF l_spc_id_pos0p IS NULL
781  	   THEN
782  	     usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_p || '], pos [' || l_id_pos0 || '] and parent [' || l_parents(1) || '].');
783  	     usim_dbif.set_crashed;
784  	     RETURN 0;
785  	   END IF;
786  	   l_parents(1)   := l_spc_id_pos0p;
787  	   l_spc_id_pos1p := usim_dbif.create_space_node(l_usim_id_rmd_p, l_id_pos1p, l_parents);
788  	   IF l_spc_id_pos1p IS NULL
789  	   THEN
790  	     usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_p || '], pos [' || l_id_pos1p || '] and parent [' || l_parents(1) || '].');
791  	     usim_dbif.set_crashed;
792  	     RETURN 0;
793  	   END IF;
794  	   l_parents(1)   := l_dim_parent;
795  	   l_spc_id_pos0n := usim_dbif.create_space_node(l_usim_id_rmd_n, l_id_pos0, l_parents);
796  	   IF l_spc_id_pos0n IS NULL
797  	   THEN
798  	     usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_n || '], pos [' || l_id_pos0 || '] and parent [' || l_parents(1) || '].');
799  	     usim_dbif.set_crashed;
800  	     RETURN 0;
801  	   END IF;
802  	   l_parents(1)   := l_spc_id_pos0n;
803  	   l_spc_id_pos1n := usim_dbif.create_space_node(l_usim_id_rmd_n, l_id_pos1n, l_parents);
804  	   IF l_spc_id_pos1n IS NULL
805  	   THEN
806  	     usim_erl.log_error('usim_creator.handle_overflow_dim', 'Could not create space id for rmd [' || l_usim_id_rmd_n || '], pos [' || l_id_pos1n || '] and parent [' || l_parents(1) || '].');
807  	     usim_dbif.set_crashed;
808  	     RETURN 0;
809  	   END IF;
810  	   usim_debug.debug_log('usim_creator.handle_overflow_dim', 'Handle new dimension in zero pos for space id [' || p_usim_id_spc || '].');
811  	   RETURN 1;
812  	 ELSIF l_classify = 1
813  	 THEN
814  	   -- connect node to available dimension
815  	   usim_debug.debug_log('usim_creator.handle_overflow_dim', 'Not implemented for space id [' || p_usim_id_spc || '].');
816  	 ELSE
817  	   usim_debug.debug_log('usim_creator.handle_overflow_dim', 'Not implemented for space id [' || p_usim_id_spc || '].');
818  	 END IF;
819  	 RETURN 1;
820    EXCEPTION
821  	 WHEN OTHERS THEN
822  	   -- write error might still work
823  	   usim_erl.log_error('usim_creator.handle_overflow_dim', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
824  	   -- try to set all to crashed
825  	   usim_dbif.set_crashed;
826  	   -- raise in any case
827  	   RAISE;
828    END handle_overflow_dim
829    ;
830  
831  
832    FUNCTION handle_overflow_pos( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
833  				   , p_do_commit   IN BOOLEAN			  DEFAULT TRUE
834  				   )
835  	 RETURN NUMBER
836    IS
837  	 l_result    usim_space.usim_id_spc%TYPE;
838  	 l_parent    usim_space.usim_id_spc%TYPE;
839  	 l_parents   usim_static.usim_ids_type;
840  	 l_id_pos    usim_position.usim_id_pos%TYPE;
841  	 l_id_rmd    usim_rel_mlv_dim.usim_id_rmd%TYPE;
842  	 l_is_valid  NUMBER;
843  	 l_return    NUMBER;
844    BEGIN
845  	 l_is_valid := usim_dbif.is_pos_extendable(p_usim_id_spc);
846  	 IF l_is_valid = 0
847  	 THEN
848  	   usim_erl.log_error('usim_creator.handle_overflow_pos', 'Used invalid node id [' || p_usim_id_spc || '] no axis zero pos or no position free.');
849  	   RETURN 0;
850  	 END IF;
851  	 IF l_is_valid = 1
852  	 THEN
853  	   -- new position with parent current given node
854  	   l_parent := p_usim_id_spc;
855  	 ELSE
856  	   -- get max pos for zero nodes using their dimension settings
857  	   l_parent := usim_dbif.get_axis_max_pos_parent(p_usim_id_spc);
858  	   IF l_parent IS NULL
859  	   THEN
860  	     usim_erl.log_error('usim_creator.handle_overflow_pos', 'Could not retrieve max pos parent id from space node [' || p_usim_id_spc || '].');
861  	     RETURN 0;
862  	   END IF;
863  	 END IF;
864  	 l_parents(1) := l_parent;
865  	 -- get next position and axis
866  	 l_return := usim_dbif.get_next_pos_on_axis(l_parent, l_id_pos, l_id_rmd);
867  	 IF l_return = 0
868  	 THEN
869  	   usim_erl.log_error('usim_creator.handle_overflow_pos', 'usim_dbif.get_next_pos_on_axis failed for parent [' || l_parent || '].');
870  	   RETURN 0;
871  	 END IF;
872  	 -- create space node with parent identified
873  	 l_result := usim_dbif.create_space_node(l_id_rmd, l_id_pos, l_parents, p_do_commit);
874  	 IF l_result IS NULL
875  	 THEN
876  	   usim_erl.log_error('usim_creator.handle_overflow_pos', 'Failed to create space node for rmd [' || l_id_rmd || '], pos [' || l_id_pos || '] and parent [' || l_parents(1) || '].');
877  	   RETURN 0;
878  	 END IF;
879  	 RETURN 1;
880    EXCEPTION
881  	 WHEN OTHERS THEN
882  	   -- write error might still work
883  	   usim_erl.log_error('usim_creator.handle_overflow_pos', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
884  	   -- try to set all to crashed
885  	   usim_dbif.set_crashed;
886  	   -- raise in any case
887  	   RAISE;
888    END handle_overflow_pos
889    ;
890  
891    FUNCTION handle_overflow_between( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
892  				       , p_do_commit   IN BOOLEAN		      DEFAULT TRUE
893  				       )
894  	 RETURN NUMBER
895    IS
896    BEGIN
897  	 -- where are we
898  	 -- if zero pos
899  	 -- if axis, next dimension only a 1 coordinate for connect is possible
900  	 IF usim_spo.is_axis_pos(p_usim_id_spc) = 1
901  	 THEN
902  
903  	   -- has child next dim with pos 1?
904  	   -- no, then delegate next free low pos inbetween.
905  	   NULL;
906  	 ELSE
907  	   -- positions free lower dimension
908  	   -- positions free higher dimension
909  	   NULL;
910  	 END IF;
911  	 usim_debug.debug_log('usim_creator.handle_overflow_between', 'Not implemented yet.');
912  	 RETURN 0;
913    EXCEPTION
914  	 WHEN OTHERS THEN
915  	   -- write error might still work
916  	   usim_erl.log_error('usim_creator.handle_overflow_between', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
917  	   -- try to set all to crashed
918  	   usim_dbif.set_crashed;
919  	   -- raise in any case
920  	   RAISE;
921    END handle_overflow_between
922    ;
923  
924  
925    FUNCTION handle_overflow( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
926  			       , p_do_commit   IN BOOLEAN		      DEFAULT TRUE
927  			       )
928  	 RETURN NUMBER
929    IS
930  	 l_escape	 NUMBER;
931  	 l_result	 NUMBER;
932  	 l_id_spc_parent usim_space.usim_id_spc%TYPE;
933    BEGIN
934  	 l_escape := usim_dbif.classify_escape(p_usim_id_spc);
935  
936  	 IF l_escape IN (3, 5)
937  	 THEN
938  	   -- escape position 5 and 3 can be handled together
939  	   l_result := usim_creator.handle_overflow_pos(p_usim_id_spc, p_do_commit);
940  	   IF l_result = 0
941  	   THEN
942  	     usim_erl.log_error('usim_creator.handle_overflow', 'Pos overflow handling error for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
943  	     usim_dbif.set_crashed;
944  	     RETURN 0;
945  	   END IF;
946  	   usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Handle pos overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
947  	 ELSIF l_escape IN (2, 4)
948  	 THEN
949  	   l_result := usim_creator.handle_overflow_dim(p_usim_id_spc, p_do_commit);
950  	   IF l_result = 0
951  	   THEN
952  	     usim_erl.log_error('usim_creator.handle_overflow', 'Dim overflow handling error for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
953  	     usim_dbif.set_crashed;
954  	     RETURN 0;
955  	   END IF;
956  	   usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Handle dim overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
957  	 ELSIF l_escape = 1
958  	 THEN
959  	   IF usim_dbif.is_pos_extendable(p_usim_id_spc) = 1
960  	   THEN
961  	     l_result := usim_creator.handle_overflow_pos(p_usim_id_spc, p_do_commit);
962  	   ELSE
963  	     l_result := usim_creator.handle_overflow_dim(p_usim_id_spc, p_do_commit);
964  	   END IF;
965  	   IF l_result = 0
966  	   THEN
967  	     usim_erl.log_error('usim_creator.handle_overflow', 'Pos/dim overflow handling error for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
968  	     usim_dbif.set_crashed;
969  	     RETURN 0;
970  	   END IF;
971  	   usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Handle overflow pos/dim for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
972  	 -- delegate options
973  	 ELSIF l_escape = 7
974  	 THEN
975  	   l_result := usim_creator.handle_overflow_between(p_usim_id_spc, p_do_commit);
976  	   usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
977  	 ELSIF l_escape = 6
978  	 THEN
979  	   usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
980  	 ELSIF l_escape = 5
981  	 THEN
982  	   usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
983  	 ELSIF l_escape = 0
984  	 THEN
985  	   usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] escape strategy [' || l_escape || '].');
986  	 ELSE
987  	   usim_debug.debug_log('usim_creator.handle_overflow', '[' || usim_dbif.get_planck_time_current || '] Not implemented. Handle overflow for [' || p_usim_id_spc || '] with unknown escape strategy [' || l_escape || '].');
988  	 END IF;
989  	 RETURN 1;
990    EXCEPTION
991  	 WHEN OTHERS THEN
992  	   -- write error might still work
993  	   usim_erl.log_error('usim_creator.handle_overflow', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
994  	   -- try to set all to crashed
995  	   usim_dbif.set_crashed;
996  	   -- raise in any case
997  	   RAISE;
998    END handle_overflow
999    ;
1000  
1001  END usim_creator;
1002  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_creator
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_creator

Package body created.

SQL> @@../PACKAGES/USIM_PROCESS.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_process
  2  IS
  3    /**A package for processing space nodes. Depends on all available packages including USIM_CREATOR.*/
  4  
  5    /**
  6    * Provides a process start node in the queue. The start node is always the base universe seed at position 0 and dimension 0
  7    * without any parent. The process direction is childs. Should be called only once. Will do nothing if processing nodes already
  8    * exist. Will create base data with given parameters, if missing, intialize planck time if not done and create a universe seed, if it
  9    * does not exist using given parameters. Will activate the universe, if not active.
 10    * @param p_max_dimension The maximum dimensions possible for this multiverse. Base data init.
 11    * @param p_usim_abs_max_number The absolute maximum number available for this multiverse. Base data init.
 12    * @param p_usim_overflow_node_seed Defines the overflow behaviour, default 0 means standard overflow behaviour. If set to 1, all new nodes are created with the universe seed at coordinate 0 as the parent. Base data init.
 13    * @param p_usim_energy_start_value The start value of energy the universe should have. For inserts the absolute value is used or default if NULL or 0. Universe seed init.
 14    * @param p_usim_planck_time_unit The outside planck time unit for this universe. Will use the absolute value or default if NULL or 0. Universe seed init.
 15    * @param p_usim_planck_length_unit The outside planck length unit for this universe. Will use the absolute value or default if NULL or 0. Universe seed init.
 16    * @param p_usim_planck_speed_unit The outside planck speed unit for this universe. Will use the absolute value or default if NULL or 0. Universe seed init.
 17    * @param p_usim_planck_stable The definition if planck units are stable (1) or can change over time (0) for this universe. Will use 1, if value range (0, 1) is not correct. Universe seed init.
 18    * @param p_usim_ultimate_border The ultimate border rule for this universe. 1 is ultimate border reached, no childs left, 0 is any border at dimensions axis even with childs left. Universe seed init.
 19    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 20    * @return Return 1 if all was successfully processed otherwise 0.
 21    */
 22    FUNCTION place_start_node( p_max_dimension	     IN NUMBER					     DEFAULT 42
 23  				, p_usim_abs_max_number      IN NUMBER					     DEFAULT 99999999999999999999999999999999999999
 24  				, p_usim_overflow_node_seed  IN NUMBER					     DEFAULT 0
 25  				, p_usim_energy_start_value  IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
 26  				, p_usim_planck_time_unit    IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
 27  				, p_usim_planck_length_unit  IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
 28  				, p_usim_planck_speed_unit   IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
 29  				, p_usim_planck_stable	     IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
 30  				, p_usim_ultimate_border     IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
 31  				, p_do_commit		     IN BOOLEAN 				     DEFAULT TRUE
 32  				)
 33  	 RETURN NUMBER
 34    ;
 35  
 36    /**
 37    * Processes a given space node by sending out energy either to child or parent nodes. Handles
 38    * border situation for process direction.
 39    * Will update table USIM_SPC_PROCESS. Using package USIM_MATHS for calculations.
 40    * @param p_usim_id_spc The space node to process. Mandatory.
 41    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 42    * @return Return 1 if all was successfully processed otherwise 0.
 43    */
 44    FUNCTION process_node( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
 45  			    , p_do_commit   IN BOOLEAN			   DEFAULT TRUE
 46  			    )
 47  	 RETURN NUMBER
 48    ;
 49  
 50    /**
 51    * Processes currently open outputs, sums up the target nodes and updates targets energy. Starts
 52    * then processing target nodes as source nodes. Handles overflows and necessary actions like dimension creation.
 53    * Overflow can result in infinity or in NUMERIC OVERFLOW!!!!
 54    * Updates the planck time. Will write result to table USIM_SPC_PROCESS. Using package USIM_MATHS for calculations.
 55    * @param p_do_commit An boolean indicator if data should be committed or not (e.g. for trigger use).
 56    * @return Return 1 if all was successfully processed otherwise 0.
 57    */
 58    FUNCTION process_queue(p_do_commit IN BOOLEAN DEFAULT TRUE)
 59  	 RETURN NUMBER
 60    ;
 61  
 62    /**
 63    * Will update the state of all universes in the multiverse. Run after execution usim_process.process_queue.
 64    * @return Return 1 if all was successfully processed otherwise 0.
 65    */
 66    FUNCTION update_universe_states(p_do_commit IN BOOLEAN DEFAULT TRUE)
 67  	 RETURN NUMBER
 68    ;
 69  
 70    /**
 71    * Runs the process queue for the given amount of times or as long as the system is valid. Will update
 72    * state of the current universes.
 73    * @return Return 1 if all was successfully processed otherwise 0.
 74    */
 75    FUNCTION run_samples( p_run_count IN NUMBER
 76  			   , p_do_commit IN BOOLEAN DEFAULT TRUE
 77  			   )
 78  	 RETURN NUMBER
 79    ;
 80  
 81  END usim_process;
 82  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_process
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_process

Package created.

SQL> @@../PACKAGES/USIM_PROCESS.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_process
  2  IS
  3    -- see header for documentation
  4  
  5    FUNCTION place_start_node( p_max_dimension	     IN NUMBER					     DEFAULT 42
  6  				, p_usim_abs_max_number      IN NUMBER					     DEFAULT 99999999999999999999999999999999999999
  7  				, p_usim_overflow_node_seed  IN NUMBER					     DEFAULT 0
  8  				, p_usim_energy_start_value  IN usim_multiverse.usim_energy_start_value%TYPE DEFAULT 1
  9  				, p_usim_planck_time_unit    IN usim_multiverse.usim_planck_time_unit%TYPE   DEFAULT 1
 10  				, p_usim_planck_length_unit  IN usim_multiverse.usim_planck_length_unit%TYPE DEFAULT 1
 11  				, p_usim_planck_speed_unit   IN usim_multiverse.usim_planck_speed_unit%TYPE  DEFAULT 1
 12  				, p_usim_planck_stable	     IN usim_multiverse.usim_planck_stable%TYPE      DEFAULT 1
 13  				, p_usim_ultimate_border     IN usim_multiverse.usim_ultimate_border%TYPE    DEFAULT 1
 14  				, p_do_commit		     IN BOOLEAN 				     DEFAULT TRUE
 15  				)
 16  	 RETURN NUMBER
 17    IS
 18  	 l_source_G	 NUMBER;
 19  	 l_distance	 NUMBER;
 20  	 l_energy	 NUMBER;
 21  	 l_start_value	 NUMBER;
 22  	 l_target_energy NUMBER;
 23  	 l_resDimG	 NUMBER;
 24  	 l_resR 	 NUMBER;
 25  	 l_resEnergy	 NUMBER;
 26  	 l_return	 NUMBER;
 27  	 l_planck_time	 NUMBER;
 28  	 l_planck_aeon	 usim_static.usim_id;
 29  	 l_state	 usim_multiverse.usim_universe_status%TYPE;
 30  	 l_base_id	 usim_space.usim_id_spc%TYPE;
 31  	 l_spr_id	 usim_spc_process.usim_id_spr%TYPE;
 32  
 33  	 CURSOR cur_childs(cp_usim_id_spc IN usim_space.usim_id_spc%TYPE)
 34  	 IS
 35  	   SELECT chi.usim_id_spc_child
 36  		, spcv.usim_energy
 37  		, spcv.dim_sign
 38  	     FROM usim_spc_child chi
 39  	    INNER JOIN usim_spc_v spcv
 40  	       ON chi.usim_id_spc_child = spcv.usim_id_spc
 41  	    WHERE chi.usim_id_spc = cp_usim_id_spc
 42  	 ;
 43    BEGIN
 44  	 IF usim_dbif.has_data_spr = 1
 45  	 THEN
 46  	   -- can't insert start node if data already exist
 47  	   usim_erl.log_error('usim_process.place_start_node', 'Process already initialized, no start node allowed.');
 48  	   RETURN 0;
 49  	 END IF;
 50  	 -- prepare base data if needed
 51  	 IF usim_dbif.has_basedata = 0
 52  	 THEN
 53  	   l_return := usim_dbif.init_basedata(p_max_dimension, p_usim_abs_max_number, p_usim_overflow_node_seed);
 54  	   IF l_return = 0
 55  	   THEN
 56  	     usim_erl.log_error('usim_process.place_start_node', 'Could not initialize base data with max dim [' || p_max_dimension || '], max_num [' || p_usim_abs_max_number || '] and overflow rule [' || p_usim_overflow_node_seed || '].');
 57  	     RETURN 0;
 58  	   END IF;
 59  	 END IF;
 60  	 -- check planck aeon
 61  	 l_planck_aeon := usim_dbif.get_planck_aeon_seq_current;
 62  	 IF l_planck_aeon = usim_static.usim_not_available
 63  	 THEN
 64  	   -- init planck aeon and time
 65  	   l_planck_time := usim_dbif.get_planck_time_next;
 66  	   IF l_planck_time IS NULL
 67  	   THEN
 68  	     usim_erl.log_error('usim_process.place_start_node', 'Could not initialize planck time.');
 69  	     RETURN 0;
 70  	   END IF;
 71  	   l_planck_aeon := usim_dbif.get_planck_aeon_seq_current;
 72  	   IF l_planck_aeon = usim_static.usim_not_available
 73  	   THEN
 74  	     usim_erl.log_error('usim_process.place_start_node', 'Could not initialize planck aeon with planck time next.');
 75  	     RETURN 0;
 76  	   END IF;
 77  	 ELSE
 78  	   -- we should have a planck time if aeon is set
 79  	   l_planck_time := usim_dbif.get_planck_time_current;
 80  	   IF l_planck_time IS NULL
 81  	   THEN
 82  	     usim_erl.log_error('usim_process.place_start_node', 'Could not get current planck time with planck aeon already set.');
 83  	     RETURN 0;
 84  	   END IF;
 85  	 END IF;
 86  	 -- check universe
 87  	 IF usim_dbif.has_data_mlv = 0
 88  	 THEN
 89  	   -- create base universe seed
 90  	   l_base_id := usim_creator.create_new_universe( p_usim_energy_start_value
 91  							, p_usim_planck_time_unit
 92  							, p_usim_planck_length_unit
 93  							, p_usim_planck_speed_unit
 94  							, p_usim_planck_stable
 95  							, p_usim_ultimate_border
 96  							, NULL
 97  							, TRUE
 98  							)
 99  	   ;
100  	   IF l_base_id IS NULL
101  	   THEN
102  	     usim_erl.log_error('usim_process.place_start_node', 'Could not create missing base universe energy start [' || p_usim_energy_start_value || '],  planck time [' || p_usim_planck_time_unit || '],	planck length [' || p_usim_planck_length_unit || '], planck speed [' || p_usim_planck_speed_unit || '], planck stable [' || p_usim_planck_stable || '], border rule [' || p_usim_ultimate_border || '] and no parent.');
103  	     -- rely on rollback of called function
104  	     RETURN 0;
105  	   END IF;
106  	 ELSE
107  	   -- universe exists, what about nodes?
108  	   IF usim_dbif.has_data_spc = 0
109  	   THEN
110  	     usim_erl.log_error('usim_process.place_start_node', 'Initialization error. Existing universe but no space nodes available.');
111  	     RETURN 0;
112  	   END IF;
113  	   l_base_id := usim_dbif.get_id_spc_base_universe;
114  	   IF l_base_id IS NULL
115  	   THEN
116  	     usim_erl.log_error('usim_process.place_start_node', 'Initialization error. Could not fetch base universe seed.');
117  	     RETURN 0;
118  	   END IF;
119  	 END IF;
120  	 -- check childs of base universe
121  	 IF usim_dbif.child_count(l_base_id) != 2
122  	 THEN
123  	   -- we expect exactly two childs for base universe seed
124  	     usim_erl.log_error('usim_process.place_start_node', 'Initialization error. Base universe seed has not the correct amount of childs (2).');
125  	     RETURN 0;
126  	 END IF;
127  	 -- activate seed universe, if not already done
128  	 l_state := usim_dbif.set_seed_active(FALSE);
129  	 IF l_state != usim_static.usim_multiverse_status_active
130  	 THEN
131  	   ROLLBACK;
132  	   -- cannot start with this universe
133  	   usim_erl.log_error('usim_process.place_start_node', 'Universe state error. Current universe cannot be switched to active, space id [' || l_base_id || '] state [' || l_state || '].');
134  	   RETURN 0;
135  	 END IF;
136  	 -- ready to start
137  	 SELECT usim_energy
138  	      , usim_energy_start_value
139  	   INTO l_energy
140  	      , l_start_value
141  	   FROM usim_spc_v
142  	  WHERE usim_id_spc = l_base_id
143  	 ;
144  	 IF l_energy IS NULL
145  	 THEN
146  	   l_energy := l_start_value;
147  	 END IF;
148  	 l_resDimG := usim_dbif.get_dim_G(l_base_id, l_source_G);
149  	 IF l_resDimG != 1
150  	 THEN
151  	   usim_erl.log_error('usim_process.place_start_node', 'Universe setup error. Calculate dimension G for space id [' || l_base_id || '] should not give error or overflow [' || l_resDimG || '].');
152  	   usim_dbif.set_crashed;
153  	   RETURN 0;
154  	 END IF;
155  	 l_resR := usim_dbif.get_outer_planck_r(l_base_id, l_distance);
156  	 IF l_resR != 1
157  	 THEN
158  	   usim_erl.log_error('usim_process.place_start_node', 'Universe setup error. Calculate radius for space id [' || l_base_id || '] should not give error or overflow [' || l_resR || '].');
159  	   usim_dbif.set_crashed;
160  	   RETURN 0;
161  	 END IF;
162  	 l_resEnergy := usim_dbif.get_acceleration(l_energy, l_distance, l_source_G, l_target_energy);
163  	 IF l_resEnergy != 1
164  	 THEN
165  	   usim_erl.log_error('usim_process.place_start_node', 'Universe setup error. Calculate energy for base seed space id [' || l_base_id || '] should not give error or overflow [' || l_resEnergy || ']. Energy [' || l_energy || '], distance [' || l_distance || '], G [' || l_source_G || '].');
166  	   usim_dbif.set_crashed;
167  	   RETURN 0;
168  	 END IF;
169  	 -- process childs
170  	 FOR rec IN cur_childs(l_base_id)
171  	 LOOP
172  	   l_spr_id := usim_dbif.create_process(l_base_id, rec.usim_id_spc_child, l_energy, rec.usim_energy, l_target_energy * rec.dim_sign, FALSE);
173  	   IF l_spr_id IS NULL
174  	   THEN
175  	     ROLLBACK;
176  	     -- error insert
177  	     usim_erl.log_error('usim_process.place_start_node', 'Could not insert process record.');
178  	     usim_dbif.set_crashed;
179  	     RETURN 0;
180  	   END IF;
181  	 END LOOP;
182  	 -- commit everything if gone well
183  	 IF p_do_commit
184  	 THEN
185  	   COMMIT;
186  	 END IF;
187  	 RETURN 1;
188    EXCEPTION
189  	 WHEN OTHERS THEN
190  	   ROLLBACK;
191  	   -- write error might still work
192  	   usim_erl.log_error('usim_process.place_start_node', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
193  	   -- try to set all to crashed
194  	   usim_dbif.set_crashed;
195  	   -- raise in any case
196  	   RAISE;
197    END place_start_node
198    ;
199  
200    FUNCTION process_node( p_usim_id_spc IN usim_space.usim_id_spc%TYPE
201  			    , p_do_commit   IN BOOLEAN			   DEFAULT TRUE
202  			    )
203  	 RETURN NUMBER
204    IS
205  	 l_source_G	 NUMBER;
206  	 l_distance	 NUMBER;
207  	 l_energy	 NUMBER;
208  	 l_start_value	 NUMBER;
209  	 l_target_energy NUMBER;
210  	 l_resDimG	 NUMBER;
211  	 l_resR 	 NUMBER;
212  	 l_resEnergy	 NUMBER;
213  	 l_is_base	 INTEGER;
214  	 l_result	 INTEGER;
215  	 l_spr_id	 usim_spc_process.usim_id_spr%TYPE;
216  	 l_executed	 BOOLEAN;
217  
218  	 CURSOR cur_childs(cp_usim_id_spc IN usim_space.usim_id_spc%TYPE)
219  	 IS
220  	   SELECT chi.usim_id_spc_child
221  		, spcv.usim_energy
222  		, spcv.dim_sign
223  	     FROM usim_spc_child chi
224  	    INNER JOIN usim_spc_v spcv
225  	       ON chi.usim_id_spc_child = spcv.usim_id_spc
226  	    WHERE chi.usim_id_spc = cp_usim_id_spc
227  	 ;
228  	 CURSOR cur_parent(cp_usim_id_spc IN usim_space.usim_id_spc%TYPE)
229  	 IS
230  	   SELECT chi.usim_id_spc
231  		, spcv.usim_energy
232  		, spcv.dim_sign
233  	     FROM usim_spc_child chi
234  	    INNER JOIN usim_spc_v spcv
235  	       ON chi.usim_id_spc = spcv.usim_id_spc
236  	    WHERE chi.usim_id_spc_child = cp_usim_id_spc
237  	 ;
238    BEGIN
239  	 IF usim_dbif.has_data_spc(p_usim_id_spc) = 0
240  	 THEN
241  	   usim_erl.log_error('usim_process.process_node', 'Used with invalid space id [' || p_usim_id_spc || '].');
242  	   RETURN 0;
243  	 END IF;
244  	 IF usim_dbif.is_seed_active = 0
245  	 THEN
246  	   -- won't operate on universe not active
247  	   usim_erl.log_error('usim_process.process_node', 'Current universe seed is not active. Node not processed space id [' || p_usim_id_spc || '].');
248  	   RETURN 0;
249  	 END IF;
250  	 -- check border situation
251  	 l_result := usim_dbif.check_border(p_usim_id_spc, FALSE);
252  	 IF l_result != 1
253  	 THEN
254  	   usim_erl.log_error('usim_process.process_node', 'Check border failed with parameter [' || p_usim_id_spc || '] and result [' || l_result || '].');
255  	   RETURN 0;
256  	 END IF;
257  	 -- operate on node
258  	 SELECT usim_energy
259  	      , usim_energy_start_value
260  	   INTO l_energy
261  	      , l_start_value
262  	   FROM usim_spc_v
263  	  WHERE usim_id_spc = p_usim_id_spc
264  	 ;
265  	 l_is_base := usim_dbif.is_universe_base_type(p_usim_id_spc);
266  	 IF l_is_base = 1
267  	 THEN
268  	   IF l_energy IS NULL
269  	   THEN
270  	     l_energy := l_start_value;
271  	   END IF;
272  	 END IF;
273  	 l_resDimG := usim_dbif.get_dim_G(p_usim_id_spc, l_source_G);
274  	 IF l_resDimG != 1
275  	 THEN
276  	   IF l_resDimG = 0
277  	   THEN
278  	     usim_debug.debug_log('usim_process.process_node', 'Overflow for space id [' || p_usim_id_spc || '] usim_dbif.get_dim_G. Set G to default 1.');
279  	     l_result	:= usim_creator.handle_overflow(p_usim_id_spc, FALSE);
280  	     IF l_result = 0
281  	     THEN
282  	       ROLLBACK;
283  	       usim_erl.log_error('usim_process.process_node', 'usim_creator.handle_overflow failed for space id [' || p_usim_id_spc || '] usim_dbif.get_dim_G.');
284  	       usim_dbif.set_crashed;
285  	       RETURN 0;
286  	     END IF;
287  	     -- set to default
288  	     l_source_G := 1;
289  	   ELSE
290  	     usim_erl.log_error('usim_process.process_node', 'Universe setup error. Calculate dimension G for space id [' || p_usim_id_spc || '] should not give error [' || l_resDimG || '].');
291  	     usim_dbif.set_crashed;
292  	     RETURN 0;
293  	   END IF;
294  	 END IF;
295  	 l_resR := usim_dbif.get_outer_planck_r(p_usim_id_spc, l_distance);
296  	 IF l_resR != 1
297  	 THEN
298  	   IF l_resR = 0
299  	   THEN
300  	     usim_debug.debug_log('usim_process.process_node', 'Overflow for space id [' || p_usim_id_spc || '] usim_dbif.get_outer_planck_r. Set distance to default 1.');
301  	     l_result	:= usim_creator.handle_overflow(p_usim_id_spc, FALSE);
302  	     IF l_result = 0
303  	     THEN
304  	       ROLLBACK;
305  	       usim_erl.log_error('usim_process.process_node', 'usim_creator.handle_overflow failed for space id [' || p_usim_id_spc || '] usim_dbif.get_outer_planck_r.');
306  	       usim_dbif.set_crashed;
307  	       RETURN 0;
308  	     END IF;
309  	     -- set to default
310  	     l_distance := 1;
311  	   ELSE
312  	     usim_erl.log_error('usim_process.process_node', 'Universe setup error. Calculate radius for space id [' || p_usim_id_spc || '] should not give error [' || l_resR || '].');
313  	     usim_dbif.set_crashed;
314  	     RETURN 0;
315  	   END IF;
316  	 END IF;
317  	 l_resEnergy := usim_dbif.get_acceleration(l_energy, l_distance, l_source_G, l_target_energy);
318  	 IF l_resEnergy != 1
319  	 THEN
320  	   IF l_resEnergy = 0
321  	   THEN
322  	     usim_debug.debug_log('usim_process.process_node', 'Overflow for space id [' || p_usim_id_spc || '] usim_dbif.get_acceleration. Set target energy to 0.');
323  	     l_result	     := usim_creator.handle_overflow(p_usim_id_spc, FALSE);
324  	     IF l_result = 0
325  	     THEN
326  	       ROLLBACK;
327  	       usim_erl.log_error('usim_process.process_node', 'usim_creator.handle_overflow failed for space id [' || p_usim_id_spc || '] usim_dbif.get_acceleration.');
328  	       usim_dbif.set_crashed;
329  	       RETURN 0;
330  	     END IF;
331  	     l_target_energy := 0;
332  	   ELSE
333  	     usim_erl.log_error('usim_process.process_node', 'Universe setup error. Calculate acceleration energy for space id [' || p_usim_id_spc || '] should not give error [' || l_resEnergy || ']. With energy [' || l_energy || '], distance [' || l_distance || '], G [' || l_source_G || '].');
334  	     usim_dbif.set_crashed;
335  	     RETURN 0;
336  	   END IF;
337  	 END IF;
338  	 -- process after checks decide direction
339  	 IF usim_dbif.get_process_spin(p_usim_id_spc) = 1
340  	 THEN
341  	   -- childs
342  	   l_executed := FALSE;
343  	   FOR rec IN cur_childs(p_usim_id_spc)
344  	   LOOP
345  	     l_executed := TRUE;
346  	     l_spr_id := usim_dbif.create_process( p_usim_id_spc
347  						 , rec.usim_id_spc_child
348  						 , l_energy
349  						 , rec.usim_energy
350  						 , CASE
351  						     WHEN l_is_base = 1
352  						     THEN l_target_energy * rec.dim_sign
353  						     ELSE l_target_energy
354  						   END
355  						 , FALSE
356  						 )
357  	     ;
358  	     IF l_spr_id IS NULL
359  	     THEN
360  	       ROLLBACK;
361  	       -- error insert
362  	       usim_erl.log_error('usim_process.process_node', 'Could not insert process record for space id [' || p_usim_id_spc || '].');
363  	       usim_dbif.set_crashed;
364  	       RETURN 0;
365  	     END IF;
366  	   END LOOP;
367  	   IF NOT l_executed
368  	   THEN
369  	     usim_erl.log_error('usim_process.process_node', 'ERROR Child cursors had no data. cur_childs(' || p_usim_id_spc || ') process spin 1');
370  	     usim_dbif.set_crashed;
371  	     RETURN 0;
372  	   END IF;
373  	 ELSIF usim_dbif.get_process_spin(p_usim_id_spc) = -1
374  	 THEN
375  	   -- parents
376  	   l_executed := FALSE;
377  	   FOR rec IN cur_parent(p_usim_id_spc)
378  	   LOOP
379  	     l_executed := TRUE;
380  	     l_spr_id := usim_dbif.create_process( p_usim_id_spc
381  						 , rec.usim_id_spc
382  						 , l_energy
383  						 , rec.usim_energy
384  						 , CASE
385  						     WHEN l_is_base = 1
386  						     THEN l_target_energy * rec.dim_sign
387  						     ELSE l_target_energy
388  						   END
389  						 , FALSE
390  						 )
391  	     ;
392  	     IF l_spr_id IS NULL
393  	     THEN
394  	       ROLLBACK;
395  	       -- error insert
396  	       usim_erl.log_error('usim_process.process_node', 'Could not insert process record for space id [' || p_usim_id_spc || '].');
397  	       usim_dbif.set_crashed;
398  	       RETURN 0;
399  	     END IF;
400  	   END LOOP;
401  	   IF NOT l_executed
402  	   THEN
403  	     usim_erl.log_error('usim_process.process_node', 'ERROR Parent cursor had no data. cur_parent(' || p_usim_id_spc || ') process spin -1');
404  	     usim_dbif.set_crashed;
405  	     RETURN 0;
406  	   END IF;
407  	 ELSE
408  	   -- invalid space id or process spin
409  	   ROLLBACK;
410  	   -- error insert
411  	   usim_erl.log_error('usim_process.process_node', 'Invalid space id [' || p_usim_id_spc || '] no process direction found.');
412  	   usim_dbif.set_crashed;
413  	   RETURN 0;
414  	 END IF;
415  	 IF p_do_commit
416  	 THEN
417  	   COMMIT;
418  	 END IF;
419  	 RETURN 1;
420    EXCEPTION
421  	 WHEN OTHERS THEN
422  	   ROLLBACK;
423  	   -- write error might still work
424  	   usim_erl.log_error('usim_process.process_node', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
425  	   -- try to set all to crashed
426  	   usim_dbif.set_crashed;
427  	   -- raise in any case
428  	   RAISE;
429    END process_node
430    ;
431  
432    FUNCTION process_queue(p_do_commit IN BOOLEAN DEFAULT TRUE)
433  	 RETURN NUMBER
434    IS
435  	 l_energy      NUMBER;
436  	 l_energy_set  NUMBER;
437  	 l_result      NUMBER;
438  	 l_planck_tick NUMBER;
439  	 l_usim_id_nod usim_node.usim_id_nod%TYPE;
440  	 l_planck_aeon usim_spc_process.usim_planck_aeon%TYPE;
441  	 l_planck_time usim_spc_process.usim_planck_time%TYPE;
442  	 l_cur_aeon    usim_spc_process.usim_planck_aeon%TYPE;
443  	 l_cur_time    usim_spc_process.usim_planck_time%TYPE;
444  	 l_usim_id_spr usim_spc_process.usim_id_spr%TYPE;
445  	 l_executed    BOOLEAN;
446  	 l_exec_inner  BOOLEAN;
447  
448  	 CURSOR cur_targets
449  	 IS
450  	   SELECT usim_id_spc_target
451  		, usim_planck_aeon
452  		, usim_planck_time
453  	     FROM usim_spc_process
454  	    WHERE is_processed = 0
455  	    GROUP BY usim_id_spc_target
456  		   , usim_planck_aeon
457  		   , usim_planck_time
458  	 ;
459  	 CURSOR cur_old_targets( cp_planck_aeon IN usim_spc_process.usim_planck_aeon%TYPE
460  			       , cp_planck_time IN usim_spc_process.usim_planck_time%TYPE
461  			       )
462  	 IS
463  	   SELECT usim_id_spc_target
464  		, usim_planck_aeon
465  		, usim_planck_time
466  	     FROM usim_spc_process
467  	    WHERE is_processed	    = 0
468  	      AND usim_planck_aeon  = cp_planck_aeon
469  	      AND usim_planck_time  = cp_planck_time
470  	    GROUP BY usim_id_spc_target
471  		   , usim_planck_aeon
472  		   , usim_planck_time
473  	 ;
474  	 CURSOR cur_target_energies( cp_usim_id_spc_target IN usim_space.usim_id_spc%TYPE
475  				   , cp_planck_aeon	   IN usim_spc_process.usim_planck_aeon%TYPE
476  				   , cp_planck_time	   IN usim_spc_process.usim_planck_time%TYPE
477  				   )
478  	 IS
479  	   SELECT usim_id_spr
480  		, usim_energy_output
481  		, usim_id_spc_source
482  	     FROM usim_spc_process
483  	    WHERE is_processed	     = 0
484  	      AND usim_id_spc_target = cp_usim_id_spc_target
485  	      AND usim_planck_aeon   = cp_planck_aeon
486  	      AND usim_planck_time   = cp_planck_time
487  	 ;
488    BEGIN
489  	 l_result := usim_dbif.has_unprocessed;
490  	 IF l_result = 0
491  	 THEN
492  	   usim_erl.log_error('usim_process.process_queue', 'ERROR No targets found. Exit process.');
493  	   usim_dbif.set_crashed;
494  	   RETURN 0;
495  	 END IF;
496  	 l_result := usim_dbif.is_queue_valid;
497  	 IF l_result != 1
498  	 THEN
499  	   usim_erl.log_error('usim_process.process_queue', 'Current process queue is not valid. State [' || l_result || '].');
500  	   RETURN 0;
501  	 END IF;
502  	 -- get aeon and time
503  	 l_result := usim_dbif.get_unprocessed_planck(l_cur_aeon, l_cur_time);
504  	 IF l_result != 1
505  	 THEN
506  	   usim_erl.log_error('usim_process.process_queue', 'Could not fetch current planck aeon and time. State [' || l_result || '].');
507  	   RETURN 0;
508  	 END IF;
509  	 -- update current targets within current planck time tick
510  	 l_executed := FALSE;
511  	 FOR recmain IN cur_targets
512  	 LOOP
513  	   l_executed := TRUE;
514  	   -- check target, if the universe seed state is invalid, do not process it
515  	   IF usim_dbif.is_seed_active = 1
516  	   THEN
517  	     l_usim_id_nod := usim_dbif.get_id_nod(recmain.usim_id_spc_target);
518  	     IF l_usim_id_nod IS NULL
519  	     THEN
520  	       usim_erl.log_error('usim_process.process_queue', 'Could not get node for target id [' || recmain.usim_id_spc_target || '].');
521  	       usim_dbif.set_crashed;
522  	       RETURN 0;
523  	     END IF;
524  	     IF l_result = 0
525  	     THEN
526  	       ROLLBACK;
527  	       usim_erl.log_error('usim_process.process_queue', 'usim_process.check_border failed. Could not flip direction of space id [' || recmain.usim_id_spc_target || '].');
528  	       usim_dbif.set_crashed;
529  	       RETURN 0;
530  	     END IF;
531  	     l_energy := NVL(usim_nod.get_energy(l_usim_id_nod), 0);
532  	     -- sum up energy for every position to be able to identify the process causing overflow
533  	     l_exec_inner := FALSE;
534  	     FOR rec IN cur_target_energies(recmain.usim_id_spc_target, recmain.usim_planck_aeon, recmain.usim_planck_time)
535  	     LOOP
536  	       l_exec_inner := TRUE;
537  	       IF usim_dbif.is_overflow_energy_add(rec.usim_energy_output, l_energy) = 1
538  	       THEN
539  		 -- overflow energy
540  		 usim_debug.debug_log('usim_process.process_queue', 'Overflow for target space id [' || recmain.usim_id_spc_target || '] with energy [' || rec.usim_energy_output || '] and current target energy [' || l_energy || ']. Set energy to 0.');
541  		 -- handle overflow and create a new universe
542  		 l_result := usim_creator.handle_overflow(recmain.usim_id_spc_target, FALSE);
543  		 IF l_result = 0
544  		 THEN
545  		   ROLLBACK;
546  		   usim_erl.log_error('usim_process.process_queue', 'usim_creator.handle_overflow failed for space id [' || recmain.usim_id_spc_target || '] usim_dbif.is_overflow_energy_add.');
547  		   usim_dbif.set_crashed;
548  		   RETURN 0;
549  		 END IF;
550  		 -- set energy to zero and do not add any more energy
551  		 l_energy := 0;
552  		 EXIT;
553  	       ELSE
554  		 l_energy := l_energy + NVL(rec.usim_energy_output, 0);
555  	       END IF;
556  	     END LOOP;
557  	     IF NOT l_exec_inner
558  	     THEN
559  	       usim_erl.log_error('usim_process.process_queue', 'Cursor cur_target_energies has no data paramenters [' || recmain.usim_id_spc_target || '], [' || recmain.usim_planck_aeon || '], [' || recmain.usim_planck_time || '].');
560  	       usim_dbif.set_crashed;
561  	       RETURN 0;
562  	     END IF;
563  	     -- update energies on target
564  	     l_energy_set := usim_nod.update_energy(l_energy, l_usim_id_nod, FALSE);
565  	     IF l_energy_set != l_energy
566  	     THEN
567  	       usim_erl.log_error('usim_process.process_queue', 'Database storage issue for target id [' || recmain.usim_id_spc_target || '] and node id [' || l_usim_id_nod || '] as stored energy [' || l_energy_set || '] does not match energy set [' || l_energy || '].');
568  	       usim_dbif.set_crashed;
569  	       RETURN 0;
570  	     END IF;
571  	   ELSE
572  	     usim_erl.log_error('usim_process.process_queue', 'No processing of targets as universe seed is not active any longer.');
573  	     RETURN 0;
574  	   END IF;
575  	 END LOOP;
576  	 IF NOT l_executed
577  	 THEN
578  	   usim_erl.log_error('usim_process.process_queue', 'Cursor cur_targets has no data.');
579  	   usim_dbif.set_crashed;
580  	   RETURN 0;
581  	 END IF;
582  	 -- done all
583  	 -- change planck tick, next processing step
584  	 l_planck_tick := usim_dbif.get_planck_time_next;
585  	 -- get current aeon after update
586  	 l_planck_aeon := usim_dbif.get_planck_aeon_seq_current;
587  	 -- create new processes and update old processes
588  	 l_executed := FALSE;
589  	 FOR recmain IN cur_old_targets(l_cur_aeon, l_cur_time)
590  	 LOOP
591  	   l_executed := TRUE;
592  	   -- create new process with childs of target
593  	   l_result := usim_process.process_node(recmain.usim_id_spc_target, FALSE);
594  	   IF l_result = 0
595  	   THEN
596  	     usim_erl.log_error('usim_process.process_queue', 'Unable to process next nodes for target id [' || recmain.usim_id_spc_target || '].');
597  	     usim_dbif.set_crashed;
598  	     RETURN 0;
599  	   END IF;
600  	   -- now update old processes
601  	   l_exec_inner := FALSE;
602  	   FOR rec IN cur_target_energies(recmain.usim_id_spc_target, recmain.usim_planck_aeon, recmain.usim_planck_time)
603  	   LOOP
604  	     l_exec_inner := TRUE;
605  	     IF usim_dbif.is_universe_active(recmain.usim_id_spc_target) = 1
606  	     THEN
607  	       l_result := usim_dbif.set_processed(rec.usim_id_spr, 1, FALSE);
608  	     ELSE
609  	       -- if universe is invalid, sets process code 2
610  	       l_result := usim_dbif.set_processed(rec.usim_id_spr, 2, FALSE);
611  	     END IF;
612  	     IF l_result = 0
613  	     THEN
614  	       usim_erl.log_error('usim_process.process_queue', 'Unable to set processed for process id [' || rec.usim_id_spr || '].');
615  	       usim_dbif.set_crashed;
616  	       RETURN 0;
617  	     END IF;
618  	     -- flip direction for processed
619  	     l_result := usim_dbif.flip_process_spin(rec.usim_id_spc_source, FALSE);
620  	     IF l_result = 0
621  	     THEN
622  	       ROLLBACK;
623  	       usim_erl.log_error('usim_process.process_queue', 'Could not flip direction of space id [' || rec.usim_id_spc_source || '].');
624  	       usim_dbif.set_crashed;
625  	       RETURN 0;
626  	     END IF;
627  	   END LOOP;
628  	   IF NOT l_exec_inner
629  	   THEN
630  	     usim_erl.log_error('usim_process.process_queue', 'Cursor cur_target_energies in old targets has no data paramenters [' || recmain.usim_id_spc_target || '], [' || recmain.usim_planck_aeon || '], [' || recmain.usim_planck_time || '].');
631  	     usim_dbif.set_crashed;
632  	     RETURN 0;
633  	   END IF;
634  	   -- handle border
635  	   l_result := usim_dbif.check_border(recmain.usim_id_spc_target, FALSE);
636  	   IF l_result != 1
637  	   THEN
638  	     usim_erl.log_error('usim_process.process_queue', 'Check border failed with parameter [' || recmain.usim_id_spc_target || '].');
639  	     usim_dbif.set_crashed;
640  	     RETURN 0;
641  	   END IF;
642  	 END LOOP;
643  	 IF NOT l_executed
644  	 THEN
645  	   usim_erl.log_error('usim_process.process_queue', 'Cursor cur_old_targets has no data for parameters [' || l_cur_aeon || '], [' || l_cur_time || '].');
646  	   usim_dbif.set_crashed;
647  	   RETURN 0;
648  	 END IF;
649  	 -- everything gone well, commit if defined
650  	 IF p_do_commit
651  	 THEN
652  	   COMMIT;
653  	 END IF;
654  	 RETURN 1;
655    EXCEPTION
656  	 WHEN OTHERS THEN
657  	   ROLLBACK;
658  	   -- write error might still work
659  	   usim_erl.log_error('usim_process.process_queue', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
660  	   -- try to set all to crashed
661  	   usim_dbif.set_crashed;
662  	   -- raise in any case
663  	   RAISE;
664    END process_queue
665    ;
666  
667    FUNCTION update_universe_states(p_do_commit IN BOOLEAN DEFAULT TRUE)
668  	 RETURN NUMBER
669    IS
670  	 l_return NUMBER;
671  
672  	 CURSOR cur_universes
673  	 IS
674  	   SELECT usim_id_mlv
675  	     FROM usim_multiverse
676  	 ;
677    BEGIN
678  	 FOR rec IN cur_universes
679  	 LOOP
680  	   l_return := usim_dbif.set_universe_state(rec.usim_id_mlv, FALSE);
681  	   IF l_return IS NULL
682  	   THEN
683  	     ROLLBACK;
684  	     usim_erl.log_error('usim_process.update_universe_states', 'Universe setting state error.');
685  	     usim_dbif.set_crashed;
686  	     RETURN 0;
687  	   END IF;
688  	 END LOOP;
689  	 IF p_do_commit
690  	 THEN
691  	   COMMIT;
692  	 END IF;
693  	 RETURN 1;
694    EXCEPTION
695  	 WHEN OTHERS THEN
696  	   ROLLBACK;
697  	   -- write error might still work
698  	   usim_erl.log_error('usim_process.update_universe_states', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
699  	   -- try to set all to crashed
700  	   usim_dbif.set_crashed;
701  	   -- raise in any case
702  	   RAISE;
703    END update_universe_states
704    ;
705  
706    FUNCTION run_samples( p_run_count IN NUMBER
707  			   , p_do_commit IN BOOLEAN DEFAULT TRUE
708  			   )
709  	 RETURN NUMBER
710    IS
711  	 l_return NUMBER;
712    BEGIN
713  	 FOR l_idx IN 1..p_run_count
714  	 LOOP
715  	   -- check system with every loop
716  	   IF usim_dbif.is_seed_active != 1
717  	   THEN
718  	     ROLLBACK;
719  	     usim_erl.log_error('usim_process.run_samples', 'Universe seed is not active. Run index: [' || l_idx || '].');
720  	     usim_dbif.set_crashed;
721  	     RETURN 0;
722  	   END IF;
723  	   IF usim_dbif.is_queue_valid != 1
724  	   THEN
725  	     ROLLBACK;
726  	     usim_erl.log_error('usim_process.run_samples', 'Process queue is not valid [' || usim_dbif.is_queue_valid || ']. Run index: [' || l_idx || '].');
727  	     usim_dbif.set_crashed;
728  	     RETURN 0;
729  	   END IF;
730  	   -- now process
731  	   l_return := usim_process.process_queue(p_do_commit);
732  	   IF l_return = 0
733  	   THEN
734  	     ROLLBACK;
735  	     usim_erl.log_error('usim_process.run_samples', 'Error running process_queue. Run index: [' || l_idx || '].');
736  	     usim_dbif.set_crashed;
737  	     RETURN 0;
738  	   END IF;
739  	   l_return := usim_process.update_universe_states(p_do_commit);
740  	   IF l_return = 0
741  	   THEN
742  	     ROLLBACK;
743  	     usim_erl.log_error('usim_process.run_samples', 'Error running update_universe_states. Run index: [' || l_idx || '].');
744  	     usim_dbif.set_crashed;
745  	     RETURN 0;
746  	   END IF;
747  	   -- commit every successful process
748  	   IF p_do_commit
749  	   THEN
750  	     COMMIT;
751  	   END IF;
752  	 END LOOP;
753  	 RETURN 1;
754    EXCEPTION
755  	 WHEN OTHERS THEN
756  	   ROLLBACK;
757  	   -- write error might still work
758  	   usim_erl.log_error('usim_process.run_samples', 'Unexpected error SQLCODE [' || SQLCODE || '] message [' || SQLERRM || '].');
759  	   -- try to set all to crashed
760  	   usim_dbif.set_crashed;
761  	   -- raise in any case
762  	   RAISE;
763    END run_samples
764    ;
765  
766  END usim_process;
767  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_process
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_process

Package body created.

SQL> --== processing packages end ==--
SQL> --== APEX package start ==--
SQL> @@../PACKAGES/USIM_APEX.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_apex
  2  IS
  3    /**This package is used as an interface to the APEX application
  4    * providing specialized functions and procedures for use in APEX.
  5    */
  6  
  7    --== package variable definition ==--
  8    -- default schema fixed, change if needed
  9    PROD_SCHEMA CONSTANT CHAR(4) := 'USIM';
 10    -- test schema fixed, change if needed
 11    TEST_SCHEMA CONSTANT CHAR(9) := 'USIM_TEST';
 12  
 13    /**
 14    * Provides a possibility to init base data with APEX as AJAX is not able to manage
 15    * big numbers. Therefore using strings for parameters and check internally for numbers.
 16    * Will report errors and exceptions to USIM_ERROR_LOG on errors of parameters. Provides also the
 17    * ability to initialize dimensions and numbers together with base data creation. Will not raise
 18    * any exception.
 19    * @param p_max_dimension The maximum dimensions possible for this multiverse.
 20    * @param p_max_abs_number The absolute maximum number available for this multiverse.
 21    * @param p_special_overflow Defines the overflow behaviour, default '0' means standard overflow behaviour. If set to '1', all new nodes are created with the universe seed at coordinate 0 as the parent.
 22    * @param p_init_dimensions If set to '1' will initialize the dimensions as defined by base data. Any other value disables this feature.
 23    * @param p_init_positions If set to '1' will initialize the possible space positions as defined by base data max number. Any other value disables this feature.
 24    */
 25    PROCEDURE run_init_basedata( p_max_dimension    VARCHAR2 DEFAULT '42'
 26  				  , p_max_abs_number   VARCHAR2 DEFAULT '99999999999999999999999999999999999999'
 27  				  , p_special_overflow VARCHAR2 DEFAULT '0'
 28  				  , p_init_dimensions  VARCHAR2 DEFAULT '1'
 29  				  , p_init_positions	 VARCHAR2 DEFAULT '1'
 30  				  )
 31    ;
 32  
 33    /**
 34    * Returns the state of base data as text. The parameters can be used
 35    * by translations to set language dependend return strings. Error messages
 36    * will nevertheless be in the language of the system.
 37    * @param p_yes_option The return value for base data exists. Defaults to Yes.
 38    * @param p_no_option The return value for base data do not exists. Defaults to No.
 39    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
 40    * @return The text message related to the state of base data or error information.
 41    */
 42    FUNCTION disp_has_basedata( p_yes_option    IN VARCHAR2 DEFAULT 'Yes'
 43  				 , p_no_option	   IN VARCHAR2 DEFAULT 'No'
 44  				 , p_error_option  IN VARCHAR2 DEFAULT 'ERROR'
 45  				 )
 46  	 RETURN VARCHAR2
 47    ;
 48  
 49    /**
 50    * Returns the text information about existing base universe. The parameters can be used
 51    * by translations to set language dependend return strings. Error messages
 52    * will nevertheless be in the language of the system.
 53    * @param p_yes_option The return value for base data exists. Defaults to Yes.
 54    * @param p_no_option The return value for base data do not exists. Defaults to No.
 55    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
 56    * @return The text message related to the state of a base universe or error information.
 57    */
 58    FUNCTION disp_has_base_universe( p_yes_option	IN VARCHAR2 DEFAULT 'Yes'
 59  				      , p_no_option	IN VARCHAR2 DEFAULT 'No'
 60  				      , p_error_option	IN VARCHAR2 DEFAULT 'ERROR'
 61  				      )
 62  	 RETURN VARCHAR2
 63    ;
 64  
 65    /**
 66    * Returns the text information about maximum dimensions. The parameters can be used
 67    * by translations to set language dependend return strings. Error messages
 68    * will nevertheless be in the language of the system.
 69    * @param p_none_option The display text if no dimensions exist. Defaults to N/A.
 70    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
 71    * @return The text message displaying maximum dimensions or error information.
 72    */
 73    FUNCTION disp_max_dimension( p_none_option  IN VARCHAR2 DEFAULT 'N/A'
 74  				  , p_error_option IN VARCHAR2 DEFAULT 'ERROR'
 75  				  )
 76  	 RETURN VARCHAR2
 77    ;
 78  
 79    /**
 80    * Returns the text information about maximum numbers. The parameters can be used
 81    * by translations to set language dependend return strings. Error messages
 82    * will nevertheless be in the language of the system.
 83    * @param p_none_option The display text if no numbers exist. Defaults to N/A.
 84    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
 85    * @return The text message displaying maximum numbers or error information.
 86    */
 87    FUNCTION disp_max_numbers( p_none_option  IN VARCHAR2 DEFAULT 'N/A'
 88  				, p_error_option IN VARCHAR2 DEFAULT 'ERROR'
 89  				)
 90  	 RETURN VARCHAR2
 91    ;
 92  
 93    /**
 94    * Returns the text information about maximum absolute number. The parameters can be used
 95    * by translations to set language dependend return strings. Error messages
 96    * will nevertheless be in the language of the system.
 97    * @param p_none_option The display text if no absolute maximum number exist. Defaults to N/A.
 98    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
 99    * @return The text message displaying the maximum absolute number or error information.
100    */
101    FUNCTION disp_max_abs_number( p_none_option  IN VARCHAR2 DEFAULT 'N/A'
102  				   , p_error_option IN VARCHAR2 DEFAULT 'ERROR'
103  				   )
104  	 RETURN VARCHAR2
105    ;
106  
107    /**
108    * Returns the text information about last processed date. The parameters can be used
109    * by translations to set language dependend return strings. Error messages
110    * will nevertheless be in the language of the system.
111    * @param p_none_option The display text if no processed records exist. Defaults to N/A.
112    * @param p_format_option The date format to use. Defaults to DD.MM.YYYY HH24:MI:SS.
113    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
114    * @return The text message displaying last processed date or error information.
115    */
116    FUNCTION disp_last_processed( p_none_option   IN VARCHAR2 DEFAULT 'N/A'
117  				   , p_format_option IN VARCHAR2 DEFAULT 'DD.MM.YYYY HH24:MI:SS'
118  				   , p_error_option  IN VARCHAR2 DEFAULT 'ERROR'
119  				   )
120  	 RETURN VARCHAR2
121    ;
122  
123    /**
124    * Returns the text information about time past since last processed date. The parameters can be used
125    * by translations to set language dependend return strings. Error messages
126    * will nevertheless be in the language of the system. Format is always Oracle system standard for
127    * timestamps subtracted.
128    * @param p_none_option The display text if no processed records exist. Defaults to N/A.
129    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
130    * @return The text message displaying last processed date or error information.
131    */
132    FUNCTION disp_since_last_processed( p_none_option   IN VARCHAR2 DEFAULT 'N/A'
133  					 , p_error_option  IN VARCHAR2 DEFAULT 'ERROR'
134  					 )
135  	 RETURN VARCHAR2
136    ;
137  
138    /**
139    * Returns the text information about amount of processed data. The parameters can be used
140    * by translations to set language dependend return strings. Error messages
141    * will nevertheless be in the language of the system.
142    * @param p_total_option The display text for total of processed. Defaults to "of total".
143    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
144    * @return The text message displaying the amount of processed data inclusive total or error information.
145    */
146    FUNCTION disp_processed( p_total_option IN VARCHAR2 DEFAULT 'total'
147  			      , p_error_option IN VARCHAR2 DEFAULT 'ERROR'
148  			      )
149  	 RETURN VARCHAR2
150    ;
151  
152    /**
153    * Returns the text information about amount of unprocessed data. The parameters can be used
154    * by translations to set language dependend return strings. Error messages
155    * will nevertheless be in the language of the system.
156    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
157    * @return The text message displaying the amount of unprocessed data or error information.
158    */
159    FUNCTION disp_unprocessed(p_error_option IN VARCHAR2 DEFAULT 'ERROR')
160  	 RETURN VARCHAR2
161    ;
162  
163    /**
164    * Returns the text information about amount of existing nodes across universes. The parameters can be used
165    * by translations to set language dependend return strings. Error messages
166    * will nevertheless be in the language of the system.
167    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
168    * @return The text message displaying the amount of existing nodes or error information.
169    */
170    FUNCTION disp_total_nodes(p_error_option IN VARCHAR2 DEFAULT 'ERROR')
171  	 RETURN VARCHAR2
172    ;
173  
174    /**
175    * Returns the text information about amount of existing universes. The parameters can be used
176    * by translations to set language dependend return strings. Error messages
177    * will nevertheless be in the language of the system.
178    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
179    * @return The text message displaying the amount of existing universes or error information.
180    */
181    FUNCTION disp_total_universes(p_error_option IN VARCHAR2 DEFAULT 'ERROR')
182  	 RETURN VARCHAR2
183    ;
184  
185    /**
186    * Returns the text information about amount of active dimensions. The parameters can be used
187    * by translations to set language dependend return strings. Error messages
188    * will nevertheless be in the language of the system.
189    * @param p_none_option The display text if no active dimensions exist. Defaults to N/A.
190    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
191    * @return The text message displaying the amount of active dimensions or error information.
192    */
193    FUNCTION disp_active_dimensions( p_none_option  IN VARCHAR2 DEFAULT 'N/A'
194  				      , p_error_option IN VARCHAR2 DEFAULT 'ERROR'
195  				      )
196  	 RETURN VARCHAR2
197    ;
198  
199    /**
200    * Returns the text information about the minimum and maximum of energy known. The parameters can be used
201    * by translations to set language dependend return strings. Error messages
202    * will nevertheless be in the language of the system.
203    * @param p_none_option The display text if no active dimensions exist. Defaults to N/A.
204    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
205    * @return The text message displaying the minimum and maximum energy or error information.
206    */
207    FUNCTION disp_minmax_energy( p_none_option  IN VARCHAR2 DEFAULT 'N/A'
208  				  , p_error_option IN VARCHAR2 DEFAULT 'ERROR'
209  				  )
210  	 RETURN VARCHAR2
211    ;
212  
213    /**
214    * Returns the text information about the minimum and maximum of coordinates known. The parameters can be used
215    * by translations to set language dependend return strings. Error messages
216    * will nevertheless be in the language of the system.
217    * @param p_none_option The display text if no active dimensions exist. Defaults to N/A.
218    * @param p_error_option The prefix value for errors in the called functions. Defaults to ERROR.
219    * @return The text message displaying the minimum and maximum coordinates or error information.
220    */
221    FUNCTION disp_minmax_coords( p_none_option  IN VARCHAR2 DEFAULT 'N/A'
222  				  , p_error_option IN VARCHAR2 DEFAULT 'ERROR'
223  				  )
224  	 RETURN VARCHAR2
225    ;
226  
227  END usim_apex;
228  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_apex
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_apex

Package created.

SQL> @@../PACKAGES/USIM_APEX.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_apex
  2  IS
  3    -- see header for documentation
  4    PROCEDURE run_init_basedata( p_max_dimension    VARCHAR2 DEFAULT '42'
  5  				  , p_max_abs_number   VARCHAR2 DEFAULT '99999999999999999999999999999999999999'
  6  				  , p_special_overflow VARCHAR2 DEFAULT '0'
  7  				  , p_init_dimensions  VARCHAR2 DEFAULT '1'
  8  				  , p_init_positions	 VARCHAR2 DEFAULT '1'
  9  				  )
 10    IS
 11  	 l_max_dimension     NUMBER;
 12  	 l_max_abs_number    NUMBER;
 13  	 l_special_overflow  NUMBER;
 14  	 l_result	     NUMBER;
 15  	 l_result_dim	     NUMBER;
 16  	 l_result_pos	     NUMBER;
 17  	 l_par_check	     NUMBER;
 18  	 l_par_error_msg     VARCHAR2(2000);
 19    BEGIN
 20  	 -- try transform parameters, may raise exception
 21  	 l_max_dimension     := NVL(TO_NUMBER(p_max_dimension), 42);
 22  	 l_max_abs_number    := NVL(TO_NUMBER(p_max_abs_number), 99999999999999999999999999999999999999);
 23  	 l_special_overflow  := NVL(TO_NUMBER(p_special_overflow), 0);
 24  	 -- check parameters, usim_base called by usim_dbif will use defaults on wrong parameters
 25  	 l_par_check	 := 1; -- assume okay
 26  	 l_par_error_msg := NULL;
 27  	 IF    TRUNC(l_max_dimension) != l_max_dimension -- no integer
 28  	    OR l_max_dimension < 0			 -- lower boundary missed
 29  	    OR l_max_dimension > 99			 -- upper boundary missed
 30  	 THEN
 31  	   l_par_check	   := 0;
 32  	   l_par_error_msg := 'ERROR p_max_dimension value not valid: ' || p_max_dimension;
 33  	 END IF;
 34  	 IF    TRUNC(l_max_abs_number) != l_max_abs_number		 -- no integer
 35  	    OR l_max_abs_number < 0					 -- lower boundary missed
 36  	    OR l_max_abs_number > 99999999999999999999999999999999999999 -- upper boundary missed
 37  	 THEN
 38  	   l_par_check	   := 0;
 39  	   IF l_par_error_msg IS NULL
 40  	   THEN
 41  	     l_par_error_msg := 'ERROR p_max_abs_number value not valid: ' || p_max_abs_number;
 42  	   ELSE
 43  	     l_par_error_msg := l_par_error_msg || ' / ERROR p_max_abs_number value not valid: ' || p_max_abs_number;
 44  	   END IF;
 45  	 END IF;
 46  	 IF l_special_overflow NOT IN (0, 1)
 47  	 THEN
 48  	   l_par_check	   := 0;
 49  	   IF l_par_error_msg IS NULL
 50  	   THEN
 51  	     l_par_error_msg := 'ERROR l_special_overflow value not valid: ' || p_special_overflow;
 52  	   ELSE
 53  	     l_par_error_msg := l_par_error_msg || ' / ERROR l_special_overflow value not valid: ' || p_special_overflow;
 54  	   END IF;
 55  	 END IF;
 56  	 IF l_par_check = 1
 57  	 THEN
 58  	   l_result := usim_dbif.init_basedata(l_max_dimension, l_max_abs_number, l_special_overflow);
 59  	   IF l_result = 1
 60  	   THEN
 61  	     -- check if we should init dimensions
 62  	     IF p_init_dimensions = '1'
 63  	     THEN
 64  	       l_result_dim := usim_dbif.init_dimensions;
 65  	       IF l_result_dim = 0
 66  	       THEN
 67  		 -- error init dimensions failed
 68  		 usim_erl.log_error('usim_apex.run_init_basedata', 'ERROR: usim_dbif.init_dimensions failed see error log.');
 69  	       END IF;
 70  	     END IF;
 71  	     -- check if we should init numbers
 72  	     IF p_init_positions = '1'
 73  	     THEN
 74  	       l_result_pos := usim_dbif.init_positions;
 75  	       IF l_result_pos = 0
 76  	       THEN
 77  		 -- error init positions failed
 78  		 usim_erl.log_error('usim_apex.run_init_basedata', 'ERROR: usim_dbif.init_positions failed see error log.');
 79  	       END IF;
 80  	     END IF;
 81  	   ELSE
 82  	     -- error init failed
 83  	     usim_erl.log_error('usim_apex.run_init_basedata', 'ERROR: usim_dbif.init_basedata failed see error log.');
 84  	   END IF;
 85  	 ELSE
 86  	     -- parameter error
 87  	     usim_erl.log_error('usim_apex.run_init_basedata', l_par_error_msg);
 88  	 END IF;
 89    EXCEPTION
 90  	 WHEN OTHERS THEN
 91  	   usim_erl.log_error('usim_apex.run_init_basedata', 'ERROR: unexpected application error ' || SQLERRM);
 92    END run_init_basedata
 93    ;
 94  
 95    FUNCTION disp_has_basedata( p_yes_option    IN VARCHAR2 DEFAULT 'Yes'
 96  				 , p_no_option	   IN VARCHAR2 DEFAULT 'No'
 97  				 , p_error_option  IN VARCHAR2 DEFAULT 'ERROR'
 98  				 )
 99  	 RETURN VARCHAR2
100    IS
101  	 l_return  VARCHAR2(4000);
102  	 l_hasdata NUMBER;
103    BEGIN
104  	 l_hasdata := usim_dbif.has_basedata;
105  	 IF l_hasdata = 1
106  	 THEN
107  	   l_return := NVL(p_yes_option, 'Yes');
108  	 ELSIF l_hasdata = 0
109  	 THEN
110  	   l_return := NVL(p_no_option, 'No');
111  	 ELSE
112  	   usim_erl.log_error('usim_apex.disp_has_basedata', 'ERROR: Invalid return value from usim_dbif.has_basedata: ' || l_hasdata);
113  	   l_return := NVL(p_error_option, 'ERROR') || ': invalid return value: ' || CASE WHEN l_hasdata IS NULL THEN 'NULL' ELSE TO_CHAR(l_hasdata) END;
114  	 END IF;
115  	 RETURN l_return;
116    EXCEPTION
117  	 WHEN OTHERS THEN
118  	   usim_erl.log_error('usim_apex.disp_has_basedata', 'ERROR: unexpected application error ' || SQLERRM);
119  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
120  	   RETURN l_return;
121    END disp_has_basedata
122    ;
123  
124    FUNCTION disp_has_base_universe( p_yes_option	IN VARCHAR2 DEFAULT 'Yes'
125  				      , p_no_option	IN VARCHAR2 DEFAULT 'No'
126  				      , p_error_option	IN VARCHAR2 DEFAULT 'ERROR'
127  				      )
128  	 RETURN VARCHAR2
129    IS
130  	 l_return  VARCHAR2(4000);
131  	 l_hasdata NUMBER;
132    BEGIN
133  	 l_hasdata := usim_mlv.has_base;
134  	 IF l_hasdata = 1
135  	 THEN
136  	   l_return := NVL(p_yes_option, 'Yes');
137  	 ELSIF l_hasdata = 0
138  	 THEN
139  	   l_return := NVL(p_no_option, 'No');
140  	 ELSE
141  	   usim_erl.log_error('usim_apex.disp_has_base_universe', 'ERROR: Invalid return value from usim_mlv.has_base: ' || l_hasdata);
142  	   l_return := NVL(p_error_option, 'ERROR') || ': invalid return value: ' || CASE WHEN l_hasdata IS NULL THEN 'NULL' ELSE TO_CHAR(l_hasdata) END;
143  	 END IF;
144  	 RETURN l_return;
145    EXCEPTION
146  	 WHEN OTHERS THEN
147  	   usim_erl.log_error('usim_apex.disp_has_base_universe', 'ERROR: unexpected application error ' || SQLERRM);
148  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
149  	   RETURN l_return;
150    END disp_has_base_universe
151    ;
152  
153    FUNCTION disp_max_dimension( p_none_option  IN VARCHAR2 DEFAULT 'N/A'
154  				  , p_error_option IN VARCHAR2 DEFAULT 'ERROR'
155  				  )
156  	 RETURN VARCHAR2
157    IS
158  	 l_return  VARCHAR2(4000);
159  	 l_hasdata NUMBER;
160    BEGIN
161  	 l_hasdata := usim_dbif.has_basedata;
162  	 IF l_hasdata = 1
163  	 THEN
164  	   l_return := TO_CHAR(usim_base.get_max_dimension);
165  	 ELSIF l_hasdata = 0
166  	 THEN
167  	   l_return := NVL(p_none_option, 'N/A');
168  	 ELSE
169  	   usim_erl.log_error('usim_apex.disp_max_dimension', 'ERROR: Invalid return value from usim_dbif.has_basedata: ' || l_hasdata);
170  	   l_return := NVL(p_error_option, 'ERROR') || ': invalid return value: ' || CASE WHEN l_hasdata IS NULL THEN 'NULL' ELSE TO_CHAR(l_hasdata) END;
171  	 END IF;
172  	 RETURN l_return;
173    EXCEPTION
174  	 WHEN OTHERS THEN
175  	   usim_erl.log_error('usim_apex.disp_max_dimension', 'ERROR: unexpected application error ' || SQLERRM);
176  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
177  	   RETURN l_return;
178    END disp_max_dimension
179    ;
180  
181    FUNCTION disp_max_numbers( p_none_option  IN VARCHAR2 DEFAULT 'N/A'
182  				, p_error_option IN VARCHAR2 DEFAULT 'ERROR'
183  				)
184  	 RETURN VARCHAR2
185    IS
186  	 l_return  VARCHAR2(4000);
187  	 l_hasdata NUMBER;
188    BEGIN
189  	 l_hasdata := usim_dbif.has_basedata;
190  	 IF l_hasdata = 1
191  	 THEN
192  	   l_return := '+' || TRIM(TO_CHAR(usim_base.get_abs_max_number)) ||
193  		       CHR(10) ||
194  		       TRIM(TO_CHAR(usim_base.get_abs_max_number * -1))
195  	   ;
196  	 ELSIF l_hasdata = 0
197  	 THEN
198  	   l_return := NVL(p_none_option, 'N/A');
199  	 ELSE
200  	   usim_erl.log_error('usim_apex.disp_max_numbers', 'ERROR: Invalid return value from usim_dbif.has_basedata: ' || l_hasdata);
201  	   l_return := NVL(p_error_option, 'ERROR') || ': invalid return value: ' || CASE WHEN l_hasdata IS NULL THEN 'NULL' ELSE TO_CHAR(l_hasdata) END;
202  	 END IF;
203  	 RETURN l_return;
204    EXCEPTION
205  	 WHEN OTHERS THEN
206  	   usim_erl.log_error('usim_apex.disp_max_numbers', 'ERROR: unexpected application error ' || SQLERRM);
207  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
208  	   RETURN l_return;
209    END disp_max_numbers
210    ;
211  
212    FUNCTION disp_max_abs_number( p_none_option  IN VARCHAR2 DEFAULT 'N/A'
213  				   , p_error_option IN VARCHAR2 DEFAULT 'ERROR'
214  				   )
215  	 RETURN VARCHAR2
216    IS
217  	 l_return  VARCHAR2(4000);
218  	 l_hasdata NUMBER;
219    BEGIN
220  	 l_hasdata := usim_dbif.has_basedata;
221  	 IF l_hasdata = 1
222  	 THEN
223  	   l_return := TRIM(TO_CHAR(usim_base.get_abs_max_number));
224  	 ELSIF l_hasdata = 0
225  	 THEN
226  	   l_return := NVL(p_none_option, 'N/A');
227  	 ELSE
228  	   usim_erl.log_error('usim_apex.disp_max_abs_number', 'ERROR: Invalid return value from usim_dbif.has_basedata: ' || l_hasdata);
229  	   l_return := NVL(p_error_option, 'ERROR') || ': invalid return value: ' || CASE WHEN l_hasdata IS NULL THEN 'NULL' ELSE TO_CHAR(l_hasdata) END;
230  	 END IF;
231  	 RETURN l_return;
232    EXCEPTION
233  	 WHEN OTHERS THEN
234  	   usim_erl.log_error('usim_apex.disp_max_abs_number', 'ERROR: unexpected application error ' || SQLERRM);
235  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
236  	   RETURN l_return;
237    END disp_max_abs_number
238    ;
239  
240    FUNCTION disp_last_processed( p_none_option   IN VARCHAR2 DEFAULT 'N/A'
241  				   , p_format_option IN VARCHAR2 DEFAULT 'DD.MM.YYYY HH24:MI:SS'
242  				   , p_error_option  IN VARCHAR2 DEFAULT 'ERROR'
243  				   )
244  	 RETURN VARCHAR2
245    IS
246  	 l_return  VARCHAR2(4000);
247  	 l_hasdata NUMBER;
248  	 l_date    DATE;
249  	 l_planck  NUMBER;
250  	 l_format  VARCHAR2(100);
251    BEGIN
252  	 l_format  := NVL(p_format_option, 'DD.MM.YYYY HH24:MI:SS');
253  	 l_hasdata := usim_dbif.has_data_spr;
254  	 IF l_hasdata = 1
255  	 THEN
256  	     WITH procs AS
257  		  (SELECT TO_NUMBER(SUBSTR(spr.usim_id_spr, 1, 17)) AS id_date_part
258  			, TO_NUMBER(SUBSTR(spr.usim_id_spr, 18)) AS id_sequence
259  			, spr.*
260  		     FROM usim_spc_process spr
261  		  )
262  	   SELECT usim_real_time
263  		, usim_planck_time
264  	     INTO l_date
265  		, l_planck
266  	     FROM procs
267  	    ORDER BY id_date_part DESC
268  		   , id_sequence DESC
269  	    FETCH NEXT 1 ROWS ONLY
270  	   ;
271  	   l_return := TO_CHAR(l_date, l_format) || ' (planck tick: ' || l_planck || ')';
272  	 ELSIF l_hasdata = 0
273  	 THEN
274  	   l_return := NVL(p_none_option, 'N/A');
275  	 ELSE
276  	   usim_erl.log_error('usim_apex.disp_last_processed', 'ERROR: Invalid return value from usim_dbif.has_data_spr: ' || l_hasdata);
277  	   l_return := NVL(p_error_option, 'ERROR') || ': invalid return value: ' || CASE WHEN l_hasdata IS NULL THEN 'NULL' ELSE TO_CHAR(l_hasdata) END;
278  	 END IF;
279  	 RETURN l_return;
280    EXCEPTION
281  	 WHEN OTHERS THEN
282  	   usim_erl.log_error('usim_apex.disp_last_processed', 'ERROR: unexpected application error ' || SQLERRM);
283  	   l_return := NVL(p_error_option, 'ERROR') || ': format option: ' || p_format_option || ' unexpected application error ' || SQLERRM;
284  	   RETURN l_return;
285    END disp_last_processed
286    ;
287  
288    FUNCTION disp_since_last_processed( p_none_option   IN VARCHAR2 DEFAULT 'N/A'
289  					 , p_error_option  IN VARCHAR2 DEFAULT 'ERROR'
290  					 )
291  	 RETURN VARCHAR2
292    IS
293  	 l_return  VARCHAR2(4000);
294  	 l_hasdata NUMBER;
295    BEGIN
296  	 l_hasdata := usim_dbif.has_data_spr;
297  	 IF l_hasdata = 1
298  	 THEN
299  	     WITH procs AS
300  		  (SELECT TO_NUMBER(SUBSTR(spr.usim_id_spr, 1, 17)) AS id_date_part
301  			, TO_NUMBER(SUBSTR(spr.usim_id_spr, 18)) AS id_sequence
302  			, spr.*
303  		     FROM usim_spc_process spr
304  		  )
305  	   SELECT TO_CHAR(SYSTIMESTAMP - usim_real_time)
306  	     INTO l_return
307  	     FROM procs
308  	    ORDER BY id_date_part DESC
309  		   , id_sequence DESC
310  	    FETCH NEXT 1 ROWS ONLY
311  	   ;
312  	 ELSIF l_hasdata = 0
313  	 THEN
314  	   l_return := NVL(p_none_option, 'N/A');
315  	 ELSE
316  	   usim_erl.log_error('usim_apex.disp_since_last_processed', 'ERROR: Invalid return value from usim_dbif.has_data_spr: ' || l_hasdata);
317  	   l_return := NVL(p_error_option, 'ERROR') || ': invalid return value: ' || CASE WHEN l_hasdata IS NULL THEN 'NULL' ELSE TO_CHAR(l_hasdata) END;
318  	 END IF;
319  	 RETURN l_return;
320    EXCEPTION
321  	 WHEN OTHERS THEN
322  	   usim_erl.log_error('usim_apex.disp_since_last_processed', 'ERROR: unexpected application error ' || SQLERRM);
323  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
324  	   RETURN l_return;
325    END disp_since_last_processed
326    ;
327  
328    FUNCTION disp_processed( p_total_option IN VARCHAR2 DEFAULT 'total'
329  			      , p_error_option IN VARCHAR2 DEFAULT 'ERROR'
330  			      )
331  	 RETURN VARCHAR2
332    IS
333  	 l_return      VARCHAR2(4000);
334  	 l_hasdata     NUMBER;
335  	 l_total       NUMBER;
336  	 l_processed   NUMBER;
337    BEGIN
338  	 l_hasdata := usim_dbif.has_data_spr;
339  	 IF l_hasdata = 1
340  	 THEN
341  	   SELECT COUNT(*) AS total
342  		, COUNT(CASE WHEN is_processed = 1 THEN 1 END) AS processed
343  	     INTO l_total
344  		, l_processed
345  	     FROM usim_spc_process
346  	   ;
347  	   l_return := TO_CHAR(l_processed) || ' (' || NVL(p_total_option, 'total') || ': ' || TO_CHAR(l_total) || ')';
348  	 ELSIF l_hasdata = 0
349  	 THEN
350  	   l_return := '0 (' || NVL(p_total_option, 'total') || ': 0)';
351  	 ELSE
352  	   usim_erl.log_error('usim_apex.disp_processed', 'ERROR: Invalid return value from usim_dbif.has_data_spr: ' || l_hasdata);
353  	   l_return := NVL(p_error_option, 'ERROR') || ': invalid return value: ' || CASE WHEN l_hasdata IS NULL THEN 'NULL' ELSE TO_CHAR(l_hasdata) END;
354  	 END IF;
355  	 RETURN l_return;
356    EXCEPTION
357  	 WHEN OTHERS THEN
358  	   usim_erl.log_error('usim_apex.disp_processed', 'ERROR: unexpected application error ' || SQLERRM);
359  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
360  	   RETURN l_return;
361    END disp_processed
362    ;
363  
364    FUNCTION disp_unprocessed(p_error_option IN VARCHAR2 DEFAULT 'ERROR')
365  	 RETURN VARCHAR2
366    IS
367  	 l_return      VARCHAR2(4000);
368  	 l_hasdata     NUMBER;
369  	 l_unprocessed NUMBER;
370    BEGIN
371  	 l_hasdata := usim_dbif.has_data_spr;
372  	 IF l_hasdata = 1
373  	 THEN
374  	   SELECT COUNT(*)
375  	     INTO l_unprocessed
376  	     FROM usim_spc_process
377  	    WHERE is_processed != 1
378  	   ;
379  	   l_return := TO_CHAR(l_unprocessed);
380  	 ELSIF l_hasdata = 0
381  	 THEN
382  	   l_return := '0';
383  	 ELSE
384  	   usim_erl.log_error('usim_apex.disp_unprocessed', 'ERROR: Invalid return value from usim_dbif.has_data_spr: ' || l_hasdata);
385  	   l_return := NVL(p_error_option, 'ERROR') || ': invalid return value: ' || CASE WHEN l_hasdata IS NULL THEN 'NULL' ELSE TO_CHAR(l_hasdata) END;
386  	 END IF;
387  	 RETURN l_return;
388    EXCEPTION
389  	 WHEN OTHERS THEN
390  	   usim_erl.log_error('usim_apex.disp_unprocessed', 'ERROR: unexpected application error ' || SQLERRM);
391  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
392  	   RETURN l_return;
393    END disp_unprocessed
394    ;
395  
396    FUNCTION disp_total_nodes(p_error_option IN VARCHAR2 DEFAULT 'ERROR')
397  	 RETURN VARCHAR2
398    IS
399  	 l_return  VARCHAR2(4000);
400  	 l_nodes   NUMBER;
401    BEGIN
402  	 SELECT COUNT(*)
403  	   INTO l_nodes
404  	   FROM usim_node
405  	 ;
406  	 l_return := TO_CHAR(l_nodes);
407  	 RETURN l_return;
408    EXCEPTION
409  	 WHEN OTHERS THEN
410  	   usim_erl.log_error('usim_apex.disp_total_nodes', 'ERROR: unexpected application error ' || SQLERRM);
411  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
412  	   RETURN l_return;
413    END disp_total_nodes
414    ;
415  
416    FUNCTION disp_total_universes(p_error_option IN VARCHAR2 DEFAULT 'ERROR')
417  	 RETURN VARCHAR2
418    IS
419  	 l_return    VARCHAR2(4000);
420  	 l_universes NUMBER;
421    BEGIN
422  	 SELECT COUNT(*)
423  	   INTO l_universes
424  	   FROM usim_multiverse
425  	 ;
426  	 l_return := TO_CHAR(l_universes);
427  	 RETURN l_return;
428    EXCEPTION
429  	 WHEN OTHERS THEN
430  	   usim_erl.log_error('usim_apex.disp_total_universes', 'ERROR: unexpected application error ' || SQLERRM);
431  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
432  	   RETURN l_return;
433    END disp_total_universes
434    ;
435  
436    FUNCTION disp_active_dimensions( p_none_option  IN VARCHAR2 DEFAULT 'N/A'
437  				      , p_error_option IN VARCHAR2 DEFAULT 'ERROR'
438  				      )
439  	 RETURN VARCHAR2
440    IS
441  	 l_return      VARCHAR2(4000);
442  	 l_dimensions  NUMBER;
443  	 l_hasdata     NUMBER;
444    BEGIN
445  	 l_hasdata := usim_dbif.has_data_spc;
446  	 IF l_hasdata = 1
447  	 THEN
448  	   SELECT MAX(usim_n_dimension)
449  	     INTO l_dimensions
450  	     FROM usim_spc_v
451  	   ;
452  	   l_return := TO_CHAR(l_dimensions);
453  	 ELSIF l_hasdata = 0
454  	 THEN
455  	   l_return := NVL(p_none_option, 'N/A');
456  	 ELSE
457  	   usim_erl.log_error('usim_apex.disp_active_dimensions', 'ERROR: Invalid return value from usim_dbif.has_data_spc: ' || l_hasdata);
458  	   l_return := NVL(p_error_option, 'ERROR') || ': invalid return value: ' || CASE WHEN l_hasdata IS NULL THEN 'NULL' ELSE TO_CHAR(l_hasdata) END;
459  	 END IF;
460  
461  	 RETURN l_return;
462    EXCEPTION
463  	 WHEN OTHERS THEN
464  	   usim_erl.log_error('usim_apex.disp_active_dimensions', 'ERROR: unexpected application error ' || SQLERRM);
465  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
466  	   RETURN l_return;
467    END disp_active_dimensions
468    ;
469  
470    FUNCTION disp_minmax_energy( p_none_option  IN VARCHAR2 DEFAULT 'N/A'
471  				  , p_error_option IN VARCHAR2 DEFAULT 'ERROR'
472  				  )
473  	 RETURN VARCHAR2
474    IS
475  	 l_return      VARCHAR2(4000);
476  	 l_min_energy  NUMBER;
477  	 l_max_energy  NUMBER;
478  	 l_hasdata     NUMBER;
479    BEGIN
480  	 l_hasdata := usim_dbif.has_data_spc;
481  	 IF l_hasdata = 1
482  	 THEN
483  	   SELECT MAX(usim_energy)
484  		, MIN(usim_energy)
485  	     INTO l_max_energy
486  		, l_min_energy
487  	     FROM usim_spc_v
488  	   ;
489  	   l_return := '+' || TO_CHAR(l_max_energy) ||
490  		       CHR(10) ||
491  		       TO_CHAR(l_min_energy)
492  	   ;
493  	 ELSIF l_hasdata = 0
494  	 THEN
495  	   l_return := NVL(p_none_option, 'N/A');
496  	 ELSE
497  	   usim_erl.log_error('usim_apex.disp_minmax_energy', 'ERROR: Invalid return value from usim_dbif.has_data_spc: ' || l_hasdata);
498  	   l_return := NVL(p_error_option, 'ERROR') || ': invalid return value: ' || CASE WHEN l_hasdata IS NULL THEN 'NULL' ELSE TO_CHAR(l_hasdata) END;
499  	 END IF;
500  
501  	 RETURN l_return;
502    EXCEPTION
503  	 WHEN OTHERS THEN
504  	   usim_erl.log_error('usim_apex.disp_minmax_energy', 'ERROR: unexpected application error ' || SQLERRM);
505  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
506  	   RETURN l_return;
507    END disp_minmax_energy
508    ;
509  
510    FUNCTION disp_minmax_coords( p_none_option  IN VARCHAR2 DEFAULT 'N/A'
511  				  , p_error_option IN VARCHAR2 DEFAULT 'ERROR'
512  				  )
513  	 RETURN VARCHAR2
514    IS
515  	 l_return      VARCHAR2(4000);
516  	 l_min_coord   NUMBER;
517  	 l_max_coord   NUMBER;
518  	 l_hasdata     NUMBER;
519    BEGIN
520  	 l_hasdata := usim_dbif.has_data_spc;
521  	 IF l_hasdata = 1
522  	 THEN
523  	   SELECT MAX(usim_coordinate)
524  		, MIN(usim_coordinate)
525  	     INTO l_max_coord
526  		, l_min_coord
527  	     FROM usim_spc_v
528  	   ;
529  	   l_return := '+' || TO_CHAR(l_max_coord) ||
530  		       CHR(10) ||
531  		       TO_CHAR(l_min_coord)
532  	   ;
533  	 ELSIF l_hasdata = 0
534  	 THEN
535  	   l_return := NVL(p_none_option, 'N/A');
536  	 ELSE
537  	   usim_erl.log_error('usim_apex.disp_minmax_coords', 'ERROR: Invalid return value from usim_dbif.has_data_spc: ' || l_hasdata);
538  	   l_return := NVL(p_error_option, 'ERROR') || ': invalid return value: ' || CASE WHEN l_hasdata IS NULL THEN 'NULL' ELSE TO_CHAR(l_hasdata) END;
539  	 END IF;
540  
541  	 RETURN l_return;
542    EXCEPTION
543  	 WHEN OTHERS THEN
544  	   usim_erl.log_error('usim_apex.disp_minmax_coords', 'ERROR: unexpected application error ' || SQLERRM);
545  	   l_return := NVL(p_error_option, 'ERROR') || ': unexpected application error ' || SQLERRM;
546  	   RETURN l_return;
547    END disp_minmax_coords
548    ;
549  
550  END usim_apex;
551  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_apex
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_apex

Package body created.

SQL> --== APEX package end ==--
SQL> -- build test model
SQL> @@USIM_TEST_MODEL.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> --== sequences start ==--
SQL> -- USIM_TEST_SUMMARY (tsu) sequence
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../SEQUENCES/USIM_TSU_ID_SEQ.sql'
  4  	      ELSE '../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Sequence USIM_TSU_ID_SEQ still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TSU_ID_SEQ'
  8  	AND object_type = 'SEQUENCE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------
../SEQUENCES/USIM_TSU_ID_SEQ.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_TEST_SUMMARY (tsu) sequence
SQL> CREATE SEQUENCE &USIM_SCHEMA..usim_tsu_id_seq
  2    MINVALUE 1
  3    INCREMENT BY 1
  4    START WITH 1
  5    CACHE 20
  6    NOORDER
  7    NOCYCLE
  8    NOKEEP
  9    NOSCALE
 10    GLOBAL
 11  ;
old   1: CREATE SEQUENCE &USIM_SCHEMA..usim_tsu_id_seq
new   1: CREATE SEQUENCE USIM_TEST.usim_tsu_id_seq

Sequence created.

SQL> --== sequences end ==--
SQL> 
SQL> --== test tables start ==--
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_TEST_SUMMARY_TBL.sql'
  4  	      ELSE '../UTIL/../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_TEST_SUMMARY still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TEST_SUMMARY'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
----------------------------------------------------------------------------------
../TABLES/USIM_TEST_SUMMARY_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_TEST_SUMMARY (tsu)
SQL> CREATE TABLE &USIM_SCHEMA..usim_test_summary
  2    ( usim_id_tsu	     NUMBER	     NOT NULL ENABLE
  3    , usim_test_object    VARCHAR2(128)   NOT NULL ENABLE
  4    , usim_tests_success  NUMBER
  5    , usim_tests_failed   NUMBER
  6    )
  7  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_test_summary
new   1: CREATE TABLE USIM_TEST.usim_test_summary

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_test_summary IS 'Table to contain test summary of tests executed. Will use the alias tsu.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_test_summary IS 'Table to contain test summary of tests executed. Will use the alias tsu.'
new   1: COMMENT ON TABLE USIM_TEST.usim_test_summary IS 'Table to contain test summary of tests executed. Will use the alias tsu.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_id_tsu IS 'Unique id of an executed test.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_id_tsu IS 'Unique id of an executed test.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_test_summary.usim_id_tsu IS 'Unique id of an executed test.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_test_object IS 'Description of the test executed.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_test_object IS 'Description of the test executed.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_test_summary.usim_test_object IS 'Description of the test executed.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_tests_success IS 'Amount of successful executed tests for the test object.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_tests_success IS 'Amount of successful executed tests for the test object.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_test_summary.usim_tests_success IS 'Amount of successful executed tests for the test object.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_tests_failed IS 'Amount of failed executed tests for the test object.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_test_summary.usim_tests_failed IS 'Amount of failed executed tests for the test object.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_test_summary.usim_tests_failed IS 'Amount of failed executed tests for the test object.'

Comment created.

SQL> 
SQL> -- pk
SQL> ALTER TABLE &USIM_SCHEMA..usim_test_summary
  2    ADD CONSTRAINT usim_tsu_pk
  3    PRIMARY KEY (usim_id_tsu)
  4    ENABLE
  5  ;
old   1: ALTER TABLE &USIM_SCHEMA..usim_test_summary
new   1: ALTER TABLE USIM_TEST.usim_test_summary

Table altered.

SQL> 
SQL> -- insert trigger
SQL> CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_tsu_ins_trg
  2    BEFORE INSERT ON &USIM_SCHEMA..usim_test_summary
  3  	 FOR EACH ROW
  4  	 BEGIN
  5  	   -- always set this values on insert, do not care about input
  6  	   :NEW.usim_id_tsu := usim_tsu_id_seq.NEXTVAL;
  7  	 END;
  8  /
old   1: CREATE OR REPLACE TRIGGER &USIM_SCHEMA..usim_tsu_ins_trg
new   1: CREATE OR REPLACE TRIGGER USIM_TEST.usim_tsu_ins_trg
old   2:   BEFORE INSERT ON &USIM_SCHEMA..usim_test_summary
new   2:   BEFORE INSERT ON USIM_TEST.usim_test_summary

Trigger created.

SQL> ALTER TRIGGER &USIM_SCHEMA..usim_tsu_ins_trg ENABLE;
old   1: ALTER TRIGGER &USIM_SCHEMA..usim_tsu_ins_trg ENABLE
new   1: ALTER TRIGGER USIM_TEST.usim_tsu_ins_trg ENABLE

Trigger altered.

SQL> -- USIM_TEST_ERRORS (ter)
SQL> SELECT CASE
  2  	      WHEN COUNT(*) = 0
  3  	      THEN '../TABLES/USIM_TEST_ERRORS_TBL.sql'
  4  	      ELSE '../UTIL/../UTIL/EXIT_SCRIPT_WITH_ERROR.sql "Table USIM_TEST_ERRORS still exists."'
  5  	    END AS SCRIPTFILE
  6    FROM all_objects
  7   WHERE object_name = 'USIM_TEST_ERRORS'
  8  	AND object_type = 'TABLE'
  9  	AND owner	= '&USIM_SCHEMA'
 10  ;
old   9:    AND owner       = '&USIM_SCHEMA'
new   9:    AND owner       = 'USIM_TEST'

SCRIPTFILE
---------------------------------------------------------------------------------
../TABLES/USIM_TEST_ERRORS_TBL.sql

1 row selected.

SQL> @@&SCRIPTFILE
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- USIM_TEST_ERRORS (ter)
SQL> CREATE TABLE &USIM_SCHEMA..usim_test_errors
  2    ( usim_id_tsu	   NUMBER				 NOT NULL ENABLE
  3    , usim_timestamp    TIMESTAMP	   DEFAULT SYSTIMESTAMP  NOT NULL ENABLE
  4    , usim_error_msg    VARCHAR2(4000)			 NOT NULL ENABLE
  5    )
  6  ;
old   1: CREATE TABLE &USIM_SCHEMA..usim_test_errors
new   1: CREATE TABLE USIM_TEST.usim_test_errors

Table created.

SQL> COMMENT ON TABLE &USIM_SCHEMA..usim_test_errors IS 'Contains errors that occured in executed tests. Will use the alias ter.';
old   1: COMMENT ON TABLE &USIM_SCHEMA..usim_test_errors IS 'Contains errors that occured in executed tests. Will use the alias ter.'
new   1: COMMENT ON TABLE USIM_TEST.usim_test_errors IS 'Contains errors that occured in executed tests. Will use the alias ter.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_errors.usim_id_tsu IS 'The related id in usim_test_summary. No FK used, only controlled by application.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_test_errors.usim_id_tsu IS 'The related id in usim_test_summary. No FK used, only controlled by application.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_test_errors.usim_id_tsu IS 'The related id in usim_test_summary. No FK used, only controlled by application.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_errors.usim_timestamp IS 'The time stamp of the error in a test.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_test_errors.usim_timestamp IS 'The time stamp of the error in a test.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_test_errors.usim_timestamp IS 'The time stamp of the error in a test.'

Comment created.

SQL> COMMENT ON COLUMN &USIM_SCHEMA..usim_test_errors.usim_error_msg IS 'The error message of the test.';
old   1: COMMENT ON COLUMN &USIM_SCHEMA..usim_test_errors.usim_error_msg IS 'The error message of the test.'
new   1: COMMENT ON COLUMN USIM_TEST.usim_test_errors.usim_error_msg IS 'The error message of the test.'

Comment created.

SQL> -- test package
SQL> @@../PACKAGES/USIM_TEST.pks
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_test
  2  IS
  3    /** Package for test support.
  4    * No checks are done, parameters must be valid.
  5    */
  6  
  7    /**
  8    * Initialize a new test.
  9    * @param p_usim_test_object The name of the test object.
 10    * @return The id of the initialized test.
 11    */
 12    FUNCTION init_test(p_usim_test_object IN usim_test_summary.usim_test_object%TYPE)
 13  	 RETURN NUMBER
 14    ;
 15  
 16    /**
 17    * Logs an error message that occured in a test for a given test object.
 18    * @param p_usim_id_tsu The id of the test object in usim_test_summary.
 19    * @param p_usim_error_msg The error message to log in usim_test_errors.
 20    */
 21    PROCEDURE log_error( p_usim_id_tsu    IN usim_test_errors.usim_id_tsu%TYPE
 22  			  , p_usim_error_msg IN usim_test_errors.usim_error_msg%TYPE
 23  			  )
 24    ;
 25  
 26    /**
 27    * Persists the test results after testing.
 28    * @param p_usim_id_tsu The id of the test object in usim_test_summary.
 29    * @param p_usim_success The amount of successful tests.
 30    * @param p_usim_failed The amount of failed tests.
 31    */
 32    PROCEDURE write_test_results( p_usim_id_tsu   IN usim_test_summary.usim_id_tsu%TYPE
 33  				   , p_usim_success  IN NUMBER
 34  				   , p_usim_failed   IN NUMBER
 35  				   )
 36    ;
 37  END usim_test;
 38  /
old   1: CREATE OR REPLACE PACKAGE &USIM_SCHEMA..usim_test
new   1: CREATE OR REPLACE PACKAGE USIM_TEST.usim_test

Package created.

SQL> @@../PACKAGES/USIM_TEST.pkb
SQL> -- make object qualified and ensure that script can start standalone
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_test
  2  IS
  3    -- see header for description
  4    FUNCTION init_test(p_usim_test_object IN usim_test_summary.usim_test_object%TYPE)
  5  	 RETURN NUMBER
  6    IS
  7  	 PRAGMA AUTONOMOUS_TRANSACTION;
  8  	 l_result NUMBER;
  9    BEGIN
 10  	 INSERT INTO usim_test_summary (usim_test_object) VALUES (p_usim_test_object) RETURNING usim_id_tsu INTO l_result;
 11  	 COMMIT;
 12  	 RETURN l_result;
 13    END init_test
 14    ;
 15  
 16    PROCEDURE log_error( p_usim_id_tsu    IN usim_test_errors.usim_id_tsu%TYPE
 17  			  , p_usim_error_msg IN usim_test_errors.usim_error_msg%TYPE
 18  			  )
 19    IS
 20  	 PRAGMA AUTONOMOUS_TRANSACTION;
 21    BEGIN
 22  	 INSERT INTO usim_test_errors
 23  	   ( usim_id_tsu
 24  	   , usim_error_msg
 25  	   )
 26  	   VALUES
 27  	   ( p_usim_id_tsu
 28  	   , p_usim_error_msg
 29  	   )
 30  	 ;
 31  	 COMMIT;
 32    END log_error
 33    ;
 34  
 35    PROCEDURE write_test_results( p_usim_id_tsu   IN usim_test_summary.usim_id_tsu%TYPE
 36  				   , p_usim_success  IN NUMBER
 37  				   , p_usim_failed   IN NUMBER
 38  				   )
 39    IS
 40    BEGIN
 41  	 UPDATE usim_test_summary
 42  	    SET usim_tests_success = p_usim_success
 43  	      , usim_tests_failed  = p_usim_failed
 44  	  WHERE usim_id_tsu = p_usim_id_tsu
 45  	 ;
 46  	 COMMIT;
 47    END write_test_results
 48    ;
 49  
 50  END usim_test;
 51  /
old   1: CREATE OR REPLACE PACKAGE BODY &USIM_SCHEMA..usim_test
new   1: CREATE OR REPLACE PACKAGE BODY USIM_TEST.usim_test

Package body created.

SQL> --== test tables end ==--
SQL> 
SQL> 
SQL> --== packages with debug code overrides start ==--
SQL> -- you may add any packages with debug code to override the standard packages here
SQL> --== packages with debug code overrides end ==--
SQL> -- check state of database
SQL> @@../UTIL/VERIFY_SYSTEM.sql
SQL> COLUMN USIM_SCHEMA NEW_VAL USIM_SCHEMA
SQL> SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS USIM_SCHEMA FROM dual;

USIM_SCHEMA
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
USIM_TEST

1 row selected.

SQL> -- check state of database
SQL> SET FEEDBACK OFF
SQL> SELECT CASE
  2  	     WHEN COUNT(*) > 0
  3  	     THEN 'ERROR Database has invalid objects'
  4  	     ELSE 'SUCCESS All database objects are valid'
  5  	   END AS info
  6    FROM all_objects
  7   WHERE status != 'VALID'
  8  	AND owner   = '&USIM_SCHEMA'
  9  ;
old   8:    AND owner   = '&USIM_SCHEMA'
new   8:    AND owner   = 'USIM_TEST'

INFO
--------------------------------------
SUCCESS All database objects are valid
SQL> -- group details if any
SQL> SELECT object_type
  2  	  , COUNT(*) AS invalid_objects
  3    FROM all_objects
  4   WHERE status != 'VALID'
  5  	AND owner   = '&USIM_SCHEMA'
  6   GROUP BY object_type
  7  ;
old   5:    AND owner   = '&USIM_SCHEMA'
new   5:    AND owner   = 'USIM_TEST'
SQL> -- details if any
SQL> SELECT object_name
  2  	  , object_type
  3  	  , status
  4    FROM all_objects
  5   WHERE status != 'VALID'
  6  	AND owner   = '&USIM_SCHEMA'
  7   ORDER BY object_type
  8  	     , object_name
  9  ;
old   6:    AND owner   = '&USIM_SCHEMA'
new   6:    AND owner   = 'USIM_TEST'
SQL> SELECT trigger_name AS not_enabled_trigger
  2  	  , table_name
  3    FROM all_triggers
  4   WHERE status != 'ENABLED'
  5  	AND owner   = '&USIM_SCHEMA'
  6  ;
old   5:    AND owner   = '&USIM_SCHEMA'
new   5:    AND owner   = 'USIM_TEST'
SQL> SET FEEDBACK ON
SQL> SPOOL OFF
