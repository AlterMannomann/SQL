-- DROP TABLE IF EXISTS usim_planck_aeon CASCADE;
-- sort columns by space needed: primary key, NOT NULLs by size, NULLS by size, character varying last (slowest access)
CREATE TABLE IF NOT EXISTS usim_planck_aeon
(
  bda_id character(32) NOT NULL,
  pla_id character(32) NOT NULL,
  pla_add bigint NOT NULL,
  pla_active boolean NOT NULL DEFAULT FALSE,
  pla_created timestamp without time zone NOT NULL DEFAULT now(),
  CONSTRAINT pla_pk PRIMARY KEY (bda_id, pla_id, pla_add),
  CONSTRAINT pla_fk FOREIGN KEY (bda_id) REFERENCES usim_basedata (bda_id) ON DELETE CASCADE
)
-- Partitions are difficult to handle as they have to be created manually
-- so currently no partitions even if it would be useful.
TABLESPACE usim_data;

ALTER TABLE usim_planck_aeon
    OWNER TO usim;

COMMENT ON TABLE usim_planck_aeon
  IS 'Holds the planck aeons of a defined simulation.  Use procedure pla_insert to ensure correct state. The planck aeon is a construct to overcome the limitations in serials. Will use the alias pla.';

COMMENT ON COLUMN usim_planck_aeon.bda_id
  IS 'The referenced id of simulation. Part of the primary key. Ignored on updates.';

COMMENT ON COLUMN usim_planck_aeon.pla_id
  IS 'The basic id of the planck aeon. Only unique together with pla_add. Automatically created by trigger, ignored on inserts. Part of the primary key. Ignored on updates.';

COMMENT ON COLUMN usim_planck_aeon.pla_add
  IS 'The id addendum to ensure planck id is unique. Cycling sequence in usim_sequences. Automatically created by trigger, ignored on inserts. Part of the primary key. Ignored on updates.';

COMMENT ON COLUMN usim_planck_aeon.pla_active
  IS 'The boolean indicator which aeon is active for a simulation. Only one aeon can be active for a simulation. Insert will always set FALSE. Use procedure pla_insert to ensure correct state.';

COMMENT ON COLUMN usim_planck_aeon.pla_created
  IS 'The creation date of an aeon. Can be used for sorting. Ignored on updates.';

-- FUNCTION: pla_fn_ins_trg()
-- DROP FUNCTION IF EXISTS pla_fn_ins_trg();

CREATE OR REPLACE FUNCTION pla_fn_ins_trg()
  RETURNS trigger
  LANGUAGE 'plpgsql'
AS $BODY$
  BEGIN
    NEW.pla_id := usim_create_id();
    CALL squ_get_sequence('pla_seq', FALSE, TRUE, NEW.pla_add, NEW.bda_id, NEW.pla_id);
    NEW.pla_active := FALSE;
    NEW.pla_created := current_timestamp;
    RETURN NEW;
  END;
$BODY$;

ALTER FUNCTION pla_fn_ins_trg()
  OWNER TO usim;

-- FUNCTION: pla_fn_upd_trg()
-- DROP FUNCTION IF EXISTS pla_fn_upd_trg();

CREATE OR REPLACE FUNCTION pla_fn_upd_trg()
  RETURNS trigger
  LANGUAGE 'plpgsql'
AS $BODY$
  BEGIN
    IF     NEW.pla_active
       AND EXISTS (SELECT * FROM usim_planck_aeon WHERE bda_id = OLD.bda_id AND pla_active)
    THEN
      RAISE EXCEPTION 'Can not activate a planck aeon for the defined simulation as long as one aeon is still active';
    END IF;
    -- ignore updates for
    NEW.bda_id := OLD.bda_id;
    NEW.pla_id := OLD.pla_id;
    NEW.pla_add := OLD.pla_add;
    NEW.pla_created := OLD.pla_created;
    RETURN NEW;
  END;
$BODY$;

ALTER FUNCTION pla_fn_upd_trg()
  OWNER TO usim;

-- Trigger: pla_ins_trg
-- DROP TRIGGER IF EXISTS pla_ins_trg ON usim_planck_aeon;

CREATE TRIGGER pla_ins_trg
  BEFORE INSERT
  ON usim_planck_aeon
  FOR EACH ROW
  EXECUTE FUNCTION pla_fn_ins_trg();

-- Trigger: pla_upd_trg
-- DROP TRIGGER IF EXISTS pla_upd_trg ON usim_planck_aeon;

CREATE TRIGGER pla_upd_trg
  BEFORE UPDATE
  ON usim_planck_aeon
  FOR EACH ROW
  EXECUTE FUNCTION pla_fn_upd_trg();

-- PROCEDURE: pla_insert
-- DROP PROCEDURE IF EXISTS pla_insert;

CREATE OR REPLACE PROCEDURE pla_insert(
  p_bda_id  IN character(32),
  p_pla_id  OUT character(32),
  p_pla_add OUT bigint
)
  LANGUAGE 'plpgsql'
AS $BODY$
  /** PROCEDURE pla_insert
  * Inserts a new aeon for the given simulation reference id and deactivates any
  * other aeons of the simulation by setting pla_active to FALSE.
  * Application is responsible for COMMIT.
  */
  BEGIN
    UPDATE usim_planck_aeon
       SET pla_active = FALSE
     WHERE bda_id = p_bda_id;
    INSERT INTO usim_planck_aeon (bda_id) VALUES (p_bda_id)
      RETURNING pla_id, pla_add INTO p_pla_id, p_pla_add;
    UPDATE usim_planck_aeon
       SET pla_active = TRUE
     WHERE bda_id = p_bda_id
       AND pla_id = p_pla_id
       AND pla_add = p_pla_add;
  END;
$BODY$;