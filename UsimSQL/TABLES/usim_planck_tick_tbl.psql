-- DROP TABLE IF EXISTS usim_planck_tick CASCADE;
-- sort columns by space needed: primary key, NOT NULLs by size, NULLS by size, character varying last (slowest access)
CREATE TABLE IF NOT EXISTS usim_planck_tick
(
  bda_id character(32) NOT NULL,
  pla_id character(32) NOT NULL,
  pla_add bigint NOT NULL,
  plt_id bigint NOT NULL,
  CONSTRAINT plt_pk PRIMARY KEY (bda_id, pla_id, pla_add, plt_id),
  CONSTRAINT plt_fk1 FOREIGN KEY (bda_id) REFERENCES usim_basedata (bda_id) ON DELETE CASCADE,
  CONSTRAINT plt_fk2 FOREIGN KEY (bda_id, pla_id, pla_add) REFERENCES usim_planck_aeon (bda_id, pla_id, pla_add) ON DELETE CASCADE
)
-- Partitions are difficult to handle as they have to be created manually
-- so currently no partitions even if would be useful.
TABLESPACE usim_data;

ALTER TABLE usim_planck_tick
    OWNER TO usim;

COMMENT ON TABLE usim_planck_tick
  IS 'Holds the planck ticks for a specific aeon. No updates allowed on this table. Make sure retrieve pla_id and pla_stamp on insert as they may change on insert. The planck tick is a construct to overcome the limitations in serials. Will use the alias plt.';

COMMENT ON COLUMN usim_planck_tick.bda_id
  IS 'The referenced id of the base data for the defined simulation.';

COMMENT ON COLUMN usim_planck_tick.pla_id
  IS 'The referenced basic id of the planck aeon.';

COMMENT ON COLUMN usim_planck_tick.pla_add
  IS 'The referenced id addendum of the planck aeon.';

COMMENT ON COLUMN usim_planck_tick.plt_id
  IS 'The id of the planck tick representing the tick. Automatically created by trigger, ignored on inserts. Will create a new aeon on overflow.';

-- FUNCTION: plt_fn_ins_trg()
-- DROP FUNCTION IF EXISTS plt_fn_ins_trg();

CREATE OR REPLACE FUNCTION plt_fn_ins_trg()
  RETURNS trigger
  LANGUAGE 'plpgsql'
AS $BODY$
  BEGIN
    IF squ_finished('plt_seq', NEW.bda_id, NEW.pla_id, usim_int_to_id(NEW.pla_add))
    THEN
      -- mark the old sequence for delete, not needed anymore
      CALL squ_set_delete('plt_seq', NEW.bda_id, NEW.pla_id, usim_int_to_id(NEW.pla_add));
      -- we need first a new planck aeon, sequence has finished
      INSERT INTO usim_planck_aeon (bda_id) VALUES (NEW.bda_id) RETURNING pla_id, pla_add INTO NEW.pla_id, NEW.pla_add;
    END IF;
    CALL squ_get_sequence('plt_seq', FALSE, TRUE, NEW.plt_id, NEW.bda_id, NEW.pla_id, usim_int_to_id(NEW.pla_add));
    RETURN NEW;
  END;
$BODY$;

ALTER FUNCTION plt_fn_ins_trg()
    OWNER TO usim;

-- FUNCTION: plt_fn_upd_trg()
-- DROP FUNCTION IF EXISTS plt_fn_upd_trg();

CREATE OR REPLACE FUNCTION plt_fn_upd_trg()
  RETURNS trigger
  LANGUAGE 'plpgsql'
AS $BODY$
  BEGIN
    -- No updates allowed
    RAISE EXCEPTION 'No updates allowed on table usim_planck_tick.';
    RETURN NEW;
  END;
$BODY$;

ALTER FUNCTION plt_fn_upd_trg()
    OWNER TO usim;

-- Trigger: plt_ins_trg
-- DROP TRIGGER IF EXISTS plt_ins_trg ON usim_planck_tick;

CREATE TRIGGER plt_ins_trg
  BEFORE INSERT
  ON usim_planck_tick
  FOR EACH ROW
  EXECUTE FUNCTION plt_fn_ins_trg();

-- Trigger: plt_upd_trg
-- DROP TRIGGER IF EXISTS plt_upd_trg ON usim_planck_tick;

CREATE TRIGGER plt_upd_trg
  BEFORE UPDATE
  ON usim_planck_tick
  FOR EACH ROW
  EXECUTE FUNCTION plt_fn_upd_trg();
