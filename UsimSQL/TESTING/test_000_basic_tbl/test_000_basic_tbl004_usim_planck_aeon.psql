CREATE OR REPLACE FUNCTION test_000_basic_tbl004_usim_planck_aeon()
  RETURNS SETOF TEXT
  LANGUAGE 'plpgsql'
AS $BODY$
  DECLARE
    l_bda_id  character(32);
    l_pla_id  character(32);
    l_pla_add bigint;
  BEGIN
    RETURN NEXT has_column('usim_test', 'usim_planck_aeon', 'pla_active', 'Check existance of pla_active in usim_planck_aeon');
    RETURN NEXT col_not_null('usim_test', 'usim_planck_aeon', 'pla_active', 'Check pla_active in usim_planck_aeon NOT NULL');
    RETURN NEXT col_type_is('usim_test', 'usim_planck_aeon', 'pla_active', 'boolean', 'Check column type of pla_active in usim_planck_aeon');
    RETURN NEXT col_has_default('usim_test', 'usim_planck_aeon', 'pla_active', 'Check pla_active in usim_planck_aeon has default');
    RETURN NEXT col_default_is('usim_test', 'usim_planck_aeon', 'pla_active', 'FALSE', 'Check pla_active in usim_planck_aeon default value');
    RETURN NEXT has_column('usim_test', 'usim_planck_aeon', 'pla_created', 'Check existance of pla_created in usim_planck_aeon');
    RETURN NEXT col_not_null('usim_test', 'usim_planck_aeon', 'pla_created', 'Check pla_created in usim_planck_aeon NOT NULL');
    RETURN NEXT col_type_is('usim_test', 'usim_planck_aeon', 'pla_created', 'timestamp without time zone', 'Check column type of pla_created in usim_planck_aeon');
    RETURN NEXT col_has_default('usim_test', 'usim_planck_aeon', 'pla_created', 'Check pla_created in usim_planck_aeon has default');
    RETURN NEXT col_default_is('usim_test', 'usim_planck_aeon', 'pla_created', 'now()', 'Check pla_created in usim_planck_aeon default value');
    -- check related objects
    RETURN NEXT can('usim_test', ARRAY['pla_fn_ins_trg', 'pla_fn_upd_trg'], 'Check usim_planck_aeon trigger functions');
    RETURN NEXT trigger_is('usim_test', 'usim_planck_aeon', 'pla_ins_trg', 'usim_test', 'pla_fn_ins_trg', 'Check usim_planck_aeon insert trigger');
    RETURN NEXT trigger_is('usim_test', 'usim_planck_aeon', 'pla_upd_trg', 'usim_test', 'pla_fn_upd_trg', 'Check usim_planck_aeon update trigger');
    -- init data for testing
    RETURN NEXT is(COUNT(*), 0::bigint, 'usim_basedata should not have any records before testing usim_planck_aeon') FROM usim_basedata;
    RETURN NEXT is(COUNT(*), 0::bigint, 'usim_planck_aeon should not have any records before testing usim_planck_aeon') FROM usim_planck_aeon;
    INSERT INTO usim_basedata DEFAULT VALUES RETURNING bda_id INTO l_bda_id;
    INSERT INTO usim_planck_aeon (bda_id) VALUES (l_bda_id) RETURNING pla_id, pla_add INTO l_pla_id, l_pla_add;
    RETURN NEXT is(COUNT(*), 1::bigint, 'successfully insert a new planck aeon into usim_planck_aeon') FROM usim_planck_aeon;
    -- set active
    UPDATE usim_planck_aeon SET pla_active = TRUE WHERE bda_id = l_bda_id AND pla_id = l_pla_id AND pla_add = l_pla_add;
    RETURN NEXT is(pla_active, TRUE, 'successfully activated planck aeon') FROM usim_planck_aeon WHERE bda_id = l_bda_id AND pla_id = l_pla_id AND pla_add = l_pla_add;
    -- insert next record
    INSERT INTO usim_planck_aeon (bda_id) VALUES (l_bda_id) RETURNING pla_id, pla_add INTO l_pla_id, l_pla_add;
    -- try to set all active
    RETURN NEXT throws_ok('UPDATE usim_planck_aeon SET pla_active = TRUE WHERE bda_id = (SELECT bda_id FROM usim_basedata)', 'Can not activate a planck aeon for the defined simulation as long as one aeon is still active', 'Check usim_planck_aeon allows only one active record');
    CALL pla_insert(l_bda_id, l_pla_id, l_pla_add);
    RETURN NEXT is(pla_active, TRUE, 'Check pla_insert on usim_planck_aeon successful, old record deactivated, new record activated') FROM usim_planck_aeon WHERE bda_id = l_bda_id AND pla_id = l_pla_id AND pla_add = l_pla_add;
  END;
$BODY$;
